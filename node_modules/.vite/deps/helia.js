import {
  detect
} from "./chunk-KMTODQPO.js";
import {
  BaseBlockstore,
  MemoryBlockstore
} from "./chunk-266XOBJX.js";
import {
  CODE_CERTHASH,
  CODE_DNS,
  CODE_DNS4,
  CODE_DNS6,
  CODE_DNSADDR,
  CODE_HTTP,
  CODE_HTTPS,
  CODE_IP4,
  CODE_IP6,
  CODE_IP6ZONE,
  CODE_IPCIDR,
  CODE_MEMORY,
  CODE_P2P,
  CODE_P2P_CIRCUIT,
  CODE_QUIC,
  CODE_QUIC_V1,
  CODE_SNI,
  CODE_TCP,
  CODE_TLS,
  CODE_UDP,
  CODE_UNIX,
  CODE_WEBRTC,
  CODE_WEBRTC_DIRECT,
  CODE_WEBTRANSPORT,
  CODE_WS,
  CODE_WSS,
  P2P,
  cidrContains,
  convertToIpNet,
  isIPv4,
  isIPv6,
  isMultiaddr,
  multiaddr,
  protocols
} from "./chunk-GWVIDH3I.js";
import {
  AbortError,
  ConnectionClosedError,
  ConnectionClosingError,
  ConnectionFailedError,
  CustomProgressEvent,
  DialError,
  FaultTolerance,
  InvalidCIDError,
  InvalidCryptoExchangeError,
  InvalidMessageError,
  InvalidMultiaddrError,
  InvalidMultihashError,
  InvalidParametersError,
  InvalidPeerIdError,
  InvalidPublicKeyError,
  KEEP_ALIVE,
  LimitedConnectionError,
  ListenError,
  MaxLengthError,
  MaxSizeError,
  MuxerClosedError,
  NotFoundError,
  NotStartedError,
  PQueue,
  ProtocolError,
  StreamResetError,
  StreamStateError,
  TimeoutError,
  TooManyInboundProtocolStreamsError,
  TooManyOutboundProtocolStreamsError,
  TypedEventEmitter,
  Uint8ArrayList,
  UnexpectedPeerError,
  UnsupportedKeyTypeError,
  UnsupportedProtocolError,
  code,
  code2,
  code3,
  connectionSymbol,
  contentRoutingSymbol,
  createScalableCuckooFilter,
  decode as decode2,
  decodeMessage,
  encode as encode2,
  encodeMessage,
  enumeration,
  generateKeyPair,
  isPeerId,
  isStartable,
  isUint8ArrayList,
  mergeOptions,
  message,
  pTimeout,
  parallel,
  pbkdf2,
  peerDiscoverySymbol,
  peerIdSymbol,
  peerRoutingSymbol,
  privateKeyFromProtobuf,
  privateKeyFromRaw,
  privateKeyToCryptoKeyPair,
  privateKeyToProtobuf,
  publicKeyFromMultihash,
  publicKeyFromProtobuf,
  publicKeyToProtobuf,
  randomBytes,
  serviceCapabilities,
  serviceDependencies,
  setMaxListeners,
  sha512,
  src_default as src_default7,
  src_exports,
  src_exports2,
  src_exports3,
  start,
  stop,
  transportSymbol,
  webcrypto_default,
  x25519
} from "./chunk-T5CRBQFB.js";
import {
  asUint8Array,
  concat,
  decode,
  encode,
  encodingLength,
  equals
} from "./chunk-BPCL3VPU.js";
import "./chunk-DYETMQ3U.js";
import "./chunk-GEK5MXOV.js";
import {
  Key,
  MemoryDatastore,
  src_default,
  src_default2 as src_default6
} from "./chunk-6PD3Z677.js";
import {
  NotFoundError as NotFoundError2
} from "./chunk-O4B2SC4X.js";
import {
  pipe,
  pushable,
  src_default as src_default5,
  src_default2 as src_default8
} from "./chunk-U7AWOMBT.js";
import {
  defaultLogger,
  logger,
  pDefer,
  queuelessPushable,
  raceSignal,
  src_default as src_default2,
  src_default2 as src_default3,
  src_default3 as src_default4
} from "./chunk-K7PRM5O7.js";
import {
  alloc,
  allocUnsafe,
  fromString,
  toString
} from "./chunk-E7RDS3JU.js";
import {
  pbkdf2Async
} from "./chunk-I4N6U4EZ.js";
import "./chunk-BSIOSPHI.js";
import {
  hmac
} from "./chunk-NJ2IMHHP.js";
import "./chunk-BIDMXIGI.js";
import {
  sha256
} from "./chunk-HHC25657.js";
import "./chunk-2YJ6SRAI.js";
import {
  ahash,
  anumber,
  clean,
  toBytes
} from "./chunk-FNOUKXXE.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-QEK2ZTOW.js";

// node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "node_modules/hashlru/index.js"(exports, module) {
    module.exports = function(max) {
      if (!max) throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache12 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value7) {
        cache12[key] = value7;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache12;
          cache12 = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache12[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache12[key] !== void 0)
            cache12[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache12[key];
          if (v !== void 0) return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value7) {
          if (cache12[key] !== void 0) cache12[key] = value7;
          else update(key, value7);
        },
        clear: function() {
          cache12 = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS({
  "node_modules/netmask/lib/netmask.js"(exports) {
    (function() {
      var Netmask2, atob2, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a, b, c, d;
        a = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c = (long & 255 << 8) >>> 8;
        d = long & 255;
        return [a, b, c, d].join(".");
      };
      ip2long = function(ip) {
        var b, c, i, j, n, ref;
        b = [];
        for (i = j = 0; j <= 3; i = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob2(ip), n = ref[0], c = ref[1];
          ip = ip.substring(c);
          b.push(n);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob2 = function(s) {
        var base14, dmax, i, n, start2;
        n = 0;
        base14 = 10;
        dmax = "9";
        i = 0;
        if (s.length > 1 && s[i] === "0") {
          if (s[i + 1] === "x" || s[i + 1] === "X") {
            i += 2;
            base14 = 16;
          } else if ("0" <= s[i + 1] && s[i + 1] <= "9") {
            i++;
            base14 = 8;
            dmax = "7";
          }
        }
        start2 = i;
        while (i < s.length) {
          if ("0" <= s[i] && s[i] <= dmax) {
            n = n * base14 + (chr(s[i]) - chr0) >>> 0;
          } else if (base14 === 16) {
            if ("a" <= s[i] && s[i] <= "f") {
              n = n * base14 + (10 + chr(s[i]) - chra) >>> 0;
            } else if ("A" <= s[i] && s[i] <= "F") {
              n = n * base14 + (10 + chr(s[i]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n > 4294967295) {
            throw new Error("too large");
          }
          i++;
        }
        if (i === start2) {
          throw new Error("empty octet");
        }
        return [n, i];
      };
      Netmask2 = function() {
        function Netmask3(net, mask) {
          var error, i, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              error = error1;
              throw new Error("Invalid mask: " + mask);
            }
            for (i = j = 32; j >= 0; i = --j) {
              if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                this.bitmask = i;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            error = error1;
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask3.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask3(ip);
          }
          if (ip instanceof Netmask3) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask3.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask3(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask3.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask3.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask3;
      }();
      exports.ip2long = ip2long;
      exports.long2ip = long2ip;
      exports.Netmask = Netmask2;
    }).call(exports);
  }
});

// node_modules/timestamp-nano/dist/timestamp.min.js
var require_timestamp_min = __commonJS({
  "node_modules/timestamp-nano/dist/timestamp.min.js"(exports, module) {
    var Timestamp = function() {
      "undefined" != typeof module && (module.exports = d);
      var l = 86400, s = 3200, T = 146097 * s / 400, e = l * T, f = 1e3 * e, c = 864e13, g = 4294967296, h = 1e6, u = "000000000", m = Math.trunc || function(n2) {
        var t2 = n2 - n2 % 1;
        return 0 == t2 && (n2 < 0 || 0 === n2 && 1 / n2 != 1 / 0) ? -0 : t2;
      }, n = d.prototype, o = (d.fromDate = function(n2) {
        return new d(+n2);
      }, d.fromInt64BE = r(0, 1, 2, 3, 0, 4), d.fromInt64LE = r(3, 2, 1, 0, 4, 0), d.fromString = function(n2) {
        var e2, r2 = new d(), n2 = (n2 += "").replace(/^\s*[+\-]?\d+/, function(n3) {
          var n3 = +n3, t2 = 1970 + (n3 - 1970) % 400;
          return r2.year = n3 - t2, t2;
        }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(n3, t2, r3) {
          return t2 < 0 && (r3 *= -1), e2 = 6e4 * (60 * +t2 + +r3), "";
        }).replace(/\.\d+$/, function(n3) {
          return r2.nano = +(n3 + u).substr(1, 9), "";
        }).split(/\D+/);
        1 < n2.length ? n2[1]-- : n2[1] = 0;
        if (r2.time = e2 = Date.UTC.apply(Date, n2) - (e2 || 0), isNaN(e2)) throw new TypeError("Invalid Date");
        return p(r2);
      }, d.fromTimeT = function(n2) {
        return y(n2, 0);
      }, n.year = 0, n.time = 0, n.nano = 0, n.addNano = function(n2) {
        return this.nano += +n2 || 0, this;
      }, n.getNano = function() {
        var n2 = p(this);
        return (n2.time % 1e3 * h + +n2.nano + 1e9) % 1e9;
      }, n.getTimeT = function() {
        var n2 = p(this), t2 = Math.floor(n2.time / 1e3), n2 = n2.year;
        n2 && (t2 += n2 * T * l / s);
        return t2;
      }, n.getYear = function() {
        return this.toDate().getUTCFullYear() + this.year;
      }, n.toDate = function() {
        return M(p(this).time);
      }, n.toJSON = function() {
        return this.toString().replace(/0{1,6}Z$/, "Z");
      }, n.toString = function(n2) {
        var t2 = this, r2 = t2.toDate(), u2 = { H: function() {
          return C(r2.getUTCHours());
        }, L: function() {
          return D(r2.getUTCMilliseconds(), 3);
        }, M: function() {
          return C(r2.getUTCMinutes());
        }, N: function() {
          return D(t2.getNano(), 9);
        }, S: function() {
          return C(r2.getUTCSeconds());
        }, Y: function() {
          var n3 = t2.getYear();
          return 999999 < n3 ? "+" + n3 : 9999 < n3 ? "+" + D(n3, 6) : 0 <= n3 ? D(n3, 4) : -999999 <= n3 ? "-" + D(-n3, 6) : n3;
        }, a: function() {
          return a[r2.getUTCDay()];
        }, b: function() {
          return i[r2.getUTCMonth()];
        }, d: function() {
          return C(r2.getUTCDate());
        }, e: function() {
          return function(n3) {
            return (9 < n3 ? "" : " ") + (0 | n3);
          }(r2.getUTCDate());
        }, m: function() {
          return C(r2.getUTCMonth() + 1);
        } };
        return function e2(n3) {
          return n3.replace(/%./g, function(n4) {
            var t3 = n4[1], r3 = v[t3], t3 = u2[t3];
            return r3 ? e2(r3) : t3 ? t3() : n4;
          });
        }(n2 || o);
      }, n.writeInt64BE = t(0, 1, 2, 3, 0, 4), n.writeInt64LE = t(3, 2, 1, 0, 4, 0), "%Y-%m-%dT%H:%M:%S.%NZ"), i = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], a = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], v = { "%": "%", F: "%Y-%m-%d", n: "\n", R: "%H:%M", T: "%H:%M:%S", t: "	", X: "%T", Z: "GMT", z: "+0000" };
      return d;
      function d(n2, t2, r2) {
        var e2 = this;
        if (!(e2 instanceof d)) return new d(n2, t2, r2);
        e2.time = +n2 || 0, e2.nano = +t2 || 0, e2.year = +r2 || 0, p(e2);
      }
      function p(n2) {
        var t2, r2, e2, u2 = n2.year, o2 = n2.time, i2 = n2.nano, a2 = ((i2 < 0 || h <= i2) && (i2 -= (r2 = Math.floor(i2 / h)) * h, o2 += r2, r2 = 1), u2 % s);
        return (o2 < -c || c < o2 || a2) && ((t2 = m(o2 / f)) && (u2 += t2 * s, o2 -= t2 * f), (e2 = M(o2)).setUTCFullYear(a2 + e2.getUTCFullYear()), e2 = (o2 = +e2) + (t2 = m((u2 -= a2) / s)) * f, t2 && -c <= e2 && e2 <= c && (u2 -= t2 * s, o2 = e2), r2 = 1), r2 && (n2.year = u2, n2.time = o2, n2.nano = i2), n2;
      }
      function M(n2) {
        var t2 = /* @__PURE__ */ new Date(0);
        return t2.setTime(n2), t2;
      }
      function y(n2, t2) {
        n2 = +n2 || 0;
        var r2 = m((t2 = (t2 | 0) * g) / e) + m(n2 / e), t2 = t2 % e + n2 % e, n2 = m(t2 / e);
        return n2 && (r2 += n2, t2 -= n2 * e), new d(1e3 * t2, 0, r2 * s);
      }
      function t(e2, u2, o2, i2, a2, f2) {
        return function(n2, t2) {
          var r2 = p(this);
          n2 = n2 || new Array(8);
          w(n2, t2 |= 0);
          var e3 = Math.floor(r2.time / 1e3), r2 = r2.year * (T * l / s), u3 = m(r2 / g) + m(e3 / g), r2 = r2 % g + e3 % g, e3 = Math.floor(r2 / g);
          e3 && (u3 += e3, r2 -= e3 * g);
          return c2(n2, t2 + a2, u3), c2(n2, t2 + f2, r2), n2;
        };
        function c2(n2, t2, r2) {
          n2[t2 + e2] = r2 >> 24 & 255, n2[t2 + u2] = r2 >> 16 & 255, n2[t2 + o2] = r2 >> 8 & 255, n2[t2 + i2] = 255 & r2;
        }
      }
      function r(r2, e2, u2, o2, i2, a2) {
        return function(n2, t2) {
          w(n2, t2 |= 0);
          var r3 = f2(n2, t2 + i2);
          return y(f2(n2, t2 + a2), r3);
        };
        function f2(n2, t2) {
          return 16777216 * n2[t2 + r2] + (n2[t2 + e2] << 16 | n2[t2 + u2] << 8 | n2[t2 + o2]);
        }
      }
      function w(n2, t2) {
        n2 = n2 && n2.length;
        if (null == n2) throw new TypeError("Invalid Buffer");
        if (n2 < t2 + 8) throw new RangeError("Out of range");
      }
      function C(n2) {
        return (9 < n2 ? "" : "0") + (0 | n2);
      }
      function D(n2, t2) {
        return (u + (0 | n2)).substr(-t2);
      }
    }();
  }
});

// node_modules/truncate-utf8-bytes/lib/truncate.js
var require_truncate = __commonJS({
  "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports, module) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module.exports = function truncate(getLength, string2, byteLength) {
      if (typeof string2 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string2.length;
      var curByteLength = 0;
      var codePoint;
      var segment;
      for (var i = 0; i < charLength; i += 1) {
        codePoint = string2.charCodeAt(i);
        segment = string2[i];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string2.charCodeAt(i + 1))) {
          i += 1;
          segment += string2[i];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength) {
          return string2.slice(0, i + 1);
        } else if (curByteLength > byteLength) {
          return string2.slice(0, i - segment.length + 1);
        }
      }
      return string2;
    };
  }
});

// node_modules/utf8-byte-length/browser.js
var require_browser = __commonJS({
  "node_modules/utf8-byte-length/browser.js"(exports, module) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module.exports = function getByteLength(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string2.length;
      var byteLength = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i = 0; i < charLength; i++) {
        codePoint = string2.charCodeAt(i);
        if (isLowSurrogate(codePoint)) {
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength += 1;
          } else {
            byteLength += 3;
          }
        } else if (codePoint <= 127) {
          byteLength += 1;
        } else if (codePoint >= 128 && codePoint <= 2047) {
          byteLength += 2;
        } else if (codePoint >= 2048 && codePoint <= 65535) {
          byteLength += 3;
        }
        prevCodePoint = codePoint;
      }
      return byteLength;
    };
  }
});

// node_modules/truncate-utf8-bytes/browser.js
var require_browser2 = __commonJS({
  "node_modules/truncate-utf8-bytes/browser.js"(exports, module) {
    "use strict";
    var truncate = require_truncate();
    var getLength = require_browser();
    module.exports = truncate.bind(null, getLength);
  }
});

// node_modules/sanitize-filename/index.js
var require_sanitize_filename = __commonJS({
  "node_modules/sanitize-filename/index.js"(exports, module) {
    "use strict";
    var truncate = require_browser2();
    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;
    function sanitize2(input, replacement) {
      if (typeof input !== "string") {
        throw new Error("Input must be string");
      }
      var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
      return truncate(sanitized, 255);
    }
    module.exports = function(input, options2) {
      var replacement = options2 && options2.replacement || "";
      var output = sanitize2(input, replacement);
      if (replacement === "") {
        return output;
      }
      return sanitize2(output, "");
    };
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module) {
    function RetryOperation(timeouts, options2) {
      if (typeof options2 === "boolean") {
        options2 = { forever: options2 };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options2 || {};
      this._maxRetryTime = options2 && options2.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message2 = error.message;
        var count = (counts[message2] || 0) + 1;
        counts[message2] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options2) {
      var timeouts = exports.timeouts(options2);
      return new RetryOperation(timeouts, {
        forever: options2 && (options2.forever || options2.retries === Infinity),
        unref: options2 && options2.unref,
        maxRetryTime: options2 && options2.maxRetryTime
      });
    };
    exports.timeouts = function(options2) {
      if (options2 instanceof Array) {
        return [].concat(options2);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options2) {
        opts[key] = options2[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options2 && options2.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options2, methods) {
      if (options2 instanceof Array) {
        methods = options2;
        options2 = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (function retryWrapper(original2) {
          var op = exports.operation(options2);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }).bind(obj, original);
        obj[method].options = options2;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module) {
    module.exports = require_retry();
  }
});

// node_modules/event-iterator/lib/event-iterator.js
var require_event_iterator = __commonJS({
  "node_modules/event-iterator/lib/event-iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EventQueue = class {
      constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
      }
      push(value7) {
        if (this.isStopped)
          return;
        const resolution = { value: value7, done: false };
        if (this.pullQueue.length) {
          const placeholder = this.pullQueue.shift();
          if (placeholder)
            placeholder.resolve(resolution);
        } else {
          this.pushQueue.push(Promise.resolve(resolution));
          if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
            this.isPaused = true;
            if (this.eventHandlers.highWater) {
              this.eventHandlers.highWater();
            } else if (console) {
              console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
            }
          }
        }
      }
      stop() {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
          placeholder.resolve({ value: void 0, done: true });
        }
        this.pullQueue.length = 0;
      }
      fail(error) {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
          for (const placeholder of this.pullQueue) {
            placeholder.reject(error);
          }
          this.pullQueue.length = 0;
        } else {
          const rejection = Promise.reject(error);
          rejection.catch(() => {
          });
          this.pushQueue.push(rejection);
        }
      }
      remove() {
        Promise.resolve().then(() => {
          if (this.removeCallback)
            this.removeCallback();
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: (value7) => {
            const result = this.pushQueue.shift();
            if (result) {
              if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                this.isPaused = false;
                if (this.eventHandlers.lowWater) {
                  this.eventHandlers.lowWater();
                }
              }
              return result;
            } else if (this.isStopped) {
              return Promise.resolve({ value: void 0, done: true });
            } else {
              return new Promise((resolve, reject) => {
                this.pullQueue.push({ resolve, reject });
              });
            }
          },
          return: () => {
            this.isStopped = true;
            this.pushQueue.length = 0;
            this.remove();
            return Promise.resolve({ value: void 0, done: true });
          }
        };
      }
    };
    var EventIterator2 = class {
      constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback = listen({
          push: (value7) => queue.push(value7),
          stop: () => queue.stop(),
          fail: (error) => queue.fail(error),
          on: (event, fn) => {
            queue.eventHandlers[event] = fn;
          }
        }) || (() => {
        });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
      }
    };
    exports.EventIterator = EventIterator2;
    exports.default = EventIterator2;
  }
});

// node_modules/event-iterator/lib/dom.js
var require_dom = __commonJS({
  "node_modules/event-iterator/lib/dom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var event_iterator_1 = require_event_iterator();
    exports.EventIterator = event_iterator_1.EventIterator;
    function subscribe(event, options2, evOptions) {
      return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options2);
        return () => this.removeEventListener(event, push, options2);
      }, evOptions);
    }
    exports.subscribe = subscribe;
    exports.default = event_iterator_1.EventIterator;
  }
});

// node_modules/@multiformats/dns/dist/src/utils/get-types.js
function getTypes(types) {
  const DEFAULT_TYPES = [
    RecordType.A
  ];
  if (types == null) {
    return DEFAULT_TYPES;
  }
  if (Array.isArray(types)) {
    if (types.length === 0) {
      return DEFAULT_TYPES;
    }
    return types;
  }
  return [
    types
  ];
}

// node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js
var DEFAULT_TTL = 60;
function toDNSResponse(obj) {
  return {
    Status: obj.Status ?? 0,
    TC: obj.TC ?? obj.flag_tc ?? false,
    RD: obj.RD ?? obj.flag_rd ?? false,
    RA: obj.RA ?? obj.flag_ra ?? false,
    AD: obj.AD ?? obj.flag_ad ?? false,
    CD: obj.CD ?? obj.flag_cd ?? false,
    Question: (obj.Question ?? obj.questions ?? []).map((question) => {
      return {
        name: question.name,
        type: RecordType[question.type]
      };
    }),
    Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
      return {
        name: answer.name,
        type: RecordType[answer.type],
        TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
        data: answer.data instanceof Uint8Array ? toString(answer.data) : answer.data
      };
    })
  };
}

// node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js
var DEFAULT_QUERY_CONCURRENCY = 4;
function dnsJsonOverHttps(url, init = {}) {
  const httpQueue = new PQueue({
    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
  });
  return async (fqdn, options2 = {}) => {
    const searchParams = new URLSearchParams();
    searchParams.set("name", fqdn);
    getTypes(options2.types).forEach((type) => {
      searchParams.append("type", RecordType[type]);
    });
    options2.onProgress?.(new CustomProgressEvent("dns:query", { detail: fqdn }));
    const response = await httpQueue.add(async () => {
      const res = await fetch(`${url}?${searchParams}`, {
        headers: {
          accept: "application/dns-json"
        },
        signal: options2?.signal
      });
      if (res.status !== 200) {
        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
      }
      const response2 = toDNSResponse(await res.json());
      options2.onProgress?.(new CustomProgressEvent("dns:response", { detail: response2 }));
      return response2;
    }, {
      signal: options2.signal
    });
    if (response == null) {
      throw new Error("No DNS response received");
    }
    return response;
  };
}

// node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js
function defaultResolver() {
  return [
    dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
    dnsJsonOverHttps("https://dns.google/resolve")
  ];
}

// node_modules/@multiformats/dns/dist/src/utils/cache.js
var import_hashlru = __toESM(require_hashlru(), 1);
var CachedAnswers = class {
  lru;
  constructor(maxSize) {
    this.lru = (0, import_hashlru.default)(maxSize);
  }
  get(fqdn, types) {
    let foundAllAnswers = true;
    const answers = [];
    for (const type of types) {
      const cached = this.getAnswers(fqdn, type);
      if (cached.length === 0) {
        foundAllAnswers = false;
        break;
      }
      answers.push(...cached);
    }
    if (foundAllAnswers) {
      return toDNSResponse({ answers });
    }
  }
  getAnswers(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    const answers = this.lru.get(key);
    if (answers != null) {
      const cachedAnswers = answers.filter((entry) => {
        return entry.expires > Date.now();
      }).map(({ expires, value: value7 }) => ({
        ...value7,
        TTL: Math.round((expires - Date.now()) / 1e3),
        type: RecordType[value7.type]
      }));
      if (cachedAnswers.length === 0) {
        this.lru.remove(key);
      }
      return cachedAnswers;
    }
    return [];
  }
  add(domain, answer) {
    const key = `${domain.toLowerCase()}-${answer.type}`;
    const answers = this.lru.get(key) ?? [];
    answers.push({
      expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
      value: answer
    });
    this.lru.set(key, answers);
  }
  remove(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};
function cache(size) {
  return new CachedAnswers(size);
}

// node_modules/@multiformats/dns/dist/src/dns.js
var DEFAULT_ANSWER_CACHE_SIZE = 1e3;
var DNS = class {
  resolvers;
  cache;
  constructor(init) {
    this.resolvers = {};
    this.cache = cache(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {
      if (!Array.isArray(resolver)) {
        resolver = [resolver];
      }
      if (!tld.endsWith(".")) {
        tld = `${tld}.`;
      }
      this.resolvers[tld] = resolver;
    });
    if (this.resolvers["."] == null) {
      this.resolvers["."] = defaultResolver();
    }
  }
  /**
   * Queries DNS resolvers for the passed record types for the passed domain.
   *
   * If cached records exist for all desired types they will be returned
   * instead.
   *
   * Any new responses will be added to the cache for subsequent requests.
   */
  async query(domain, options2 = {}) {
    const types = getTypes(options2.types);
    const cached = options2.cached !== false ? this.cache.get(domain, types) : void 0;
    if (cached != null) {
      options2.onProgress?.(new CustomProgressEvent("dns:cache", { detail: cached }));
      return cached;
    }
    const tld = `${domain.split(".").pop()}.`;
    const resolvers = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
      return Math.random() > 0.5 ? -1 : 1;
    });
    const errors = [];
    for (const resolver of resolvers) {
      if (options2.signal?.aborted === true) {
        break;
      }
      try {
        const result = await resolver(domain, {
          ...options2,
          types
        });
        for (const answer of result.Answer) {
          this.cache.add(domain, answer);
        }
        return result;
      } catch (err) {
        errors.push(err);
        options2.onProgress?.(new CustomProgressEvent("dns:error", { detail: err }));
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`);
  }
};

// node_modules/@multiformats/dns/dist/src/index.js
var RecordType;
(function(RecordType2) {
  RecordType2[RecordType2["A"] = 1] = "A";
  RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
  RecordType2[RecordType2["TXT"] = 16] = "TXT";
  RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
})(RecordType || (RecordType = {}));
function dns(init = {}) {
  return new DNS(init);
}

// node_modules/race-event/dist/src/index.js
var AbortError2 = class extends Error {
  type;
  code;
  constructor(message2, code17) {
    super(message2 ?? "The operation was aborted");
    this.type = "aborted";
    this.name = "AbortError";
    this.code = code17 ?? "ABORT_ERR";
  }
};
async function raceEvent(emitter, eventName, signal, opts) {
  const error = new AbortError2(opts?.errorMessage, opts?.errorCode);
  if (signal?.aborted === true) {
    return Promise.reject(error);
  }
  return new Promise((resolve, reject) => {
    function removeListeners() {
      signal?.removeEventListener("abort", abortListener);
      emitter.removeEventListener(eventName, eventListener);
      if (opts?.errorEvent != null) {
        emitter.removeEventListener(opts.errorEvent, errorEventListener);
      }
    }
    const eventListener = (evt) => {
      try {
        if (opts?.filter?.(evt) === false) {
          return;
        }
      } catch (err) {
        removeListeners();
        reject(err);
        return;
      }
      removeListeners();
      resolve(evt);
    };
    const errorEventListener = (evt) => {
      removeListeners();
      reject(evt.detail);
    };
    const abortListener = () => {
      removeListeners();
      reject(error);
    };
    signal?.addEventListener("abort", abortListener);
    emitter.addEventListener(eventName, eventListener);
    if (opts?.errorEvent != null) {
      emitter.addEventListener(opts.errorEvent, errorEventListener);
    }
  });
}

// node_modules/@libp2p/utils/dist/src/debounce.js
function debounce(func2, wait) {
  let timeout;
  const output = function() {
    const later = function() {
      timeout = void 0;
      void func2();
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
  output.start = () => {
  };
  output.stop = () => {
    clearTimeout(timeout);
  };
  return output;
}

// node_modules/@libp2p/utils/dist/src/errors.js
var RateLimitError = class extends Error {
  remainingPoints;
  msBeforeNext;
  consumedPoints;
  isFirstInDuration;
  constructor(message2 = "Rate limit exceeded", props) {
    super(message2);
    this.name = "RateLimitError";
    this.remainingPoints = props.remainingPoints;
    this.msBeforeNext = props.msBeforeNext;
    this.consumedPoints = props.consumedPoints;
    this.isFirstInDuration = props.isFirstInDuration;
  }
};
var QueueFullError = class extends Error {
  static name = "QueueFullError";
  constructor(message2 = "The queue was full") {
    super(message2);
    this.name = "QueueFullError";
  }
};

// node_modules/@libp2p/utils/dist/src/queue/recipient.js
var JobRecipient = class {
  deferred;
  signal;
  constructor(signal) {
    this.signal = signal;
    this.deferred = pDefer();
    this.onAbort = this.onAbort.bind(this);
    this.signal?.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    this.deferred.reject(this.signal?.reason ?? new AbortError());
  }
  cleanup() {
    this.signal?.removeEventListener("abort", this.onAbort);
  }
};

// node_modules/@libp2p/utils/dist/src/queue/job.js
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
var Job = class {
  id;
  fn;
  options;
  recipients;
  status;
  timeline;
  controller;
  constructor(fn, options2) {
    this.id = randomId();
    this.status = "queued";
    this.fn = fn;
    this.options = options2;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      return acc && curr.signal?.aborted === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError());
      this.cleanup();
    }
  }
  async join(options2 = {}) {
    const recipient = new JobRecipient(options2.signal);
    this.recipients.push(recipient);
    options2.signal?.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      recipient.cleanup();
      recipient.signal?.removeEventListener("abort", this.onAbort);
    });
  }
};

// node_modules/@libp2p/utils/dist/src/queue/index.js
var Queue = class extends TypedEventEmitter {
  concurrency;
  maxSize;
  queue;
  pending;
  sort;
  constructor(init = {}) {
    super();
    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    if (init.metricName != null) {
      init.metrics?.registerMetricGroup(init.metricName, {
        calculate: () => {
          return {
            size: this.queue.length,
            running: this.pending,
            queued: this.queue.length - this.pending
          };
        }
      });
    }
    this.sort = init.sort;
    this.queue = [];
    this.emitEmpty = debounce(this.emitEmpty.bind(this), 1);
    this.emitIdle = debounce(this.emitIdle.bind(this), 1);
  }
  emitEmpty() {
    if (this.size !== 0) {
      return;
    }
    this.safeDispatchEvent("empty");
  }
  emitIdle() {
    if (this.running !== 0) {
      return;
    }
    this.safeDispatchEvent("idle");
  }
  tryToStartAnother() {
    if (this.size === 0) {
      this.emitEmpty();
      if (this.running === 0) {
        this.emitIdle();
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
        this.pending--;
        this.tryToStartAnother();
        this.safeDispatchEvent("next");
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options2) {
    options2?.signal?.throwIfAborted();
    if (this.size === this.maxSize) {
      throw new QueueFullError();
    }
    const job = new Job(fn, options2);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    this.tryToStartAnother();
    return job.join(options2).then((result) => {
      this.safeDispatchEvent("completed", { detail: result });
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("error", { detail: err });
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options2) {
    if (this.size === 0) {
      return;
    }
    await raceEvent(this, "empty", options2?.signal);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options2) {
    if (this.size < limit) {
      return;
    }
    await raceEvent(this, "next", options2?.signal, {
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options2) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await raceEvent(this, "idle", options2?.signal);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options2) {
    options2?.signal?.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail);
      }
    };
    const onQueueError = (evt) => {
      cleanup(evt.detail);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new AbortError("Queue aborted"));
    };
    this.addEventListener("completed", onQueueJobComplete);
    this.addEventListener("error", onQueueError);
    this.addEventListener("idle", onQueueIdle);
    options2?.signal?.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("completed", onQueueJobComplete);
      this.removeEventListener("error", onQueueError);
      this.removeEventListener("idle", onQueueIdle);
      options2?.signal?.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
};

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bytes.js
var empty = new Uint8Array(0);
function equals2(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@helia/utils/node_modules/multiformats/dist/src/vendor/base-x.js
function base(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base.js
var Encoder = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or(left, right) {
  return new ComposedDecoder({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name9, prefix, baseEncode);
    this.decoder = new Decoder(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec(name9, prefix, encode39, decode61);
}
function baseX({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default(alphabet2, name9);
  return from({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce(decode61(text))
  });
}
function decode3(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode3(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc4648({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx(alphabet2);
  return from({
    prefix,
    name: name9,
    encode(input) {
      return encode3(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode3(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base36.js
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base32.js
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@helia/utils/node_modules/multiformats/dist/src/vendor/varint.js
var encode_1 = encode4;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode4(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode4.bytes = offset - oldOffset + 1;
  return out;
}
var decode4 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value7) {
  return value7 < N1 ? 1 : value7 < N2 ? 2 : value7 < N3 ? 3 : value7 < N4 ? 4 : value7 < N5 ? 5 : value7 < N6 ? 6 : value7 < N7 ? 7 : value7 < N8 ? 8 : value7 < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode4,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/@helia/utils/node_modules/multiformats/dist/src/varint.js
function decode5(data, offset = 0) {
  const code17 = varint_default.decode(data, offset);
  return [code17, varint_default.decode.bytes];
}
function encodeTo(int, target, offset = 0) {
  varint_default.encode(int, target, offset);
  return target;
}
function encodingLength2(int) {
  return varint_default.encodingLength(int);
}

// node_modules/@helia/utils/node_modules/multiformats/dist/src/hashes/digest.js
function create(code17, digest5) {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength2(code17);
  const digestOffset = sizeOffset + encodingLength2(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code17, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest5, digestOffset);
  return new Digest(code17, size, digest5, bytes);
}
function decode6(multihash) {
  const bytes = coerce(multihash);
  const [code17, sizeOffset] = decode5(bytes);
  const [size, digestOffset] = decode5(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code17, size, digest5, bytes);
}
function equals3(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals2(a.bytes, data.bytes);
  }
}
var Digest = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/@helia/utils/node_modules/multiformats/dist/src/cid.js
function format(link, base14) {
  const { bytes, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV0(bytes, baseCache(link), base14 ?? base58btc.encoder);
    default:
      return toStringV1(bytes, baseCache(link), base14 ?? base32.encoder);
  }
}
var cache2 = /* @__PURE__ */ new WeakMap();
function baseCache(cid) {
  const baseCache11 = cache2.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache2.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code17, multihash, bytes) {
    this.code = code17;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code17, multihash } = this;
        if (code17 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code17, digest: digest5 } = this.multihash;
        const multihash = create(code17, digest5);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals3(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format(this, base14);
  }
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value7 = input;
    if (value7 instanceof _CID) {
      return value7;
    } else if (value7["/"] != null && value7["/"] === value7.bytes || value7.asCID === value7) {
      const { version: version3, code: code17, multihash, bytes } = value7;
      return new _CID(version3, code17, multihash, bytes ?? encodeCID(version3, code17, multihash.bytes));
    } else if (value7[cidSymbol] === true) {
      const { version: version3, multihash, code: code17 } = value7;
      const digest5 = decode6(multihash);
      return _CID.create(version3, code17, digest5);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code17, digest5) {
    if (typeof code17 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code17 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version3, code17, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version3, code17, digest5.bytes);
        return new _CID(version3, code17, digest5, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code17, digest5) {
    return _CID.create(1, code17, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest5 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest5) : _CID.createV1(specs.codec, digest5);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length16] = decode5(initialBytes.subarray(offset));
      offset += length16;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base14 ?? base58btc;
      return [base58btc.prefix, decoder.decode(source)];
    }
    case base32.prefix: {
      const decoder = base14 ?? base32;
      return [base32.prefix, decoder.decode(source)];
    }
    case base36.prefix: {
      const decoder = base14 ?? base36;
      return [base36.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV0(bytes, cache12, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV1(bytes, cache12, base14) {
  const { prefix } = base14;
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
function encodeCID(version3, code17, multihash) {
  const codeOffset = encodingLength2(version3);
  const hashOffset = codeOffset + encodingLength2(code17);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version3, bytes, 0);
  encodeTo(code17, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol = Symbol.for("@ipld/js-cid/CID");

// node_modules/@helia/utils/node_modules/multiformats/dist/src/hashes/hasher.js
function from2({ name: name9, code: code17, encode: encode39 }) {
  return new Hasher(name9, code17, encode39);
}
var Hasher = class {
  name;
  code;
  encode;
  constructor(name9, code17, encode39) {
    this.name = name9;
    this.code = code17;
    this.encode = encode39;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest5) => create(this.code, digest5));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@helia/utils/node_modules/multiformats/dist/src/block.js
function readonly({ enumerable = true, configurable = false } = {}) {
  return { enumerable, configurable, writable: false };
}
function* linksWithin(path, value7) {
  if (value7 != null && typeof value7 === "object") {
    if (Array.isArray(value7)) {
      for (const [index, element] of value7.entries()) {
        const elementPath = [...path, index];
        const cid = CID.asCID(element);
        if (cid != null) {
          yield [elementPath.join("/"), cid];
        } else if (typeof element === "object") {
          yield* links(element, elementPath);
        }
      }
    } else {
      const cid = CID.asCID(value7);
      if (cid != null) {
        yield [path.join("/"), cid];
      } else {
        yield* links(value7, path);
      }
    }
  }
}
function* links(source, base14) {
  if (source == null || source instanceof Uint8Array) {
    return;
  }
  const cid = CID.asCID(source);
  if (cid != null) {
    yield [base14.join("/"), cid];
  }
  for (const [key, value7] of Object.entries(source)) {
    const path = [...base14, key];
    yield* linksWithin(path, value7);
  }
}
function* treeWithin(path, value7) {
  if (Array.isArray(value7)) {
    for (const [index, element] of value7.entries()) {
      const elementPath = [...path, index];
      yield elementPath.join("/");
      if (typeof element === "object" && CID.asCID(element) == null) {
        yield* tree(element, elementPath);
      }
    }
  } else {
    yield* tree(value7, path);
  }
}
function* tree(source, base14) {
  if (source == null || typeof source !== "object") {
    return;
  }
  for (const [key, value7] of Object.entries(source)) {
    const path = [...base14, key];
    yield path.join("/");
    if (value7 != null && !(value7 instanceof Uint8Array) && typeof value7 === "object" && CID.asCID(value7) == null) {
      yield* treeWithin(path, value7);
    }
  }
}
function get(source, path) {
  let node = source;
  for (const [index, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node);
    if (cid != null) {
      return { value: cid, remaining: path.slice(index + 1).join("/") };
    }
  }
  return { value: node };
}
var Block = class {
  cid;
  bytes;
  value;
  asBlock;
  constructor({ cid, bytes, value: value7 }) {
    if (cid == null || bytes == null || typeof value7 === "undefined") {
      throw new Error("Missing required argument");
    }
    this.cid = cid;
    this.bytes = bytes;
    this.value = value7;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly(),
      bytes: readonly(),
      value: readonly(),
      asBlock: readonly()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path = "/") {
    return get(this.value, path.split("/").filter(Boolean));
  }
};
function createUnsafe({ bytes, cid, value: maybeValue, codec }) {
  const value7 = maybeValue !== void 0 ? maybeValue : codec?.decode(bytes);
  if (value7 === void 0) {
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  }
  return new Block({
    cid,
    bytes,
    value: value7
  });
}

// node_modules/@helia/utils/dist/src/pins.js
var DATASTORE_PIN_PREFIX = "/pin/";
var DATASTORE_BLOCK_PREFIX = "/pinned-block/";
var DATASTORE_ENCODING = base36;
var DAG_WALK_QUEUE_CONCURRENCY = 1;
function toDSKey(cid) {
  if (cid.version === 0) {
    cid = cid.toV1();
  }
  return new Key(`${DATASTORE_PIN_PREFIX}${cid.toString(DATASTORE_ENCODING)}`);
}
var PinsImpl = class {
  datastore;
  blockstore;
  getCodec;
  constructor(datastore, blockstore, getCodec2) {
    this.datastore = datastore;
    this.blockstore = blockstore;
    this.getCodec = getCodec2;
  }
  async *add(cid, options2 = {}) {
    const pinKey = toDSKey(cid);
    if (await this.datastore.has(pinKey)) {
      throw new Error("Already pinned");
    }
    const depth = Math.round(options2.depth ?? Infinity);
    if (depth < 0) {
      throw new Error("Depth must be greater than or equal to 0");
    }
    const queue = new Queue({
      concurrency: DAG_WALK_QUEUE_CONCURRENCY
    });
    for await (const childCid of this.#walkDag(cid, queue, {
      ...options2,
      depth
    })) {
      await this.#updatePinnedBlock(childCid, (pinnedBlock) => {
        if (pinnedBlock.pinnedBy.find((c) => equals(c, cid.bytes)) != null) {
          return false;
        }
        pinnedBlock.pinCount++;
        pinnedBlock.pinnedBy.push(cid.bytes);
        return true;
      }, options2);
      yield childCid;
    }
    const pin = {
      depth,
      metadata: options2.metadata ?? {}
    };
    await this.datastore.put(pinKey, encode2(pin), options2);
  }
  /**
   * Walk a DAG in an iterable fashion
   */
  async *#walkDag(cid, queue, options2) {
    if (options2.depth === -1) {
      return;
    }
    const codec = await this.getCodec(cid.code);
    const bytes = await this.blockstore.get(cid, options2);
    const block = createUnsafe({ bytes, cid, codec });
    yield cid;
    for (const [, cid2] of block.links()) {
      yield* await queue.add(async () => {
        return this.#walkDag(cid2, queue, {
          ...options2,
          depth: options2.depth - 1
        });
      });
    }
  }
  /**
   * Update the pin count for the CID
   */
  async #updatePinnedBlock(cid, withPinnedBlock, options2) {
    const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);
    let pinnedBlock = {
      pinCount: 0,
      pinnedBy: []
    };
    try {
      pinnedBlock = decode2(await this.datastore.get(blockKey, options2));
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    const shouldContinue = withPinnedBlock(pinnedBlock);
    if (!shouldContinue) {
      return;
    }
    if (pinnedBlock.pinCount === 0) {
      if (await this.datastore.has(blockKey)) {
        await this.datastore.delete(blockKey);
        return;
      }
    }
    await this.datastore.put(blockKey, encode2(pinnedBlock), options2);
    options2.onProgress?.(new CustomProgressEvent("helia:pin:add", cid));
  }
  async *rm(cid, options2 = {}) {
    const pinKey = toDSKey(cid);
    const buf = await this.datastore.get(pinKey, options2);
    const pin = decode2(buf);
    await this.datastore.delete(pinKey, options2);
    const queue = new Queue({
      concurrency: DAG_WALK_QUEUE_CONCURRENCY
    });
    for await (const childCid of this.#walkDag(cid, queue, {
      ...options2,
      depth: pin.depth
    })) {
      await this.#updatePinnedBlock(childCid, (pinnedBlock) => {
        pinnedBlock.pinCount--;
        pinnedBlock.pinnedBy = pinnedBlock.pinnedBy.filter((c) => equals(c, cid.bytes));
        return true;
      }, {
        ...options2,
        depth: pin.depth
      });
      yield childCid;
    }
  }
  async *ls(options2 = {}) {
    for await (const { key, value: value7 } of this.datastore.query({
      prefix: DATASTORE_PIN_PREFIX + (options2.cid != null ? `${options2.cid.toString(base36)}` : "")
    }, options2)) {
      const cid = CID.parse(key.toString().substring(5), base36);
      const pin = decode2(value7);
      yield {
        cid,
        ...pin
      };
    }
  }
  async isPinned(cid, options2 = {}) {
    const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);
    return this.datastore.has(blockKey, options2);
  }
  async get(cid, options2) {
    const pinKey = toDSKey(cid);
    const buf = await this.datastore.get(pinKey, options2);
    return decode2(buf);
  }
  async setMetadata(cid, metadata, options2) {
    const pinKey = toDSKey(cid);
    const buf = await this.datastore.get(pinKey, options2);
    const pin = decode2(buf);
    pin.metadata = metadata ?? {};
    await this.datastore.put(pinKey, encode2(pin), options2);
  }
};

// node_modules/@helia/interface/dist/src/blocks.js
var DEFAULT_SESSION_MIN_PROVIDERS = 1;
var DEFAULT_SESSION_MAX_PROVIDERS = 5;

// node_modules/@helia/interface/dist/src/errors.js
var InsufficientProvidersError = class extends Error {
  static name = "InsufficientProvidersError";
  constructor(message2 = "Insufficient providers found") {
    super(message2);
    this.name = "InsufficientProvidersError";
  }
};
var NoRoutersAvailableError = class extends Error {
  static name = "NoRoutersAvailableError";
  constructor(message2 = "No routers available") {
    super(message2);
    this.name = "NoRoutersAvailableError";
  }
};
var UnknownHashAlgorithmError = class extends Error {
  static name = "UnknownHashAlgorithmError";
  constructor(message2 = "Unknown hash algorithm") {
    super(message2);
    this.name = "UnknownHashAlgorithmError";
  }
};
var UnknownCodecError = class extends Error {
  static name = "UnknownCodecError";
  constructor(message2 = "Unknown codec") {
    super(message2);
    this.name = "UnknownCodecError";
  }
};

// node_modules/@libp2p/utils/dist/src/peer-queue.js
var PeerQueue = class extends Queue {
  has(peerId2) {
    return this.find(peerId2) != null;
  }
  find(peerId2) {
    return this.queue.find((job) => {
      return peerId2.equals(job.options.peerId);
    });
  }
};

// node_modules/@helia/utils/dist/src/routing.js
var DEFAULT_PROVIDER_LOOKUP_CONCURRENCY = 5;
var Routing = class {
  log;
  routers;
  providerLookupConcurrency;
  constructor(components, init) {
    this.log = components.logger.forComponent("helia:routing");
    this.routers = init.routers ?? [];
    this.providerLookupConcurrency = init.providerLookupConcurrency ?? DEFAULT_PROVIDER_LOOKUP_CONCURRENCY;
    this.findProviders = components.metrics?.traceFunction("helia.routing.findProviders", this.findProviders.bind(this), {
      optionsIndex: 1
    }) ?? this.findProviders;
    this.provide = components.metrics?.traceFunction("helia.routing.provide", this.provide.bind(this), {
      optionsIndex: 1
    }) ?? this.provide;
    this.cancelReprovide = components.metrics?.traceFunction("helia.routing.cancelReprovide", this.cancelReprovide.bind(this), {
      optionsIndex: 1
    }) ?? this.cancelReprovide;
    this.put = components.metrics?.traceFunction("helia.routing.put", this.put.bind(this), {
      optionsIndex: 2
    }) ?? this.put;
    this.get = components.metrics?.traceFunction("helia.routing.get", this.get.bind(this), {
      optionsIndex: 1
    }) ?? this.get;
    this.findPeer = components.metrics?.traceFunction("helia.routing.findPeer", this.findPeer.bind(this), {
      optionsIndex: 1
    }) ?? this.findPeer;
    this.getClosestPeers = components.metrics?.traceFunction("helia.routing.getClosestPeers", this.getClosestPeers.bind(this), {
      optionsIndex: 1
    }) ?? this.getClosestPeers;
  }
  async start() {
    await start(...this.routers);
  }
  async stop() {
    await stop(...this.routers);
  }
  /**
   * Iterates over all content routers in parallel to find providers of the
   * given key
   */
  async *findProviders(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoRoutersAvailableError("No content routers available");
    }
    const queue = new PeerQueue({
      concurrency: this.providerLookupConcurrency
    });
    queue.addEventListener("error", () => {
    });
    for await (const peer of src_default2(queue.toGenerator(), ...supports(this.routers, "findProviders").map((router) => router.findProviders(key, options2)))) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length === 0) {
        if (queue.find(peer.id) != null) {
          continue;
        }
        queue.add(async () => {
          try {
            const provider = await this.findPeer(peer.id, options2);
            if (provider.multiaddrs.length === 0) {
              return null;
            }
            return provider;
          } catch (err) {
            this.log.error("could not load multiaddrs for peer %p", peer.id, err);
            return null;
          }
        }, {
          peerId: peer.id,
          signal: options2.signal
        }).catch((err) => {
          this.log.error("could not load multiaddrs for peer %p", peer.id, err);
        });
      }
      yield peer;
    }
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoRoutersAvailableError("No content routers available");
    }
    await Promise.all(supports(this.routers, "provide").map(async (router) => {
      await router.provide(key, options2);
    }));
  }
  async cancelReprovide(key, options2 = {}) {
    await Promise.all(supports(this.routers, "cancelReprovide").map(async (router) => {
      await router.cancelReprovide(key, options2);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value7, options2) {
    await Promise.all(supports(this.routers, "put").map(async (router) => {
      await router.put(key, value7, options2);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options2) {
    return Promise.any(supports(this.routers, "get").map(async (router) => {
      return router.get(key, options2);
    }));
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options2) {
    if (this.routers.length === 0) {
      throw new NoRoutersAvailableError("No peer routers available");
    }
    const self2 = this;
    const source = src_default2(...supports(this.routers, "findPeer").map((router) => async function* () {
      try {
        yield await router.findPeer(id, options2);
      } catch (err) {
        self2.log.error(err);
      }
    }()));
    for await (const peer of source) {
      if (peer == null) {
        continue;
      }
      return peer;
    }
    throw new NotFoundError("Could not find peer in routing");
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoRoutersAvailableError("No peer routers available");
    }
    for await (const peer of src_default2(...supports(this.routers, "getClosestPeers").map((router) => router.getClosestPeers(key, options2)))) {
      if (peer == null) {
        continue;
      }
      yield peer;
    }
  }
};
function supports(routers, key) {
  return routers.filter((router) => router[key] != null);
}

// node_modules/abort-error/dist/src/index.js
var AbortError3 = class extends Error {
  static name = "AbortError";
  name = "AbortError";
  constructor(message2 = "The operation was aborted", ...rest) {
    super(message2, ...rest);
  }
};

// node_modules/it-queue/dist/src/errors.js
var QueueFullError2 = class extends Error {
  static name = "QueueFullError";
  constructor(message2 = "The queue was full") {
    super(message2);
    this.name = "QueueFullError";
  }
};

// node_modules/it-queue/dist/src/recipient.js
var JobRecipient2 = class {
  deferred;
  signal;
  constructor(signal) {
    this.signal = signal;
    this.deferred = Promise.withResolvers();
    this.onAbort = this.onAbort.bind(this);
    this.signal?.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    this.deferred.reject(this.signal?.reason ?? new AbortError3());
  }
  cleanup() {
    this.signal?.removeEventListener("abort", this.onAbort);
  }
};

// node_modules/it-queue/dist/src/job.js
function randomId2() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
var Job2 = class {
  id;
  fn;
  options;
  recipients;
  status;
  timeline;
  controller;
  constructor(fn, options2) {
    this.id = randomId2();
    this.status = "queued";
    this.fn = fn;
    this.options = options2;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      return acc && curr.signal?.aborted === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError3());
      this.cleanup();
    }
  }
  async join(options2 = {}) {
    const recipient = new JobRecipient2(options2.signal);
    this.recipients.push(recipient);
    options2.signal?.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      recipient.cleanup();
      recipient.signal?.removeEventListener("abort", this.onAbort);
    });
  }
};

// node_modules/it-queue/dist/src/utils.js
function debounce2(func2, wait) {
  let timeout;
  const output = function() {
    const later = function() {
      timeout = void 0;
      void func2();
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
  output.start = () => {
  };
  output.stop = () => {
    clearTimeout(timeout);
  };
  return output;
}

// node_modules/it-queue/dist/src/index.js
var Queue2 = class extends TypedEventEmitter {
  concurrency;
  maxSize;
  queue;
  pending;
  sort;
  autoStart;
  constructor(init = {}) {
    super();
    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    this.autoStart = init.autoStart ?? true;
    this.sort = init.sort;
    this.queue = [];
    this.emitEmpty = debounce2(this.emitEmpty.bind(this), 1);
    this.emitIdle = debounce2(this.emitIdle.bind(this), 1);
  }
  [Symbol.asyncIterator]() {
    return this.toGenerator();
  }
  emitEmpty() {
    if (this.size !== 0) {
      return;
    }
    this.safeDispatchEvent("empty");
  }
  emitIdle() {
    if (this.running !== 0) {
      return;
    }
    this.safeDispatchEvent("idle");
  }
  tryToStartAnother() {
    if (this.size === 0) {
      this.emitEmpty();
      if (this.running === 0) {
        this.emitIdle();
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
        this.pending--;
        this.safeDispatchEvent("next");
        if (this.autoStart) {
          this.tryToStartAnother();
        }
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Start the queue. If the `autoStart` parameter passed to the constructor was
   * not `false` this is a no-op
   */
  start() {
    if (this.autoStart !== false) {
      return;
    }
    this.autoStart = true;
    this.tryToStartAnother();
  }
  /**
   * Prevent further jobs from running - call `.start` to start the queue again
   */
  pause() {
    this.autoStart = false;
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options2) {
    options2?.signal?.throwIfAborted();
    if (this.size === this.maxSize) {
      throw new QueueFullError2();
    }
    const job = new Job2(fn, options2);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    if (this.autoStart) {
      this.tryToStartAnother();
    }
    return job.join(options2).then((result) => {
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError3());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options2) {
    if (this.size === 0) {
      return;
    }
    await raceEvent(this, "empty", options2?.signal);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options2) {
    if (this.size < limit) {
      return;
    }
    await raceEvent(this, "next", options2?.signal, {
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options2) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await raceEvent(this, "idle", options2?.signal);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options2) {
    options2?.signal?.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail.result);
      }
    };
    const onQueueError = (evt) => {
      cleanup(evt.detail.error);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new AbortError3("Queue aborted"));
    };
    this.addEventListener("success", onQueueJobComplete);
    this.addEventListener("failure", onQueueError);
    this.addEventListener("idle", onQueueIdle);
    options2?.signal?.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("success", onQueueJobComplete);
      this.removeEventListener("failure", onQueueError);
      this.removeEventListener("idle", onQueueIdle);
      options2?.signal?.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
};

// node_modules/mortice/dist/src/constants.js
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_ABORT_READ_LOCK_REQUEST = "lock:worker:abort-read-request";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var MASTER_READ_LOCK_ERROR = "lock:master:error-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_ABORT_WRITE_LOCK_REQUEST = "lock:worker:abort-write-request";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
var MASTER_WRITE_LOCK_ERROR = "lock:master:error-write";
var WORKER_FINALIZE = "lock:worker:finalize";
var BROADCAST_CHANNEL_NAME = "mortice";
var defaultOptions = {
  singleProcess: false
};

// node_modules/mortice/dist/src/main/channel.js
var handleChannelWorkerLockRequest = (emitter, channel, masterEvent, abortMasterEvent, requestType, abortType, errorType, releaseType, grantType) => {
  return (event) => {
    if (event.data == null) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    if (requestEvent.type === requestType) {
      emitter.safeDispatchEvent(masterEvent, {
        detail: {
          name: requestEvent.name,
          identifier: requestEvent.identifier,
          handler: async () => {
            channel.postMessage({
              type: grantType,
              name: requestEvent.name,
              identifier: requestEvent.identifier
            });
            await new Promise((resolve) => {
              const releaseEventListener = (event2) => {
                if (event2?.data == null) {
                  return;
                }
                const releaseEvent = {
                  type: event2.data.type,
                  name: event2.data.name,
                  identifier: event2.data.identifier
                };
                if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                  channel.removeEventListener("message", releaseEventListener);
                  resolve();
                }
              };
              channel.addEventListener("message", releaseEventListener);
            });
          },
          onError: (err) => {
            channel.postMessage({
              type: errorType,
              name: requestEvent.name,
              identifier: requestEvent.identifier,
              error: {
                message: err.message,
                name: err.name,
                stack: err.stack
              }
            });
          }
        }
      });
    }
    if (requestEvent.type === abortType) {
      emitter.safeDispatchEvent(abortMasterEvent, {
        detail: {
          name: requestEvent.name,
          identifier: requestEvent.identifier
        }
      });
    }
    if (requestEvent.type === WORKER_FINALIZE) {
      emitter.safeDispatchEvent("finalizeRequest", {
        detail: {
          name: requestEvent.name
        }
      });
    }
  };
};

// node_modules/mortice/dist/src/utils.js
var nanoid = (size = 10) => {
  return Math.random().toString().substring(2, size + 2);
};

// node_modules/mortice/dist/src/workers/channel.js
var MorticeChannelWorker = class {
  name;
  channel;
  constructor(name9) {
    this.name = name9;
    this.channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
  }
  readLock(options2) {
    return this.sendRequest(WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_GRANT_READ_LOCK, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, options2);
  }
  writeLock(options2) {
    return this.sendRequest(WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_GRANT_WRITE_LOCK, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, options2);
  }
  finalize() {
    this.channel.postMessage({
      type: WORKER_FINALIZE,
      name: this.name
    });
    this.channel.close();
  }
  async sendRequest(requestType, abortType, grantType, errorType, releaseType, options2) {
    options2?.signal?.throwIfAborted();
    const id = nanoid();
    this.channel.postMessage({
      type: requestType,
      identifier: id,
      name: this.name
    });
    return new Promise((resolve, reject) => {
      const abortListener = () => {
        this.channel.postMessage({
          type: abortType,
          identifier: id,
          name: this.name
        });
      };
      options2?.signal?.addEventListener("abort", abortListener, {
        once: true
      });
      const listener = (event) => {
        if (event.data?.identifier !== id) {
          return;
        }
        if (event.data?.type === grantType) {
          this.channel.removeEventListener("message", listener);
          options2?.signal?.removeEventListener("abort", abortListener);
          resolve(() => {
            this.channel.postMessage({
              type: releaseType,
              identifier: id,
              name: this.name
            });
          });
        }
        if (event.data.type === errorType) {
          this.channel.removeEventListener("message", listener);
          options2?.signal?.removeEventListener("abort", abortListener);
          const err = new Error();
          if (event.data.error != null) {
            err.message = event.data.error.message;
            err.name = event.data.error.name;
            err.stack = event.data.error.stack;
          }
          reject(err);
        }
      };
      this.channel.addEventListener("message", listener);
    });
  }
};

// node_modules/mortice/dist/src/browser.js
var browser_default = (options2) => {
  options2 = Object.assign({}, defaultOptions, options2);
  const isPrimary = Boolean(globalThis.document) || options2.singleProcess;
  if (isPrimary) {
    const channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
    const emitter = new TypedEventEmitter();
    channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestReadLock", "abortReadLockRequest", WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestWriteLock", "abortWriteLockRequest", WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return new MorticeChannelWorker(options2.name);
};

// node_modules/mortice/dist/src/mortice.js
var mutexes = /* @__PURE__ */ new Map();
var implementation;
function isMortice(obj) {
  return typeof obj?.readLock === "function" && typeof obj?.writeLock === "function";
}
function getImplementation(opts) {
  if (implementation == null) {
    implementation = browser_default(opts);
    if (!isMortice(implementation)) {
      const emitter = implementation;
      emitter.addEventListener("requestReadLock", (event) => {
        const mutexName = event.detail.name;
        const identifier = event.detail.identifier;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        const abortController = new AbortController();
        const abortListener = (event2) => {
          if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
            return;
          }
          abortController.abort();
        };
        emitter.addEventListener("abortReadLockRequest", abortListener);
        void mutex.readLock({
          signal: abortController.signal
        }).then(async (release) => {
          await event.detail.handler().finally(() => {
            release();
          });
        }).catch((err) => {
          event.detail.onError(err);
        }).finally(() => {
          emitter.removeEventListener("abortReadLockRequest", abortListener);
        });
      });
      emitter.addEventListener("requestWriteLock", (event) => {
        const mutexName = event.detail.name;
        const identifier = event.detail.identifier;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        const abortController = new AbortController();
        const abortListener = (event2) => {
          if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
            return;
          }
          abortController.abort();
        };
        emitter.addEventListener("abortWriteLockRequest", abortListener);
        void mutex.writeLock({
          signal: abortController.signal
        }).then(async (release) => {
          await event.detail.handler().finally(() => {
            release();
          });
        }).catch((err) => {
          event.detail.onError(err);
        }).finally(() => {
          emitter.removeEventListener("abortWriteLockRequest", abortListener);
        });
      });
      emitter.addEventListener("finalizeRequest", (event) => {
        const mutexName = event.detail.name;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        mutex.finalize();
      });
    }
  }
  return implementation;
}
async function createReleasable(queue, options2) {
  let res;
  let rej;
  const p = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  const listener = () => {
    rej(new AbortError3());
  };
  options2?.signal?.addEventListener("abort", listener, {
    once: true
  });
  queue.add(async () => {
    await new Promise((resolve) => {
      res(() => {
        options2?.signal?.removeEventListener("abort", listener);
        resolve();
      });
    });
  }, {
    signal: options2?.signal
  }).catch((err) => {
    rej(err);
  });
  return p;
}
var createMutex = (name9, options2) => {
  let mutex = mutexes.get(name9);
  if (mutex != null) {
    return mutex;
  }
  const implementation2 = getImplementation(options2);
  if (isMortice(implementation2)) {
    mutex = implementation2;
    mutexes.set(name9, mutex);
    return mutex;
  }
  const masterQueue = new Queue2({
    concurrency: 1
  });
  let readQueue;
  mutex = {
    async readLock(opts) {
      if (readQueue != null) {
        return createReleasable(readQueue, opts);
      }
      readQueue = new Queue2({
        concurrency: options2.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleasable(readQueue, opts);
      void masterQueue.add(async () => {
        localReadQueue.start();
        await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return readPromise;
    },
    async writeLock(opts) {
      readQueue = null;
      return createReleasable(masterQueue, opts);
    },
    finalize: () => {
      mutexes.delete(name9);
    },
    queue: masterQueue
  };
  mutexes.set(name9, mutex);
  if (options2.autoFinalize === true) {
    masterQueue.addEventListener("idle", () => {
      mutex.finalize();
    }, {
      once: true
    });
  }
  return mutex;
};

// node_modules/mortice/dist/src/index.js
var defaultOptions2 = {
  name: "lock",
  concurrency: Infinity,
  singleProcess: false,
  autoFinalize: false
};
function createMortice(options2) {
  const opts = Object.assign({}, defaultOptions2, options2);
  return createMutex(opts.name, opts);
}

// node_modules/@helia/utils/dist/src/storage.js
var BlockStorage = class {
  lock;
  child;
  pins;
  started;
  /**
   * Create a new BlockStorage
   */
  constructor(blockstore, pins, options2 = {}) {
    this.child = blockstore;
    this.pins = pins;
    this.lock = createMortice({
      singleProcess: options2.holdGcLock
    });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await start(this.child);
    this.started = true;
  }
  async stop() {
    await stop(this.child);
    this.started = false;
  }
  unwrap() {
    return this.child;
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.put(cid, block, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.putMany(blocks, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Get a block by cid
   */
  async get(cid, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.get(cid, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.getMany(cids, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.writeLock();
    try {
      if (await this.pins.isPinned(cid)) {
        throw new Error("CID was pinned");
      }
      await this.child.delete(cid, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.writeLock();
    try {
      const storage = this;
      yield* this.child.deleteMany(async function* () {
        for await (const cid of cids) {
          if (await storage.pins.isPinned(cid)) {
            throw new Error("CID was pinned");
          }
          yield cid;
        }
      }(), options2);
    } finally {
      releaseLock();
    }
  }
  async has(cid, options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.has(cid, options2);
    } finally {
      releaseLock();
    }
  }
  async *getAll(options2 = {}) {
    options2?.signal?.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.getAll(options2);
    } finally {
      releaseLock();
    }
  }
  createSession(root, options2) {
    options2?.signal?.throwIfAborted();
    return this.child.createSession(root, options2);
  }
};

// node_modules/@helia/utils/dist/src/utils/datastore-version.js
var DS_VERSION_KEY = new Key("/version");
var CURRENT_VERSION = 1;
async function assertDatastoreVersionIsCurrent(datastore) {
  if (!await datastore.has(DS_VERSION_KEY)) {
    await datastore.put(DS_VERSION_KEY, fromString(`${CURRENT_VERSION}`));
    return;
  }
  const buf = await datastore.get(DS_VERSION_KEY);
  const str = toString(buf);
  const version3 = parseInt(str, 10);
  if (version3 !== CURRENT_VERSION) {
    throw new Error("Unknown datastore version, a datastore migration may be required");
  }
}

// node_modules/@helia/utils/node_modules/multiformats/dist/src/codecs/json.js
var json_exports = {};
__export(json_exports, {
  code: () => code4,
  decode: () => decode7,
  encode: () => encode5,
  name: () => name
});
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var name = "json";
var code4 = 512;
function encode5(node) {
  return textEncoder.encode(JSON.stringify(node));
}
function decode7(data) {
  return JSON.parse(textDecoder.decode(data));
}

// node_modules/@helia/utils/node_modules/multiformats/dist/src/codecs/raw.js
var raw_exports = {};
__export(raw_exports, {
  code: () => code5,
  decode: () => decode8,
  encode: () => encode6,
  name: () => name2
});
var name2 = "raw";
var code5 = 85;
function encode6(node) {
  return coerce(node);
}
function decode8(data) {
  return coerce(data);
}

// node_modules/@helia/utils/dist/src/utils/is-promise.js
function isPromise(p) {
  return p?.then != null;
}

// node_modules/@helia/utils/dist/src/utils/get-codec.js
function getCodec(initialCodecs = [], loadCodec) {
  const codecs = {
    [code3]: src_exports3,
    [code5]: raw_exports,
    [code]: src_exports,
    [code2]: src_exports2,
    [code4]: json_exports
  };
  initialCodecs.forEach((codec) => {
    codecs[codec.code] = codec;
  });
  return async (code17) => {
    let codec = codecs[code17];
    if (codec == null && loadCodec != null) {
      const res = loadCodec(code17);
      if (isPromise(res)) {
        codec = await res;
      } else {
        codec = res;
      }
      codecs[codec.code] = codec;
    }
    if (codec != null) {
      return codec;
    }
    throw new UnknownCodecError(`Could not load codec for ${code17}`);
  };
}

// node_modules/@helia/utils/node_modules/multiformats/dist/src/hashes/identity.js
var code6 = 0;
var name3 = "identity";
var encode7 = coerce;
function digest(input) {
  return create(code6, encode7(input));
}
var identity = { code: code6, name: name3, encode: encode7, digest };

// node_modules/@helia/utils/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha(name9) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name9, data));
}
var sha2562 = from2({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha5122 = from2({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/@helia/utils/dist/src/utils/get-hasher.js
function getHasher(initialHashers = [], loadHasher) {
  const hashers = {
    [sha2562.code]: sha2562,
    [sha5122.code]: sha5122,
    [identity.code]: identity
  };
  initialHashers.forEach((hasher) => {
    hashers[hasher.code] = hasher;
  });
  return async (code17) => {
    let hasher = hashers[code17];
    if (hasher == null && loadHasher != null) {
      const res = loadHasher(code17);
      if (isPromise(res)) {
        hasher = await res;
      } else {
        hasher = res;
      }
      hashers[hasher.code] = hasher;
    }
    if (hasher != null) {
      return hasher;
    }
    throw new UnknownHashAlgorithmError(`No hasher configured for multihash code 0x${code17.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`);
  };
}

// node_modules/any-signal/dist/src/index.js
function anySignal(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if (signal2?.aborted === true) {
      onAbort();
      break;
    }
    if (signal2?.addEventListener != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}

// node_modules/blockstore-core/dist/src/identity.js
var IDENTITY_CODEC = 0;
var IdentityBlockstore = class extends BaseBlockstore {
  child;
  constructor(child) {
    super();
    this.child = child;
  }
  put(key, block, options2) {
    if (key.multihash.code === IDENTITY_CODEC) {
      options2?.signal?.throwIfAborted();
      return key;
    }
    if (this.child == null) {
      options2?.signal?.throwIfAborted();
      return key;
    }
    return this.child.put(key, block, options2);
  }
  get(key, options2) {
    if (key.multihash.code === IDENTITY_CODEC) {
      options2?.signal?.throwIfAborted();
      return key.multihash.digest;
    }
    if (this.child == null) {
      options2?.signal?.throwIfAborted();
      throw new NotFoundError2();
    }
    return this.child.get(key, options2);
  }
  has(key, options2) {
    if (key.multihash.code === IDENTITY_CODEC) {
      options2?.signal?.throwIfAborted();
      return true;
    }
    if (this.child == null) {
      options2?.signal?.throwIfAborted();
      return false;
    }
    return this.child.has(key, options2);
  }
  delete(key, options2) {
    if (key.code === IDENTITY_CODEC) {
      options2?.signal?.throwIfAborted();
      return;
    }
    if (this.child != null) {
      return this.child.delete(key, options2);
    }
  }
  getAll(options2) {
    if (this.child != null) {
      return this.child.getAll(options2);
    }
    options2?.signal?.throwIfAborted();
    return [];
  }
};

// node_modules/it-foreach/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function isPromise2(thing) {
  return thing?.then != null;
}
function forEach(source, fn) {
  let index = 0;
  if (isAsyncIterable(source)) {
    return async function* () {
      for await (const val of source) {
        const res2 = fn(val, index++);
        if (isPromise2(res2)) {
          await res2;
        }
        yield val;
      }
    }();
  }
  const peekable = src_default3(source);
  const { value: value7, done } = peekable.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = fn(value7, index++);
  if (typeof res?.then === "function") {
    return async function* () {
      yield value7;
      for (const val of peekable) {
        const res2 = fn(val, index++);
        if (isPromise2(res2)) {
          await res2;
        }
        yield val;
      }
    }();
  }
  const func2 = fn;
  return function* () {
    yield value7;
    for (const val of peekable) {
      func2(val, index++);
      yield val;
    }
  }();
}
var src_default9 = forEach;

// node_modules/@helia/utils/dist/src/utils/networked-storage.js
var Storage = class {
  child;
  getHasher;
  log;
  logger;
  components;
  /**
   * Create a new BlockStorage
   */
  constructor(components) {
    this.log = components.logger.forComponent("helia:networked-storage");
    this.logger = components.logger;
    this.components = components;
    this.child = new IdentityBlockstore(components.blockstore);
    this.getHasher = components.getHasher;
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options2 = {}) {
    if (await this.child.has(cid, options2)) {
      options2.onProgress?.(new CustomProgressEvent("blocks:put:duplicate", cid));
      return cid;
    }
    options2.onProgress?.(new CustomProgressEvent("blocks:put:providers:notify", cid));
    await Promise.all(this.components.blockBrokers.map(async (broker) => broker.announce?.(cid, block, options2)));
    options2.onProgress?.(new CustomProgressEvent("blocks:put:blockstore:put", cid));
    return this.child.put(cid, block, options2);
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options2 = {}) {
    const missingBlocks = src_default4(blocks, async ({ cid }) => {
      const has = await this.child.has(cid, options2);
      if (has) {
        options2.onProgress?.(new CustomProgressEvent("blocks:put-many:duplicate", cid));
      }
      return !has;
    });
    const notifyEach = src_default9(missingBlocks, async ({ cid, block }) => {
      options2.onProgress?.(new CustomProgressEvent("blocks:put-many:providers:notify", cid));
      await Promise.all(this.components.blockBrokers.map(async (broker) => broker.announce?.(cid, block, options2)));
    });
    options2.onProgress?.(new CustomProgressEvent("blocks:put-many:blockstore:put-many"));
    yield* this.child.putMany(notifyEach, options2);
  }
  /**
   * Get a block by cid
   */
  async get(cid, options2 = {}) {
    if (options2.offline !== true && !await this.child.has(cid, options2)) {
      const hasher = await this.getHasher(cid.multihash.code);
      options2.onProgress?.(new CustomProgressEvent("blocks:get:providers:get", cid));
      const block = await raceBlockRetrievers(cid, this.components.blockBrokers, hasher, {
        ...options2,
        log: this.log
      });
      options2.onProgress?.(new CustomProgressEvent("blocks:get:blockstore:put", cid));
      await this.child.put(cid, block, options2);
      options2.onProgress?.(new CustomProgressEvent("blocks:get:providers:notify", cid));
      await Promise.all(this.components.blockBrokers.map(async (broker) => broker.announce?.(cid, block, options2)));
      return block;
    }
    options2.onProgress?.(new CustomProgressEvent("blocks:get:blockstore:get", cid));
    return this.child.get(cid, options2);
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options2 = {}) {
    options2.onProgress?.(new CustomProgressEvent("blocks:get-many:blockstore:get-many"));
    yield* this.child.getMany(src_default9(cids, async (cid) => {
      if (options2.offline !== true && !await this.child.has(cid, options2)) {
        const hasher = await this.getHasher(cid.multihash.code);
        options2.onProgress?.(new CustomProgressEvent("blocks:get-many:providers:get", cid));
        const block = await raceBlockRetrievers(cid, this.components.blockBrokers, hasher, {
          ...options2,
          log: this.log
        });
        options2.onProgress?.(new CustomProgressEvent("blocks:get-many:blockstore:put", cid));
        await this.child.put(cid, block, options2);
        options2.onProgress?.(new CustomProgressEvent("blocks:get-many:providers:notify", cid));
        await Promise.all(this.components.blockBrokers.map(async (broker) => broker.announce?.(cid, block, options2)));
      }
    }));
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options2 = {}) {
    options2.onProgress?.(new CustomProgressEvent("blocks:delete:blockstore:delete", cid));
    await this.child.delete(cid, options2);
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options2 = {}) {
    options2.onProgress?.(new CustomProgressEvent("blocks:delete-many:blockstore:delete-many"));
    yield* this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cid;
      }
    }(), options2);
  }
  async has(cid, options2 = {}) {
    return this.child.has(cid, options2);
  }
  async *getAll(options2 = {}) {
    options2.onProgress?.(new CustomProgressEvent("blocks:get-all:blockstore:get-many"));
    yield* this.child.getAll(options2);
  }
};
var NetworkedStorage = class extends Storage {
  started;
  /**
   * Create a new BlockStorage
   */
  constructor(components) {
    super(components);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await start(this.child, ...this.components.blockBrokers);
    this.started = true;
  }
  async stop() {
    await stop(this.child, ...this.components.blockBrokers);
    this.started = false;
  }
  unwrap() {
    return this.child;
  }
  createSession(root, options2) {
    const blockBrokers = this.components.blockBrokers.map((broker) => {
      if (broker.createSession == null) {
        return broker;
      }
      return broker.createSession(options2);
    });
    return new SessionStorage({
      blockstore: this.child,
      blockBrokers,
      getHasher: this.getHasher,
      logger: this.logger
    }, {
      root
    });
  }
};
var SessionStorage = class extends Storage {
  closeController;
  constructor(components, init) {
    super(components);
    this.closeController = new AbortController();
    setMaxListeners(Infinity, this.closeController.signal);
    this.log = components.logger.forComponent(`helia:session-storage:${init.root}`);
  }
  close() {
    this.closeController.abort();
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      return await super.put(cid, block, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      yield* super.putMany(blocks, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Get a block by cid
   */
  async get(cid, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      return await super.get(cid, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      yield* super.getMany(cids, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      await super.delete(cid, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      yield* super.deleteMany(cids, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  async has(cid, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      return await super.has(cid, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  async *getAll(options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      yield* super.getAll({
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
};
function isRetrievingBlockBroker(broker) {
  return typeof broker.retrieve === "function";
}
var getCidBlockVerifierFunction = (cid, hasher) => {
  if (hasher == null) {
    throw new InvalidParametersError(`No hasher configured for multihash code 0x${cid.multihash.code.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`);
  }
  return async (block) => {
    let hash;
    const res = hasher.digest(block);
    if (isPromise(res)) {
      hash = await res;
    } else {
      hash = res;
    }
    if (!equals(hash.digest, cid.multihash.digest)) {
      throw new InvalidMultihashError("Hash of downloaded block did not match multihash from passed CID");
    }
  };
};
async function raceBlockRetrievers(cid, blockBrokers, hasher, options2) {
  const validateFn = getCidBlockVerifierFunction(cid, hasher);
  const controller = new AbortController();
  const signal = anySignal([controller.signal, options2.signal]);
  setMaxListeners(Infinity, controller.signal, signal);
  const retrievers = [];
  for (const broker of blockBrokers) {
    if (isRetrievingBlockBroker(broker)) {
      retrievers.push(broker);
    }
  }
  try {
    return await Promise.any(retrievers.map(async (retriever) => {
      try {
        let blocksWereValidated = false;
        const block = await retriever.retrieve(cid, {
          ...options2,
          signal,
          validateFn: async (block2) => {
            await validateFn(block2);
            blocksWereValidated = true;
          }
        });
        if (!blocksWereValidated) {
          await validateFn(block);
        }
        return block;
      } catch (err) {
        options2.log.error("could not retrieve verified block for %c", cid, err);
        throw err;
      }
    }));
  } finally {
    controller.abort();
    signal.clear();
  }
}

// node_modules/@helia/utils/node_modules/multiformats/dist/src/bases/base64.js
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@helia/utils/dist/src/abstract-session.js
var AbstractSession = class extends TypedEventEmitter {
  initialPeerSearchComplete;
  requests;
  name;
  log;
  logger;
  minProviders;
  maxProviders;
  providers;
  evictionFilter;
  initialProviders;
  constructor(components, init) {
    super();
    setMaxListeners(Infinity, this);
    this.name = init.name;
    this.logger = components.logger;
    this.log = components.logger.forComponent(this.name);
    this.requests = /* @__PURE__ */ new Map();
    this.minProviders = init.minProviders ?? DEFAULT_SESSION_MIN_PROVIDERS;
    this.maxProviders = init.maxProviders ?? DEFAULT_SESSION_MAX_PROVIDERS;
    this.providers = [];
    this.evictionFilter = createScalableCuckooFilter(this.maxProviders);
    this.initialProviders = init.providers ?? [];
  }
  async retrieve(cid, options2 = {}) {
    const cidStr = base64.encode(cid.multihash.bytes);
    const existingJob = this.requests.get(cidStr);
    if (existingJob != null) {
      this.log("join existing request for %c", cid);
      return existingJob;
    }
    const deferred = pDefer();
    this.requests.set(cidStr, deferred.promise);
    if (this.providers.length === 0) {
      let first = false;
      if (this.initialPeerSearchComplete == null) {
        first = true;
        this.log = this.logger.forComponent(`${this.name}:${cid}`);
        this.initialPeerSearchComplete = this.findProviders(cid, this.minProviders, options2);
      }
      await this.initialPeerSearchComplete;
      if (first) {
        this.log("found initial session peers for %c", cid);
      }
    }
    let foundBlock = false;
    const queue = new Queue({
      concurrency: this.maxProviders
    });
    queue.addEventListener("error", () => {
    });
    queue.addEventListener("failure", (evt) => {
      this.log.error("error querying provider %o, evicting from session", evt.detail.job.options.provider, evt.detail.error);
      this.evict(evt.detail.job.options.provider);
    });
    queue.addEventListener("success", (evt) => {
      foundBlock = true;
      deferred.resolve(evt.detail.result);
    });
    queue.addEventListener("idle", () => {
      if (foundBlock || options2.signal?.aborted === true) {
        this.log.trace("session idle, found block");
        return;
      }
      Promise.resolve().then(async () => {
        this.log("no session peers had block for for %c, finding new providers", cid);
        for (let i = 0; i < this.minProviders; i++) {
          if (this.providers.length === 0) {
            break;
          }
          const provider = this.providers[Math.floor(Math.random() * this.providers.length)];
          this.evict(provider);
        }
        await this.findProviders(cid, this.minProviders, options2);
        this.log("found new providers re-retrieving %c", cid);
        this.requests.delete(cidStr);
        deferred.resolve(await this.retrieve(cid, options2));
      }).catch((err) => {
        this.log.error("could not find new providers for %c", cid, err);
        deferred.reject(err);
      });
    });
    const peerAddedToSessionListener = (event) => {
      queue.add(async () => {
        return this.queryProvider(cid, event.detail, options2);
      }, {
        provider: event.detail
      }).catch((err) => {
        if (options2.signal?.aborted === true) {
          return;
        }
        this.log.error("error retrieving session block for %c", cid, err);
      });
    };
    this.addEventListener("provider", peerAddedToSessionListener);
    Promise.all([...this.providers].map(async (provider) => {
      return queue.add(async () => {
        return this.queryProvider(cid, provider, options2);
      }, {
        provider
      });
    })).catch((err) => {
      if (options2.signal?.aborted === true) {
        return;
      }
      this.log.error("error retrieving session block for %c", cid, err);
    });
    const signalAbortedListener = () => {
      deferred.reject(new AbortError(options2.signal?.reason ?? "Session aborted"));
      queue.abort();
    };
    options2.signal?.addEventListener("abort", signalAbortedListener);
    try {
      return await deferred.promise;
    } finally {
      this.removeEventListener("provider", peerAddedToSessionListener);
      options2.signal?.removeEventListener("abort", signalAbortedListener);
      queue.clear();
      this.requests.delete(cidStr);
    }
  }
  evict(provider) {
    this.evictionFilter.add(this.toEvictionKey(provider));
    const index = this.providers.findIndex((prov) => this.equals(prov, provider));
    if (index === -1) {
      return;
    }
    this.providers.splice(index, 1);
  }
  isEvicted(provider) {
    return this.evictionFilter.has(this.toEvictionKey(provider));
  }
  hasProvider(provider) {
    if (this.providers.find((prov) => this.equals(prov, provider)) != null) {
      return true;
    }
    if (this.isEvicted(provider)) {
      return true;
    }
    return false;
  }
  async findProviders(cid, count, options2) {
    const deferred = pDefer();
    let found = 0;
    void Promise.resolve().then(async () => {
      this.log("finding %d-%d new provider(s) for %c", count, this.maxProviders, cid);
      if (this.initialProviders.length > 0) {
        while (found < count && this.initialProviders.length > 0) {
          const prov = this.initialProviders.pop();
          if (prov == null) {
            break;
          }
          const provider = await this.convertToProvider(prov, options2);
          if (options2.signal?.aborted === true) {
            break;
          }
          if (provider == null) {
            continue;
          }
          if (this.hasProvider(provider)) {
            continue;
          }
          this.log("found %d/%d new providers", found, this.maxProviders);
          this.providers.push(provider);
          this.safeDispatchEvent("provider", {
            detail: provider
          });
          found++;
          if (found === count) {
            this.log("session is ready");
            deferred.resolve();
          }
          if (this.providers.length === this.maxProviders) {
            this.log("found max session peers", found);
            break;
          }
        }
      }
      if (found < this.maxProviders) {
        for await (const provider of this.findNewProviders(cid, options2)) {
          if (found === this.maxProviders || options2.signal?.aborted === true) {
            break;
          }
          if (this.hasProvider(provider)) {
            continue;
          }
          this.log("found %d/%d new providers", found, this.maxProviders);
          this.providers.push(provider);
          this.safeDispatchEvent("provider", {
            detail: provider
          });
          found++;
          if (found === count) {
            this.log("session is ready");
            deferred.resolve();
          }
          if (this.providers.length === this.maxProviders) {
            this.log("found max session peers", found);
            break;
          }
        }
      }
      this.log("found %d/%d new session peers", found, this.maxProviders);
      if (found < count) {
        throw new InsufficientProvidersError(`Found ${found} of ${count} ${this.name} providers for ${cid}`);
      }
    }).catch((err) => {
      this.log.error("error searching routing for potential session peers for %c", cid, err.errors ?? err);
      deferred.reject(err);
    });
    return deferred.promise;
  }
};

// node_modules/@helia/utils/dist/src/index.js
var Helia = class {
  blockstore;
  datastore;
  pins;
  logger;
  routing;
  getCodec;
  getHasher;
  dns;
  metrics;
  log;
  constructor(init) {
    this.logger = init.logger ?? defaultLogger();
    this.log = this.logger.forComponent("helia");
    this.getHasher = getHasher(init.hashers, init.loadHasher);
    this.getCodec = getCodec(init.codecs, init.loadCodec);
    this.dns = init.dns ?? dns();
    this.metrics = init.metrics;
    const components = {
      blockstore: init.blockstore,
      datastore: init.datastore,
      logger: this.logger,
      blockBrokers: [],
      getHasher: this.getHasher,
      getCodec: this.getCodec,
      dns: this.dns,
      metrics: this.metrics,
      ...init.components ?? {}
    };
    this.routing = components.routing = new Routing(components, {
      routers: (init.routers ?? []).flatMap((router) => {
        const routers = [
          router
        ];
        if (router[contentRoutingSymbol] != null) {
          routers.push(router[contentRoutingSymbol]);
        }
        if (router[peerRoutingSymbol] != null) {
          routers.push(router[peerRoutingSymbol]);
        }
        return routers;
      }),
      providerLookupConcurrency: init.providerLookupConcurrency
    });
    const networkedStorage = new NetworkedStorage(components);
    this.pins = new PinsImpl(init.datastore, networkedStorage, this.getCodec);
    this.blockstore = new BlockStorage(networkedStorage, this.pins, {
      holdGcLock: init.holdGcLock ?? true
    });
    this.datastore = init.datastore;
    components.blockBrokers = init.blockBrokers.map((fn) => {
      return fn(components);
    });
  }
  async start() {
    await assertDatastoreVersionIsCurrent(this.datastore);
    await start(this.blockstore, this.datastore, this.routing);
  }
  async stop() {
    await stop(this.blockstore, this.datastore, this.routing);
  }
  async gc(options2 = {}) {
    const releaseLock = await this.blockstore.lock.writeLock();
    try {
      const helia = this;
      const blockstore = this.blockstore.unwrap();
      this.log("gc start");
      await src_default(blockstore.deleteMany(async function* () {
        for await (const { cid } of blockstore.getAll()) {
          try {
            if (await helia.pins.isPinned(cid, options2)) {
              continue;
            }
            yield cid;
            options2.onProgress?.(new CustomProgressEvent("helia:gc:deleted", cid));
          } catch (err) {
            helia.log.error("Error during gc", err);
            options2.onProgress?.(new CustomProgressEvent("helia:gc:error", err));
          }
        }
      }()));
    } finally {
      releaseLock();
    }
    this.log("gc finished");
  }
};

// node_modules/helia/dist/src/helia-p2p.js
var HeliaP2P = class extends Helia {
  libp2p;
  constructor(init) {
    super({
      ...init,
      components: {
        libp2p: init.libp2p
      }
    });
    this.libp2p = init.libp2p;
  }
  async start() {
    await super.start();
    await this.libp2p.start();
  }
  async stop() {
    await super.stop();
    await this.libp2p.stop();
  }
};

// node_modules/it-length-prefixed/dist/src/constants.js
var MAX_LENGTH_LENGTH = 8;
var MAX_DATA_LENGTH = 1024 * 1024 * 4;

// node_modules/it-length-prefixed/dist/src/errors.js
var InvalidMessageLengthError = class extends Error {
  name = "InvalidMessageLengthError";
  code = "ERR_INVALID_MSG_LENGTH";
};
var InvalidDataLengthError = class extends Error {
  name = "InvalidDataLengthError";
  code = "ERR_MSG_DATA_TOO_LONG";
};
var InvalidDataLengthLengthError = class extends Error {
  name = "InvalidDataLengthLengthError";
  code = "ERR_MSG_LENGTH_TOO_LONG";
};
var UnexpectedEOFError = class extends Error {
  name = "UnexpectedEOFError";
  code = "ERR_UNEXPECTED_EOF";
};

// node_modules/it-length-prefixed/dist/src/utils.js
function isAsyncIterable2(thing) {
  return thing[Symbol.asyncIterator] != null;
}

// node_modules/it-length-prefixed/dist/src/encode.js
function validateMaxDataLength(chunk, maxDataLength) {
  if (chunk.byteLength > maxDataLength) {
    throw new InvalidDataLengthError("Message length too long");
  }
}
var defaultEncoder = (length16) => {
  const lengthLength = encodingLength(length16);
  const lengthBuf = allocUnsafe(lengthLength);
  encode(length16, lengthBuf);
  defaultEncoder.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder.bytes = 0;
function encode8(source, options2) {
  options2 = options2 ?? {};
  const encodeLength = options2.lengthEncoder ?? defaultEncoder;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH;
  function* maybeYield(chunk) {
    validateMaxDataLength(chunk, maxDataLength);
    const length16 = encodeLength(chunk.byteLength);
    if (length16 instanceof Uint8Array) {
      yield length16;
    } else {
      yield* length16;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  if (isAsyncIterable2(source)) {
    return async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  return function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  }();
}
encode8.single = (chunk, options2) => {
  options2 = options2 ?? {};
  const encodeLength = options2.lengthEncoder ?? defaultEncoder;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH;
  validateMaxDataLength(chunk, maxDataLength);
  return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);
};

// node_modules/it-length-prefixed/dist/src/decode.js
var ReadMode;
(function(ReadMode2) {
  ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
  ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
var defaultDecoder = (buf) => {
  const length16 = decode(buf);
  defaultDecoder.bytes = encodingLength(length16);
  return length16;
};
defaultDecoder.bytes = 0;
function decode9(source, options2) {
  const buffer = new Uint8ArrayList();
  let mode = ReadMode.LENGTH;
  let dataLength = -1;
  const lengthDecoder = options2?.lengthDecoder ?? defaultDecoder;
  const maxLengthLength = options2?.maxLengthLength ?? MAX_LENGTH_LENGTH;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH;
  function* maybeYield() {
    while (buffer.byteLength > 0) {
      if (mode === ReadMode.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer);
          if (dataLength < 0) {
            throw new InvalidMessageLengthError("Invalid message length");
          }
          if (dataLength > maxDataLength) {
            throw new InvalidDataLengthError("Message length too long");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer.consume(dataLengthLength);
          if (options2?.onLength != null) {
            options2.onLength(dataLength);
          }
          mode = ReadMode.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer.byteLength > maxLengthLength) {
              throw new InvalidDataLengthLengthError("Message length length too long");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode.DATA) {
        if (buffer.byteLength < dataLength) {
          break;
        }
        const data = buffer.sublist(0, dataLength);
        buffer.consume(dataLength);
        if (options2?.onData != null) {
          options2.onData(data);
        }
        yield data;
        mode = ReadMode.LENGTH;
      }
    }
  }
  if (isAsyncIterable2(source)) {
    return async function* () {
      for await (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw new UnexpectedEOFError("Unexpected end of input");
      }
    }();
  }
  return function* () {
    for (const buf of source) {
      buffer.append(buf);
      yield* maybeYield();
    }
    if (buffer.byteLength > 0) {
      throw new UnexpectedEOFError("Unexpected end of input");
    }
  }();
}
decode9.fromReader = (reader, options2) => {
  let byteLength = 1;
  const varByteSource = async function* () {
    while (true) {
      try {
        const { done, value: value7 } = await reader.next(byteLength);
        if (done === true) {
          return;
        }
        if (value7 != null) {
          yield value7;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  }();
  const onLength = (l) => {
    byteLength = l;
  };
  return decode9(varByteSource, {
    ...options2 ?? {},
    onLength
  });
};

// node_modules/@helia/bitswap/dist/src/constants.js
var BITSWAP_120 = "/ipfs/bitswap/1.2.0";
var DEFAULT_MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;
var DEFAULT_MAX_INBOUND_STREAMS = 1024;
var DEFAULT_MAX_OUTBOUND_STREAMS = 1024;
var DEFAULT_MESSAGE_RECEIVE_TIMEOUT = 5e3;
var DEFAULT_MESSAGE_SEND_DELAY = 10;
var DEFAULT_MESSAGE_SEND_CONCURRENCY = 50;
var DEFAULT_RUN_ON_TRANSIENT_CONNECTIONS = false;
var DEFAULT_MAX_PROVIDERS_PER_REQUEST = 3;
var DEFAULT_MAX_OUTGOING_MESSAGE_SIZE = 1024 * 1024 * 4;
var DEFAULT_MAX_INCOMING_MESSAGE_SIZE = DEFAULT_MAX_OUTGOING_MESSAGE_SIZE;

// node_modules/@helia/bitswap/dist/src/pb/message.js
var WantType;
(function(WantType2) {
  WantType2["WantBlock"] = "WantBlock";
  WantType2["WantHave"] = "WantHave";
})(WantType || (WantType = {}));
var __WantTypeValues;
(function(__WantTypeValues2) {
  __WantTypeValues2[__WantTypeValues2["WantBlock"] = 0] = "WantBlock";
  __WantTypeValues2[__WantTypeValues2["WantHave"] = 1] = "WantHave";
})(__WantTypeValues || (__WantTypeValues = {}));
(function(WantType2) {
  WantType2.codec = () => {
    return enumeration(__WantTypeValues);
  };
})(WantType || (WantType = {}));
var WantlistEntry;
(function(WantlistEntry2) {
  let _codec;
  WantlistEntry2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.cid != null && obj.cid.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.cid);
        }
        if (obj.priority != null && obj.priority !== 0) {
          w.uint32(16);
          w.int32(obj.priority);
        }
        if (obj.cancel != null) {
          w.uint32(24);
          w.bool(obj.cancel);
        }
        if (obj.wantType != null) {
          w.uint32(32);
          WantType.codec().encode(obj.wantType, w);
        }
        if (obj.sendDontHave != null) {
          w.uint32(40);
          w.bool(obj.sendDontHave);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          cid: alloc(0),
          priority: 0
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.cid = reader.bytes();
              break;
            }
            case 2: {
              obj.priority = reader.int32();
              break;
            }
            case 3: {
              obj.cancel = reader.bool();
              break;
            }
            case 4: {
              obj.wantType = WantType.codec().decode(reader);
              break;
            }
            case 5: {
              obj.sendDontHave = reader.bool();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WantlistEntry2.encode = (obj) => {
    return encodeMessage(obj, WantlistEntry2.codec());
  };
  WantlistEntry2.decode = (buf, opts) => {
    return decodeMessage(buf, WantlistEntry2.codec(), opts);
  };
})(WantlistEntry || (WantlistEntry = {}));
var Wantlist;
(function(Wantlist2) {
  let _codec;
  Wantlist2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.entries != null) {
          for (const value7 of obj.entries) {
            w.uint32(10);
            WantlistEntry.codec().encode(value7, w);
          }
        }
        if (obj.full != null) {
          w.uint32(16);
          w.bool(obj.full);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          entries: []
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.entries != null && obj.entries.length === opts.limits.entries) {
                throw new MaxLengthError('Decode error - map field "entries" had too many elements');
              }
              obj.entries.push(WantlistEntry.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.entries$
              }));
              break;
            }
            case 2: {
              obj.full = reader.bool();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Wantlist2.encode = (obj) => {
    return encodeMessage(obj, Wantlist2.codec());
  };
  Wantlist2.decode = (buf, opts) => {
    return decodeMessage(buf, Wantlist2.codec(), opts);
  };
})(Wantlist || (Wantlist = {}));
var Block2;
(function(Block3) {
  let _codec;
  Block3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.prefix != null && obj.prefix.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.prefix);
        }
        if (obj.data != null && obj.data.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          prefix: alloc(0),
          data: alloc(0)
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.prefix = reader.bytes();
              break;
            }
            case 2: {
              obj.data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Block3.encode = (obj) => {
    return encodeMessage(obj, Block3.codec());
  };
  Block3.decode = (buf, opts) => {
    return decodeMessage(buf, Block3.codec(), opts);
  };
})(Block2 || (Block2 = {}));
var BlockPresenceType;
(function(BlockPresenceType2) {
  BlockPresenceType2["HaveBlock"] = "HaveBlock";
  BlockPresenceType2["DoNotHaveBlock"] = "DoNotHaveBlock";
})(BlockPresenceType || (BlockPresenceType = {}));
var __BlockPresenceTypeValues;
(function(__BlockPresenceTypeValues2) {
  __BlockPresenceTypeValues2[__BlockPresenceTypeValues2["HaveBlock"] = 0] = "HaveBlock";
  __BlockPresenceTypeValues2[__BlockPresenceTypeValues2["DoNotHaveBlock"] = 1] = "DoNotHaveBlock";
})(__BlockPresenceTypeValues || (__BlockPresenceTypeValues = {}));
(function(BlockPresenceType2) {
  BlockPresenceType2.codec = () => {
    return enumeration(__BlockPresenceTypeValues);
  };
})(BlockPresenceType || (BlockPresenceType = {}));
var BlockPresence;
(function(BlockPresence2) {
  let _codec;
  BlockPresence2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.cid != null && obj.cid.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.cid);
        }
        if (obj.type != null && __BlockPresenceTypeValues[obj.type] !== 0) {
          w.uint32(16);
          BlockPresenceType.codec().encode(obj.type, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          cid: alloc(0),
          type: BlockPresenceType.HaveBlock
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.cid = reader.bytes();
              break;
            }
            case 2: {
              obj.type = BlockPresenceType.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  BlockPresence2.encode = (obj) => {
    return encodeMessage(obj, BlockPresence2.codec());
  };
  BlockPresence2.decode = (buf, opts) => {
    return decodeMessage(buf, BlockPresence2.codec(), opts);
  };
})(BlockPresence || (BlockPresence = {}));
var BitswapMessage;
(function(BitswapMessage2) {
  let _codec;
  BitswapMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.wantlist != null) {
          w.uint32(10);
          Wantlist.codec().encode(obj.wantlist, w);
        }
        if (obj.blocks != null) {
          for (const value7 of obj.blocks) {
            w.uint32(26);
            Block2.codec().encode(value7, w);
          }
        }
        if (obj.blockPresences != null) {
          for (const value7 of obj.blockPresences) {
            w.uint32(34);
            BlockPresence.codec().encode(value7, w);
          }
        }
        if (obj.pendingBytes != null && obj.pendingBytes !== 0) {
          w.uint32(40);
          w.int32(obj.pendingBytes);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          blocks: [],
          blockPresences: [],
          pendingBytes: 0
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.wantlist = Wantlist.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.wantlist
              });
              break;
            }
            case 3: {
              if (opts.limits?.blocks != null && obj.blocks.length === opts.limits.blocks) {
                throw new MaxLengthError('Decode error - map field "blocks" had too many elements');
              }
              obj.blocks.push(Block2.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.blocks$
              }));
              break;
            }
            case 4: {
              if (opts.limits?.blockPresences != null && obj.blockPresences.length === opts.limits.blockPresences) {
                throw new MaxLengthError('Decode error - map field "blockPresences" had too many elements');
              }
              obj.blockPresences.push(BlockPresence.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.blockPresences$
              }));
              break;
            }
            case 5: {
              obj.pendingBytes = reader.int32();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  BitswapMessage2.encode = (obj) => {
    return encodeMessage(obj, BitswapMessage2.codec());
  };
  BitswapMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, BitswapMessage2.codec(), opts);
  };
})(BitswapMessage || (BitswapMessage = {}));

// node_modules/@helia/bitswap/dist/src/utils/merge-messages.js
function mergeMessages(existingMessage, newMessage) {
  for (const [key, entry] of newMessage.wantlist.entries()) {
    const existingEntry = existingMessage.wantlist.get(key);
    if (existingEntry != null) {
      if (existingEntry.priority > entry.priority) {
        entry.priority = existingEntry.priority;
      }
      entry.cancel = entry.cancel ?? existingEntry.cancel;
      entry.wantType = entry.wantType ?? existingEntry.wantType;
      entry.sendDontHave = entry.sendDontHave ?? existingEntry.sendDontHave;
    }
    existingMessage.wantlist.set(key, entry);
  }
  for (const [key, blockPresence] of newMessage.blockPresences.entries()) {
    existingMessage.blockPresences.set(key, blockPresence);
  }
  for (const [key, block] of newMessage.blocks.entries()) {
    existingMessage.blocks.set(key, block);
  }
  if (newMessage.full && !existingMessage.full) {
    existingMessage.full = true;
  }
  return existingMessage;
}

// node_modules/@helia/bitswap/dist/src/errors.js
var BlockTooLargeError = class extends Error {
  static name = "BlockTooLargeError";
  constructor(message2 = "Block too large") {
    super(message2);
    this.name = "BlockTooLargeError";
  }
};

// node_modules/@helia/bitswap/dist/src/utils/split-message.js
var MAX_BLOCK_SIZE = 4193648;
var MAX_ENCODED_BLOCK_SIZE = MAX_BLOCK_SIZE + 16;
function* splitMessage(message2, maxSize) {
  const wantListEntries = [...message2.wantlist.values()];
  const blockPresences = [...message2.blockPresences.values()];
  const blocks = [...message2.blocks.values()];
  let wantListIndex = 0;
  let blockPresencesIndex = 0;
  let blocksIndex = 0;
  let doneSending = false;
  while (true) {
    const subMessage = {
      wantlist: {
        full: message2.full ?? false,
        entries: []
      },
      blockPresences: [],
      blocks: [],
      pendingBytes: 0
    };
    let size = BitswapMessage.encode(subMessage).byteLength;
    let { added, hasMore, newSize } = addToMessage(blocks, subMessage.blocks, blocksIndex, maxSize, size, calculateEncodedBlockSize);
    blocksIndex += added;
    size = newSize;
    const haveMoreBlocks = hasMore;
    ({ added, hasMore, newSize } = addToMessage(blockPresences, subMessage.blockPresences, blockPresencesIndex, maxSize, size, calculateEncodedBlockPresenceSize));
    blockPresencesIndex += added;
    size = newSize;
    const haveMorePresences = hasMore;
    ({ added, hasMore, newSize } = addToMessage(wantListEntries, subMessage.wantlist.entries, wantListIndex, maxSize, size, calculateEncodedWantlistEntrySize));
    wantListIndex += added;
    size = newSize;
    const haveMoreWantlistEntries = hasMore;
    doneSending = !haveMoreBlocks && !haveMorePresences && !haveMoreWantlistEntries;
    if (!doneSending) {
      subMessage.wantlist.full = false;
    }
    yield BitswapMessage.encode(subMessage);
    if (doneSending) {
      break;
    }
  }
}
function addToMessage(input, output, start2, maxSize, size, calculateSize) {
  let added = 0;
  let hasMore = false;
  for (let i = start2; i < input.length; i++) {
    const item = input[i];
    const itemSize = calculateSize(item);
    if (itemSize > MAX_ENCODED_BLOCK_SIZE) {
      throw new BlockTooLargeError("Cannot send block as after encoding it is over the max message size");
    }
    const newSize = size + itemSize;
    if (newSize > maxSize) {
      hasMore = true;
      break;
    }
    output.push(item);
    added++;
    size = newSize;
  }
  return { hasMore, added, newSize: size };
}
function calculateEncodedBlockSize(block) {
  return calculateLength(3, Block2.encode(block));
}
function calculateEncodedBlockPresenceSize(blockPresence) {
  return calculateLength(4, BlockPresence.encode(blockPresence));
}
function calculateEncodedWantlistEntrySize(entry) {
  return calculateLength(1, WantlistEntry.encode(entry));
}
function calculateLength(fieldNumber, data) {
  const fieldNumberLength = encodingLength(fieldNumber);
  const dataLengthLength = encodingLength(data.byteLength);
  return fieldNumberLength + dataLengthLength + data.byteLength;
}

// node_modules/@helia/bitswap/dist/src/network.js
var Network = class extends TypedEventEmitter {
  log;
  libp2p;
  routing;
  protocols;
  running;
  maxInboundStreams;
  maxOutboundStreams;
  messageReceiveTimeout;
  registrarIds;
  metrics;
  sendQueue;
  runOnLimitedConnections;
  maxOutgoingMessageSize;
  maxIncomingMessageSize;
  constructor(components, init = {}) {
    super();
    this.log = components.logger.forComponent("helia:bitswap:network");
    this.libp2p = components.libp2p;
    this.routing = components.routing;
    this.protocols = init.protocols ?? [BITSWAP_120];
    this.registrarIds = [];
    this.running = false;
    this._onStream = this._onStream.bind(this);
    this.maxInboundStreams = init.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
    this.messageReceiveTimeout = init.messageReceiveTimeout ?? DEFAULT_MESSAGE_RECEIVE_TIMEOUT;
    this.runOnLimitedConnections = init.runOnLimitedConnections ?? DEFAULT_RUN_ON_TRANSIENT_CONNECTIONS;
    this.maxIncomingMessageSize = init.maxIncomingMessageSize ?? DEFAULT_MAX_OUTGOING_MESSAGE_SIZE;
    this.maxOutgoingMessageSize = init.maxOutgoingMessageSize ?? init.maxIncomingMessageSize ?? DEFAULT_MAX_INCOMING_MESSAGE_SIZE;
    this.metrics = {
      blocksSent: components.metrics?.registerCounter("helia_bitswap_sent_blocks_total"),
      dataSent: components.metrics?.registerCounter("helia_bitswap_sent_data_bytes_total")
    };
    this.sendQueue = new PeerQueue({
      concurrency: init.messageSendConcurrency ?? DEFAULT_MESSAGE_SEND_CONCURRENCY,
      metrics: components.metrics,
      metricName: "helia_bitswap_message_send_queue"
    });
    this.sendQueue.addEventListener("error", (evt) => {
      this.log.error("error sending wantlist to peer", evt.detail);
    });
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    await this.libp2p.handle(this.protocols, this._onStream, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnections
    });
    const topology = {
      onConnect: (peerId2) => {
        this.safeDispatchEvent("peer:connected", {
          detail: peerId2
        });
      },
      onDisconnect: (peerId2) => {
        this.safeDispatchEvent("peer:disconnected", {
          detail: peerId2
        });
      }
    };
    this.registrarIds = [];
    for (const protocol of this.protocols) {
      this.registrarIds.push(await this.libp2p.register(protocol, topology));
    }
    this.libp2p.getConnections().forEach((conn) => {
      this.safeDispatchEvent("peer:connected", {
        detail: conn.remotePeer
      });
    });
  }
  async stop() {
    this.running = false;
    await this.libp2p.unhandle(this.protocols);
    if (this.registrarIds != null) {
      for (const id of this.registrarIds) {
        this.libp2p.unregister(id);
      }
      this.registrarIds = [];
    }
  }
  /**
   * Handles incoming bitswap messages
   */
  _onStream(info) {
    if (!this.running) {
      return;
    }
    const { stream, connection } = info;
    Promise.resolve().then(async () => {
      this.log("incoming new bitswap %s stream from %p", stream.protocol, connection.remotePeer);
      const abortListener = () => {
        if (stream.status === "open") {
          stream.abort(new TimeoutError(`Incoming Bitswap stream timed out after ${this.messageReceiveTimeout}ms`));
        } else {
          this.log("stream aborted with status %s", stream.status);
        }
      };
      let signal = AbortSignal.timeout(this.messageReceiveTimeout);
      setMaxListeners(Infinity, signal);
      signal.addEventListener("abort", abortListener);
      await stream.closeWrite();
      await pipe(stream, (source) => decode9(source, {
        maxDataLength: this.maxIncomingMessageSize
      }), async (source) => {
        for await (const data of source) {
          try {
            const message2 = BitswapMessage.decode(data);
            this.log("incoming new bitswap %s message from %p on stream", stream.protocol, connection.remotePeer, stream.id);
            this.safeDispatchEvent("bitswap:message", {
              detail: {
                peer: connection.remotePeer,
                message: message2
              }
            });
            signal.removeEventListener("abort", abortListener);
            signal = AbortSignal.timeout(this.messageReceiveTimeout);
            setMaxListeners(Infinity, signal);
            signal.addEventListener("abort", abortListener);
          } catch (err) {
            this.log.error("error reading incoming bitswap message from %p on stream", connection.remotePeer, stream.id, err);
            stream.abort(err);
            break;
          }
        }
      });
    }).catch((err) => {
      this.log.error("error handling incoming stream from %p", connection.remotePeer, err);
      stream.abort(err);
    });
  }
  /**
   * Find bitswap providers for a given `cid`.
   */
  async *findProviders(cid, options2) {
    options2?.onProgress?.(new CustomProgressEvent("bitswap:network:find-providers", cid));
    for await (const provider of this.routing.findProviders(cid, options2)) {
      const dialable = await this.libp2p.isDialable(provider.multiaddrs, {
        runOnLimitedConnection: this.runOnLimitedConnections
      });
      if (!dialable) {
        continue;
      }
      yield provider;
    }
  }
  /**
   * Find the providers of a given `cid` and connect to them.
   */
  async findAndConnect(cid, options2) {
    if (options2?.providers != null) {
      await Promise.all(options2.providers.map(async (prov) => this.connectTo(prov).catch((err) => {
        this.log.error("could not connect to supplied provider - %e", err);
      })));
    }
    await src_default(src_default5(src_default6(this.findProviders(cid, options2), options2?.maxProviders ?? DEFAULT_MAX_PROVIDERS_PER_REQUEST), async (provider) => this.connectTo(provider.id, options2))).catch((err) => {
      this.log.error(err);
    });
  }
  /**
   * Connect to the given peer
   * Send the given msg (instance of Message) to the given peer
   */
  async sendMessage(peerId2, message2, options2) {
    if (!this.running) {
      throw new Error("network isn't running");
    }
    const existingJob = this.sendQueue.queue.find((job) => {
      return peerId2.equals(job.options.peerId) && job.status === "queued";
    });
    if (existingJob != null) {
      existingJob.options.message = mergeMessages(existingJob.options.message, message2);
      await existingJob.join({
        signal: options2?.signal
      });
      return;
    }
    await this.sendQueue.add(async (options3) => {
      const message3 = options3?.message;
      if (message3 == null) {
        throw new InvalidParametersError("No message to send");
      }
      this.log("sendMessage to %p", peerId2);
      options3?.onProgress?.(new CustomProgressEvent("bitswap:network:send-wantlist", peerId2));
      const stream = await this.libp2p.dialProtocol(peerId2, BITSWAP_120, options3);
      await stream.closeRead();
      try {
        await pipe(splitMessage(message3, this.maxOutgoingMessageSize), (source) => encode8(source), stream);
        await stream.close(options3);
      } catch (err) {
        options3?.onProgress?.(new CustomProgressEvent("bitswap:network:send-wantlist:error", { peer: peerId2, error: err }));
        this.log.error("error sending message to %p", peerId2, err);
        stream.abort(err);
      }
      this._updateSentStats(message3.blocks);
    }, {
      peerId: peerId2,
      signal: options2?.signal,
      message: message2
    });
  }
  /**
   * Connects to another peer
   */
  async connectTo(peer, options2) {
    if (!this.running) {
      throw new NotStartedError("Network isn't running");
    }
    options2?.onProgress?.(new CustomProgressEvent("bitswap:network:dial", peer));
    const [connection] = await Promise.all([
      this.libp2p.dial(peer, options2),
      raceEvent(this.libp2p, "peer:identify", options2?.signal, {
        filter: (evt) => {
          if (!evt.detail.peerId.equals(peer)) {
            return false;
          }
          if (evt.detail.protocols.includes(BITSWAP_120)) {
            return true;
          }
          throw new UnsupportedProtocolError(`${peer} did not support ${BITSWAP_120}`);
        }
      })
    ]);
    return connection;
  }
  _updateSentStats(blocks) {
    let bytes = 0;
    for (const block of blocks.values()) {
      bytes += block.data.byteLength;
    }
    this.metrics.dataSent?.increment(bytes);
    this.metrics.blocksSent?.increment(blocks.size);
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bytes.js
var empty2 = new Uint8Array(0);
function equals4(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce2(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/vendor/base-x.js
function base2(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src2 = base2;
var _brrp__multiformats_scope_baseX2 = src2;
var base_x_default2 = _brrp__multiformats_scope_baseX2;

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base.js
var Encoder2 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder2 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or2(left, right) {
  return new ComposedDecoder2({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec2 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name9, prefix, baseEncode);
    this.decoder = new Decoder2(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from3({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec2(name9, prefix, encode39, decode61);
}
function baseX2({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default2(alphabet2, name9);
  return from3({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce2(decode61(text))
  });
}
function decode10(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode9(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx2(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc46482({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx2(alphabet2);
  return from3({
    prefix,
    name: name9,
    encode(input) {
      return encode9(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode10(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base58.js
var base58btc2 = baseX2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base32.js
var base322 = rfc46482({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper2 = rfc46482({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad2 = rfc46482({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper2 = rfc46482({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex2 = rfc46482({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper2 = rfc46482({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad2 = rfc46482({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper2 = rfc46482({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z2 = rfc46482({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base36.js
var base362 = baseX2({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper2 = baseX2({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/vendor/varint.js
var encode_12 = encode10;
var MSB2 = 128;
var REST2 = 127;
var MSBALL2 = ~REST2;
var INT2 = Math.pow(2, 31);
function encode10(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode10.bytes = offset - oldOffset + 1;
  return out;
}
var decode11 = read2;
var MSB$12 = 128;
var REST$12 = 127;
function read2(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N82 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length2 = function(value7) {
  return value7 < N12 ? 1 : value7 < N22 ? 2 : value7 < N32 ? 3 : value7 < N42 ? 4 : value7 < N52 ? 5 : value7 < N62 ? 6 : value7 < N72 ? 7 : value7 < N82 ? 8 : value7 < N92 ? 9 : 10;
};
var varint2 = {
  encode: encode_12,
  decode: decode11,
  encodingLength: length2
};
var _brrp_varint2 = varint2;
var varint_default2 = _brrp_varint2;

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/varint.js
function decode12(data, offset = 0) {
  const code17 = varint_default2.decode(data, offset);
  return [code17, varint_default2.decode.bytes];
}
function encodeTo2(int, target, offset = 0) {
  varint_default2.encode(int, target, offset);
  return target;
}
function encodingLength3(int) {
  return varint_default2.encodingLength(int);
}

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/digest.js
function create2(code17, digest5) {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength3(code17);
  const digestOffset = sizeOffset + encodingLength3(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo2(code17, bytes, 0);
  encodeTo2(size, bytes, sizeOffset);
  bytes.set(digest5, digestOffset);
  return new Digest2(code17, size, digest5, bytes);
}
function decode13(multihash) {
  const bytes = coerce2(multihash);
  const [code17, sizeOffset] = decode12(bytes);
  const [size, digestOffset] = decode12(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest2(code17, size, digest5, bytes);
}
function equals5(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals4(a.bytes, data.bytes);
  }
}
var Digest2 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/cid.js
function format2(link, base14) {
  const { bytes, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV02(bytes, baseCache2(link), base14 ?? base58btc2.encoder);
    default:
      return toStringV12(bytes, baseCache2(link), base14 ?? base322.encoder);
  }
}
var cache3 = /* @__PURE__ */ new WeakMap();
function baseCache2(cid) {
  const baseCache11 = cache3.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache3.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID2 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code17, multihash, bytes) {
    this.code = code17;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code17, multihash } = this;
        if (code17 !== DAG_PB_CODE2) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE2) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code17, digest: digest5 } = this.multihash;
        const multihash = create2(code17, digest5);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals5(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format2(this, base14);
  }
  toJSON() {
    return { "/": format2(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value7 = input;
    if (value7 instanceof _CID) {
      return value7;
    } else if (value7["/"] != null && value7["/"] === value7.bytes || value7.asCID === value7) {
      const { version: version3, code: code17, multihash, bytes } = value7;
      return new _CID(version3, code17, multihash, bytes ?? encodeCID2(version3, code17, multihash.bytes));
    } else if (value7[cidSymbol2] === true) {
      const { version: version3, multihash, code: code17 } = value7;
      const digest5 = decode13(multihash);
      return _CID.create(version3, code17, digest5);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code17, digest5) {
    if (typeof code17 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code17 !== DAG_PB_CODE2) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
        } else {
          return new _CID(version3, code17, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID2(version3, code17, digest5.bytes);
        return new _CID(version3, code17, digest5, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE2, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code17, digest5) {
    return _CID.create(1, code17, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest5 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest5) : _CID.createV1(specs.codec, digest5);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length16] = decode12(initialBytes.subarray(offset));
      offset += length16;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE2;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes2(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache2(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes2(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(`${base58btc2.prefix}${source}`)
      ];
    }
    case base58btc2.prefix: {
      const decoder = base14 ?? base58btc2;
      return [base58btc2.prefix, decoder.decode(source)];
    }
    case base322.prefix: {
      const decoder = base14 ?? base322;
      return [base322.prefix, decoder.decode(source)];
    }
    case base362.prefix: {
      const decoder = base14 ?? base362;
      return [base362.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV02(bytes, cache12, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc2.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV12(bytes, cache12, base14) {
  const { prefix } = base14;
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE2 = 112;
var SHA_256_CODE2 = 18;
function encodeCID2(version3, code17, multihash) {
  const codeOffset = encodingLength3(version3);
  const hashOffset = codeOffset + encodingLength3(code17);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo2(version3, bytes, 0);
  encodeTo2(code17, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/identity.js
var code7 = 0;
var name4 = "identity";
var encode11 = coerce2;
function digest2(input) {
  return create2(code7, encode11(input));
}
var identity2 = { code: code7, name: name4, encode: encode11, digest: digest2 };

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/hasher.js
function from4({ name: name9, code: code17, encode: encode39 }) {
  return new Hasher2(name9, code17, encode39);
}
var Hasher2 = class {
  name;
  code;
  encode;
  constructor(name9, code17, encode39) {
    this.name = name9;
    this.code = code17;
    this.encode = encode39;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create2(this.code, result) : result.then((digest5) => create2(this.code, digest5));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha2(name9) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name9, data));
}
var sha2563 = from4({
  name: "sha2-256",
  code: 18,
  encode: sha2("SHA-256")
});
var sha5123 = from4({
  name: "sha2-512",
  code: 19,
  encode: sha2("SHA-512")
});

// node_modules/@libp2p/peer-id/dist/src/peer-id.js
var inspect = Symbol.for("nodejs.util.inspect.custom");
var LIBP2P_KEY_CODE = 114;
var PeerIdImpl = class {
  type;
  multihash;
  publicKey;
  string;
  constructor(init) {
    this.type = init.type;
    this.multihash = init.multihash;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  [peerIdSymbol] = true;
  toString() {
    if (this.string == null) {
      this.string = base58btc2.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  toMultihash() {
    return this.multihash;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID2.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    if (id == null) {
      return false;
    }
    if (id instanceof Uint8Array) {
      return equals(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return this.toString() === id;
    } else if (id?.toMultihash()?.bytes != null) {
      return equals(this.multihash.bytes, id.toMultihash().bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```TypeScript
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [inspect]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerId = class extends PeerIdImpl {
  type = "RSA";
  publicKey;
  constructor(init) {
    super({ ...init, type: "RSA" });
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerId = class extends PeerIdImpl {
  type = "Ed25519";
  publicKey;
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    this.publicKey = init.publicKey;
  }
};
var Secp256k1PeerId = class extends PeerIdImpl {
  type = "secp256k1";
  publicKey;
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    this.publicKey = init.publicKey;
  }
};
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 2336;
var URLPeerId = class {
  type = "url";
  multihash;
  publicKey;
  url;
  constructor(url) {
    this.url = url.toString();
    this.multihash = identity2.digest(fromString(this.url));
  }
  [inspect]() {
    return `PeerId(${this.url})`;
  }
  [peerIdSymbol] = true;
  toString() {
    return this.toCID().toString();
  }
  toMultihash() {
    return this.multihash;
  }
  toCID() {
    return CID2.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.toMultihash());
  }
  toJSON() {
    return this.toString();
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString(other);
    }
    return other.toString() === this.toString();
  }
};

// node_modules/@libp2p/peer-id/dist/src/index.js
var LIBP2P_KEY_CODE2 = 114;
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE2 = 2336;
function peerIdFromString(str, decoder) {
  let multihash;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    multihash = decode13(base58btc2.decode(`z${str}`));
  } else if (str.startsWith("k51qzi5uqu5") || str.startsWith("kzwfwjn5ji4") || str.startsWith("k2k4r8") || str.startsWith("bafz")) {
    return peerIdFromCID(CID2.parse(str));
  } else {
    if (decoder == null) {
      throw new InvalidParametersError('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
    }
    multihash = decode13(decoder.decode(str));
  }
  return peerIdFromMultihash(multihash);
}
function peerIdFromPublicKey(publicKey2) {
  if (publicKey2.type === "Ed25519") {
    return new Ed25519PeerId({
      multihash: publicKey2.toCID().multihash,
      publicKey: publicKey2
    });
  } else if (publicKey2.type === "secp256k1") {
    return new Secp256k1PeerId({
      multihash: publicKey2.toCID().multihash,
      publicKey: publicKey2
    });
  } else if (publicKey2.type === "RSA") {
    return new RSAPeerId({
      multihash: publicKey2.toCID().multihash,
      publicKey: publicKey2
    });
  }
  throw new UnsupportedKeyTypeError();
}
function peerIdFromPrivateKey(privateKey) {
  return peerIdFromPublicKey(privateKey.publicKey);
}
function peerIdFromMultihash(multihash) {
  if (isSha256Multihash(multihash)) {
    return new RSAPeerId({ multihash });
  } else if (isIdentityMultihash(multihash)) {
    try {
      const publicKey2 = publicKeyFromMultihash(multihash);
      if (publicKey2.type === "Ed25519") {
        return new Ed25519PeerId({ multihash, publicKey: publicKey2 });
      } else if (publicKey2.type === "secp256k1") {
        return new Secp256k1PeerId({ multihash, publicKey: publicKey2 });
      }
    } catch (err) {
      const url = toString(multihash.digest);
      return new URLPeerId(new URL(url));
    }
  }
  throw new InvalidMultihashError("Supplied PeerID Multihash is invalid");
}
function peerIdFromCID(cid) {
  if (cid?.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE2 && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
    throw new InvalidCIDError("Supplied PeerID CID is invalid");
  }
  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
    const url = toString(cid.multihash.digest);
    return new URLPeerId(new URL(url));
  }
  return peerIdFromMultihash(cid.multihash);
}
function isIdentityMultihash(multihash) {
  return multihash.code === identity2.code;
}
function isSha256Multihash(multihash) {
  return multihash.code === sha2563.code;
}

// node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/bytes.js
var empty3 = new Uint8Array(0);
function coerce3(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/vendor/base-x.js
function base3(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src3 = base3;
var _brrp__multiformats_scope_baseX3 = src3;
var base_x_default3 = _brrp__multiformats_scope_baseX3;

// node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/bases/base.js
var Encoder3 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder3 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or3(this, decoder);
  }
};
var ComposedDecoder3 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or3(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or3(left, right) {
  return new ComposedDecoder3({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec3 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder3(name9, prefix, baseEncode);
    this.decoder = new Decoder3(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from5({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec3(name9, prefix, encode39, decode61);
}
function baseX3({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default3(alphabet2, name9);
  return from5({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce3(decode61(text))
  });
}

// node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/bases/base58.js
var base58btc3 = baseX3({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr3 = baseX3({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/vendor/varint.js
var encode_13 = encode12;
var MSB3 = 128;
var REST3 = 127;
var MSBALL3 = ~REST3;
var INT3 = Math.pow(2, 31);
function encode12(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT3) {
    out[offset++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode12.bytes = offset - oldOffset + 1;
  return out;
}
var decode14 = read3;
var MSB$13 = 128;
var REST$13 = 127;
function read3(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$13);
  read3.bytes = counter - offset;
  return res;
}
var N13 = Math.pow(2, 7);
var N23 = Math.pow(2, 14);
var N33 = Math.pow(2, 21);
var N43 = Math.pow(2, 28);
var N53 = Math.pow(2, 35);
var N63 = Math.pow(2, 42);
var N73 = Math.pow(2, 49);
var N83 = Math.pow(2, 56);
var N93 = Math.pow(2, 63);
var length3 = function(value7) {
  return value7 < N13 ? 1 : value7 < N23 ? 2 : value7 < N33 ? 3 : value7 < N43 ? 4 : value7 < N53 ? 5 : value7 < N63 ? 6 : value7 < N73 ? 7 : value7 < N83 ? 8 : value7 < N93 ? 9 : 10;
};
var varint3 = {
  encode: encode_13,
  decode: decode14,
  encodingLength: length3
};
var _brrp_varint3 = varint3;
var varint_default3 = _brrp_varint3;

// node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/varint.js
function decode15(data, offset = 0) {
  const code17 = varint_default3.decode(data, offset);
  return [code17, varint_default3.decode.bytes];
}

// node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/hashes/digest.js
function decode16(multihash) {
  const bytes = coerce3(multihash);
  const [code17, sizeOffset] = decode15(bytes);
  const [size, digestOffset] = decode15(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest3(code17, size, digest5, bytes);
}
var Digest3 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/util.js
function mapIterable(iter, map2) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map2(val)
      };
    }
  };
  return iterator;
}
function peerIdFromString2(str) {
  const multihash = decode16(base58btc3.decode(`z${str}`));
  return peerIdFromMultihash(multihash);
}

// node_modules/@libp2p/peer-collections/dist/src/map.js
var PeerMap = class {
  map;
  constructor(map2) {
    this.map = /* @__PURE__ */ new Map();
    if (map2 != null) {
      for (const [key, value7] of map2.entries()) {
        this.map.set(key.toString(), { key, value: value7 });
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    return this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [val[1].key, val[1].value];
    });
  }
  forEach(fn) {
    this.map.forEach((value7, key) => {
      fn(value7.value, value7.key, this);
    });
  }
  get(peer) {
    return this.map.get(peer.toString())?.value;
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value7) {
    this.map.set(peer.toString(), { key: peer, value: value7 });
  }
  keys() {
    return mapIterable(this.map.values(), (val) => {
      return val.key;
    });
  }
  values() {
    return mapIterable(this.map.values(), (val) => val.value);
  }
  get size() {
    return this.map.size;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/set.js
var PeerSet = class _PeerSet {
  set;
  constructor(set) {
    this.set = /* @__PURE__ */ new Set();
    if (set != null) {
      for (const key of set) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId2 = peerIdFromString2(val[0]);
      return [peerId2, peerId2];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const peerId2 = peerIdFromString2(str);
      predicate(peerId2, peerId2, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString2(val);
    });
  }
  intersection(other) {
    const output = new _PeerSet();
    for (const peerId2 of other) {
      if (this.has(peerId2)) {
        output.add(peerId2);
      }
    }
    return output;
  }
  difference(other) {
    const output = new _PeerSet();
    for (const peerId2 of this) {
      if (!other.has(peerId2)) {
        output.add(peerId2);
      }
    }
    return output;
  }
  union(other) {
    const output = new _PeerSet();
    for (const peerId2 of other) {
      output.add(peerId2);
    }
    for (const peerId2 of this) {
      output.add(peerId2);
    }
    return output;
  }
};
function peerSet() {
  return new PeerSet();
}

// node_modules/@libp2p/peer-collections/dist/src/filter.js
var PeerFilter = class {
  filter;
  constructor(size, errorRate) {
    this.filter = createScalableCuckooFilter(size, errorRate);
  }
  has(peerId2) {
    return this.filter.has(peerId2.toMultihash().bytes);
  }
  add(peerId2) {
    this.filter.add(peerId2.toMultihash().bytes);
  }
  remove(peerId2) {
    this.filter.remove?.(peerId2.toMultihash().bytes);
  }
};
function peerFilter(size, errorRate = 1e-3) {
  return new PeerFilter(size, errorRate);
}

// node_modules/@libp2p/peer-collections/dist/src/tracked-map.js
var TrackedPeerMap = class extends PeerMap {
  metric;
  constructor(init) {
    super();
    const { name: name9, metrics } = init;
    this.metric = metrics.registerMetric(name9);
    this.updateComponentMetric();
  }
  set(key, value7) {
    super.set(key, value7);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedPeerMap(config) {
  const { name: name9, metrics } = config;
  let map2;
  if (metrics != null) {
    map2 = new TrackedPeerMap({ name: name9, metrics });
  } else {
    map2 = new PeerMap();
  }
  return map2;
}

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bytes.js
var empty4 = new Uint8Array(0);
function equals7(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce4(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/vendor/base-x.js
function base4(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src4 = base4;
var _brrp__multiformats_scope_baseX4 = src4;
var base_x_default4 = _brrp__multiformats_scope_baseX4;

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base.js
var Encoder4 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder4 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or4(this, decoder);
  }
};
var ComposedDecoder4 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or4(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or4(left, right) {
  return new ComposedDecoder4({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec4 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder4(name9, prefix, baseEncode);
    this.decoder = new Decoder4(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from6({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec4(name9, prefix, encode39, decode61);
}
function baseX4({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default4(alphabet2, name9);
  return from6({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce4(decode61(text))
  });
}
function decode17(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode13(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx3(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc46483({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx3(alphabet2);
  return from6({
    prefix,
    name: name9,
    encode(input) {
      return encode13(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode17(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base32.js
var base323 = rfc46483({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper3 = rfc46483({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad3 = rfc46483({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper3 = rfc46483({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex3 = rfc46483({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper3 = rfc46483({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad3 = rfc46483({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper3 = rfc46483({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z3 = rfc46483({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base36.js
var base363 = baseX4({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper3 = baseX4({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base58.js
var base58btc4 = baseX4({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr4 = baseX4({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/vendor/varint.js
var encode_14 = encode14;
var MSB4 = 128;
var REST4 = 127;
var MSBALL4 = ~REST4;
var INT4 = Math.pow(2, 31);
function encode14(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT4) {
    out[offset++] = num & 255 | MSB4;
    num /= 128;
  }
  while (num & MSBALL4) {
    out[offset++] = num & 255 | MSB4;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode14.bytes = offset - oldOffset + 1;
  return out;
}
var decode18 = read4;
var MSB$14 = 128;
var REST$14 = 127;
function read4(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read4.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$14) << shift : (b & REST$14) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$14);
  read4.bytes = counter - offset;
  return res;
}
var N14 = Math.pow(2, 7);
var N24 = Math.pow(2, 14);
var N34 = Math.pow(2, 21);
var N44 = Math.pow(2, 28);
var N54 = Math.pow(2, 35);
var N64 = Math.pow(2, 42);
var N74 = Math.pow(2, 49);
var N84 = Math.pow(2, 56);
var N94 = Math.pow(2, 63);
var length4 = function(value7) {
  return value7 < N14 ? 1 : value7 < N24 ? 2 : value7 < N34 ? 3 : value7 < N44 ? 4 : value7 < N54 ? 5 : value7 < N64 ? 6 : value7 < N74 ? 7 : value7 < N84 ? 8 : value7 < N94 ? 9 : 10;
};
var varint4 = {
  encode: encode_14,
  decode: decode18,
  encodingLength: length4
};
var _brrp_varint4 = varint4;
var varint_default4 = _brrp_varint4;

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/varint.js
function decode19(data, offset = 0) {
  const code17 = varint_default4.decode(data, offset);
  return [code17, varint_default4.decode.bytes];
}
function encodeTo4(int, target, offset = 0) {
  varint_default4.encode(int, target, offset);
  return target;
}
function encodingLength5(int) {
  return varint_default4.encodingLength(int);
}

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/hashes/digest.js
function create3(code17, digest5) {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength5(code17);
  const digestOffset = sizeOffset + encodingLength5(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo4(code17, bytes, 0);
  encodeTo4(size, bytes, sizeOffset);
  bytes.set(digest5, digestOffset);
  return new Digest4(code17, size, digest5, bytes);
}
function decode20(multihash) {
  const bytes = coerce4(multihash);
  const [code17, sizeOffset] = decode19(bytes);
  const [size, digestOffset] = decode19(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest4(code17, size, digest5, bytes);
}
function equals8(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals7(a.bytes, data.bytes);
  }
}
var Digest4 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/cid.js
function format3(link, base14) {
  const { bytes, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV03(bytes, baseCache3(link), base14 ?? base58btc4.encoder);
    default:
      return toStringV13(bytes, baseCache3(link), base14 ?? base323.encoder);
  }
}
var cache4 = /* @__PURE__ */ new WeakMap();
function baseCache3(cid) {
  const baseCache11 = cache4.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache4.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID3 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code17, multihash, bytes) {
    this.code = code17;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code17, multihash } = this;
        if (code17 !== DAG_PB_CODE3) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE3) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code17, digest: digest5 } = this.multihash;
        const multihash = create3(code17, digest5);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals8(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format3(this, base14);
  }
  toJSON() {
    return { "/": format3(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value7 = input;
    if (value7 instanceof _CID) {
      return value7;
    } else if (value7["/"] != null && value7["/"] === value7.bytes || value7.asCID === value7) {
      const { version: version3, code: code17, multihash, bytes } = value7;
      return new _CID(version3, code17, multihash, bytes ?? encodeCID3(version3, code17, multihash.bytes));
    } else if (value7[cidSymbol3] === true) {
      const { version: version3, multihash, code: code17 } = value7;
      const digest5 = decode20(multihash);
      return _CID.create(version3, code17, digest5);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code17, digest5) {
    if (typeof code17 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code17 !== DAG_PB_CODE3) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`);
        } else {
          return new _CID(version3, code17, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID3(version3, code17, digest5.bytes);
        return new _CID(version3, code17, digest5, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE3, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code17, digest5) {
    return _CID.create(1, code17, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce4(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest5 = new Digest4(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest5) : _CID.createV1(specs.codec, digest5);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length16] = decode19(initialBytes.subarray(offset));
      offset += length16;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE3;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes3(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache3(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes3(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc4;
      return [
        base58btc4.prefix,
        decoder.decode(`${base58btc4.prefix}${source}`)
      ];
    }
    case base58btc4.prefix: {
      const decoder = base14 ?? base58btc4;
      return [base58btc4.prefix, decoder.decode(source)];
    }
    case base323.prefix: {
      const decoder = base14 ?? base323;
      return [base323.prefix, decoder.decode(source)];
    }
    case base363.prefix: {
      const decoder = base14 ?? base363;
      return [base363.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV03(bytes, cache12, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc4.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV13(bytes, cache12, base14) {
  const { prefix } = base14;
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE3 = 112;
var SHA_256_CODE3 = 18;
function encodeCID3(version3, code17, multihash) {
  const codeOffset = encodingLength5(version3);
  const hashOffset = codeOffset + encodingLength5(code17);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo4(version3, bytes, 0);
  encodeTo4(code17, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol3 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/bases/base64.js
var base642 = rfc46483({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad2 = rfc46483({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url2 = rfc46483({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad2 = rfc46483({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@helia/bitswap/dist/src/utils/bitswap-message.js
var QueuedBitswapMessage = class {
  full;
  pendingBytes;
  wantlist;
  blocks;
  blockPresences;
  constructor(full = false, pendingBytes = 0) {
    this.full = full;
    this.wantlist = /* @__PURE__ */ new Map();
    this.blocks = /* @__PURE__ */ new Map();
    this.blockPresences = /* @__PURE__ */ new Map();
    this.pendingBytes = 0;
  }
  addWantlistEntry(cid, entry) {
    const key = base642.encode(cid.multihash.bytes);
    this.wantlist.set(key, entry);
  }
  addBlockPresence(cid, blockPresence) {
    const key = base642.encode(cid.multihash.bytes);
    this.blockPresences.set(key, blockPresence);
  }
  addBlock(cid, block) {
    const key = base642.encode(cid.multihash.bytes);
    this.blocks.set(key, block);
  }
};

// node_modules/@helia/bitswap/dist/src/utils/varint-encoder.js
function varintEncoder(buf) {
  let out = new Uint8Array(buf.reduce((acc, curr) => {
    return acc + encodingLength(curr);
  }, 0));
  let offset = 0;
  for (const num of buf) {
    out = encode(num, out, offset);
    offset += encodingLength(num);
  }
  return out;
}
var varint_encoder_default = varintEncoder;

// node_modules/@helia/bitswap/dist/src/utils/cid-prefix.js
function cidToPrefix(cid) {
  return varint_encoder_default([
    cid.version,
    cid.code,
    cid.multihash.code,
    cid.multihash.digest.byteLength
  ]);
}

// node_modules/@helia/bitswap/dist/src/peer-want-lists/ledger.js
var Ledger = class {
  peerId;
  blockstore;
  network;
  wants;
  exchangeCount;
  bytesSent;
  bytesReceived;
  lastExchange;
  maxSizeReplaceHasWithBlock;
  log;
  constructor(components, init) {
    this.peerId = components.peerId;
    this.blockstore = components.blockstore;
    this.network = components.network;
    this.wants = /* @__PURE__ */ new Map();
    this.log = components.logger.forComponent(`helia:bitswap:ledger:${components.peerId}`);
    this.exchangeCount = 0;
    this.bytesSent = 0;
    this.bytesReceived = 0;
    this.maxSizeReplaceHasWithBlock = init.maxSizeReplaceHasWithBlock ?? DEFAULT_MAX_SIZE_REPLACE_HAS_WITH_BLOCK;
  }
  sentBytes(n) {
    this.exchangeCount++;
    this.lastExchange = (/* @__PURE__ */ new Date()).getTime();
    this.bytesSent += n;
  }
  receivedBytes(n) {
    this.exchangeCount++;
    this.lastExchange = (/* @__PURE__ */ new Date()).getTime();
    this.bytesReceived += n;
  }
  debtRatio() {
    return this.bytesSent / (this.bytesReceived + 1);
  }
  async sendBlocksToPeer(options2) {
    const message2 = new QueuedBitswapMessage();
    const sentBlocks = /* @__PURE__ */ new Set();
    for (const [key, entry] of this.wants.entries()) {
      try {
        const block = await this.blockstore.get(entry.cid, options2);
        if (entry.wantType === WantType.WantHave) {
          if (block.byteLength < this.maxSizeReplaceHasWithBlock) {
            this.log("sending have and block for %c", entry.cid);
            sentBlocks.add(key);
            message2.addBlock(entry.cid, {
              data: block,
              prefix: cidToPrefix(entry.cid)
            });
          } else {
            this.log("sending have for %c", entry.cid);
            message2.addBlockPresence(entry.cid, {
              cid: entry.cid.bytes,
              type: BlockPresenceType.HaveBlock
            });
          }
        } else {
          this.log("sending block for %c", entry.cid);
          sentBlocks.add(key);
          message2.addBlock(entry.cid, {
            data: block,
            prefix: cidToPrefix(entry.cid)
          });
        }
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
        this.log("do not have block for %c", entry.cid);
        if (!entry.sendDontHave) {
          continue;
        }
        if (entry.sentDoNotHave === true) {
          continue;
        }
        entry.sentDoNotHave = true;
        message2.addBlockPresence(entry.cid, {
          cid: entry.cid.bytes,
          type: BlockPresenceType.DoNotHaveBlock
        });
      }
    }
    if (message2.blocks.size > 0 || message2.blockPresences.size > 0) {
      this.log("sending message");
      await this.network.sendMessage(this.peerId, message2, options2);
      this.log("sent message");
      this.sentBytes([...message2.blocks.values()].reduce((acc, curr) => acc + curr.data.byteLength, 0));
      for (const key of sentBlocks) {
        this.wants.delete(key);
      }
    }
  }
};

// node_modules/@helia/bitswap/dist/src/peer-want-lists/index.js
var PeerWantLists = class {
  blockstore;
  network;
  ledgerMap;
  maxSizeReplaceHasWithBlock;
  log;
  logger;
  constructor(components, init = {}) {
    this.blockstore = components.blockstore;
    this.network = components.network;
    this.maxSizeReplaceHasWithBlock = init.maxSizeReplaceHasWithBlock;
    this.log = components.logger.forComponent("helia:bitswap:peer-want-lists");
    this.logger = components.logger;
    this.ledgerMap = trackedPeerMap({
      name: "helia_bitswap_ledger_map",
      metrics: components.metrics
    });
    this.network.addEventListener("bitswap:message", (evt) => {
      this.receiveMessage(evt.detail.peer, evt.detail.message).catch((err) => {
        this.log.error("error receiving bitswap message from %p", evt.detail.peer, err);
      });
    });
    this.network.addEventListener("peer:disconnected", (evt) => {
      this.peerDisconnected(evt.detail);
    });
  }
  ledgerForPeer(peerId2) {
    const ledger = this.ledgerMap.get(peerId2);
    if (ledger == null) {
      return void 0;
    }
    return {
      peer: ledger.peerId,
      value: ledger.debtRatio(),
      sent: ledger.bytesSent,
      received: ledger.bytesReceived,
      exchanged: ledger.exchangeCount
    };
  }
  wantListForPeer(peerId2) {
    const ledger = this.ledgerMap.get(peerId2);
    if (ledger == null) {
      return void 0;
    }
    return [...ledger.wants.values()];
  }
  peers() {
    return Array.from(this.ledgerMap.values()).map((l) => l.peerId);
  }
  /**
   * Handle incoming messages
   */
  async receiveMessage(peerId2, message2) {
    let ledger = this.ledgerMap.get(peerId2);
    if (ledger == null) {
      ledger = new Ledger({
        peerId: peerId2,
        blockstore: this.blockstore,
        network: this.network,
        logger: this.logger
      }, {
        maxSizeReplaceHasWithBlock: this.maxSizeReplaceHasWithBlock
      });
      this.ledgerMap.set(peerId2, ledger);
    }
    ledger.receivedBytes(message2.blocks?.reduce((acc, curr) => acc + curr.data.byteLength, 0) ?? 0);
    if (message2.wantlist != null) {
      if (message2.wantlist.full === true) {
        ledger.wants.clear();
      }
      for (const entry of message2.wantlist.entries) {
        const cid = CID3.decode(entry.cid);
        const cidStr = toString(cid.multihash.bytes, "base64");
        if (entry.cancel === true) {
          this.log("peer %p cancelled want of block for %c", peerId2, cid);
          ledger.wants.delete(cidStr);
        } else {
          if (entry.wantType === WantType.WantHave) {
            this.log("peer %p wanted block presence for %c", peerId2, cid);
          } else {
            this.log("peer %p wanted block for %c", peerId2, cid);
          }
          ledger.wants.set(cidStr, {
            cid,
            priority: entry.priority,
            wantType: entry.wantType ?? WantType.WantBlock,
            sendDontHave: entry.sendDontHave ?? false
          });
        }
      }
    }
    this.log("send blocks to peer");
    await ledger.sendBlocksToPeer();
  }
  async receivedBlock(cid, options2) {
    const cidStr = toString(cid.multihash.bytes, "base64");
    const ledgers = [];
    for (const ledger of this.ledgerMap.values()) {
      if (ledger.wants.has(cidStr)) {
        ledgers.push(ledger);
      }
    }
    await Promise.all(ledgers.map(async (ledger) => ledger.sendBlocksToPeer(options2)));
  }
  peerDisconnected(peerId2) {
    this.ledgerMap.delete(peerId2);
  }
};

// node_modules/@helia/bitswap/dist/src/session.js
var BitswapSession = class extends AbstractSession {
  wantList;
  network;
  libp2p;
  constructor(components, init) {
    super(components, {
      ...init,
      name: "helia:bitswap:session"
    });
    this.wantList = components.wantList;
    this.network = components.network;
    this.libp2p = components.libp2p;
  }
  async queryProvider(cid, provider, options2) {
    this.log("sending WANT-BLOCK for %c to %p", cid, provider);
    const result = await this.wantList.wantSessionBlock(cid, provider, options2);
    this.log("%p %s %c", provider, result.has ? "has" : "does not have", cid);
    if (result.has && result.block != null) {
      return result.block;
    }
    throw new Error("Provider did not have block");
  }
  async *findNewProviders(cid, options2 = {}) {
    for await (const provider of this.network.findProviders(cid, options2)) {
      yield provider.id;
    }
  }
  toEvictionKey(provider) {
    return provider.toMultihash().bytes;
  }
  equals(providerA, providerB) {
    return providerA.equals(providerB);
  }
  async convertToProvider(provider, options2) {
    if (isPeerId(provider)) {
      return provider;
    }
    const connection = await this.libp2p.dial(provider, options2);
    return connection.remotePeer;
  }
};
function createBitswapSession(components, init) {
  return new BitswapSession(components, init);
}

// node_modules/@helia/bitswap/dist/src/stats.js
var Stats = class {
  blocksReceived;
  duplicateBlocksReceived;
  dataReceived;
  duplicateDataReceived;
  constructor(components) {
    this.blocksReceived = components.metrics?.registerMetricGroup("helia_bitswap_received_blocks");
    this.duplicateBlocksReceived = components.metrics?.registerMetricGroup("helia_bitswap_duplicate_received_blocks");
    this.dataReceived = components.metrics?.registerMetricGroup("helia_bitswap_data_received_bytes");
    this.duplicateDataReceived = components.metrics?.registerMetricGroup("helia_bitswap_duplicate_data_received_bytes");
  }
  updateBlocksReceived(count = 1, peerId2) {
    const stats = {
      global: count
    };
    if (peerId2 != null) {
      stats[peerId2.toString()] = count;
    }
    this.blocksReceived?.increment(stats);
  }
  updateDuplicateBlocksReceived(count = 1, peerId2) {
    const stats = {
      global: count
    };
    if (peerId2 != null) {
      stats[peerId2.toString()] = count;
    }
    this.duplicateBlocksReceived?.increment(stats);
  }
  updateDataReceived(bytes, peerId2) {
    const stats = {
      global: bytes
    };
    if (peerId2 != null) {
      stats[peerId2.toString()] = bytes;
    }
    this.dataReceived?.increment(stats);
  }
  updateDuplicateDataReceived(bytes, peerId2) {
    const stats = {
      global: bytes
    };
    if (peerId2 != null) {
      stats[peerId2.toString()] = bytes;
    }
    this.duplicateDataReceived?.increment(stats);
  }
};

// node_modules/@libp2p/utils/dist/src/tracked-map.js
var TrackedMap = class extends Map {
  metric;
  constructor(init) {
    super();
    const { name: name9, metrics } = init;
    this.metric = metrics.registerMetric(name9);
    this.updateComponentMetric();
  }
  set(key, value7) {
    super.set(key, value7);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedMap(config) {
  const { name: name9, metrics } = config;
  let map2;
  if (metrics != null) {
    map2 = new TrackedMap({ name: name9, metrics });
  } else {
    map2 = /* @__PURE__ */ new Map();
  }
  return map2;
}

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/hashes/hasher.js
function from7({ name: name9, code: code17, encode: encode39 }) {
  return new Hasher3(name9, code17, encode39);
}
var Hasher3 = class {
  name;
  code;
  encode;
  constructor(name9, code17, encode39) {
    this.name = name9;
    this.code = code17;
    this.encode = encode39;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create3(this.code, result) : result.then((digest5) => create3(this.code, digest5));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@helia/bitswap/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha3(name9) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name9, data));
}
var sha2564 = from7({
  name: "sha2-256",
  code: 18,
  encode: sha3("SHA-256")
});
var sha5124 = from7({
  name: "sha2-512",
  code: 19,
  encode: sha3("SHA-512")
});

// node_modules/@helia/bitswap/dist/src/utils/varint-decoder.js
function varintDecoder(buf) {
  if (!(buf instanceof Uint8Array)) {
    throw new Error("arg needs to be a Uint8Array");
  }
  const result = [];
  while (buf.length > 0) {
    const num = decode(buf);
    result.push(num);
    buf = buf.slice(encodingLength(num));
  }
  return result;
}
var varint_decoder_default = varintDecoder;

// node_modules/@helia/bitswap/dist/src/want-list.js
var WantList = class extends TypedEventEmitter {
  /**
   * Tracks what CIDs we've previously sent to which peers
   */
  peers;
  wants;
  network;
  log;
  sendMessagesDelay;
  sendMessagesTimeout;
  hashLoader;
  sendingMessages;
  constructor(components, init = {}) {
    super();
    setMaxListeners(Infinity, this);
    this.peers = trackedPeerMap({
      name: "helia_bitswap_peers",
      metrics: components.metrics
    });
    this.wants = trackedMap({
      name: "helia_bitswap_wantlist",
      metrics: components.metrics
    });
    this.network = components.network;
    this.sendMessagesDelay = init.sendMessagesDelay ?? DEFAULT_MESSAGE_SEND_DELAY;
    this.log = components.logger.forComponent("helia:bitswap:wantlist");
    this.hashLoader = init.hashLoader;
    this.network.addEventListener("bitswap:message", (evt) => {
      this.receiveMessage(evt.detail.peer, evt.detail.message).catch((err) => {
        this.log.error("error receiving bitswap message from %p", evt.detail.peer, err);
      });
    });
    this.network.addEventListener("peer:connected", (evt) => {
      this.peerConnected(evt.detail).catch((err) => {
        this.log.error("error processing newly connected bitswap peer %p", evt.detail, err);
      });
    });
    this.network.addEventListener("peer:disconnected", (evt) => {
      this.peerDisconnected(evt.detail);
    });
  }
  async addEntry(cid, options2) {
    const cidStr = toString(cid.multihash.bytes, "base64");
    let entry = this.wants.get(cidStr);
    if (entry == null) {
      entry = {
        cid,
        priority: options2.priority ?? 1,
        wantType: options2.wantType ?? WantType.WantBlock,
        cancel: false,
        sendDontHave: true
      };
      this.wants.set(cidStr, entry);
    }
    if (entry.wantType === WantType.WantHave && options2.wantType === WantType.WantBlock) {
      entry.wantType = WantType.WantBlock;
    }
    await this.sendMessagesDebounced();
    try {
      if (options2.wantType === WantType.WantBlock) {
        const event2 = await raceEvent(this, "block", options2?.signal, {
          filter: (event3) => {
            return equals(cid.multihash.digest, event3.detail.cid.multihash.digest);
          },
          errorMessage: "Want was aborted"
        });
        return event2.detail;
      }
      const event = await raceEvent(this, "presence", options2?.signal, {
        filter: (event2) => {
          return equals(cid.multihash.digest, event2.detail.cid.multihash.digest);
        },
        errorMessage: "Want was aborted"
      });
      return event.detail;
    } finally {
      if (options2.signal?.aborted === true) {
        this.log("want for %c was aborted, cancelling want", cid);
        entry.cancel = true;
        await this.sendMessagesDebounced();
      }
    }
  }
  async sendMessagesDebounced() {
    await this.sendingMessages?.promise;
    clearTimeout(this.sendMessagesTimeout);
    this.sendMessagesTimeout = setTimeout(() => {
      void this.sendMessages().catch((err) => {
        this.log("error sending messages to peers", err);
      });
    }, this.sendMessagesDelay);
  }
  async sendMessages() {
    this.sendingMessages = pDefer();
    await Promise.all([...this.peers.entries()].map(async ([peerId2, sentWants]) => {
      const sent = /* @__PURE__ */ new Set();
      const message2 = new QueuedBitswapMessage();
      for (const [key, entry] of this.wants.entries()) {
        const sentPreviously = sentWants.has(key);
        if (sentPreviously || entry.cancel) {
          continue;
        }
        sent.add(key);
        message2.addWantlistEntry(entry.cid, {
          cid: entry.cid.bytes,
          priority: entry.priority,
          wantType: entry.wantType,
          cancel: entry.cancel,
          sendDontHave: entry.sendDontHave
        });
      }
      if (message2.wantlist.size === 0) {
        return;
      }
      try {
        await this.network.sendMessage(peerId2, message2);
        for (const key of sent) {
          sentWants.add(key);
        }
      } catch (err) {
        this.log.error("error sending full wantlist to new peer", err);
      }
    })).catch((err) => {
      this.log.error("error sending messages", err);
    });
    for (const [key, entry] of this.wants) {
      if (entry.cancel) {
        this.wants.delete(key);
        for (const sentWants of this.peers.values()) {
          sentWants.delete(key);
        }
      }
    }
    this.sendingMessages.resolve();
  }
  has(cid) {
    const cidStr = toString(cid.multihash.bytes, "base64");
    return this.wants.has(cidStr);
  }
  /**
   * Add a CID to the wantlist
   */
  async wantSessionPresence(cid, peerId2, options2 = {}) {
    const message2 = new QueuedBitswapMessage();
    message2.addWantlistEntry(cid, {
      cid: cid.bytes,
      sendDontHave: true,
      wantType: WantType.WantHave,
      priority: 1
    });
    await this.network.sendMessage(peerId2, message2);
    const event = await raceEvent(this, "presence", options2.signal, {
      filter: (event2) => {
        return peerId2.equals(event2.detail.sender) && equals(cid.multihash.digest, event2.detail.cid.multihash.digest);
      }
    });
    return event.detail;
  }
  /**
   * Add a CID to the wantlist
   */
  async wantBlock(cid, options2 = {}) {
    return this.addEntry(cid, {
      ...options2,
      wantType: WantType.WantBlock
    });
  }
  /**
   * Add a CID to the wantlist
   */
  async wantSessionBlock(cid, peerId2, options2 = {}) {
    const message2 = new QueuedBitswapMessage();
    message2.addWantlistEntry(cid, {
      cid: cid.bytes,
      sendDontHave: true,
      wantType: WantType.WantBlock,
      priority: 1
    });
    await this.network.sendMessage(peerId2, message2);
    const event = await raceEvent(this, "presence", options2.signal, {
      filter: (event2) => {
        return peerId2.equals(event2.detail.sender) && equals(cid.multihash.digest, event2.detail.cid.multihash.digest);
      }
    });
    return event.detail;
  }
  /**
   * Invoked when a block has been received from an external source
   */
  async receivedBlock(cid, options2) {
    const cidStr = toString(cid.multihash.bytes, "base64");
    const entry = this.wants.get(cidStr);
    if (entry == null) {
      return;
    }
    entry.cancel = true;
    await this.sendMessagesDebounced();
  }
  /**
   * Invoked when a message is received from a bitswap peer
   */
  async receiveMessage(sender, message2) {
    this.log("received message from %p with %d blocks", sender, message2.blocks.length);
    let blocksCancelled = false;
    for (const block of message2.blocks) {
      if (block.prefix == null || block.data == null) {
        continue;
      }
      const values = varint_decoder_default(block.prefix);
      const cidVersion = values[0];
      const multicodec2 = values[1];
      const hashAlg = values[2];
      const hasher = hashAlg === sha2564.code ? sha2564 : await this.hashLoader?.getHasher(hashAlg);
      if (hasher == null) {
        this.log.error("unknown hash algorithm", hashAlg);
        continue;
      }
      let hash = hasher.digest(block.data);
      if (hash.then != null) {
        hash = await hash;
      }
      const cid = CID3.create(cidVersion === 0 ? 0 : 1, multicodec2, hash);
      this.log("received block from %p for %c", sender, cid);
      this.safeDispatchEvent("block", {
        detail: {
          sender,
          cid,
          block: block.data
        }
      });
      this.safeDispatchEvent("presence", {
        detail: {
          sender,
          cid,
          has: true,
          block: block.data
        }
      });
      const cidStr = toString(cid.multihash.bytes, "base64");
      const entry = this.wants.get(cidStr);
      if (entry == null) {
        continue;
      }
      entry.cancel = true;
      blocksCancelled = true;
    }
    for (const { cid: cidBytes, type } of message2.blockPresences) {
      const cid = CID3.decode(cidBytes);
      this.log("received %s from %p for %c", type, sender, cid);
      this.safeDispatchEvent("presence", {
        detail: {
          sender,
          cid,
          has: type === BlockPresenceType.HaveBlock
        }
      });
    }
    if (blocksCancelled) {
      await this.sendMessagesDebounced();
    }
  }
  /**
   * Invoked when the network topology notices a new peer that supports Bitswap
   */
  async peerConnected(peerId2) {
    const sentWants = /* @__PURE__ */ new Set();
    const message2 = new QueuedBitswapMessage(true);
    for (const [key, entry] of this.wants.entries()) {
      if (entry.cancel) {
        continue;
      }
      sentWants.add(key);
      message2.addWantlistEntry(entry.cid, {
        cid: entry.cid.bytes,
        priority: 1,
        wantType: WantType.WantBlock,
        cancel: false,
        sendDontHave: false
      });
    }
    if (message2.wantlist.size === 0) {
      this.peers.set(peerId2, sentWants);
      return;
    }
    try {
      await this.network.sendMessage(peerId2, message2);
      this.peers.set(peerId2, sentWants);
    } catch (err) {
      this.log.error("error sending full wantlist to new peer %p", peerId2, err);
    }
  }
  /**
   * Invoked when the network topology notices peer that supports Bitswap has
   * disconnected
   */
  peerDisconnected(peerId2) {
    this.peers.delete(peerId2);
  }
  start() {
  }
  stop() {
    this.peers.clear();
    clearTimeout(this.sendMessagesTimeout);
  }
};

// node_modules/@helia/bitswap/dist/src/bitswap.js
var Bitswap = class {
  log;
  logger;
  stats;
  network;
  blockstore;
  peerWantLists;
  wantList;
  libp2p;
  constructor(components, init = {}) {
    this.logger = components.logger;
    this.log = components.logger.forComponent("helia:bitswap");
    this.blockstore = components.blockstore;
    this.libp2p = components.libp2p;
    this.stats = new Stats(components);
    this.network = new Network(components, init);
    this.peerWantLists = new PeerWantLists({
      ...components,
      network: this.network
    }, init);
    this.wantList = new WantList({
      ...components,
      network: this.network
    }, init);
  }
  createSession(options2 = {}) {
    return createBitswapSession({
      wantList: this.wantList,
      network: this.network,
      logger: this.logger,
      libp2p: this.libp2p
    }, options2);
  }
  async want(cid, options2 = {}) {
    const controller = new AbortController();
    const signal = anySignal([controller.signal, options2.signal]);
    setMaxListeners(Infinity, controller.signal, signal);
    this.network.findAndConnect(cid, {
      ...options2,
      signal
    }).catch((err) => {
      if (!controller.signal.aborted) {
        this.log.error("error during finding and connect for cid %c", cid, err);
      }
    });
    try {
      const result = await this.wantList.wantBlock(cid, {
        ...options2,
        signal
      });
      return result.block;
    } finally {
      controller.abort();
      signal.clear();
    }
  }
  /**
   * Sends notifications about the arrival of a block
   */
  async notify(cid, block, options2 = {}) {
    await Promise.all([
      this.peerWantLists.receivedBlock(cid, options2),
      this.wantList.receivedBlock(cid, options2)
    ]);
  }
  getWantlist() {
    return [...this.wantList.wants.values()].filter((entry) => !entry.cancel).map((entry) => ({
      cid: entry.cid,
      priority: entry.priority,
      wantType: entry.wantType
    }));
  }
  getPeerWantlist(peer) {
    return this.peerWantLists.wantListForPeer(peer);
  }
  /**
   * Start the bitswap node
   */
  async start() {
    this.wantList.start();
    await this.network.start();
  }
  /**
   * Stop the bitswap node
   */
  async stop() {
    this.wantList.stop();
    await this.network.stop();
  }
};

// node_modules/@helia/bitswap/dist/src/index.js
var createBitswap = (components, options2 = {}) => {
  return new Bitswap(components, options2);
};

// node_modules/@helia/block-brokers/dist/src/bitswap.js
var BitswapBlockBroker = class {
  bitswap;
  started;
  constructor(components, init = {}) {
    const { getHasher: getHasher2 } = components;
    this.bitswap = createBitswap(components, {
      hashLoader: {
        getHasher: async (codecOrName) => {
          return getHasher2(codecOrName);
        }
      },
      ...init
    });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await this.bitswap.start();
    this.started = true;
  }
  async stop() {
    await this.bitswap.stop();
    this.started = false;
  }
  async announce(cid, block, options2) {
    await this.bitswap.notify(cid, block, options2);
  }
  async retrieve(cid, options2 = {}) {
    return this.bitswap.want(cid, options2);
  }
  createSession(options2) {
    const session = this.bitswap.createSession(options2);
    return {
      announce: async (cid, block, options3) => {
        await this.bitswap.notify(cid, block, options3);
      },
      retrieve: async (cid, options3) => {
        return session.retrieve(cid, options3);
      }
    };
  }
};
function bitswap(init = {}) {
  return (components) => new BitswapBlockBroker(components, init);
}

// node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
var ASSUME_HTTP_CODES = [
  CODE_TCP,
  CODE_DNS,
  CODE_DNSADDR,
  CODE_DNS4,
  CODE_DNS6
];
function extractSNI(ma) {
  return extractTuple("sni", ma)?.value;
}
function extractPort(ma) {
  const port = extractTuple("tcp", ma)?.value;
  if (port == null) {
    return "";
  }
  return `:${port}`;
}
function extractTuple(name9, ma) {
  return ma.find((component) => component.name === name9);
}
function hasTLS(ma) {
  return ma.some(({ code: code17 }) => code17 === CODE_TLS);
}
function interpretNext(head, rest) {
  const interpreter = interpreters[head.name];
  if (interpreter == null) {
    throw new Error(`Can't interpret protocol ${head.name}`);
  }
  const restVal = interpreter(head, rest);
  if (head.code === CODE_IP6) {
    return `[${restVal}]`;
  }
  return restVal;
}
var interpreters = {
  ip4: (head, rest) => head.value,
  ip6: (head, rest) => {
    if (rest.length === 0) {
      return head.value;
    }
    return `[${head.value}]`;
  },
  tcp: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `tcp://${interpretNext(tail, rest)}:${head.value}`;
  },
  udp: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `udp://${interpretNext(tail, rest)}:${head.value}`;
  },
  dnsaddr: (head, rest) => head.value,
  dns4: (head, rest) => head.value,
  dns6: (head, rest) => head.value,
  dns: (head, rest) => head.value,
  ipfs: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tail, rest)}`;
  },
  p2p: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tail, rest)}`;
  },
  http: (head, rest) => {
    const maHasTLS = hasTLS(rest);
    const sni = extractSNI(rest);
    const port = extractPort(rest);
    if (maHasTLS && sni != null) {
      return `https://${sni}${port}`;
    }
    const protocol = maHasTLS ? "https://" : "http://";
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal?.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  "http-path": (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    const baseVal = interpretNext(tail, rest);
    const decodedValue = decodeURIComponent(head.value ?? "");
    return `${baseVal}${decodedValue}`;
  },
  tls: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tail, rest);
  },
  sni: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tail, rest);
  },
  https: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal?.replace("tcp://", "");
    return `https://${baseVal}`;
  },
  ws: (head, rest) => {
    const maHasTLS = hasTLS(rest);
    const sni = extractSNI(rest);
    const port = extractPort(rest);
    if (maHasTLS && sni != null) {
      return `wss://${sni}${port}`;
    }
    const protocol = maHasTLS ? "wss://" : "ws://";
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal?.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  wss: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal?.replace("tcp://", "");
    return `wss://${baseVal}`;
  }
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const components = ma.getComponents();
  const head = components.pop();
  if (head == null) {
    throw new Error("Unexpected end of multiaddr");
  }
  const interpreter = interpreters[head.name];
  if (interpreter == null) {
    throw new Error(`No interpreter found for ${head.name}`);
  }
  let uri = interpreter(head, components) ?? "";
  if (opts?.assumeHttp !== false && ASSUME_HTTP_CODES.includes(head.code)) {
    uri = uri.replace(/^.*:\/\//, "");
    if (head.value === "443") {
      uri = `https://${uri}`;
    } else {
      uri = `http://${uri}`;
    }
  }
  if (uri.startsWith("http://") || uri.startsWith("https://") || uri.startsWith("ws://") || uri.startsWith("wss://")) {
    uri = new URL(uri).toString();
    if (uri.endsWith("/")) {
      uri = uri.substring(0, uri.length - 1);
    }
  }
  return uri;
}

// node_modules/@helia/block-brokers/node_modules/multiformats/dist/src/bytes.js
var empty5 = new Uint8Array(0);

// node_modules/@helia/block-brokers/node_modules/multiformats/dist/src/bases/base.js
var Encoder5 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder5 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or5(this, decoder);
  }
};
var ComposedDecoder5 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or5(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or5(left, right) {
  return new ComposedDecoder5({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec5 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder5(name9, prefix, baseEncode);
    this.decoder = new Decoder5(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from8({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec5(name9, prefix, encode39, decode61);
}
function decode21(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode15(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx4(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc46484({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx4(alphabet2);
  return from8({
    prefix,
    name: name9,
    encode(input) {
      return encode15(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode21(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/@helia/block-brokers/node_modules/multiformats/dist/src/bases/base64.js
var base643 = rfc46484({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad3 = rfc46484({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url3 = rfc46484({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad3 = rfc46484({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/trustless-gateway.js
var TrustlessGateway = class {
  url;
  /**
   * The number of times this gateway has been attempted to be used to fetch a
   * block. This includes successful, errored, and aborted attempts. By counting
   * even aborted attempts, slow gateways that are out-raced by others will be
   * considered less reliable.
   */
  #attempts = 0;
  /**
   * The number of times this gateway has errored while attempting to fetch a
   * block. This includes `response.ok === false` and any other errors that
   * throw while attempting to fetch a block. This does not include aborted
   * attempts.
   */
  #errors = 0;
  /**
   * The number of times this gateway has returned an invalid block. A gateway
   * that returns the wrong blocks for a CID should be considered for removal
   * from the list of gateways to fetch blocks from.
   */
  #invalidBlocks = 0;
  /**
   * The number of times this gateway has successfully fetched a block.
   */
  #successes = 0;
  /**
   * A map of pending responses for this gateway. This is used to ensure that
   * only one request per CID is made to a given gateway at a time, and that we
   * don't make multiple in-flight requests for the same CID to the same gateway.
   */
  #pendingResponses = /* @__PURE__ */ new Map();
  log;
  transformRequestInit;
  constructor(url, { logger: logger2, transformRequestInit }) {
    this.url = url instanceof URL ? url : new URL(url);
    this.transformRequestInit = transformRequestInit;
    this.log = logger2.forComponent(`helia:trustless-gateway-block-broker:${this.url.hostname}`);
  }
  /**
   * This function returns a unique string for the multihash.bytes of the CID.
   *
   * Some useful resources for why this is needed can be found using the links below:
   *
   * - https://github.com/ipfs/helia/pull/503#discussion_r1572451331
   * - https://github.com/ipfs/kubo/issues/6815
   * - https://www.notion.so/pl-strflt/Handling-ambiguity-around-CIDs-9d5e14f6516f438980b01ef188efe15d#d9d45cd1ed8b4d349b96285de4aed5ab
   */
  #uniqueBlockId(cid) {
    const multihashBytes = cid.multihash.bytes;
    return base643.encode(multihashBytes);
  }
  /**
   * Fetch a raw block from `this.url` following the specification defined at
   * https://specs.ipfs.tech/http-gateways/trustless-gateway/
   */
  async getRawBlock(cid, signal) {
    const gwUrl = new URL(this.url.toString());
    gwUrl.pathname = `/ipfs/${cid.toString()}`;
    gwUrl.search = "?format=raw";
    if (signal?.aborted === true) {
      throw new Error(`Signal to fetch raw block for CID ${cid} from gateway ${this.url} was aborted prior to fetch`);
    }
    const blockId = this.#uniqueBlockId(cid);
    const innerController = new AbortController();
    const abortInnerSignal = () => {
      innerController.abort();
    };
    signal?.addEventListener("abort", abortInnerSignal);
    try {
      let pendingResponse = this.#pendingResponses.get(blockId);
      if (pendingResponse == null) {
        this.#attempts++;
        const defaultReqInit = {
          signal: innerController.signal,
          headers: {
            Accept: "application/vnd.ipld.raw"
          },
          cache: "force-cache"
        };
        const reqInit = this.transformRequestInit != null ? await this.transformRequestInit(defaultReqInit) : defaultReqInit;
        pendingResponse = fetch(gwUrl.toString(), reqInit).then(async (res) => {
          this.log("GET %s %d", gwUrl, res.status);
          if (!res.ok) {
            this.#errors++;
            throw new Error(`unable to fetch raw block for CID ${cid} from gateway ${this.url}`);
          }
          this.#successes++;
          return new Uint8Array(await res.arrayBuffer());
        });
        this.#pendingResponses.set(blockId, pendingResponse);
      }
      return await pendingResponse;
    } catch (cause) {
      if (signal?.aborted === true) {
        throw new Error(`fetching raw block for CID ${cid} from gateway ${this.url} was aborted`);
      }
      this.#errors++;
      throw new Error(`unable to fetch raw block for CID ${cid}`);
    } finally {
      signal?.removeEventListener("abort", abortInnerSignal);
      this.#pendingResponses.delete(blockId);
    }
  }
  /**
   * Encapsulate the logic for determining whether a gateway is considered
   * reliable, for prioritization. This is based on the number of successful attempts made
   * and the number of errors encountered.
   *
   * Unused gateways have 100% reliability; They will be prioritized over
   * gateways with a 100% success rate to ensure that we attempt all gateways.
   */
  reliability() {
    if (this.#attempts === 0) {
      return 1;
    }
    if (this.#invalidBlocks > 0) {
      return -Infinity;
    }
    return this.#successes / (this.#attempts + this.#errors * 3);
  }
  /**
   * Increment the number of invalid blocks returned by this gateway.
   */
  incrementInvalidBlocks() {
    this.#invalidBlocks++;
  }
  getStats() {
    return {
      attempts: this.#attempts,
      errors: this.#errors,
      invalidBlocks: this.#invalidBlocks,
      successes: this.#successes,
      pendingResponses: this.#pendingResponses.size
    };
  }
};

// node_modules/@libp2p/utils/dist/src/private-ip.js
var import_netmask = __toESM(require_netmask());
var PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ipRange) => new import_netmask.Netmask(ipRange));
function ipv4Check(ipAddr) {
  for (const r of NETMASK_RANGES) {
    if (r.contains(ipAddr)) {
      return true;
    }
  }
  return false;
}
function isIpv4MappedIpv6(ipAddr) {
  return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr);
}
function ipv4MappedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  if (parts.length < 2) {
    return false;
  }
  const octet34 = parts[parts.length - 1].padStart(4, "0");
  const octet12 = parts[parts.length - 2].padStart(4, "0");
  const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`;
  return ipv4Check(ip4);
}
function isIpv4EmbeddedIpv6(ipAddr) {
  return /^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr);
}
function ipv4EmbeddedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  const ip4 = parts[parts.length - 1];
  return ipv4Check(ip4);
}
function ipv6Check(ipAddr) {
  return /^::$/.test(ipAddr) || /^::1$/.test(ipAddr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);
}
function isPrivateIp(ip) {
  if (isIPv4(ip)) {
    return ipv4Check(ip);
  }
  if (isIpv4MappedIpv6(ip)) {
    return ipv4MappedIpv6Check(ip);
  }
  if (isIpv4EmbeddedIpv6(ip)) {
    return ipv4EmbeddedIpv6Check(ip);
  }
  if (isIPv6(ip)) {
    return ipv6Check(ip);
  }
}

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/bytes.js
var empty6 = new Uint8Array(0);
function coerce6(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/vendor/base-x.js
function base5(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src5 = base5;
var _brrp__multiformats_scope_baseX5 = src5;
var base_x_default6 = _brrp__multiformats_scope_baseX5;

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/bases/base.js
var Encoder6 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder6 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or6(this, decoder);
  }
};
var ComposedDecoder6 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or6(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or6(left, right) {
  return new ComposedDecoder6({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec6 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder6(name9, prefix, baseEncode);
    this.decoder = new Decoder6(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from9({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec6(name9, prefix, encode39, decode61);
}
function baseX5({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default6(alphabet2, name9);
  return from9({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce6(decode61(text))
  });
}
function decode22(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode16(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx5(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc46485({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx5(alphabet2);
  return from9({
    prefix,
    name: name9,
    encode(input) {
      return encode16(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode22(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/bases/base58.js
var base58btc5 = baseX5({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr5 = baseX5({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/bases/base64.js
var base644 = rfc46485({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad4 = rfc46485({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url4 = rfc46485({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad4 = rfc46485({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
var toParts = (ma) => {
  return ma.toString().split("/").slice(1);
};
var func = (fn) => {
  return {
    match: (vals) => {
      if (vals.length < 1) {
        return false;
      }
      if (fn(vals[0])) {
        return vals.slice(1);
      }
      return false;
    },
    pattern: "fn"
  };
};
var literal = (str) => {
  return {
    match: (vals) => func((val) => val === str).match(vals),
    pattern: str
  };
};
var string = () => {
  return {
    match: (vals) => func((val) => typeof val === "string").match(vals),
    pattern: "{string}"
  };
};
var number = () => {
  return {
    match: (vals) => func((val) => !isNaN(parseInt(val))).match(vals),
    pattern: "{number}"
  };
};
var peerId = () => {
  return {
    match: (vals) => {
      if (vals.length < 2) {
        return false;
      }
      if (vals[0] !== "p2p" && vals[0] !== "ipfs") {
        return false;
      }
      if (vals[1].startsWith("Q") || vals[1].startsWith("1")) {
        try {
          base58btc5.decode(`z${vals[1]}`);
        } catch (err) {
          return false;
        }
      } else {
        return false;
      }
      return vals.slice(2);
    },
    pattern: "/p2p/{peerid}"
  };
};
var certhash = () => {
  return {
    match: (vals) => {
      if (vals.length < 2) {
        return false;
      }
      if (vals[0] !== "certhash") {
        return false;
      }
      try {
        base64url4.decode(vals[1]);
      } catch {
        return false;
      }
      return vals.slice(2);
    },
    pattern: "/certhash/{certhash}"
  };
};
var optional = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    },
    pattern: `optional(${matcher.pattern})`
  };
};
var or7 = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    },
    pattern: `or(${matchers.map((m) => m.pattern).join(", ")})`
  };
};
var and = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    },
    pattern: `and(${matchers.map((m) => m.pattern).join(", ")})`
  };
};
function fmt(...matchers) {
  function match(ma) {
    let parts = toParts(ma);
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matchers,
    matches,
    exactMatch
  };
}

// node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var _PEER_ID = peerId();
var PEER_ID = fmt(_PEER_ID);
var _DNS4 = and(literal("dns4"), string());
var _DNS6 = and(literal("dns6"), string());
var _DNSADDR = and(literal("dnsaddr"), string());
var _DNS = and(literal("dns"), string());
var DNS4 = fmt(_DNS4, optional(peerId()));
var DNS6 = fmt(_DNS6, optional(peerId()));
var DNSADDR = fmt(_DNSADDR, optional(peerId()));
var DNS2 = fmt(or7(_DNS, _DNSADDR, _DNS4, _DNS6), optional(peerId()));
var _IP4 = and(literal("ip4"), func(isIPv4));
var _IP6 = and(literal("ip6"), func(isIPv6));
var _IP = or7(_IP4, _IP6);
var _IP_OR_DOMAIN = or7(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
var IP_OR_DOMAIN = fmt(or7(_IP, and(or7(_DNS, _DNSADDR, _DNS4, _DNS6), optional(peerId()))));
var IP4 = fmt(_IP4);
var IP6 = fmt(_IP6);
var IP = fmt(_IP);
var _TCP = and(_IP_OR_DOMAIN, literal("tcp"), number());
var _UDP = and(_IP_OR_DOMAIN, literal("udp"), number());
var TCP = fmt(and(_TCP, optional(peerId())));
var UDP = fmt(_UDP);
var _QUIC = and(_UDP, literal("quic"), optional(peerId()));
var _QUICV1 = and(_UDP, literal("quic-v1"), optional(peerId()));
var QUIC_V0_OR_V1 = or7(_QUIC, _QUICV1);
var QUIC = fmt(_QUIC);
var QUICV1 = fmt(_QUICV1);
var _WEB = or7(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUICV1);
var _WebSockets = or7(and(_WEB, literal("ws"), optional(peerId())));
var WebSockets = fmt(_WebSockets);
var _WebSocketsSecure = or7(and(_WEB, literal("wss"), optional(peerId())), and(_WEB, literal("tls"), optional(and(literal("sni"), string())), literal("ws"), optional(peerId())));
var WebSocketsSecure = fmt(_WebSocketsSecure);
var _WebRTCDirect = and(_UDP, literal("webrtc-direct"), optional(certhash()), optional(certhash()), optional(peerId()));
var WebRTCDirect = fmt(_WebRTCDirect);
var _WebTransport = and(_QUICV1, literal("webtransport"), optional(certhash()), optional(certhash()), optional(peerId()));
var WebTransport = fmt(_WebTransport);
var _P2P = or7(_WebSockets, _WebSocketsSecure, and(_TCP, optional(peerId())), and(QUIC_V0_OR_V1, optional(peerId())), and(_IP_OR_DOMAIN, optional(peerId())), _WebRTCDirect, _WebTransport, peerId());
var P2P2 = fmt(_P2P);
var _Circuit = and(_P2P, literal("p2p-circuit"), peerId());
var Circuit = fmt(_Circuit);
var _WebRTC = or7(and(_P2P, literal("p2p-circuit"), literal("webrtc"), optional(peerId())), and(_P2P, literal("webrtc"), optional(peerId())), and(literal("webrtc"), optional(peerId())));
var WebRTC = fmt(_WebRTC);
var _HTTP = or7(and(_IP_OR_DOMAIN, literal("tcp"), number(), literal("http"), optional(peerId())), and(_IP_OR_DOMAIN, literal("http"), optional(peerId())));
var HTTP = fmt(_HTTP);
var _HTTPS = or7(and(_IP_OR_DOMAIN, literal("tcp"), or7(and(literal("443"), literal("http")), and(number(), literal("https")), and(number(), literal("tls"), literal("http"))), optional(peerId())), and(_IP_OR_DOMAIN, literal("tls"), literal("http"), optional(peerId())), and(_IP_OR_DOMAIN, literal("https"), optional(peerId())));
var HTTPS = fmt(_HTTPS);
var _Memory = or7(and(literal("memory"), string(), optional(peerId())));
var Memory = fmt(_Memory);
var _Unix = or7(and(literal("unix"), string(), optional(peerId())));
var Unix = fmt(_Unix);

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/utils.js
function filterNonHTTPMultiaddrs(multiaddrs, allowInsecure, allowLocal) {
  return multiaddrs.filter((ma) => {
    if (HTTPS.matches(ma) || allowInsecure && HTTP.matches(ma)) {
      if (allowLocal) {
        return true;
      }
      if (DNS2.matches(ma)) {
        return true;
      }
      return isPrivateIp(ma.toOptions().host) === false;
    }
    if (!allowInsecure && allowLocal) {
      const { host } = ma.toOptions();
      if (host === "127.0.0.1" || host === "localhost" || host.endsWith(".localhost")) {
        return true;
      }
    }
    return false;
  });
}
async function* findHttpGatewayProviders(cid, routing, logger2, allowInsecure, allowLocal, options2 = {}) {
  for await (const provider of routing.findProviders(cid, options2)) {
    const httpAddresses = filterNonHTTPMultiaddrs(provider.multiaddrs, allowInsecure, allowLocal);
    if (httpAddresses.length === 0) {
      continue;
    }
    const uri = multiaddrToUri(httpAddresses[0]);
    yield new TrustlessGateway(uri, { logger: logger2, transformRequestInit: options2.transformRequestInit });
  }
}

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/session.js
var TrustlessGatewaySession = class extends AbstractSession {
  routing;
  allowInsecure;
  allowLocal;
  transformRequestInit;
  constructor(components, init) {
    super(components, {
      ...init,
      name: "helia:trustless-gateway:session"
    });
    this.routing = components.routing;
    this.allowInsecure = init.allowInsecure ?? DEFAULT_ALLOW_INSECURE;
    this.allowLocal = init.allowLocal ?? DEFAULT_ALLOW_LOCAL;
    this.transformRequestInit = init.transformRequestInit;
  }
  async queryProvider(cid, provider, options2) {
    this.log("fetching BLOCK for %c from %s", cid, provider.url);
    const block = await provider.getRawBlock(cid, options2.signal);
    this.log.trace("got block for %c from %s", cid, provider.url);
    await options2.validateFn?.(block);
    return block;
  }
  async *findNewProviders(cid, options2 = {}) {
    yield* findHttpGatewayProviders(cid, this.routing, this.logger, this.allowInsecure, this.allowLocal, { ...options2, transformRequestInit: this.transformRequestInit });
  }
  toEvictionKey(provider) {
    return provider.url.toString();
  }
  equals(providerA, providerB) {
    return providerA.url.toString() === providerB.url.toString();
  }
  async convertToProvider(provider, options2) {
    if (isPeerId(provider)) {
      return;
    }
    const httpAddresses = filterNonHTTPMultiaddrs(Array.isArray(provider) ? provider : [provider], this.allowInsecure, this.allowLocal);
    if (httpAddresses.length === 0) {
      return;
    }
    const uri = multiaddrToUri(httpAddresses[0]);
    return new TrustlessGateway(uri, {
      logger: this.logger,
      transformRequestInit: this.transformRequestInit
    });
  }
};
function createTrustlessGatewaySession(components, init) {
  return new TrustlessGatewaySession(components, init);
}

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/broker.js
var TrustlessGatewayBlockBroker = class {
  allowInsecure;
  allowLocal;
  transformRequestInit;
  routing;
  log;
  logger;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("helia:trustless-gateway-block-broker");
    this.logger = components.logger;
    this.routing = components.routing;
    this.allowInsecure = init.allowInsecure ?? DEFAULT_ALLOW_INSECURE;
    this.allowLocal = init.allowLocal ?? DEFAULT_ALLOW_LOCAL;
    this.transformRequestInit = init.transformRequestInit;
  }
  async retrieve(cid, options2 = {}) {
    const aggregateErrors = [];
    for await (const gateway of findHttpGatewayProviders(cid, this.routing, this.logger, this.allowInsecure, this.allowLocal, { ...options2, transformRequestInit: this.transformRequestInit })) {
      this.log("getting block for %c from %s", cid, gateway.url);
      try {
        const block = await gateway.getRawBlock(cid, options2.signal);
        this.log.trace("got block for %c from %s", cid, gateway.url);
        try {
          await options2.validateFn?.(block);
        } catch (err) {
          this.log.error("failed to validate block for %c from %s", cid, gateway.url, err);
          continue;
        }
        return block;
      } catch (err) {
        this.log.error("failed to get block for %c from %s", cid, gateway.url, err);
        if (err instanceof Error) {
          aggregateErrors.push(err);
        } else {
          aggregateErrors.push(new Error(`Unable to fetch raw block for CID ${cid} from gateway ${gateway.url}`));
        }
        if (options2.signal?.aborted === true) {
          this.log.trace("request aborted while fetching raw block for CID %c from gateway %s", cid, gateway.url);
          break;
        }
      }
    }
    if (aggregateErrors.length > 0) {
      throw new AggregateError(aggregateErrors, `Unable to fetch raw block for CID ${cid} from any gateway`);
    } else {
      throw new Error(`Unable to fetch raw block for CID ${cid} from any gateway`);
    }
  }
  createSession(options2 = {}) {
    return createTrustlessGatewaySession({
      logger: this.logger,
      routing: this.routing
    }, {
      ...options2,
      allowLocal: this.allowLocal,
      allowInsecure: this.allowInsecure,
      transformRequestInit: this.transformRequestInit
    });
  }
};

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js
var DEFAULT_ALLOW_INSECURE = false;
var DEFAULT_ALLOW_LOCAL = false;
function trustlessGateway(init = {}) {
  return (components) => new TrustlessGatewayBlockBroker(components, init);
}

// node_modules/browser-readablestream-to-it/dist/src/index.js
async function* browserReadableStreamToIt(stream, options2 = {}) {
  const reader = stream.getReader();
  try {
    while (true) {
      const result = await reader.read();
      if (result.done) {
        return;
      }
      yield result.value;
    }
  } finally {
    if (options2.preventCancel !== true) {
      await reader.cancel();
    }
    reader.releaseLock();
  }
}

// node_modules/ipns/dist/src/index.js
var import_timestamp_nano = __toESM(require_timestamp_min());

// node_modules/ipns/dist/src/errors.js
var SignatureVerificationError = class extends Error {
  static name = "SignatureVerificationError";
  constructor(message2 = "Record signature verification failed") {
    super(message2);
    this.name = "SignatureVerificationError";
  }
};
var RecordExpiredError = class extends Error {
  static name = "RecordExpiredError";
  constructor(message2 = "Record has expired") {
    super(message2);
    this.name = "RecordExpiredError";
  }
};
var UnsupportedValidityError = class extends Error {
  static name = "UnsupportedValidityError";
  constructor(message2 = "The validity type is unsupported") {
    super(message2);
    this.name = "UnsupportedValidityError";
  }
};
var RecordTooLargeError = class extends Error {
  static name = "RecordTooLargeError";
  constructor(message2 = "The record is too large") {
    super(message2);
    this.name = "RecordTooLargeError";
  }
};
var InvalidValueError = class extends Error {
  static name = "InvalidValueError";
  constructor(message2 = "Value must be a valid content path starting with /") {
    super(message2);
    this.name = "InvalidValueError";
  }
};
var InvalidRecordDataError = class extends Error {
  static name = "InvalidRecordDataError";
  constructor(message2 = "Invalid record data") {
    super(message2);
    this.name = "InvalidRecordDataError";
  }
};
var InvalidEmbeddedPublicKeyError = class extends Error {
  static name = "InvalidEmbeddedPublicKeyError";
  constructor(message2 = "Invalid embedded public key") {
    super(message2);
    this.name = "InvalidEmbeddedPublicKeyError";
  }
};

// node_modules/ipns/dist/src/pb/ipns.js
var IpnsEntry;
(function(IpnsEntry2) {
  let ValidityType;
  (function(ValidityType2) {
    ValidityType2["EOL"] = "EOL";
  })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let __ValidityTypeValues;
  (function(__ValidityTypeValues2) {
    __ValidityTypeValues2[__ValidityTypeValues2["EOL"] = 0] = "EOL";
  })(__ValidityTypeValues || (__ValidityTypeValues = {}));
  (function(ValidityType2) {
    ValidityType2.codec = () => {
      return enumeration(__ValidityTypeValues);
    };
  })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let _codec;
  IpnsEntry2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.value != null) {
          w.uint32(10);
          w.bytes(obj.value);
        }
        if (obj.signatureV1 != null) {
          w.uint32(18);
          w.bytes(obj.signatureV1);
        }
        if (obj.validityType != null) {
          w.uint32(24);
          IpnsEntry2.ValidityType.codec().encode(obj.validityType, w);
        }
        if (obj.validity != null) {
          w.uint32(34);
          w.bytes(obj.validity);
        }
        if (obj.sequence != null) {
          w.uint32(40);
          w.uint64(obj.sequence);
        }
        if (obj.ttl != null) {
          w.uint32(48);
          w.uint64(obj.ttl);
        }
        if (obj.pubKey != null) {
          w.uint32(58);
          w.bytes(obj.pubKey);
        }
        if (obj.signatureV2 != null) {
          w.uint32(66);
          w.bytes(obj.signatureV2);
        }
        if (obj.data != null) {
          w.uint32(74);
          w.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {};
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.value = reader.bytes();
              break;
            }
            case 2: {
              obj.signatureV1 = reader.bytes();
              break;
            }
            case 3: {
              obj.validityType = IpnsEntry2.ValidityType.codec().decode(reader);
              break;
            }
            case 4: {
              obj.validity = reader.bytes();
              break;
            }
            case 5: {
              obj.sequence = reader.uint64();
              break;
            }
            case 6: {
              obj.ttl = reader.uint64();
              break;
            }
            case 7: {
              obj.pubKey = reader.bytes();
              break;
            }
            case 8: {
              obj.signatureV2 = reader.bytes();
              break;
            }
            case 9: {
              obj.data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  IpnsEntry2.encode = (obj) => {
    return encodeMessage(obj, IpnsEntry2.codec());
  };
  IpnsEntry2.decode = (buf, opts) => {
    return decodeMessage(buf, IpnsEntry2.codec(), opts);
  };
})(IpnsEntry || (IpnsEntry = {}));

// node_modules/ipns/node_modules/multiformats/dist/src/bytes.js
var empty7 = new Uint8Array(0);
function equals9(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce7(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/ipns/node_modules/multiformats/dist/src/vendor/base-x.js
function base6(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src6 = base6;
var _brrp__multiformats_scope_baseX6 = src6;
var base_x_default7 = _brrp__multiformats_scope_baseX6;

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base.js
var Encoder7 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder7 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or8(this, decoder);
  }
};
var ComposedDecoder7 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or8(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or8(left, right) {
  return new ComposedDecoder7({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec7 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder7(name9, prefix, baseEncode);
    this.decoder = new Decoder7(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from10({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec7(name9, prefix, encode39, decode61);
}
function baseX6({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default7(alphabet2, name9);
  return from10({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce7(decode61(text))
  });
}
function decode23(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode17(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx6(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc46486({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx6(alphabet2);
  return from10({
    prefix,
    name: name9,
    encode(input) {
      return encode17(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode23(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base36.js
var base364 = baseX6({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper4 = baseX6({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base32.js
var base324 = rfc46486({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper4 = rfc46486({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad4 = rfc46486({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper4 = rfc46486({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex4 = rfc46486({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper4 = rfc46486({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad4 = rfc46486({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper4 = rfc46486({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z4 = rfc46486({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/ipns/node_modules/multiformats/dist/src/bases/base58.js
var base58btc6 = baseX6({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr6 = baseX6({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/ipns/node_modules/multiformats/dist/src/vendor/varint.js
var encode_15 = encode18;
var MSB5 = 128;
var REST5 = 127;
var MSBALL5 = ~REST5;
var INT5 = Math.pow(2, 31);
function encode18(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT5) {
    out[offset++] = num & 255 | MSB5;
    num /= 128;
  }
  while (num & MSBALL5) {
    out[offset++] = num & 255 | MSB5;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode18.bytes = offset - oldOffset + 1;
  return out;
}
var decode24 = read5;
var MSB$15 = 128;
var REST$15 = 127;
function read5(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read5.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$15) << shift : (b & REST$15) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$15);
  read5.bytes = counter - offset;
  return res;
}
var N15 = Math.pow(2, 7);
var N25 = Math.pow(2, 14);
var N35 = Math.pow(2, 21);
var N45 = Math.pow(2, 28);
var N55 = Math.pow(2, 35);
var N65 = Math.pow(2, 42);
var N75 = Math.pow(2, 49);
var N85 = Math.pow(2, 56);
var N95 = Math.pow(2, 63);
var length5 = function(value7) {
  return value7 < N15 ? 1 : value7 < N25 ? 2 : value7 < N35 ? 3 : value7 < N45 ? 4 : value7 < N55 ? 5 : value7 < N65 ? 6 : value7 < N75 ? 7 : value7 < N85 ? 8 : value7 < N95 ? 9 : 10;
};
var varint5 = {
  encode: encode_15,
  decode: decode24,
  encodingLength: length5
};
var _brrp_varint5 = varint5;
var varint_default5 = _brrp_varint5;

// node_modules/ipns/node_modules/multiformats/dist/src/varint.js
function decode25(data, offset = 0) {
  const code17 = varint_default5.decode(data, offset);
  return [code17, varint_default5.decode.bytes];
}
function encodeTo5(int, target, offset = 0) {
  varint_default5.encode(int, target, offset);
  return target;
}
function encodingLength6(int) {
  return varint_default5.encodingLength(int);
}

// node_modules/ipns/node_modules/multiformats/dist/src/hashes/digest.js
function create4(code17, digest5) {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength6(code17);
  const digestOffset = sizeOffset + encodingLength6(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo5(code17, bytes, 0);
  encodeTo5(size, bytes, sizeOffset);
  bytes.set(digest5, digestOffset);
  return new Digest5(code17, size, digest5, bytes);
}
function decode26(multihash) {
  const bytes = coerce7(multihash);
  const [code17, sizeOffset] = decode25(bytes);
  const [size, digestOffset] = decode25(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest5(code17, size, digest5, bytes);
}
function equals10(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals9(a.bytes, data.bytes);
  }
}
var Digest5 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/ipns/node_modules/multiformats/dist/src/cid.js
function format4(link, base14) {
  const { bytes, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV04(bytes, baseCache4(link), base14 ?? base58btc6.encoder);
    default:
      return toStringV14(bytes, baseCache4(link), base14 ?? base324.encoder);
  }
}
var cache5 = /* @__PURE__ */ new WeakMap();
function baseCache4(cid) {
  const baseCache11 = cache5.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache5.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID4 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code17, multihash, bytes) {
    this.code = code17;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code17, multihash } = this;
        if (code17 !== DAG_PB_CODE4) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE4) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code17, digest: digest5 } = this.multihash;
        const multihash = create4(code17, digest5);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals10(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format4(this, base14);
  }
  toJSON() {
    return { "/": format4(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value7 = input;
    if (value7 instanceof _CID) {
      return value7;
    } else if (value7["/"] != null && value7["/"] === value7.bytes || value7.asCID === value7) {
      const { version: version3, code: code17, multihash, bytes } = value7;
      return new _CID(version3, code17, multihash, bytes ?? encodeCID4(version3, code17, multihash.bytes));
    } else if (value7[cidSymbol4] === true) {
      const { version: version3, multihash, code: code17 } = value7;
      const digest5 = decode26(multihash);
      return _CID.create(version3, code17, digest5);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code17, digest5) {
    if (typeof code17 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code17 !== DAG_PB_CODE4) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE4}) block encoding`);
        } else {
          return new _CID(version3, code17, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID4(version3, code17, digest5.bytes);
        return new _CID(version3, code17, digest5, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE4, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code17, digest5) {
    return _CID.create(1, code17, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce7(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest5 = new Digest5(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest5) : _CID.createV1(specs.codec, digest5);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length16] = decode25(initialBytes.subarray(offset));
      offset += length16;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE4;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes4(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache4(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes4(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc6;
      return [
        base58btc6.prefix,
        decoder.decode(`${base58btc6.prefix}${source}`)
      ];
    }
    case base58btc6.prefix: {
      const decoder = base14 ?? base58btc6;
      return [base58btc6.prefix, decoder.decode(source)];
    }
    case base324.prefix: {
      const decoder = base14 ?? base324;
      return [base324.prefix, decoder.decode(source)];
    }
    case base364.prefix: {
      const decoder = base14 ?? base364;
      return [base364.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV04(bytes, cache12, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc6.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV14(bytes, cache12, base14) {
  const { prefix } = base14;
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE4 = 112;
var SHA_256_CODE4 = 18;
function encodeCID4(version3, code17, multihash) {
  const codeOffset = encodingLength6(version3);
  const hashOffset = codeOffset + encodingLength6(code17);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo5(version3, bytes, 0);
  encodeTo5(code17, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol4 = Symbol.for("@ipld/js-cid/CID");

// node_modules/ipns/dist/src/utils.js
var log = logger("ipns:utils");
var IPNS_PREFIX = fromString("/ipns/");
var IDENTITY_CODEC2 = 0;
var SHA2_256_CODEC = 18;
function extractPublicKeyFromIPNSRecord(record) {
  let pubKey;
  if (record.pubKey != null) {
    try {
      pubKey = publicKeyFromProtobuf(record.pubKey);
    } catch (err) {
      log.error(err);
      throw err;
    }
  }
  if (pubKey != null) {
    return pubKey;
  }
}
function ipnsRecordDataForV2Sig(data) {
  const entryData = fromString("ipns-signature:");
  return concat([entryData, data]);
}
function marshalIPNSRecord(obj) {
  if ("signatureV1" in obj) {
    return IpnsEntry.encode({
      value: fromString(obj.value),
      signatureV1: obj.signatureV1,
      validityType: obj.validityType,
      validity: fromString(obj.validity),
      sequence: obj.sequence,
      ttl: obj.ttl,
      pubKey: obj.pubKey,
      signatureV2: obj.signatureV2,
      data: obj.data
    });
  } else {
    return IpnsEntry.encode({
      pubKey: obj.pubKey,
      signatureV2: obj.signatureV2,
      data: obj.data
    });
  }
}
function unmarshalIPNSRecord(buf) {
  const message2 = IpnsEntry.decode(buf);
  if (message2.sequence != null) {
    message2.sequence = BigInt(message2.sequence);
  }
  if (message2.ttl != null) {
    message2.ttl = BigInt(message2.ttl);
  }
  if (message2.signatureV2 == null || message2.data == null) {
    throw new SignatureVerificationError("Missing data or signatureV2");
  }
  const data = parseCborData(message2.data);
  const value7 = normalizeByteValue(data.Value);
  const validity = toString(data.Validity);
  if (message2.value != null && message2.signatureV1 != null) {
    validateCborDataMatchesPbData(message2);
    return {
      value: value7,
      validityType: IpnsEntry.ValidityType.EOL,
      validity,
      sequence: data.Sequence,
      ttl: data.TTL,
      pubKey: message2.pubKey,
      signatureV1: message2.signatureV1,
      signatureV2: message2.signatureV2,
      data: message2.data
    };
  } else if (message2.signatureV2 != null) {
    return {
      value: value7,
      validityType: IpnsEntry.ValidityType.EOL,
      validity,
      sequence: data.Sequence,
      ttl: data.TTL,
      pubKey: message2.pubKey,
      signatureV2: message2.signatureV2,
      data: message2.data
    };
  } else {
    throw new Error("invalid record: does not include signatureV1 or signatureV2");
  }
}
function multihashToIPNSRoutingKey(digest5) {
  return concat([
    IPNS_PREFIX,
    digest5.bytes
  ]);
}
function multihashFromIPNSRoutingKey(key) {
  const digest5 = decode26(key.slice(IPNS_PREFIX.length));
  if (!isCodec(digest5, IDENTITY_CODEC2) && !isCodec(digest5, SHA2_256_CODEC)) {
    throw new InvalidMultihashError("Multihash in IPNS key was not identity or sha2-256");
  }
  return digest5;
}
function parseCborData(buf) {
  const data = decode2(buf);
  if (data.ValidityType === 0) {
    data.ValidityType = IpnsEntry.ValidityType.EOL;
  } else {
    throw new UnsupportedValidityError("The validity type is unsupported");
  }
  if (Number.isInteger(data.Sequence)) {
    data.Sequence = BigInt(data.Sequence);
  }
  if (Number.isInteger(data.TTL)) {
    data.TTL = BigInt(data.TTL);
  }
  return data;
}
function normalizeByteValue(value7) {
  const string2 = toString(value7).trim();
  if (string2.startsWith("/")) {
    return string2;
  }
  try {
    return `/ipfs/${CID4.decode(value7).toV1().toString()}`;
  } catch {
  }
  try {
    return `/ipfs/${CID4.parse(string2).toV1().toString()}`;
  } catch {
  }
  throw new InvalidValueError("Value must be a valid content path starting with /");
}
function validateCborDataMatchesPbData(entry) {
  if (entry.data == null) {
    throw new InvalidRecordDataError("Record data is missing");
  }
  const data = parseCborData(entry.data);
  if (!equals(data.Value, entry.value ?? new Uint8Array(0))) {
    throw new SignatureVerificationError('Field "value" did not match between protobuf and CBOR');
  }
  if (!equals(data.Validity, entry.validity ?? new Uint8Array(0))) {
    throw new SignatureVerificationError('Field "validity" did not match between protobuf and CBOR');
  }
  if (data.ValidityType !== entry.validityType) {
    throw new SignatureVerificationError('Field "validityType" did not match between protobuf and CBOR');
  }
  if (data.Sequence !== entry.sequence) {
    throw new SignatureVerificationError('Field "sequence" did not match between protobuf and CBOR');
  }
  if (data.TTL !== entry.ttl) {
    throw new SignatureVerificationError('Field "ttl" did not match between protobuf and CBOR');
  }
}
function isCodec(digest5, codec) {
  return digest5.code === codec;
}

// node_modules/ipns/dist/src/index.js
var log2 = logger("ipns");
var DEFAULT_TTL_NS = 5 * 60 * 1e9;
var namespace = "/ipns/";
var namespaceLength = namespace.length;

// node_modules/ipns/dist/src/validator.js
var import_timestamp_nano2 = __toESM(require_timestamp_min());
var log3 = logger("ipns:validator");
var MAX_RECORD_SIZE = 1024 * 10;
var validate = async (publicKey2, marshalledRecord) => {
  const record = unmarshalIPNSRecord(marshalledRecord);
  let isValid;
  try {
    const dataForSignature = ipnsRecordDataForV2Sig(record.data);
    isValid = await publicKey2.verify(dataForSignature, record.signatureV2);
  } catch (err) {
    isValid = false;
  }
  if (!isValid) {
    log3.error("record signature verification failed");
    throw new SignatureVerificationError("Record signature verification failed");
  }
  if (record.validityType === IpnsEntry.ValidityType.EOL) {
    if (import_timestamp_nano2.default.fromString(record.validity).toDate().getTime() < Date.now()) {
      log3.error("record has expired");
      throw new RecordExpiredError("record has expired");
    }
  } else if (record.validityType != null) {
    log3.error("the validity type is unsupported");
    throw new UnsupportedValidityError("The validity type is unsupported");
  }
  log3("ipns record for %s is valid", record.value);
};
async function ipnsValidator(routingKey, marshalledRecord) {
  if (marshalledRecord.byteLength > MAX_RECORD_SIZE) {
    throw new RecordTooLargeError("The record is too large");
  }
  const routingMultihash = multihashFromIPNSRoutingKey(routingKey);
  let routingPubKey;
  if (isCodec(routingMultihash, 0)) {
    routingPubKey = publicKeyFromMultihash(routingMultihash);
  }
  const receivedRecord = unmarshalIPNSRecord(marshalledRecord);
  const recordPubKey = extractPublicKeyFromIPNSRecord(receivedRecord) ?? routingPubKey;
  if (recordPubKey == null) {
    throw new InvalidEmbeddedPublicKeyError("Could not extract public key from IPNS record or routing key");
  }
  const expectedRoutingKey = multihashToIPNSRoutingKey(recordPubKey.toMultihash());
  if (!equals(expectedRoutingKey, routingKey)) {
    throw new InvalidEmbeddedPublicKeyError("Embedded public key did not match routing key");
  }
  await validate(recordPubKey, marshalledRecord);
}

// node_modules/it-ndjson/dist/src/errors.js
var InvalidMessageLengthError2 = class extends Error {
  name = "InvalidMessageLengthError";
  code = "ERR_INVALID_MESSAGE_LENGTH";
};

// node_modules/it-ndjson/dist/src/parse.js
async function* parse(source, opts = {}) {
  const matcher = /\r?\n/;
  const decoder = new TextDecoder("utf8");
  let buffer = "";
  for await (let chunk of source) {
    if (typeof chunk === "string") {
      chunk = new TextEncoder().encode(chunk);
    }
    if (isUint8ArrayList(chunk)) {
      chunk = chunk.subarray();
    }
    buffer += decoder.decode(chunk, { stream: true });
    if (buffer.length > (opts?.maxMessageLength ?? buffer.length)) {
      throw new InvalidMessageLengthError2("Incoming message too long");
    }
    const parts = buffer.split(matcher);
    buffer = parts.pop() ?? "";
    for (let i = 0; i < parts.length; i++) {
      yield JSON.parse(parts[i]);
    }
  }
  buffer += decoder.decode();
  if (buffer !== "") {
    yield JSON.parse(buffer);
  }
}

// node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/errors.js
var InvalidRequestError = class extends Error {
  static name = "InvalidRequestError";
  constructor(message2 = "Invalid request") {
    super(message2);
    this.name = "InvalidRequestError";
  }
};
var BadResponseError = class extends Error {
  static name = "BadResponseError";
  constructor(message2 = "Bad response") {
    super(message2);
    this.name = "BadResponseError";
  }
};

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bytes.js
var empty8 = new Uint8Array(0);
function equals11(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce8(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/vendor/base-x.js
function base7(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src7 = base7;
var _brrp__multiformats_scope_baseX7 = src7;
var base_x_default8 = _brrp__multiformats_scope_baseX7;

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base.js
var Encoder8 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder8 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or9(this, decoder);
  }
};
var ComposedDecoder8 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or9(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or9(left, right) {
  return new ComposedDecoder8({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec8 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder8(name9, prefix, baseEncode);
    this.decoder = new Decoder8(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from11({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec8(name9, prefix, encode39, decode61);
}
function baseX7({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default8(alphabet2, name9);
  return from11({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce8(decode61(text))
  });
}
function decode27(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode19(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx7(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc46487({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx7(alphabet2);
  return from11({
    prefix,
    name: name9,
    encode(input) {
      return encode19(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode27(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base32.js
var base325 = rfc46487({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper5 = rfc46487({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad5 = rfc46487({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper5 = rfc46487({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex5 = rfc46487({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper5 = rfc46487({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad5 = rfc46487({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper5 = rfc46487({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z5 = rfc46487({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base36.js
var base365 = baseX7({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper5 = baseX7({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/bases/base58.js
var base58btc7 = baseX7({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr7 = baseX7({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/vendor/varint.js
var encode_16 = encode20;
var MSB6 = 128;
var REST6 = 127;
var MSBALL6 = ~REST6;
var INT6 = Math.pow(2, 31);
function encode20(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT6) {
    out[offset++] = num & 255 | MSB6;
    num /= 128;
  }
  while (num & MSBALL6) {
    out[offset++] = num & 255 | MSB6;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode20.bytes = offset - oldOffset + 1;
  return out;
}
var decode28 = read6;
var MSB$16 = 128;
var REST$16 = 127;
function read6(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read6.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$16) << shift : (b & REST$16) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$16);
  read6.bytes = counter - offset;
  return res;
}
var N16 = Math.pow(2, 7);
var N26 = Math.pow(2, 14);
var N36 = Math.pow(2, 21);
var N46 = Math.pow(2, 28);
var N56 = Math.pow(2, 35);
var N66 = Math.pow(2, 42);
var N76 = Math.pow(2, 49);
var N86 = Math.pow(2, 56);
var N96 = Math.pow(2, 63);
var length6 = function(value7) {
  return value7 < N16 ? 1 : value7 < N26 ? 2 : value7 < N36 ? 3 : value7 < N46 ? 4 : value7 < N56 ? 5 : value7 < N66 ? 6 : value7 < N76 ? 7 : value7 < N86 ? 8 : value7 < N96 ? 9 : 10;
};
var varint6 = {
  encode: encode_16,
  decode: decode28,
  encodingLength: length6
};
var _brrp_varint6 = varint6;
var varint_default6 = _brrp_varint6;

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/varint.js
function decode29(data, offset = 0) {
  const code17 = varint_default6.decode(data, offset);
  return [code17, varint_default6.decode.bytes];
}
function encodeTo6(int, target, offset = 0) {
  varint_default6.encode(int, target, offset);
  return target;
}
function encodingLength7(int) {
  return varint_default6.encodingLength(int);
}

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/hashes/digest.js
function create5(code17, digest5) {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength7(code17);
  const digestOffset = sizeOffset + encodingLength7(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo6(code17, bytes, 0);
  encodeTo6(size, bytes, sizeOffset);
  bytes.set(digest5, digestOffset);
  return new Digest6(code17, size, digest5, bytes);
}
function decode30(multihash) {
  const bytes = coerce8(multihash);
  const [code17, sizeOffset] = decode29(bytes);
  const [size, digestOffset] = decode29(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest6(code17, size, digest5, bytes);
}
function equals12(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals11(a.bytes, data.bytes);
  }
}
var Digest6 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/@helia/delegated-routing-v1-http-api-client/node_modules/multiformats/dist/src/cid.js
function format5(link, base14) {
  const { bytes, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV05(bytes, baseCache5(link), base14 ?? base58btc7.encoder);
    default:
      return toStringV15(bytes, baseCache5(link), base14 ?? base325.encoder);
  }
}
var cache6 = /* @__PURE__ */ new WeakMap();
function baseCache5(cid) {
  const baseCache11 = cache6.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache6.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID5 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code17, multihash, bytes) {
    this.code = code17;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code17, multihash } = this;
        if (code17 !== DAG_PB_CODE5) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE5) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code17, digest: digest5 } = this.multihash;
        const multihash = create5(code17, digest5);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals12(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format5(this, base14);
  }
  toJSON() {
    return { "/": format5(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value7 = input;
    if (value7 instanceof _CID) {
      return value7;
    } else if (value7["/"] != null && value7["/"] === value7.bytes || value7.asCID === value7) {
      const { version: version3, code: code17, multihash, bytes } = value7;
      return new _CID(version3, code17, multihash, bytes ?? encodeCID5(version3, code17, multihash.bytes));
    } else if (value7[cidSymbol5] === true) {
      const { version: version3, multihash, code: code17 } = value7;
      const digest5 = decode30(multihash);
      return _CID.create(version3, code17, digest5);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code17, digest5) {
    if (typeof code17 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code17 !== DAG_PB_CODE5) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE5}) block encoding`);
        } else {
          return new _CID(version3, code17, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID5(version3, code17, digest5.bytes);
        return new _CID(version3, code17, digest5, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE5, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code17, digest5) {
    return _CID.create(1, code17, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce8(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest5 = new Digest6(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest5) : _CID.createV1(specs.codec, digest5);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length16] = decode29(initialBytes.subarray(offset));
      offset += length16;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE5;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes5(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache5(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes5(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc7;
      return [
        base58btc7.prefix,
        decoder.decode(`${base58btc7.prefix}${source}`)
      ];
    }
    case base58btc7.prefix: {
      const decoder = base14 ?? base58btc7;
      return [base58btc7.prefix, decoder.decode(source)];
    }
    case base325.prefix: {
      const decoder = base14 ?? base325;
      return [base325.prefix, decoder.decode(source)];
    }
    case base365.prefix: {
      const decoder = base14 ?? base365;
      return [base365.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV05(bytes, cache12, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc7.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV15(bytes, cache12, base14) {
  const { prefix } = base14;
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE5 = 112;
var SHA_256_CODE5 = 18;
function encodeCID5(version3, code17, multihash) {
  const codeOffset = encodingLength7(version3);
  const hashOffset = codeOffset + encodingLength7(code17);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo6(version3, bytes, 0);
  encodeTo6(code17, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol5 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/routings.js
var IPNS_PREFIX2 = fromString("/ipns/");
function isIPNSKey(key) {
  return equals(key.subarray(0, IPNS_PREFIX2.byteLength), IPNS_PREFIX2);
}
var DelegatedRoutingV1HttpApiClientContentRouting = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async *findProviders(cid, options2 = {}) {
    yield* src_default5(this.client.getProviders(cid, options2), (record) => {
      return {
        id: record.ID,
        multiaddrs: record.Addrs ?? []
      };
    });
  }
  async provide() {
  }
  async cancelReprovide() {
  }
  async put(key, value7, options2) {
    if (!isIPNSKey(key)) {
      return;
    }
    const digest5 = multihashFromIPNSRoutingKey(key);
    const cid = CID5.createV1(114, digest5);
    const record = unmarshalIPNSRecord(value7);
    await this.client.putIPNS(cid, record, options2);
  }
  async get(key, options2) {
    if (!isIPNSKey(key)) {
      throw new NotFoundError("Not found");
    }
    const digest5 = multihashFromIPNSRoutingKey(key);
    const cid = CID5.createV1(114, digest5);
    try {
      const record = await this.client.getIPNS(cid, options2);
      return marshalIPNSRecord(record);
    } catch (err) {
      if (err.name === "BadResponseError") {
        throw new NotFoundError("Not found");
      }
      throw err;
    }
  }
};
var DelegatedRoutingV1HttpApiClientPeerRouting = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async findPeer(peerId2, options2 = {}) {
    const peer = await src_default7(this.client.getPeers(peerId2, options2));
    if (peer != null) {
      return {
        id: peer.ID,
        multiaddrs: peer.Addrs ?? []
      };
    }
    throw new NotFoundError("Not found");
  }
  async *getClosestPeers(key, options2 = {}) {
  }
};

// node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/client.js
var log4 = logger("delegated-routing-v1-http-api-client");
var defaultValues = {
  concurrentRequests: 4,
  timeout: 3e4,
  cacheTTL: 5 * 60 * 1e3,
  // 5 minutes default as per https://specs.ipfs.tech/routing/http-routing-v1/#response-headers
  cacheName: "delegated-routing-v1-cache"
};
var DefaultDelegatedRoutingV1HttpApiClient = class {
  started;
  httpQueue;
  shutDownController;
  clientUrl;
  timeout;
  contentRouting;
  peerRouting;
  filterAddrs;
  filterProtocols;
  inFlightRequests;
  cacheName;
  cache;
  cacheTTL;
  /**
   * Create a new DelegatedContentRouting instance
   */
  constructor(url, init = {}) {
    this.started = false;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    this.httpQueue = new PQueue({
      concurrency: init.concurrentRequests ?? defaultValues.concurrentRequests
    });
    this.inFlightRequests = /* @__PURE__ */ new Map();
    this.clientUrl = url instanceof URL ? url : new URL(url);
    this.timeout = init.timeout ?? defaultValues.timeout;
    this.filterAddrs = init.filterAddrs;
    this.filterProtocols = init.filterProtocols;
    this.contentRouting = new DelegatedRoutingV1HttpApiClientContentRouting(this);
    this.peerRouting = new DelegatedRoutingV1HttpApiClientPeerRouting(this);
    this.cacheName = init.cacheName ?? defaultValues.cacheName;
    this.cacheTTL = init.cacheTTL ?? defaultValues.cacheTTL;
  }
  get [contentRoutingSymbol]() {
    return this.contentRouting;
  }
  get [peerRoutingSymbol]() {
    return this.peerRouting;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    this.started = true;
    if (this.cacheTTL > 0) {
      this.cache = await globalThis.caches?.open(this.cacheName);
      if (this.cache != null) {
        log4("cache enabled with ttl %d", this.cacheTTL);
      }
    }
  }
  async stop() {
    this.httpQueue.clear();
    this.shutDownController.abort();
    await globalThis.caches?.delete(this.cacheName);
    this.started = false;
  }
  async *getProviders(cid, options2 = {}) {
    log4("getProviders starts: %c", cid);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners(Infinity, timeoutSignal, signal);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    try {
      await onStart.promise;
      const url = new URL(`${this.clientUrl}routing/v1/providers/${cid.toString()}`);
      this.#addFilterParams(url, options2.filterAddrs, options2.filterProtocols);
      const getOptions = { headers: { Accept: "application/x-ndjson" }, signal };
      const res = await this.#makeRequest(url.toString(), getOptions);
      if (res == null) {
        throw new BadResponseError("No response received");
      }
      if (!res.ok) {
        if (res.status === 404) {
          throw new NotFoundError("No matching records found");
        }
        if (res.status === 422) {
          throw new InvalidRequestError("Request does not conform to schema or semantic constraints");
        }
        throw new BadResponseError(`Unexpected status code: ${res.status}`);
      }
      if (res.body == null) {
        throw new BadResponseError("Routing response had no body");
      }
      const contentType = res.headers.get("Content-Type");
      if (contentType == null) {
        throw new BadResponseError("No Content-Type header received");
      }
      if (contentType?.startsWith("application/json")) {
        const body = await res.json();
        for (const provider of body.Providers) {
          const record = this.#conformToPeerSchema(provider);
          if (record != null) {
            yield record;
          }
        }
      } else if (contentType.includes("application/x-ndjson")) {
        for await (const provider of parse(browserReadableStreamToIt(res.body))) {
          const record = this.#conformToPeerSchema(provider);
          if (record != null) {
            yield record;
          }
        }
      } else {
        throw new BadResponseError(`Unsupported Content-Type: ${contentType}`);
      }
    } finally {
      signal.clear();
      onFinish.resolve();
      log4("getProviders finished: %c", cid);
    }
  }
  async *getPeers(peerId2, options2 = {}) {
    log4("getPeers starts: %c", peerId2);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners(Infinity, timeoutSignal, signal);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    try {
      await onStart.promise;
      const url = new URL(`${this.clientUrl}routing/v1/peers/${peerId2.toCID().toString()}`);
      this.#addFilterParams(url, options2.filterAddrs, options2.filterProtocols);
      const getOptions = { headers: { Accept: "application/x-ndjson" }, signal };
      const res = await this.#makeRequest(url.toString(), getOptions);
      if (res.status === 404) {
        throw new NotFoundError("No matching records found");
      }
      if (res.status === 422) {
        throw new InvalidRequestError("Request does not conform to schema or semantic constraints");
      }
      if (res.body == null) {
        throw new BadResponseError("Routing response had no body");
      }
      const contentType = res.headers.get("Content-Type");
      if (contentType === "application/json") {
        const body = await res.json();
        for (const peer of body.Peers) {
          const record = this.#conformToPeerSchema(peer);
          if (record != null) {
            yield record;
          }
        }
      } else {
        for await (const peer of parse(browserReadableStreamToIt(res.body))) {
          const record = this.#conformToPeerSchema(peer);
          if (record != null) {
            yield record;
          }
        }
      }
    } catch (err) {
      log4.error("getPeers errored:", err);
    } finally {
      signal.clear();
      onFinish.resolve();
      log4("getPeers finished: %c", peerId2);
    }
  }
  async getIPNS(libp2pKey, options2 = {}) {
    log4("getIPNS starts: %s", libp2pKey);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners(Infinity, timeoutSignal, signal);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    const resource = `${this.clientUrl}routing/v1/ipns/${libp2pKey}`;
    try {
      await onStart.promise;
      const getOptions = { headers: { Accept: "application/vnd.ipfs.ipns-record" }, signal };
      const res = await this.#makeRequest(resource, getOptions);
      log4("getIPNS GET %s %d", resource, res.status);
      if (res.status === 404) {
        throw new NotFoundError("No matching records found");
      }
      if (res.status === 422) {
        throw new InvalidRequestError("Request does not conform to schema or semantic constraints");
      }
      if (res.body == null) {
        throw new BadResponseError("GET ipns response had no body");
      }
      const buf = await res.arrayBuffer();
      const body = new Uint8Array(buf, 0, buf.byteLength);
      if (options2.validate !== false) {
        await ipnsValidator(multihashToIPNSRoutingKey(libp2pKey.multihash), body);
      }
      return unmarshalIPNSRecord(body);
    } catch (err) {
      log4.error("getIPNS GET %s error:", resource, err);
      throw err;
    } finally {
      signal.clear();
      onFinish.resolve();
      log4("getIPNS finished: %s", libp2pKey);
    }
  }
  async putIPNS(libp2pKey, record, options2 = {}) {
    log4("putIPNS starts: %c", libp2pKey);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners(Infinity, timeoutSignal, signal);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    const resource = `${this.clientUrl}routing/v1/ipns/${libp2pKey}`;
    try {
      await onStart.promise;
      const body = marshalIPNSRecord(record);
      const getOptions = { method: "PUT", headers: { "Content-Type": "application/vnd.ipfs.ipns-record" }, body, signal };
      const res = await this.#makeRequest(resource, getOptions);
      log4("putIPNS PUT %s %d", resource, res.status);
      if (res.status !== 200) {
        throw new BadResponseError("PUT ipns response had status other than 200");
      }
    } catch (err) {
      log4.error("putIPNS PUT %s error:", resource, err.stack);
      throw err;
    } finally {
      signal.clear();
      onFinish.resolve();
      log4("putIPNS finished: %c", libp2pKey);
    }
  }
  #conformToPeerSchema(record) {
    try {
      const protocols2 = [];
      const multiaddrs = record.Addrs?.map(multiaddr) ?? [];
      if (record.Protocols != null) {
        protocols2.push(...record.Protocols);
      }
      if (record.Protocol != null) {
        protocols2.push(record.Protocol);
        delete record.Protocol;
      }
      return {
        ...record,
        Schema: "peer",
        ID: peerIdFromString(record.ID),
        Addrs: multiaddrs,
        Protocols: protocols2
      };
    } catch (err) {
      log4.error("could not conform record to peer schema", err);
    }
  }
  #addFilterParams(url, filterAddrs, filterProtocols) {
    if (filterAddrs != null || this.filterAddrs != null) {
      const adressFilter = filterAddrs?.join(",") ?? this.filterAddrs?.join(",") ?? "";
      if (adressFilter !== "") {
        url.searchParams.set("filter-addrs", adressFilter);
      }
    }
    if (filterProtocols != null || this.filterProtocols != null) {
      const protocolFilter = filterProtocols?.join(",") ?? this.filterProtocols?.join(",") ?? "";
      if (protocolFilter !== "") {
        url.searchParams.set("filter-protocols", protocolFilter);
      }
    }
  }
  /**
   * makeRequest has two features:
   * - Ensures only one concurrent request is made for the same URL
   * - Caches GET requests if the Cache API is available
   */
  async #makeRequest(url, options2) {
    const requestMethod = options2.method ?? "GET";
    const key = `${requestMethod}-${url}`;
    if (requestMethod === "GET") {
      const cachedResponse = await this.cache?.match(url);
      if (cachedResponse != null) {
        const expires = parseInt(cachedResponse.headers.get("x-cache-expires") ?? "0", 10);
        if (expires > Date.now()) {
          log4("returning cached response for %s", key);
          return cachedResponse;
        } else {
          await this.cache?.delete(url);
        }
      }
    }
    const existingRequest = this.inFlightRequests.get(key);
    if (existingRequest != null) {
      const response2 = await existingRequest;
      log4("deduplicating outgoing request for %s", key);
      return response2.clone();
    }
    const requestPromise = fetch(url, options2).then(async (response2) => {
      if (this.cache != null && response2.ok && requestMethod === "GET") {
        const expires = Date.now() + this.cacheTTL;
        const headers = new Headers(response2.headers);
        headers.set("x-cache-expires", expires.toString());
        const cachedResponse = new Response(response2.clone().body, {
          status: response2.status,
          statusText: response2.statusText,
          headers
        });
        await this.cache.put(url, cachedResponse);
      }
      return response2;
    }).finally(() => {
      this.inFlightRequests.delete(key);
    });
    this.inFlightRequests.set(key, requestPromise);
    const response = await requestPromise;
    return response;
  }
};

// node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/index.js
function createDelegatedRoutingV1HttpApiClient(url, init = {}) {
  return new DefaultDelegatedRoutingV1HttpApiClient(new URL(url), init);
}

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bytes.js
var empty9 = new Uint8Array(0);
function equals13(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce9(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@helia/routers/node_modules/multiformats/dist/src/vendor/base-x.js
function base8(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src8 = base8;
var _brrp__multiformats_scope_baseX8 = src8;
var base_x_default9 = _brrp__multiformats_scope_baseX8;

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base.js
var Encoder9 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder9 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or10(this, decoder);
  }
};
var ComposedDecoder9 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or10(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or10(left, right) {
  return new ComposedDecoder9({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec9 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder9(name9, prefix, baseEncode);
    this.decoder = new Decoder9(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from12({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec9(name9, prefix, encode39, decode61);
}
function baseX8({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default9(alphabet2, name9);
  return from12({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce9(decode61(text))
  });
}
function decode31(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode21(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx8(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc46488({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx8(alphabet2);
  return from12({
    prefix,
    name: name9,
    encode(input) {
      return encode21(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode31(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base32.js
var base326 = rfc46488({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper6 = rfc46488({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad6 = rfc46488({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper6 = rfc46488({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex6 = rfc46488({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper6 = rfc46488({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad6 = rfc46488({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper6 = rfc46488({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z6 = rfc46488({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base36.js
var base366 = baseX8({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper6 = baseX8({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/bases/base58.js
var base58btc8 = baseX8({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr8 = baseX8({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@helia/routers/node_modules/multiformats/dist/src/vendor/varint.js
var encode_17 = encode22;
var MSB7 = 128;
var REST7 = 127;
var MSBALL7 = ~REST7;
var INT7 = Math.pow(2, 31);
function encode22(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT7) {
    out[offset++] = num & 255 | MSB7;
    num /= 128;
  }
  while (num & MSBALL7) {
    out[offset++] = num & 255 | MSB7;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode22.bytes = offset - oldOffset + 1;
  return out;
}
var decode32 = read7;
var MSB$17 = 128;
var REST$17 = 127;
function read7(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read7.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$17) << shift : (b & REST$17) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$17);
  read7.bytes = counter - offset;
  return res;
}
var N17 = Math.pow(2, 7);
var N27 = Math.pow(2, 14);
var N37 = Math.pow(2, 21);
var N47 = Math.pow(2, 28);
var N57 = Math.pow(2, 35);
var N67 = Math.pow(2, 42);
var N77 = Math.pow(2, 49);
var N87 = Math.pow(2, 56);
var N97 = Math.pow(2, 63);
var length7 = function(value7) {
  return value7 < N17 ? 1 : value7 < N27 ? 2 : value7 < N37 ? 3 : value7 < N47 ? 4 : value7 < N57 ? 5 : value7 < N67 ? 6 : value7 < N77 ? 7 : value7 < N87 ? 8 : value7 < N97 ? 9 : 10;
};
var varint7 = {
  encode: encode_17,
  decode: decode32,
  encodingLength: length7
};
var _brrp_varint7 = varint7;
var varint_default7 = _brrp_varint7;

// node_modules/@helia/routers/node_modules/multiformats/dist/src/varint.js
function decode33(data, offset = 0) {
  const code17 = varint_default7.decode(data, offset);
  return [code17, varint_default7.decode.bytes];
}
function encodeTo7(int, target, offset = 0) {
  varint_default7.encode(int, target, offset);
  return target;
}
function encodingLength8(int) {
  return varint_default7.encodingLength(int);
}

// node_modules/@helia/routers/node_modules/multiformats/dist/src/hashes/digest.js
function create6(code17, digest5) {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength8(code17);
  const digestOffset = sizeOffset + encodingLength8(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo7(code17, bytes, 0);
  encodeTo7(size, bytes, sizeOffset);
  bytes.set(digest5, digestOffset);
  return new Digest7(code17, size, digest5, bytes);
}
function decode34(multihash) {
  const bytes = coerce9(multihash);
  const [code17, sizeOffset] = decode33(bytes);
  const [size, digestOffset] = decode33(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest7(code17, size, digest5, bytes);
}
function equals14(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals13(a.bytes, data.bytes);
  }
}
var Digest7 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/@helia/routers/node_modules/multiformats/dist/src/cid.js
function format6(link, base14) {
  const { bytes, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV06(bytes, baseCache6(link), base14 ?? base58btc8.encoder);
    default:
      return toStringV16(bytes, baseCache6(link), base14 ?? base326.encoder);
  }
}
var cache7 = /* @__PURE__ */ new WeakMap();
function baseCache6(cid) {
  const baseCache11 = cache7.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache7.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID6 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code17, multihash, bytes) {
    this.code = code17;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code17, multihash } = this;
        if (code17 !== DAG_PB_CODE6) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE6) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code17, digest: digest5 } = this.multihash;
        const multihash = create6(code17, digest5);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals14(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format6(this, base14);
  }
  toJSON() {
    return { "/": format6(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value7 = input;
    if (value7 instanceof _CID) {
      return value7;
    } else if (value7["/"] != null && value7["/"] === value7.bytes || value7.asCID === value7) {
      const { version: version3, code: code17, multihash, bytes } = value7;
      return new _CID(version3, code17, multihash, bytes ?? encodeCID6(version3, code17, multihash.bytes));
    } else if (value7[cidSymbol6] === true) {
      const { version: version3, multihash, code: code17 } = value7;
      const digest5 = decode34(multihash);
      return _CID.create(version3, code17, digest5);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code17, digest5) {
    if (typeof code17 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code17 !== DAG_PB_CODE6) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE6}) block encoding`);
        } else {
          return new _CID(version3, code17, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID6(version3, code17, digest5.bytes);
        return new _CID(version3, code17, digest5, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE6, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code17, digest5) {
    return _CID.create(1, code17, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce9(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest5 = new Digest7(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest5) : _CID.createV1(specs.codec, digest5);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length16] = decode33(initialBytes.subarray(offset));
      offset += length16;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE6;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes6(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache6(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes6(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc8;
      return [
        base58btc8.prefix,
        decoder.decode(`${base58btc8.prefix}${source}`)
      ];
    }
    case base58btc8.prefix: {
      const decoder = base14 ?? base58btc8;
      return [base58btc8.prefix, decoder.decode(source)];
    }
    case base326.prefix: {
      const decoder = base14 ?? base326;
      return [base326.prefix, decoder.decode(source)];
    }
    case base366.prefix: {
      const decoder = base14 ?? base366;
      return [base366.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV06(bytes, cache12, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc8.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV16(bytes, cache12, base14) {
  const { prefix } = base14;
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE6 = 112;
var SHA_256_CODE6 = 18;
function encodeCID6(version3, code17, multihash) {
  const codeOffset = encodingLength8(version3);
  const hashOffset = codeOffset + encodingLength8(code17);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo7(version3, bytes, 0);
  encodeTo7(code17, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol6 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@helia/routers/dist/src/utils/delegated-http-routing-defaults.browser.js
function delegatedHTTPRoutingDefaults() {
  return {
    filterProtocols: ["unknown", "transport-bitswap", "transport-ipfs-gateway-http"],
    filterAddrs: ["https", "webtransport", "webrtc", "webrtc-direct", "wss", "tls"]
  };
}

// node_modules/@helia/routers/dist/src/delegated-http-routing.js
var IPNS_PREFIX3 = fromString("/ipns/");

// node_modules/ip-regex/index.js
var word = "[a-fA-F\\d:]";
var boundry = (options2) => options2 && options2.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6segment = "[a-fA-F\\d]{1,4}";
var v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
var v4exact = new RegExp(`^${v4}$`);
var v6exact = new RegExp(`^${v6}$`);
var ipRegex = (options2) => options2 && options2.exact ? v46Exact : new RegExp(`(?:${boundry(options2)}${v4}${boundry(options2)})|(?:${boundry(options2)}${v6}${boundry(options2)})`, "g");
ipRegex.v4 = (options2) => options2 && options2.exact ? v4exact : new RegExp(`${boundry(options2)}${v4}${boundry(options2)}`, "g");
ipRegex.v6 = (options2) => options2 && options2.exact ? v6exact : new RegExp(`${boundry(options2)}${v6}${boundry(options2)}`, "g");
var ip_regex_default = ipRegex;

// node_modules/function-timeout/browser.js
function functionTimeout(function_) {
  const wrappedFunction = (...arguments_) => function_(...arguments_);
  Object.defineProperty(wrappedFunction, "name", {
    value: `functionTimeout(${function_.name || "<anonymous>"})`,
    configurable: true
  });
  return wrappedFunction;
}
function isTimeoutError() {
  return false;
}

// node_modules/is-regexp/index.js
var { toString: toString2 } = Object.prototype;
function isRegexp(value7) {
  return toString2.call(value7) === "[object RegExp]";
}

// node_modules/clone-regexp/index.js
var flagMap = {
  global: "g",
  ignoreCase: "i",
  multiline: "m",
  dotAll: "s",
  sticky: "y",
  unicode: "u"
};
function clonedRegexp(regexp, options2 = {}) {
  if (!isRegexp(regexp)) {
    throw new TypeError("Expected a RegExp instance");
  }
  const flags = Object.keys(flagMap).map((flag) => (typeof options2[flag] === "boolean" ? options2[flag] : regexp[flag]) ? flagMap[flag] : "").join("");
  const clonedRegexp2 = new RegExp(options2.source || regexp.source, flags);
  clonedRegexp2.lastIndex = typeof options2.lastIndex === "number" ? options2.lastIndex : regexp.lastIndex;
  return clonedRegexp2;
}

// node_modules/super-regex/index.js
function isMatch(regex, string2, { timeout } = {}) {
  try {
    return functionTimeout(() => clonedRegexp(regex).test(string2), { timeout })();
  } catch (error) {
    if (isTimeoutError(error)) {
      return false;
    }
    throw error;
  }
}

// node_modules/is-ip/index.js
var maxIPv4Length = 15;
var maxIPv6Length = 45;
var options = {
  timeout: 400
};
function isIPv62(string2) {
  if (string2.length > maxIPv6Length) {
    return false;
  }
  return isMatch(ip_regex_default.v6({ exact: true }), string2, options);
}
function isIPv42(string2) {
  if (string2.length > maxIPv4Length) {
    return false;
  }
  return isMatch(ip_regex_default.v4({ exact: true }), string2, options);
}

// node_modules/@multiformats/uri-to-multiaddr/dist/src/index.js
var portFor = {
  http: "80",
  https: "443",
  ws: "80",
  wss: "443"
};
var BROWSER_SCHEMES = ["http", "https", "ws", "wss"];
function uriToMultiaddr(uriStr, opts) {
  opts = opts ?? {};
  const defaultDnsType = opts.defaultDnsType ?? "dns";
  const { scheme, hostname, port, path } = parseUri(uriStr);
  const parts = [
    tupleForHostname(hostname, defaultDnsType),
    tupleForPort(port, scheme),
    tupleForScheme(scheme)
  ];
  if (path != null) {
    parts.push(tupleForPath(path));
  }
  const multiaddrStr = "/" + parts.filter((x) => Boolean(x)).reduce((a, b) => a.concat(b), []).join("/");
  return multiaddr(multiaddrStr);
}
function parseUri(uriStr) {
  const [scheme] = uriStr.split(":");
  if (!BROWSER_SCHEMES.includes(scheme)) {
    uriStr = "http" + uriStr.substring(scheme.length);
  }
  let { protocol, hostname, port, pathname, search } = new URL(uriStr);
  if (port == null || port === "") {
    const protocolPort = portForProtocol(scheme);
    if (protocolPort != null) {
      port = protocolPort;
    }
    if (protocolPort == null && protocol === "http:") {
      port = "80";
    }
  }
  let path;
  if (pathname != null && pathname !== "" && pathname !== "/") {
    if (pathname.startsWith("/")) {
      pathname = pathname.substring(1);
    }
    path = pathname;
  }
  if (search != null && search !== "") {
    path = path ?? "";
    path += search;
  }
  return { scheme, hostname, port, path };
}
function tupleForHostname(hostname, defaultDnsType) {
  if (hostname == null || hostname === "") {
    return void 0;
  }
  if (isIPv42(hostname)) {
    return ["ip4", hostname];
  }
  if (isIPv62(hostname)) {
    return ["ip6", hostname];
  }
  if (hostname[0] === "[") {
    const trimmed = hostname.substring(1, hostname.length - 1);
    if (isIPv62(trimmed)) {
      return ["ip6", trimmed];
    }
  }
  return [defaultDnsType, hostname];
}
function tupleForPort(port, scheme) {
  if (port == null || port === "") {
    return void 0;
  }
  if (scheme === "udp") {
    return ["udp", port];
  }
  return ["tcp", port];
}
function tupleForScheme(scheme) {
  if (scheme.match(/^tcp$|^udp$/) != null) {
    return void 0;
  }
  if (scheme === "https") {
    return ["/tls/http"];
  }
  if (scheme === "wss") {
    return ["/tls/ws"];
  }
  return [scheme];
}
function tupleForPath(path) {
  if (path == null || path === "") {
    return void 0;
  }
  return ["http-path", encodeURIComponent(path)];
}
function portForProtocol(protocol) {
  if (protocol == null || protocol === "" || portFor[protocol] == null) {
    return void 0;
  }
  return portFor[protocol];
}

// node_modules/@helia/routers/node_modules/multiformats/dist/src/hashes/identity.js
var code8 = 0;
var name5 = "identity";
var encode23 = coerce9;
function digest3(input) {
  return create6(code8, encode23(input));
}
var identity3 = { code: code8, name: name5, encode: encode23, digest: digest3 };

// node_modules/@helia/routers/dist/src/http-gateway-routing.js
var DEFAULT_TRUSTLESS_GATEWAYS = [
  // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs.github.io/public-gateway-checker/
  "https://trustless-gateway.link",
  // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs.github.io/public-gateway-checker/
  "https://4everland.io"
];
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE3 = 2336;
function toPeerInfo(url) {
  url = url.toString();
  return {
    id: peerIdFromCID(CID6.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE3, identity3.digest(fromString(url)))),
    multiaddrs: [
      uriToMultiaddr(url)
    ]
  };
}
var HTTPGatewayRouter = class {
  gateways;
  shuffle;
  constructor(init = {}) {
    this.gateways = (init.gateways ?? DEFAULT_TRUSTLESS_GATEWAYS).map((url) => toPeerInfo(url));
    this.shuffle = init.shuffle ?? true;
  }
  async *findProviders(cid, options2) {
    yield* (this.shuffle ? this.gateways.toSorted(() => Math.random() > 0.5 ? 1 : -1) : this.gateways).map((info) => ({
      ...info,
      protocols: ["transport-ipfs-gateway-http"]
    }));
  }
};
function httpGatewayRouting(init = {}) {
  return new HTTPGatewayRouter(init);
}

// node_modules/@helia/routers/dist/src/libp2p-routing.js
var Libp2pRouter = class {
  libp2p;
  constructor(libp2p) {
    this.libp2p = libp2p;
  }
  async provide(cid, options2) {
    await this.libp2p.contentRouting.provide(cid, options2);
  }
  async cancelReprovide(key, options2) {
    await this.libp2p.contentRouting.cancelReprovide(key, options2);
  }
  async *findProviders(cid, options2) {
    yield* this.libp2p.contentRouting.findProviders(cid, options2);
  }
  async put(key, value7, options2) {
    await this.libp2p.contentRouting.put(key, value7, options2);
  }
  async get(key, options2) {
    return this.libp2p.contentRouting.get(key, options2);
  }
  async findPeer(peerId2, options2) {
    return this.libp2p.peerRouting.findPeer(peerId2, options2);
  }
  async *getClosestPeers(key, options2) {
    yield* this.libp2p.peerRouting.getClosestPeers(key, options2);
  }
};
function libp2pRouting(libp2p) {
  return new Libp2pRouter(libp2p);
}

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bytes.js
var empty10 = new Uint8Array(0);
function coerce10(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/vendor/base-x.js
function base9(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src9 = base9;
var _brrp__multiformats_scope_baseX9 = src9;
var base_x_default10 = _brrp__multiformats_scope_baseX9;

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base.js
var Encoder10 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder10 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or11(this, decoder);
  }
};
var ComposedDecoder10 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or11(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or11(left, right) {
  return new ComposedDecoder10({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec10 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder10(name9, prefix, baseEncode);
    this.decoder = new Decoder10(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from13({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec10(name9, prefix, encode39, decode61);
}
function baseX9({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default10(alphabet2, name9);
  return from13({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce10(decode61(text))
  });
}
function decode35(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode24(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx9(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc46489({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx9(alphabet2);
  return from13({
    prefix,
    name: name9,
    encode(input) {
      return encode24(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode35(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base58.js
var base58btc9 = baseX9({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr9 = baseX9({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/vendor/varint.js
var encode_18 = encode25;
var MSB8 = 128;
var REST8 = 127;
var MSBALL8 = ~REST8;
var INT8 = Math.pow(2, 31);
function encode25(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT8) {
    out[offset++] = num & 255 | MSB8;
    num /= 128;
  }
  while (num & MSBALL8) {
    out[offset++] = num & 255 | MSB8;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode25.bytes = offset - oldOffset + 1;
  return out;
}
var decode36 = read8;
var MSB$18 = 128;
var REST$18 = 127;
function read8(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read8.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$18) << shift : (b & REST$18) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$18);
  read8.bytes = counter - offset;
  return res;
}
var N18 = Math.pow(2, 7);
var N28 = Math.pow(2, 14);
var N38 = Math.pow(2, 21);
var N48 = Math.pow(2, 28);
var N58 = Math.pow(2, 35);
var N68 = Math.pow(2, 42);
var N78 = Math.pow(2, 49);
var N88 = Math.pow(2, 56);
var N98 = Math.pow(2, 63);
var length8 = function(value7) {
  return value7 < N18 ? 1 : value7 < N28 ? 2 : value7 < N38 ? 3 : value7 < N48 ? 4 : value7 < N58 ? 5 : value7 < N68 ? 6 : value7 < N78 ? 7 : value7 < N88 ? 8 : value7 < N98 ? 9 : 10;
};
var varint8 = {
  encode: encode_18,
  decode: decode36,
  encodingLength: length8
};
var _brrp_varint8 = varint8;
var varint_default8 = _brrp_varint8;

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/varint.js
function encodeTo8(int, target, offset = 0) {
  varint_default8.encode(int, target, offset);
  return target;
}
function encodingLength9(int) {
  return varint_default8.encodingLength(int);
}

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/hashes/digest.js
function create7(code17, digest5) {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength9(code17);
  const digestOffset = sizeOffset + encodingLength9(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo8(code17, bytes, 0);
  encodeTo8(size, bytes, sizeOffset);
  bytes.set(digest5, digestOffset);
  return new Digest8(code17, size, digest5, bytes);
}
var Digest8 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/hashes/hasher.js
function from14({ name: name9, code: code17, encode: encode39 }) {
  return new Hasher4(name9, code17, encode39);
}
var Hasher4 = class {
  name;
  code;
  encode;
  constructor(name9, code17, encode39) {
    this.name = name9;
    this.code = code17;
    this.encode = encode39;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create7(this.code, result) : result.then((digest5) => create7(this.code, digest5));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha4(name9) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name9, data));
}
var sha2565 = from14({
  name: "sha2-256",
  code: 18,
  encode: sha4("SHA-256")
});
var sha5125 = from14({
  name: "sha2-512",
  code: 19,
  encode: sha4("SHA-512")
});

// node_modules/@libp2p/keychain/dist/src/keychain.js
var import_sanitize_filename = __toESM(require_sanitize_filename(), 1);

// node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js
var aes_gcm_browser_exports = {};
__export(aes_gcm_browser_exports, {
  create: () => create8,
  derivedEmptyPasswordKey: () => derivedEmptyPasswordKey
});
var derivedEmptyPasswordKey = {
  alg: "A128GCM",
  ext: true,
  /* spell-checker:disable-next-line */
  k: "scm9jmO_4BJAgdwWGVulLg",
  key_ops: ["encrypt", "decrypt"],
  kty: "oct"
};
function create8(opts) {
  const algorithm = opts?.algorithm ?? "AES-GCM";
  let keyLength = opts?.keyLength ?? 16;
  const nonceLength = opts?.nonceLength ?? 12;
  const digest5 = opts?.digest ?? "SHA-256";
  const saltLength = opts?.saltLength ?? 16;
  const iterations = opts?.iterations ?? 32767;
  const crypto2 = webcrypto_default.get();
  keyLength *= 8;
  async function encrypt(data, password) {
    const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
    const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest5 } };
        const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      } catch {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest5 } };
      const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
    }
    const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
  }
  async function decrypt(data, password) {
    const salt = data.subarray(0, saltLength);
    const nonce = data.subarray(saltLength, saltLength + nonceLength);
    const ciphertext = data.subarray(saltLength + nonceLength);
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest5 } };
        const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      } catch {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["decrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest5 } };
      const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
    }
    const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
    return new Uint8Array(plaintext);
  }
  const cipher = {
    encrypt,
    decrypt
  };
  return cipher;
}

// node_modules/asn1js/build/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  Any: () => Any,
  BaseBlock: () => BaseBlock,
  BaseStringBlock: () => BaseStringBlock,
  BitString: () => BitString,
  BmpString: () => BmpString,
  Boolean: () => Boolean2,
  CharacterString: () => CharacterString,
  Choice: () => Choice,
  Constructed: () => Constructed,
  DATE: () => DATE,
  DateTime: () => DateTime,
  Duration: () => Duration,
  EndOfContent: () => EndOfContent,
  Enumerated: () => Enumerated,
  GeneralString: () => GeneralString,
  GeneralizedTime: () => GeneralizedTime,
  GraphicString: () => GraphicString,
  HexBlock: () => HexBlock,
  IA5String: () => IA5String,
  Integer: () => Integer,
  Null: () => Null,
  NumericString: () => NumericString,
  ObjectIdentifier: () => ObjectIdentifier,
  OctetString: () => OctetString,
  Primitive: () => Primitive,
  PrintableString: () => PrintableString,
  RawData: () => RawData,
  RelativeObjectIdentifier: () => RelativeObjectIdentifier,
  Repeated: () => Repeated,
  Sequence: () => Sequence,
  Set: () => Set2,
  TIME: () => TIME,
  TeletexString: () => TeletexString,
  TimeOfDay: () => TimeOfDay,
  UTCTime: () => UTCTime,
  UniversalString: () => UniversalString,
  Utf8String: () => Utf8String,
  ValueBlock: () => ValueBlock,
  VideotexString: () => VideotexString,
  ViewWriter: () => ViewWriter,
  VisibleString: () => VisibleString,
  compareSchema: () => compareSchema,
  fromBER: () => fromBER,
  verifySchema: () => verifySchema
});

// node_modules/pvtsutils/build/index.es.js
var ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
var BufferSourceConverter = class _BufferSourceConverter {
  static isArrayBuffer(data) {
    return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
  }
  static toArrayBuffer(data) {
    if (this.isArrayBuffer(data)) {
      return data;
    }
    if (data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
  }
  static toUint8Array(data) {
    return this.toView(data, Uint8Array);
  }
  static toView(data, type) {
    if (data.constructor === type) {
      return data;
    }
    if (this.isArrayBuffer(data)) {
      return new type(data);
    }
    if (this.isArrayBufferView(data)) {
      return new type(data.buffer, data.byteOffset, data.byteLength);
    }
    throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
  }
  static isBufferSource(data) {
    return this.isArrayBufferView(data) || this.isArrayBuffer(data);
  }
  static isArrayBufferView(data) {
    return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
  }
  static isEqual(a, b) {
    const aView = _BufferSourceConverter.toUint8Array(a);
    const bView = _BufferSourceConverter.toUint8Array(b);
    if (aView.length !== bView.byteLength) {
      return false;
    }
    for (let i = 0; i < aView.length; i++) {
      if (aView[i] !== bView[i]) {
        return false;
      }
    }
    return true;
  }
  static concat(...args) {
    let buffers;
    if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
      buffers = args[0];
    } else if (Array.isArray(args[0]) && args[1] instanceof Function) {
      buffers = args[0];
    } else {
      if (args[args.length - 1] instanceof Function) {
        buffers = args.slice(0, args.length - 1);
      } else {
        buffers = args;
      }
    }
    let size = 0;
    for (const buffer of buffers) {
      size += buffer.byteLength;
    }
    const res = new Uint8Array(size);
    let offset = 0;
    for (const buffer of buffers) {
      const view = this.toUint8Array(buffer);
      res.set(view, offset);
      offset += view.length;
    }
    if (args[args.length - 1] instanceof Function) {
      return this.toView(res, args[args.length - 1]);
    }
    return res.buffer;
  }
};
var STRING_TYPE = "string";
var HEX_REGEX = /^[0-9a-f\s]+$/i;
var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
var BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
var Utf8Converter = class {
  static fromString(text) {
    const s = unescape(encodeURIComponent(text));
    const uintArray = new Uint8Array(s.length);
    for (let i = 0; i < s.length; i++) {
      uintArray[i] = s.charCodeAt(i);
    }
    return uintArray.buffer;
  }
  static toString(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let encodedString = "";
    for (let i = 0; i < buf.length; i++) {
      encodedString += String.fromCharCode(buf[i]);
    }
    const decodedString = decodeURIComponent(escape(encodedString));
    return decodedString;
  }
};
var Utf16Converter = class {
  static toString(buffer, littleEndian = false) {
    const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
    const dataView = new DataView(arrayBuffer);
    let res = "";
    for (let i = 0; i < arrayBuffer.byteLength; i += 2) {
      const code17 = dataView.getUint16(i, littleEndian);
      res += String.fromCharCode(code17);
    }
    return res;
  }
  static fromString(text, littleEndian = false) {
    const res = new ArrayBuffer(text.length * 2);
    const dataView = new DataView(res);
    for (let i = 0; i < text.length; i++) {
      dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);
    }
    return res;
  }
};
var Convert = class _Convert {
  static isHex(data) {
    return typeof data === STRING_TYPE && HEX_REGEX.test(data);
  }
  static isBase64(data) {
    return typeof data === STRING_TYPE && BASE64_REGEX.test(data);
  }
  static isBase64Url(data) {
    return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);
  }
  static ToString(buffer, enc = "utf8") {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.ToUtf8String(buf);
      case "binary":
        return this.ToBinary(buf);
      case "hex":
        return this.ToHex(buf);
      case "base64":
        return this.ToBase64(buf);
      case "base64url":
        return this.ToBase64Url(buf);
      case "utf16le":
        return Utf16Converter.toString(buf, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buf);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static FromString(str, enc = "utf8") {
    if (!str) {
      return new ArrayBuffer(0);
    }
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.FromUtf8String(str);
      case "binary":
        return this.FromBinary(str);
      case "hex":
        return this.FromHex(str);
      case "base64":
        return this.FromBase64(str);
      case "base64url":
        return this.FromBase64Url(str);
      case "utf16le":
        return Utf16Converter.fromString(str, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(str);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static ToBase64(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    if (typeof btoa !== "undefined") {
      const binary = this.ToString(buf, "binary");
      return btoa(binary);
    } else {
      return Buffer.from(buf).toString("base64");
    }
  }
  static FromBase64(base647) {
    const formatted = this.formatString(base647);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!_Convert.isBase64(formatted)) {
      throw new TypeError("Argument 'base64Text' is not Base64 encoded");
    }
    if (typeof atob !== "undefined") {
      return this.FromBinary(atob(formatted));
    } else {
      return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
    }
  }
  static FromBase64Url(base64url7) {
    const formatted = this.formatString(base64url7);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!_Convert.isBase64Url(formatted)) {
      throw new TypeError("Argument 'base64url' is not Base64Url encoded");
    }
    return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
  }
  static ToBase64Url(data) {
    return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  }
  static FromUtf8String(text, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.FromBinary(text);
      case "utf8":
        return Utf8Converter.fromString(text);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(text);
      case "utf16le":
      case "usc2":
        return Utf16Converter.fromString(text, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static ToUtf8String(buffer, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.ToBinary(buffer);
      case "utf8":
        return Utf8Converter.toString(buffer);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buffer);
      case "utf16le":
      case "usc2":
        return Utf16Converter.toString(buffer, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static FromBinary(text) {
    const stringLength = text.length;
    const resultView = new Uint8Array(stringLength);
    for (let i = 0; i < stringLength; i++) {
      resultView[i] = text.charCodeAt(i);
    }
    return resultView.buffer;
  }
  static ToBinary(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let res = "";
    for (let i = 0; i < buf.length; i++) {
      res += String.fromCharCode(buf[i]);
    }
    return res;
  }
  static ToHex(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let result = "";
    const len = buf.length;
    for (let i = 0; i < len; i++) {
      const byte = buf[i];
      if (byte < 16) {
        result += "0";
      }
      result += byte.toString(16);
    }
    return result;
  }
  static FromHex(hexString) {
    let formatted = this.formatString(hexString);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!_Convert.isHex(formatted)) {
      throw new TypeError("Argument 'hexString' is not HEX encoded");
    }
    if (formatted.length % 2) {
      formatted = `0${formatted}`;
    }
    const res = new Uint8Array(formatted.length / 2);
    for (let i = 0; i < formatted.length; i = i + 2) {
      const c = formatted.slice(i, i + 2);
      res[i / 2] = parseInt(c, 16);
    }
    return res.buffer;
  }
  static ToUtf16String(buffer, littleEndian = false) {
    return Utf16Converter.toString(buffer, littleEndian);
  }
  static FromUtf16String(text, littleEndian = false) {
    return Utf16Converter.fromString(text, littleEndian);
  }
  static Base64Padding(base647) {
    const padCount = 4 - base647.length % 4;
    if (padCount < 4) {
      for (let i = 0; i < padCount; i++) {
        base647 += "=";
      }
    }
    return base647;
  }
  static formatString(data) {
    return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
  }
};
Convert.DEFAULT_UTF8_ENCODING = "utf8";
function combine(...buf) {
  const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);
  const res = new Uint8Array(totalByteLength);
  let currentPos = 0;
  buf.map((item) => new Uint8Array(item)).forEach((arr) => {
    for (const item2 of arr) {
      res[currentPos++] = item2;
    }
  });
  return res.buffer;
}
function isEqual(bytes1, bytes2) {
  if (!(bytes1 && bytes2)) {
    return false;
  }
  if (bytes1.byteLength !== bytes2.byteLength) {
    return false;
  }
  const b1 = new Uint8Array(bytes1);
  const b2 = new Uint8Array(bytes2);
  for (let i = 0; i < bytes1.byteLength; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/pvutils/build/utils.es.js
function utilFromBase(inputBuffer, inputBase) {
  let result = 0;
  if (inputBuffer.length === 1) {
    return inputBuffer[0];
  }
  for (let i = inputBuffer.length - 1; i >= 0; i--) {
    result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
  }
  return result;
}
function utilToBase(value7, base14, reserved = -1) {
  const internalReserved = reserved;
  let internalValue = value7;
  let result = 0;
  let biggest = Math.pow(2, base14);
  for (let i = 1; i < 8; i++) {
    if (value7 < biggest) {
      let retBuf;
      if (internalReserved < 0) {
        retBuf = new ArrayBuffer(i);
        result = i;
      } else {
        if (internalReserved < i) {
          return new ArrayBuffer(0);
        }
        retBuf = new ArrayBuffer(internalReserved);
        result = internalReserved;
      }
      const retView = new Uint8Array(retBuf);
      for (let j = i - 1; j >= 0; j--) {
        const basis = Math.pow(2, j * base14);
        retView[result - j - 1] = Math.floor(internalValue / basis);
        internalValue -= retView[result - j - 1] * basis;
      }
      return retBuf;
    }
    biggest *= Math.pow(2, base14);
  }
  return new ArrayBuffer(0);
}
function utilConcatView(...views) {
  let outputLength = 0;
  let prevLength = 0;
  for (const view of views) {
    outputLength += view.length;
  }
  const retBuf = new ArrayBuffer(outputLength);
  const retView = new Uint8Array(retBuf);
  for (const view of views) {
    retView.set(view, prevLength);
    prevLength += view.length;
  }
  return retView;
}
function utilDecodeTC() {
  const buf = new Uint8Array(this.valueHex);
  if (this.valueHex.byteLength >= 2) {
    const condition1 = buf[0] === 255 && buf[1] & 128;
    const condition2 = buf[0] === 0 && (buf[1] & 128) === 0;
    if (condition1 || condition2) {
      this.warnings.push("Needlessly long format");
    }
  }
  const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const bigIntView = new Uint8Array(bigIntBuffer);
  for (let i = 0; i < this.valueHex.byteLength; i++) {
    bigIntView[i] = 0;
  }
  bigIntView[0] = buf[0] & 128;
  const bigInt = utilFromBase(bigIntView, 8);
  const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const smallIntView = new Uint8Array(smallIntBuffer);
  for (let j = 0; j < this.valueHex.byteLength; j++) {
    smallIntView[j] = buf[j];
  }
  smallIntView[0] &= 127;
  const smallInt = utilFromBase(smallIntView, 8);
  return smallInt - bigInt;
}
function utilEncodeTC(value7) {
  const modValue = value7 < 0 ? value7 * -1 : value7;
  let bigInt = 128;
  for (let i = 1; i < 8; i++) {
    if (modValue <= bigInt) {
      if (value7 < 0) {
        const smallInt = bigInt - modValue;
        const retBuf2 = utilToBase(smallInt, 8, i);
        const retView2 = new Uint8Array(retBuf2);
        retView2[0] |= 128;
        return retBuf2;
      }
      let retBuf = utilToBase(modValue, 8, i);
      let retView = new Uint8Array(retBuf);
      if (retView[0] & 128) {
        const tempBuf = retBuf.slice(0);
        const tempView = new Uint8Array(tempBuf);
        retBuf = new ArrayBuffer(retBuf.byteLength + 1);
        retView = new Uint8Array(retBuf);
        for (let k = 0; k < tempBuf.byteLength; k++) {
          retView[k + 1] = tempView[k];
        }
        retView[0] = 0;
      }
      return retBuf;
    }
    bigInt *= Math.pow(2, 8);
  }
  return new ArrayBuffer(0);
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
  if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
    return false;
  }
  const view1 = new Uint8Array(inputBuffer1);
  const view2 = new Uint8Array(inputBuffer2);
  for (let i = 0; i < view1.length; i++) {
    if (view1[i] !== view2[i]) {
      return false;
    }
  }
  return true;
}
function padNumber(inputNumber, fullLength) {
  const str = inputNumber.toString(10);
  if (fullLength < str.length) {
    return "";
  }
  const dif = fullLength - str.length;
  const padding = new Array(dif);
  for (let i = 0; i < dif; i++) {
    padding[i] = "0";
  }
  const paddingString = padding.join("");
  return paddingString.concat(str);
}
var log22 = Math.log(2);

// node_modules/asn1js/build/index.es.js
function assertBigInt() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat2(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0; i < buffers.length; i++) {
    const buffer = buffers[i];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0; i < buffers.length; i++) {
    const buffer = buffers[i];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}
var ViewWriter = class {
  constructor() {
    this.items = [];
  }
  write(buf) {
    this.items.push(buf);
  }
  final() {
    return concat2(this.items);
  }
};
var powers2 = [new Uint8Array([1])];
var digitsString = "0123456789";
var NAME = "name";
var VALUE_HEX_VIEW = "valueHexView";
var IS_HEX_ONLY = "isHexOnly";
var ID_BLOCK = "idBlock";
var TAG_CLASS = "tagClass";
var TAG_NUMBER = "tagNumber";
var IS_CONSTRUCTED = "isConstructed";
var FROM_BER = "fromBER";
var TO_BER = "toBER";
var LOCAL = "local";
var EMPTY_STRING = "";
var EMPTY_BUFFER = new ArrayBuffer(0);
var EMPTY_VIEW = new Uint8Array(0);
var END_OF_CONTENT_NAME = "EndOfContent";
var OCTET_STRING_NAME = "OCTET STRING";
var BIT_STRING_NAME = "BIT STRING";
function HexBlock(BaseClass) {
  var _a3;
  return _a3 = class Some extends BaseClass {
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value7) {
      this.valueHexView = new Uint8Array(value7);
    }
    constructor(...args) {
      var _b;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== void 0 ? _b : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a3.NAME = "hexBlock", _a3;
}
var LocalBaseBlock = class {
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value7) {
    this.valueBeforeDecodeView = new Uint8Array(value7);
  }
  constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
};
LocalBaseBlock.NAME = "baseBlock";
var ValueBlock = class extends LocalBaseBlock {
  fromBER(_inputBuffer, _inputOffset, _inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(_sizeOnly, _writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
};
ValueBlock.NAME = "valueBlock";
var LocalIdentificationBlock = class extends HexBlock(LocalBaseBlock) {
  constructor({ idBlock = {} } = {}) {
    var _a3, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a3 = idBlock.isHexOnly) !== null && _a3 !== void 0 ? _a3 : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number2 = this.tagNumber;
        number2 &= 31;
        firstOctet |= number2;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0; i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0; i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0; i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i = 0; i < count; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
};
LocalIdentificationBlock.NAME = "identificationBlock";
var LocalLengthBlock = class extends LocalBaseBlock {
  constructor({ lenBlock = {} } = {}) {
    var _a3, _b, _c;
    super();
    this.isIndefiniteForm = (_a3 = lenBlock.isIndefiniteForm) !== null && _a3 !== void 0 ? _a3 : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0; i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
};
LocalLengthBlock.NAME = "lengthBlock";
var typeStore = {};
var BaseBlock = class extends LocalBaseBlock {
  constructor({ name: name9 = EMPTY_STRING, optional: optional8 = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
    super(parameters);
    this.name = name9;
    this.optional = optional8;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock(parameters);
    this.lenBlock = new LocalLengthBlock(parameters);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter();
    if (!writer) {
      prepareIndefiniteForm(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    const name9 = this.constructor.NAME;
    const value7 = Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
    return `${name9} : ${value7}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
};
BaseBlock.NAME = "BaseBlock";
function prepareIndefiniteForm(baseBlock) {
  var _a3;
  if (baseBlock instanceof typeStore.Constructed) {
    for (const value7 of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm(value7)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!((_a3 = baseBlock.lenBlock) === null || _a3 === void 0 ? void 0 : _a3.isIndefiniteForm);
}
var BaseStringBlock = class extends BaseBlock {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value7) {
    this.valueBlock.value = value7;
  }
  constructor({ value: value7 = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
    super(parameters, stringValueBlockType);
    if (value7) {
      this.fromString(value7);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
};
BaseStringBlock.NAME = "BaseStringBlock";
var LocalPrimitiveValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ isHexOnly = true, ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = isHexOnly;
  }
};
LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
var _a$w;
var Primitive = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalPrimitiveValueBlock);
    this.idBlock.isConstructed = false;
  }
};
_a$w = Primitive;
(() => {
  typeStore.Primitive = _a$w;
})();
Primitive.NAME = "PRIMITIVE";
function localChangeType(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType();
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock({}, ValueBlock);
  const baseBlock = new LocalBaseBlock();
  if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore.Boolean;
          break;
        case 2:
          newASN1Type = typeStore.Integer;
          break;
        case 3:
          newASN1Type = typeStore.BitString;
          break;
        case 4:
          newASN1Type = typeStore.OctetString;
          break;
        case 5:
          newASN1Type = typeStore.Null;
          break;
        case 6:
          newASN1Type = typeStore.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore.Sequence;
          break;
        case 17:
          newASN1Type = typeStore.Set;
          break;
        case 18:
          newASN1Type = typeStore.NumericString;
          break;
        case 19:
          newASN1Type = typeStore.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore.IA5String;
          break;
        case 23:
          newASN1Type = typeStore.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore.BmpString;
          break;
        case 31:
          newASN1Type = typeStore.DATE;
          break;
        case 32:
          newASN1Type = typeStore.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore.DateTime;
          break;
        case 34:
          newASN1Type = typeStore.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
    }
  }
  returnObject = localChangeType(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock({}, ValueBlock);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen(indefiniteLength, length16) {
  if (indefiniteLength) {
    return 1;
  }
  return length16;
}
var LocalConstructedValueBlock = class extends ValueBlock {
  constructor({ value: value7 = [], isIndefiniteForm = false, ...parameters } = {}) {
    super(parameters);
    this.value = value7;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter();
    for (let i = 0; i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value7 of this.value) {
      object.value.push(value7.toJSON());
    }
    return object;
  }
};
LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
var _a$v;
var Constructed = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalConstructedValueBlock);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value7 of this.valueBlock.value) {
      values.push(value7.toString("ascii").split("\n").map((o) => `  ${o}`).join("\n"));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join("\n")}` : `${blockName} :`;
  }
};
_a$v = Constructed;
(() => {
  typeStore.Constructed = _a$v;
})();
Constructed.NAME = "CONSTRUCTED";
var LocalEndOfContentValueBlock = class extends ValueBlock {
  fromBER(inputBuffer, inputOffset, _inputLength) {
    return inputOffset;
  }
  toBER(_sizeOnly) {
    return EMPTY_BUFFER;
  }
};
LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
var _a$u;
var EndOfContent = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalEndOfContentValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
};
_a$u = EndOfContent;
(() => {
  typeStore.EndOfContent = _a$u;
})();
EndOfContent.NAME = END_OF_CONTENT_NAME;
var _a$t;
var Null = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, ValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
};
_a$t = Null;
(() => {
  typeStore.Null = _a$t;
})();
Null.NAME = "NULL";
var LocalBooleanValueBlock = class extends HexBlock(ValueBlock) {
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value7) {
    this.valueHexView[0] = value7 ? 255 : 0;
  }
  constructor({ value: value7, ...parameters } = {}) {
    super(parameters);
    if (parameters.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value7) {
      this.value = value7;
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
};
LocalBooleanValueBlock.NAME = "BooleanValueBlock";
var _a$s;
var Boolean2 = class extends BaseBlock {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value7) {
    this.valueBlock.value = value7;
  }
  constructor(parameters = {}) {
    super(parameters, LocalBooleanValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
};
_a$s = Boolean2;
(() => {
  typeStore.Boolean = _a$s;
})();
Boolean2.NAME = "BOOLEAN";
var LocalOctetStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
  constructor({ isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0; i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
};
LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
var _a$r;
var OctetString = class extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalOctetStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf.byteLength) {
          const asn = localFromBER(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch {
      }
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    }
    const name9 = this.constructor.NAME;
    const value7 = Convert.ToHex(this.valueBlock.valueHexView);
    return `${name9} : ${value7}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof _a$r) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
};
_a$r = OctetString;
(() => {
  typeStore.OctetString = _a$r;
})();
OctetString.NAME = OCTET_STRING_NAME;
var LocalBitStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value7 of this.value) {
        const currentBlockName = value7.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value7.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf = intBuffer.subarray(1);
      try {
        if (buf.byteLength) {
          const asn = localFromBER(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch {
      }
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
};
LocalBitStringValueBlock.NAME = "BitStringValueBlock";
var _a$q;
var BitString = class extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalBitStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      const name9 = this.constructor.NAME;
      const value7 = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
      return `${name9} : ${value7}`;
    }
  }
};
_a$q = BitString;
(() => {
  typeStore.BitString = _a$q;
})();
BitString.NAME = BIT_STRING_NAME;
var _a$p;
function viewAdd(first, second3) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second3);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value7 = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max; i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value7 = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value7 = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value7 / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value7 % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value7 % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power2(n) {
  if (n >= powers2.length) {
    for (let p = powers2.length; p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers2[p - 1].slice(0);
      for (let i = digits.length - 1; i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers2.push(digits);
    }
  }
  return powers2[n];
}
function viewSub(first, second3) {
  let b = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second3);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value7;
  let counter = 0;
  for (let i = secondViewCopyLength; i >= 0; i--, counter++) {
    value7 = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value7 < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value7 + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value7;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {
      value7 = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value7 < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value7 + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value7;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}
var LocalIntegerValueBlock = class extends HexBlock(ValueBlock) {
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  constructor({ value: value7, ...parameters } = {}) {
    super(parameters);
    this._valueDec = 0;
    if (parameters.valueHex) {
      this.setValueHex();
    }
    if (value7 !== void 0) {
      this.valueDec = value7;
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0; i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub(power2(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd(digits, power2(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0; i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString.charAt(0);
    return result;
  }
};
_a$p = LocalIntegerValueBlock;
LocalIntegerValueBlock.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o;
var Integer = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalIntegerValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value7) {
    assertBigInt();
    const bigIntValue = BigInt(value7);
    const writer = new ViewWriter();
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
      const secondInt = firstInt + bigIntValue;
      const second3 = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second3[0] |= 128;
      writer.write(second3);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new _a$o({ valueHex: writer.final() });
    return res;
  }
  convertToDER() {
    const integer = new _a$o({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new _a$o({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
};
_a$o = Integer;
(() => {
  typeStore.Integer = _a$o;
})();
Integer.NAME = "INTEGER";
var _a$n;
var Enumerated = class extends Integer {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
};
_a$n = Enumerated;
(() => {
  typeStore.Enumerated = _a$n;
})();
Enumerated.NAME = "ENUMERATED";
var LocalSidValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0; i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0; i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value7) {
    assertBigInt();
    let bits = BigInt(value7).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes = new Uint8Array(bits.length / 7);
    for (let i = 0; i < bytes.length; i++) {
      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);
    }
    this.fromBER(bytes.buffer, 0, bytes.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0; i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0; i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
};
LocalSidValueBlock.NAME = "sidBlock";
var LocalObjectIdentifierValueBlock = class extends ValueBlock {
  constructor({ value: value7 = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value7) {
      this.fromString(value7);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock();
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0; i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat2(retBuffers);
  }
  fromString(string2) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string2.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string2.substring(pos1);
      else
        sid = string2.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock();
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0; i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0; i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
};
LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
var _a$m;
var ObjectIdentifier = class extends BaseBlock {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value7) {
    this.valueBlock.fromString(value7);
  }
  constructor(parameters = {}) {
    super(parameters, LocalObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
};
_a$m = ObjectIdentifier;
(() => {
  typeStore.ObjectIdentifier = _a$m;
})();
ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
var LocalRelativeSidValueBlock = class extends HexBlock(LocalBaseBlock) {
  constructor({ valueDec = 0, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0; i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0; i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0; i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i = 0; i < len; i++)
        retView[i] = encodedView[i] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
};
LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
var LocalRelativeObjectIdentifierValueBlock = class extends ValueBlock {
  constructor({ value: value7 = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value7) {
      this.fromString(value7);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock();
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, _writer) {
    const retBuffers = [];
    for (let i = 0; i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat2(retBuffers);
  }
  fromString(string2) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string2.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string2.substring(pos1);
      else
        sid = string2.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock();
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0; i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0; i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
};
LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l;
var RelativeObjectIdentifier = class extends BaseBlock {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value7) {
    this.valueBlock.fromString(value7);
  }
  constructor(parameters = {}) {
    super(parameters, LocalRelativeObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
};
_a$l = RelativeObjectIdentifier;
(() => {
  typeStore.RelativeObjectIdentifier = _a$l;
})();
RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
var _a$k;
var Sequence = class extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
};
_a$k = Sequence;
(() => {
  typeStore.Sequence = _a$k;
})();
Sequence.NAME = "SEQUENCE";
var _a$j;
var Set2 = class extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
};
_a$j = Set2;
(() => {
  typeStore.Set = _a$j;
})();
Set2.NAME = "SET";
var LocalStringValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = true;
    this.value = EMPTY_STRING;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
};
LocalStringValueBlock.NAME = "StringValueBlock";
var LocalSimpleStringValueBlock = class extends LocalStringValueBlock {
};
LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
var LocalSimpleStringBlock = class extends BaseStringBlock {
  constructor({ ...parameters } = {}) {
    super(parameters, LocalSimpleStringValueBlock);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0; i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
};
LocalSimpleStringBlock.NAME = "SIMPLE STRING";
var LocalUtf8StringValueBlock = class extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
};
LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
var _a$i;
var Utf8String = class extends LocalUtf8StringValueBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
};
_a$i = Utf8String;
(() => {
  typeStore.Utf8String = _a$i;
})();
Utf8String.NAME = "UTF8String";
var LocalBmpStringValueBlock = class extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
};
LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
var _a$h;
var BmpString = class extends LocalBmpStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
};
_a$h = BmpString;
(() => {
  typeStore.BmpString = _a$h;
})();
BmpString.NAME = "BMPString";
var LocalUniversalStringValueBlock = class extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0; i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0; i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1; j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
};
LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
var _a$g;
var UniversalString = class extends LocalUniversalStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
};
_a$g = UniversalString;
(() => {
  typeStore.UniversalString = _a$g;
})();
UniversalString.NAME = "UniversalString";
var _a$f;
var NumericString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
};
_a$f = NumericString;
(() => {
  typeStore.NumericString = _a$f;
})();
NumericString.NAME = "NumericString";
var _a$e;
var PrintableString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
};
_a$e = PrintableString;
(() => {
  typeStore.PrintableString = _a$e;
})();
PrintableString.NAME = "PrintableString";
var _a$d;
var TeletexString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
};
_a$d = TeletexString;
(() => {
  typeStore.TeletexString = _a$d;
})();
TeletexString.NAME = "TeletexString";
var _a$c;
var VideotexString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
};
_a$c = VideotexString;
(() => {
  typeStore.VideotexString = _a$c;
})();
VideotexString.NAME = "VideotexString";
var _a$b;
var IA5String = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
};
_a$b = IA5String;
(() => {
  typeStore.IA5String = _a$b;
})();
IA5String.NAME = "IA5String";
var _a$a;
var GraphicString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
};
_a$a = GraphicString;
(() => {
  typeStore.GraphicString = _a$a;
})();
GraphicString.NAME = "GraphicString";
var _a$9;
var VisibleString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
};
_a$9 = VisibleString;
(() => {
  typeStore.VisibleString = _a$9;
})();
VisibleString.NAME = "VisibleString";
var _a$8;
var GeneralString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
};
_a$8 = GeneralString;
(() => {
  typeStore.GeneralString = _a$8;
})();
GeneralString.NAME = "GeneralString";
var _a$7;
var CharacterString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
};
_a$7 = CharacterString;
(() => {
  typeStore.CharacterString = _a$7;
})();
CharacterString.NAME = "CharacterString";
var _a$6;
var UTCTime = class extends VisibleString {
  constructor({ value: value7, valueDate, ...parameters } = {}) {
    super(parameters);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value7) {
      this.fromString(value7);
      this.valueBlock.valueHexView = new Uint8Array(value7.length);
      for (let i = 0; i < value7.length; i++)
        this.valueBlock.valueHexView[i] = value7.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0; i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2e3 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
};
_a$6 = UTCTime;
(() => {
  typeStore.UTCTime = _a$6;
})();
UTCTime.NAME = "UTCTime";
var _a$5;
var GeneralizedTime = class extends UTCTime {
  constructor(parameters = {}) {
    var _b;
    super(parameters);
    (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
    return new Date(utcDate);
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number2 = new Number(inputString[inputString.length - 1]);
      if (isNaN(number2.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number2 = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number2.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number2;
        if (differenceString.length === 4) {
          number2 = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number2.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number2;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1e3 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1e3 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1e3 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1; j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
};
_a$5 = GeneralizedTime;
(() => {
  typeStore.GeneralizedTime = _a$5;
})();
GeneralizedTime.NAME = "GeneralizedTime";
var _a$4;
var DATE = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
};
_a$4 = DATE;
(() => {
  typeStore.DATE = _a$4;
})();
DATE.NAME = "DATE";
var _a$3;
var TimeOfDay = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
};
_a$3 = TimeOfDay;
(() => {
  typeStore.TimeOfDay = _a$3;
})();
TimeOfDay.NAME = "TimeOfDay";
var _a$2;
var DateTime = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
};
_a$2 = DateTime;
(() => {
  typeStore.DateTime = _a$2;
})();
DateTime.NAME = "DateTime";
var _a$1;
var Duration = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
};
_a$1 = Duration;
(() => {
  typeStore.Duration = _a$1;
})();
Duration.NAME = "Duration";
var _a;
var TIME = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
};
_a = TIME;
(() => {
  typeStore.TIME = _a;
})();
TIME.NAME = "TIME";
var Any = class {
  constructor({ name: name9 = EMPTY_STRING, optional: optional8 = false } = {}) {
    this.name = name9;
    this.optional = optional8;
  }
};
var Choice = class extends Any {
  constructor({ value: value7 = [], ...parameters } = {}) {
    super(parameters);
    this.value = value7;
  }
};
var Repeated = class extends Any {
  constructor({ value: value7 = new Any(), local = false, ...parameters } = {}) {
    super(parameters);
    this.value = value7;
    this.local = local;
  }
};
var RawData = class {
  get data() {
    return this.dataView.slice().buffer;
  }
  set data(value7) {
    this.dataView = BufferSourceConverter.toUint8Array(value7);
  }
  constructor({ data = EMPTY_VIEW } = {}) {
    this.dataView = BufferSourceConverter.toUint8Array(data);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const endLength = inputOffset + inputLength;
    this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
    return endLength;
  }
  toBER(_sizeOnly) {
    return this.dataView.slice().buffer;
  }
};
function compareSchema(root, inputData, inputSchema) {
  if (inputSchema instanceof Choice) {
    for (const element of inputSchema.value) {
      const result = compareSchema(root, inputData, element);
      if (result.verified) {
        return {
          verified: true,
          result: root
        };
      }
    }
    {
      const _result = {
        verified: false,
        result: { error: "Wrong values for Choice type" }
      };
      if (inputSchema.hasOwnProperty(NAME))
        _result.name = inputSchema.name;
      return _result;
    }
  }
  if (inputSchema instanceof Any) {
    if (inputSchema.hasOwnProperty(NAME))
      root[inputSchema.name] = inputData;
    return {
      verified: true,
      result: root
    };
  }
  if (root instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong root object" }
    };
  }
  if (inputData instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 data" }
    };
  }
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (ID_BLOCK in inputSchema === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (FROM_BER in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (TO_BER in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  const encodedId = inputSchema.idBlock.toBER(false);
  if (encodedId.byteLength === 0) {
    return {
      verified: false,
      result: { error: "Error encoding idBlock for ASN.1 schema" }
    };
  }
  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
  if (decodedOffset === -1) {
    return {
      verified: false,
      result: { error: "Error decoding idBlock for ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
    return {
      verified: false,
      result: root
    };
  }
  if (!(IS_HEX_ONLY in inputSchema.idBlock)) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.isHexOnly) {
    if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const schemaView = inputSchema.idBlock.valueHexView;
    const asn1View = inputData.idBlock.valueHexView;
    if (schemaView.length !== asn1View.length) {
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0; i < schemaView.length; i++) {
      if (schemaView[i] !== asn1View[1]) {
        return {
          verified: false,
          result: root
        };
      }
    }
  }
  if (inputSchema.name) {
    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
    if (inputSchema.name)
      root[inputSchema.name] = inputData;
  }
  if (inputSchema instanceof typeStore.Constructed) {
    let admission = 0;
    let result = {
      verified: false,
      result: { error: "Unknown error" }
    };
    let maxLength = inputSchema.valueBlock.value.length;
    if (maxLength > 0) {
      if (inputSchema.valueBlock.value[0] instanceof Repeated) {
        maxLength = inputData.valueBlock.value.length;
      }
    }
    if (maxLength === 0) {
      return {
        verified: true,
        result: root
      };
    }
    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
      let _optional = true;
      for (let i = 0; i < inputSchema.valueBlock.value.length; i++)
        _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
      if (_optional) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name)
          delete root[inputSchema.name];
      }
      root.error = "Inconsistent object length";
      return {
        verified: false,
        result: root
      };
    }
    for (let i = 0; i < maxLength; i++) {
      if (i - admission >= inputData.valueBlock.value.length) {
        if (inputSchema.valueBlock.value[i].optional === false) {
          const _result = {
            verified: false,
            result: root
          };
          root.error = "Inconsistent length between ASN.1 data and schema";
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
      } else {
        if (inputSchema.valueBlock.value[0] instanceof Repeated) {
          result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[0].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
          if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
            let arrayRoot = {};
            if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
              arrayRoot = inputData;
            else
              arrayRoot = root;
            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
              arrayRoot[inputSchema.valueBlock.value[0].name] = [];
            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
          }
        } else {
          result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[i].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
        }
      }
    }
    if (result.verified === false) {
      const _result = {
        verified: false,
        result: root
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return {
      verified: true,
      result: root
    };
  }
  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {
    const asn1 = localFromBER(inputData.valueBlock.valueHexView);
    if (asn1.offset === -1) {
      const _result = {
        verified: false,
        result: asn1.result
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
  }
  return {
    verified: true,
    result: root
  };
}
function verifySchema(inputBuffer, inputSchema) {
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema type" }
    };
  }
  const asn1 = localFromBER(BufferSourceConverter.toUint8Array(inputBuffer));
  if (asn1.offset === -1) {
    return {
      verified: false,
      result: asn1.result
    };
  }
  return compareSchema(asn1.result, asn1.result, inputSchema);
}

// node_modules/@libp2p/keychain/node_modules/multiformats/dist/src/bases/base64.js
var base645 = rfc46489({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad5 = rfc46489({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url5 = rfc46489({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad5 = rfc46489({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/keychain/dist/src/utils/constants.js
var SALT_LENGTH = 16;
var KEY_SIZE = 32;
var ITERATIONS = 1e4;

// node_modules/@libp2p/keychain/dist/src/utils/export.js
async function exporter(privateKey, password) {
  const cipher = aes_gcm_browser_exports.create();
  const encryptedKey = await cipher.encrypt(privateKey, password);
  return base645.encode(encryptedKey);
}
async function exportPrivateKey(key, password, format11) {
  if (key.type === "RSA") {
    return exportRSAPrivateKey(key, password, format11);
  }
  if (key.type === "Ed25519") {
    return exportEd25519PrivateKey(key, password, format11);
  }
  if (key.type === "secp256k1") {
    return exportSecp256k1PrivateKey(key, password, format11);
  }
  if (key.type === "ECDSA") {
    return exportECDSAPrivateKey(key, password, format11);
  }
  throw new UnsupportedKeyTypeError();
}
async function exportEd25519PrivateKey(key, password, format11 = "libp2p-key") {
  if (format11 === "libp2p-key") {
    return exporter(privateKeyToProtobuf(key), password);
  } else {
    throw new InvalidParametersError(`export format '${format11}' is not supported`);
  }
}
async function exportSecp256k1PrivateKey(key, password, format11 = "libp2p-key") {
  if (format11 === "libp2p-key") {
    return exporter(privateKeyToProtobuf(key), password);
  } else {
    throw new InvalidParametersError("Export format is not supported");
  }
}
async function exportECDSAPrivateKey(key, password, format11 = "libp2p-key") {
  if (format11 === "libp2p-key") {
    return exporter(privateKeyToProtobuf(key), password);
  } else {
    throw new InvalidParametersError(`export format '${format11}' is not supported`);
  }
}
async function exportRSAPrivateKey(key, password, format11 = "pkcs-8") {
  if (format11 === "pkcs-8") {
    return exportToPem(key, password);
  } else if (format11 === "libp2p-key") {
    return exporter(privateKeyToProtobuf(key), password);
  } else {
    throw new InvalidParametersError("Export format is not supported");
  }
}
async function exportToPem(privateKey, password) {
  const crypto2 = webcrypto_default.get();
  const keyWrapper = new Sequence({
    value: [
      // version (0)
      new Integer({ value: 0 }),
      // privateKeyAlgorithm
      new Sequence({
        value: [
          // rsaEncryption OID
          new ObjectIdentifier({
            value: "1.2.840.113549.1.1.1"
          }),
          new Null()
        ]
      }),
      // PrivateKey
      new OctetString({
        valueHex: privateKey.raw
      })
    ]
  });
  const keyBuf = keyWrapper.toBER();
  const keyArr = new Uint8Array(keyBuf, 0, keyBuf.byteLength);
  const salt = randomBytes(SALT_LENGTH);
  const encryptionKey = await pbkdf2Async(sha512, password, salt, {
    c: ITERATIONS,
    dkLen: KEY_SIZE
  });
  const iv = randomBytes(16);
  const cryptoKey = await crypto2.subtle.importKey("raw", encryptionKey, "AES-CBC", false, ["encrypt"]);
  const encrypted = await crypto2.subtle.encrypt({
    name: "AES-CBC",
    iv
  }, cryptoKey, keyArr);
  const pbkdf2Params = new Sequence({
    value: [
      // salt
      new OctetString({ valueHex: salt }),
      // iteration count
      new Integer({ value: ITERATIONS }),
      // key length
      new Integer({ value: KEY_SIZE }),
      // AlgorithmIdentifier
      new Sequence({
        value: [
          // hmacWithSHA512
          new ObjectIdentifier({ value: "1.2.840.113549.2.11" }),
          new Null()
        ]
      })
    ]
  });
  const encryptionAlgorithm = new Sequence({
    value: [
      // pkcs5PBES2
      new ObjectIdentifier({
        value: "1.2.840.113549.1.5.13"
      }),
      new Sequence({
        value: [
          // keyDerivationFunc
          new Sequence({
            value: [
              // pkcs5PBKDF2
              new ObjectIdentifier({
                value: "1.2.840.113549.1.5.12"
              }),
              // PBKDF2-params
              pbkdf2Params
            ]
          }),
          // encryptionScheme
          new Sequence({
            value: [
              // aes256-CBC
              new ObjectIdentifier({
                value: "2.16.840.1.101.3.4.1.42"
              }),
              // iv
              new OctetString({
                valueHex: iv
              })
            ]
          })
        ]
      })
    ]
  });
  const finalWrapper = new Sequence({
    value: [
      encryptionAlgorithm,
      new OctetString({ valueHex: encrypted })
    ]
  });
  const finalWrapperBuf = finalWrapper.toBER();
  const finalWrapperArr = new Uint8Array(finalWrapperBuf, 0, finalWrapperBuf.byteLength);
  return [
    "-----BEGIN ENCRYPTED PRIVATE KEY-----",
    ...toString(finalWrapperArr, "base64pad").split(/(.{64})/).filter(Boolean),
    "-----END ENCRYPTED PRIVATE KEY-----"
  ].join("\n");
}

// node_modules/@libp2p/keychain/dist/src/utils/import.js
async function importPrivateKey(encryptedKey, password) {
  try {
    const key = await importer(encryptedKey, password);
    return privateKeyFromProtobuf(key);
  } catch {
  }
  if (!encryptedKey.includes("BEGIN")) {
    throw new InvalidParametersError("Encrypted key was not a libp2p-key or a PEM file");
  }
  return importFromPem(encryptedKey, password);
}
async function importer(privateKey, password) {
  const encryptedKey = base645.decode(privateKey);
  const cipher = aes_gcm_browser_exports.create();
  return cipher.decrypt(encryptedKey, password);
}
async function importFromPem(pem, password) {
  const crypto2 = webcrypto_default.get();
  let plaintext;
  if (pem.includes("-----BEGIN ENCRYPTED PRIVATE KEY-----")) {
    const key2 = fromString(pem.replace("-----BEGIN ENCRYPTED PRIVATE KEY-----", "").replace("-----END ENCRYPTED PRIVATE KEY-----", "").replace(/\n/g, "").trim(), "base64pad");
    const { result } = fromBER(key2);
    const { iv, salt, iterations, keySize, cipherText } = findEncryptedPEMData(result);
    const encryptionKey = await pbkdf2Async(sha512, password, salt, {
      c: iterations,
      dkLen: keySize
    });
    const cryptoKey = await crypto2.subtle.importKey("raw", encryptionKey, "AES-CBC", false, ["decrypt"]);
    const decrypted = toUint8Array(await crypto2.subtle.decrypt({
      name: "AES-CBC",
      iv
    }, cryptoKey, cipherText));
    const { result: decryptedResult } = fromBER(decrypted);
    plaintext = findPEMData(decryptedResult);
  } else if (pem.includes("-----BEGIN PRIVATE KEY-----")) {
    const key2 = fromString(pem.replace("-----BEGIN PRIVATE KEY-----", "").replace("-----END PRIVATE KEY-----", "").replace(/\n/g, "").trim(), "base64pad");
    const { result } = fromBER(key2);
    plaintext = findPEMData(result);
  } else {
    throw new InvalidParametersError("Could not parse private key from PEM data");
  }
  const key = privateKeyFromRaw(plaintext);
  if (key.type !== "RSA") {
    throw new InvalidParametersError("Could not parse RSA private key from PEM data");
  }
  return key;
}
function findEncryptedPEMData(root) {
  const encryptionAlgorithm = root.valueBlock.value[0];
  const scheme = encryptionAlgorithm.valueBlock.value[0].toString();
  if (scheme !== "OBJECT IDENTIFIER : 1.2.840.113549.1.5.13") {
    throw new InvalidParametersError("Only pkcs5PBES2 encrypted private keys are supported");
  }
  const keyDerivationFunc = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[0];
  const keyDerivationFuncName = keyDerivationFunc.valueBlock.value[0].toString();
  if (keyDerivationFuncName !== "OBJECT IDENTIFIER : 1.2.840.113549.1.5.12") {
    throw new InvalidParametersError("Only pkcs5PBKDF2 key derivation functions are supported");
  }
  const pbkdf2Params = keyDerivationFunc.valueBlock.value[1];
  const salt = toUint8Array(pbkdf2Params.valueBlock.value[0].getValue());
  let iterations = ITERATIONS;
  let keySize = KEY_SIZE;
  if (pbkdf2Params.valueBlock.value.length === 3) {
    iterations = Number(pbkdf2Params.valueBlock.value[1].toBigInt());
    keySize = Number(pbkdf2Params.valueBlock.value[2].toBigInt());
  } else if (pbkdf2Params.valueBlock.value.length === 2) {
    throw new InvalidParametersError("Could not derive key size and iterations from PEM file - please use @libp2p/rsa to re-import your key");
  }
  const encryptionScheme = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[1];
  const encryptionSchemeName = encryptionScheme.valueBlock.value[0].toString();
  if (encryptionSchemeName === "OBJECT IDENTIFIER : 1.2.840.113549.3.7") {
  } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 1.3.14.3.2.7") {
  } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.2") {
  } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.22") {
  } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.42") {
  } else {
    throw new InvalidParametersError("Only AES-CBC encryption schemes are supported");
  }
  const iv = toUint8Array(encryptionScheme.valueBlock.value[1].getValue());
  return {
    cipherText: toUint8Array(root.valueBlock.value[1].getValue()),
    salt,
    iterations,
    keySize,
    iv
  };
}
function findPEMData(seq) {
  return toUint8Array(seq.valueBlock.value[2].getValue());
}
function toUint8Array(buf) {
  return new Uint8Array(buf, 0, buf.byteLength);
}

// node_modules/@libp2p/keychain/dist/src/keychain.js
var keyPrefix = "/pkcs8/";
var infoPrefix = "/info/";
var privates = /* @__PURE__ */ new WeakMap();
var NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1e3
};
var defaultOptions3 = {
  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/
  dek: {
    keyLength: 512 / 8,
    iterationCount: 1e4,
    salt: "you should override this value with a crypto secure random number",
    hash: "sha2-512"
  }
};
function validateKeyName(name9) {
  if (name9 == null) {
    return false;
  }
  if (typeof name9 !== "string") {
    return false;
  }
  return name9 === (0, import_sanitize_filename.default)(name9.trim()) && name9.length > 0;
}
async function randomDelay() {
  const min = 200;
  const max = 1e3;
  const delay3 = Math.random() * (max - min) + min;
  await new Promise((resolve) => setTimeout(resolve, delay3));
}
function DsName(name9) {
  return new Key(keyPrefix + name9);
}
function DsInfoName(name9) {
  return new Key(infoPrefix + name9);
}
async function keyId(key) {
  const pb = privateKeyToProtobuf(key);
  const hash = await sha2565.digest(pb);
  return base58btc9.encode(hash.bytes).substring(1);
}
var Keychain = class {
  components;
  init;
  log;
  self;
  /**
   * Creates a new instance of a key chain
   */
  constructor(components, init) {
    this.components = components;
    this.log = components.logger.forComponent("libp2p:keychain");
    this.init = mergeOptions(defaultOptions3, init);
    this.self = init.selfKey ?? "self";
    if (this.init.pass != null && this.init.pass?.length < 20) {
      throw new Error("pass must be least 20 characters");
    }
    if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {
      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
    }
    if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {
      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
    }
    if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {
      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
    }
    const dek = this.init.pass != null && this.init.dek?.salt != null ? pbkdf2(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates.set(this, { dek });
  }
  [Symbol.toStringTag] = "@libp2p/keychain";
  [serviceCapabilities] = [
    "@libp2p/keychain"
  ];
  /**
   * Generates the options for a keychain.  A random salt is produced.
   *
   * @returns {object}
   */
  static generateOptions() {
    const options2 = Object.assign({}, defaultOptions3);
    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
    options2.dek.salt = toString(randomBytes(saltLength), "base64");
    return options2;
  }
  /**
   * Gets an object that can encrypt/decrypt protected data.
   * The default options for a keychain.
   *
   * @returns {object}
   */
  static get options() {
    return defaultOptions3;
  }
  async findKeyByName(name9) {
    if (!validateKeyName(name9)) {
      await randomDelay();
      throw new InvalidParametersError(`Invalid key name '${name9}'`);
    }
    const datastoreName = DsInfoName(name9);
    try {
      const res = await this.components.datastore.get(datastoreName);
      return JSON.parse(toString(res));
    } catch (err) {
      await randomDelay();
      this.log.error(err);
      throw new NotFoundError(`Key '${name9}' does not exist.`);
    }
  }
  async findKeyById(id) {
    try {
      const query = {
        prefix: infoPrefix
      };
      for await (const value7 of this.components.datastore.query(query)) {
        const key = JSON.parse(toString(value7.value));
        if (key.id === id) {
          return key;
        }
      }
      throw new InvalidParametersError(`Key with id '${id}' does not exist.`);
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  async importKey(name9, key) {
    if (!validateKeyName(name9)) {
      await randomDelay();
      throw new InvalidParametersError(`Invalid key name '${name9}'`);
    }
    if (key == null) {
      await randomDelay();
      throw new InvalidParametersError("Key is required");
    }
    const datastoreName = DsName(name9);
    const exists = await this.components.datastore.has(datastoreName);
    if (exists) {
      await randomDelay();
      throw new InvalidParametersError(`Key '${name9}' already exists`);
    }
    let kid;
    let pem;
    try {
      kid = await keyId(key);
      const cached = privates.get(this);
      if (cached == null) {
        throw new InvalidParametersError("dek missing");
      }
      const dek = cached.dek;
      pem = await exportPrivateKey(key, dek, key.type === "RSA" ? "pkcs-8" : "libp2p-key");
    } catch (err) {
      await randomDelay();
      throw err;
    }
    const keyInfo = {
      name: name9,
      id: kid
    };
    const batch = this.components.datastore.batch();
    batch.put(datastoreName, fromString(pem));
    batch.put(DsInfoName(name9), fromString(JSON.stringify(keyInfo)));
    await batch.commit();
    return keyInfo;
  }
  async exportKey(name9) {
    if (!validateKeyName(name9)) {
      await randomDelay();
      throw new InvalidParametersError(`Invalid key name '${name9}'`);
    }
    const datastoreName = DsName(name9);
    try {
      const res = await this.components.datastore.get(datastoreName);
      const pem = toString(res);
      const cached = privates.get(this);
      if (cached == null) {
        throw new InvalidParametersError("dek missing");
      }
      const dek = cached.dek;
      return await importPrivateKey(pem, dek);
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  async removeKey(name9) {
    if (!validateKeyName(name9) || name9 === this.self) {
      await randomDelay();
      throw new InvalidParametersError(`Invalid key name '${name9}'`);
    }
    const datastoreName = DsName(name9);
    const keyInfo = await this.findKeyByName(name9);
    const batch = this.components.datastore.batch();
    batch.delete(datastoreName);
    batch.delete(DsInfoName(name9));
    await batch.commit();
    return keyInfo;
  }
  /**
   * List all the keys.
   *
   * @returns {Promise<KeyInfo[]>}
   */
  async listKeys() {
    const query = {
      prefix: infoPrefix
    };
    const info = [];
    for await (const value7 of this.components.datastore.query(query)) {
      info.push(JSON.parse(toString(value7.value)));
    }
    return info;
  }
  /**
   * Rename a key
   *
   * @param {string} oldName - The old local key name; must already exist.
   * @param {string} newName - The new local key name; must not already exist.
   * @returns {Promise<KeyInfo>}
   */
  async renameKey(oldName, newName) {
    if (!validateKeyName(oldName) || oldName === this.self) {
      await randomDelay();
      throw new InvalidParametersError(`Invalid old key name '${oldName}'`);
    }
    if (!validateKeyName(newName) || newName === this.self) {
      await randomDelay();
      throw new InvalidParametersError(`Invalid new key name '${newName}'`);
    }
    const oldDatastoreName = DsName(oldName);
    const newDatastoreName = DsName(newName);
    const oldInfoName = DsInfoName(oldName);
    const newInfoName = DsInfoName(newName);
    const exists = await this.components.datastore.has(newDatastoreName);
    if (exists) {
      await randomDelay();
      throw new InvalidParametersError(`Key '${newName}' already exists`);
    }
    try {
      const pem = await this.components.datastore.get(oldDatastoreName);
      const res = await this.components.datastore.get(oldInfoName);
      const keyInfo = JSON.parse(toString(res));
      keyInfo.name = newName;
      const batch = this.components.datastore.batch();
      batch.put(newDatastoreName, pem);
      batch.put(newInfoName, fromString(JSON.stringify(keyInfo)));
      batch.delete(oldDatastoreName);
      batch.delete(oldInfoName);
      await batch.commit();
      return keyInfo;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Rotate keychain password and re-encrypt all associated keys
   */
  async rotateKeychainPass(oldPass, newPass) {
    if (typeof oldPass !== "string") {
      await randomDelay();
      throw new InvalidParametersError(`Invalid old pass type '${typeof oldPass}'`);
    }
    if (typeof newPass !== "string") {
      await randomDelay();
      throw new InvalidParametersError(`Invalid new pass type '${typeof newPass}'`);
    }
    if (newPass.length < 20) {
      await randomDelay();
      throw new InvalidParametersError(`Invalid pass length ${newPass.length}`);
    }
    this.log("recreating keychain");
    const cached = privates.get(this);
    if (cached == null) {
      throw new InvalidParametersError("dek missing");
    }
    const oldDek = cached.dek;
    this.init.pass = newPass;
    const newDek = newPass != null && this.init.dek?.salt != null ? pbkdf2(newPass, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates.set(this, { dek: newDek });
    const keys = await this.listKeys();
    for (const key of keys) {
      const res = await this.components.datastore.get(DsName(key.name));
      const pem = toString(res);
      const privateKey = await importPrivateKey(pem, oldDek);
      const password = newDek.toString();
      const keyAsPEM = await exportPrivateKey(privateKey, password, privateKey.type === "RSA" ? "pkcs-8" : "libp2p-key");
      const batch = this.components.datastore.batch();
      const keyInfo = {
        name: key.name,
        id: key.id
      };
      batch.put(DsName(key.name), fromString(keyAsPEM));
      batch.put(DsInfoName(key.name), fromString(JSON.stringify(keyInfo)));
      await batch.commit();
    }
    this.log("keychain reconstructed");
  }
};

// node_modules/@libp2p/keychain/dist/src/index.js
function keychain(init = {}) {
  return (components) => {
    return new Keychain(components, init);
  };
}

// node_modules/@libp2p/config/dist/src/load-private-key.js
async function loadOrCreateSelfKey(datastore, init = {}) {
  const selfKey = init.selfKey ?? "self";
  const chain = keychain(init)({
    datastore,
    logger: defaultLogger()
  });
  let privateKey;
  if (await datastore.has(new Key(`/pkcs8/${selfKey}`))) {
    privateKey = await chain.exportKey(selfKey);
  } else {
    privateKey = await generateKeyPair(init.keyType ?? "Ed25519");
    await chain.importKey(selfKey, privateKey);
  }
  return privateKey;
}

// node_modules/libp2p/dist/src/connection-manager/resolvers/dnsaddr.js
var DNSAddrResolver = class {
  dns;
  canResolve(ma) {
    return ma.getComponents().some(({ name: name9 }) => name9 === "dnsaddr");
  }
  async resolve(ma, options2) {
    const hostname = ma.getComponents().find((component) => component.name === "dnsaddr")?.value;
    if (hostname == null) {
      return [ma];
    }
    const resolver = this.getDNS(options2);
    const result = await resolver.query(`_dnsaddr.${hostname}`, {
      signal: options2?.signal,
      types: [
        RecordType.TXT
      ]
    });
    const peerId2 = ma.getComponents().find((component) => component.name === "p2p")?.value;
    const output = [];
    for (const answer of result.Answer) {
      const addr = answer.data.replace(/["']/g, "").trim().split("=")[1];
      if (addr == null) {
        continue;
      }
      if (peerId2 != null && !addr.includes(peerId2)) {
        continue;
      }
      output.push(multiaddr(addr));
    }
    return output;
  }
  getDNS(options2) {
    if (options2.dns != null) {
      return options2.dns;
    }
    if (this.dns == null) {
      this.dns = dns();
    }
    return this.dns;
  }
};
var dnsaddrResolver = new DNSAddrResolver();

// node_modules/libp2p/dist/src/config.js
var DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (multiaddrs) => multiaddrs
  },
  connectionManager: {
    resolvers: {
      dnsaddr: dnsaddrResolver
    }
  },
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  }
};
async function validateConfig(opts) {
  const resultingOptions = mergeOptions(DefaultConfig, opts);
  if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {
    throw new InvalidParametersError("Private network is enforced, but no protector was provided");
  }
  return resultingOptions;
}

// node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
var Envelope;
(function(Envelope3) {
  let _codec;
  Envelope3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.payload);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          publicKey: alloc(0),
          payloadType: alloc(0),
          payload: alloc(0),
          signature: alloc(0)
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              obj.payloadType = reader.bytes();
              break;
            }
            case 3: {
              obj.payload = reader.bytes();
              break;
            }
            case 5: {
              obj.signature = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope3.encode = (obj) => {
    return encodeMessage(obj, Envelope3.codec());
  };
  Envelope3.decode = (buf, opts) => {
    return decodeMessage(buf, Envelope3.codec(), opts);
  };
})(Envelope || (Envelope = {}));

// node_modules/@libp2p/peer-record/dist/src/envelope/errors.js
var InvalidSignatureError = class extends Error {
  constructor(message2 = "Invalid signature") {
    super(message2);
    this.name = "InvalidSignatureError";
  }
};

// node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var RecordEnvelope = class _RecordEnvelope {
  /**
   * Unmarshal a serialized Envelope protobuf message
   */
  static createFromProtobuf = (data) => {
    const envelopeData = Envelope.decode(data);
    const publicKey2 = publicKeyFromProtobuf(envelopeData.publicKey);
    return new _RecordEnvelope({
      publicKey: publicKey2,
      payloadType: envelopeData.payloadType,
      payload: envelopeData.payload,
      signature: envelopeData.signature
    });
  };
  /**
   * Seal marshals the given Record, places the marshaled bytes inside an Envelope
   * and signs it with the given peerId's private key
   */
  static seal = async (record, privateKey, options2) => {
    if (privateKey == null) {
      throw new Error("Missing private key");
    }
    const domain = record.domain;
    const payloadType = record.codec;
    const payload = record.marshal();
    const signData = formatSignaturePayload(domain, payloadType, payload);
    const signature = await privateKey.sign(signData.subarray(), options2);
    return new _RecordEnvelope({
      publicKey: privateKey.publicKey,
      payloadType,
      payload,
      signature
    });
  };
  /**
   * Open and certify a given marshaled envelope.
   * Data is unmarshaled and the signature validated for the given domain.
   */
  static openAndCertify = async (data, domain, options2) => {
    const envelope = _RecordEnvelope.createFromProtobuf(data);
    const valid = await envelope.validate(domain, options2);
    if (!valid) {
      throw new InvalidSignatureError("Envelope signature is not valid for the given domain");
    }
    return envelope;
  };
  publicKey;
  payloadType;
  payload;
  signature;
  marshaled;
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   */
  constructor(init) {
    const { publicKey: publicKey2, payloadType, payload, signature } = init;
    this.publicKey = publicKey2;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  /**
   * Marshal the envelope content
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = Envelope.encode({
        publicKey: publicKeyToProtobuf(this.publicKey),
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  /**
   * Verifies if the other Envelope is identical to this one
   */
  equals(other) {
    if (other == null) {
      return false;
    }
    return equals(this.marshal(), other.marshal());
  }
  /**
   * Validate envelope data signature for the given domain
   */
  async validate(domain, options2) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    return this.publicKey.verify(signData.subarray(), this.signature, options2);
  }
};
var formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString(domain);
  const domainLength = encode(domainUint8Array.byteLength);
  const payloadTypeLength = encode(payloadType.length);
  const payloadLength = encode(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};

// node_modules/@libp2p/utils/dist/src/array-equals.js
function arrayEquals(a, b) {
  const sort = (a2, b2) => a2.toString().localeCompare(b2.toString());
  if (a.length !== b.length) {
    return false;
  }
  b.sort(sort);
  return a.sort(sort).every((item, index) => b[index].equals(item));
}

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bytes.js
var empty11 = new Uint8Array(0);
function coerce11(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/vendor/varint.js
var encode_19 = encode26;
var MSB9 = 128;
var REST9 = 127;
var MSBALL9 = ~REST9;
var INT9 = Math.pow(2, 31);
function encode26(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT9) {
    out[offset++] = num & 255 | MSB9;
    num /= 128;
  }
  while (num & MSBALL9) {
    out[offset++] = num & 255 | MSB9;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode26.bytes = offset - oldOffset + 1;
  return out;
}
var decode38 = read9;
var MSB$19 = 128;
var REST$19 = 127;
function read9(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read9.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$19) << shift : (b & REST$19) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$19);
  read9.bytes = counter - offset;
  return res;
}
var N19 = Math.pow(2, 7);
var N29 = Math.pow(2, 14);
var N39 = Math.pow(2, 21);
var N49 = Math.pow(2, 28);
var N59 = Math.pow(2, 35);
var N69 = Math.pow(2, 42);
var N79 = Math.pow(2, 49);
var N89 = Math.pow(2, 56);
var N99 = Math.pow(2, 63);
var length9 = function(value7) {
  return value7 < N19 ? 1 : value7 < N29 ? 2 : value7 < N39 ? 3 : value7 < N49 ? 4 : value7 < N59 ? 5 : value7 < N69 ? 6 : value7 < N79 ? 7 : value7 < N89 ? 8 : value7 < N99 ? 9 : 10;
};
var varint9 = {
  encode: encode_19,
  decode: decode38,
  encodingLength: length9
};
var _brrp_varint9 = varint9;
var varint_default9 = _brrp_varint9;

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/varint.js
function decode39(data, offset = 0) {
  const code17 = varint_default9.decode(data, offset);
  return [code17, varint_default9.decode.bytes];
}

// node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/digest.js
function decode40(multihash) {
  const bytes = coerce11(multihash);
  const [code17, sizeOffset] = decode39(bytes);
  const [size, digestOffset] = decode39(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest9(code17, size, digest5, bytes);
}
var Digest9 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

// node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
var PeerRecord;
(function(PeerRecord3) {
  let AddressInfo;
  (function(AddressInfo2) {
    let _codec2;
    AddressInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length16, opts = {}) => {
          const obj = {
            multiaddr: alloc(0)
          };
          const end = length16 == null ? reader.len : reader.pos + length16;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.multiaddr = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo2.encode = (obj) => {
      return encodeMessage(obj, AddressInfo2.codec());
    };
    AddressInfo2.decode = (buf, opts) => {
      return decodeMessage(buf, AddressInfo2.codec(), opts);
    };
  })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
  let _codec;
  PeerRecord3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.peerId != null && obj.peerId.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.peerId);
        }
        if (obj.seq != null && obj.seq !== 0n) {
          w.uint32(16);
          w.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value7 of obj.addresses) {
            w.uint32(26);
            PeerRecord3.AddressInfo.codec().encode(value7, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          peerId: alloc(0),
          seq: 0n,
          addresses: []
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.peerId = reader.bytes();
              break;
            }
            case 2: {
              obj.seq = reader.uint64();
              break;
            }
            case 3: {
              if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.addresses$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord3.encode = (obj) => {
    return encodeMessage(obj, PeerRecord3.codec());
  };
  PeerRecord3.decode = (buf, opts) => {
    return decodeMessage(buf, PeerRecord3.codec(), opts);
  };
})(PeerRecord || (PeerRecord = {}));

// node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
var PeerRecord2 = class _PeerRecord {
  /**
   * Unmarshal Peer Record Protobuf
   */
  static createFromProtobuf = (buf) => {
    const peerRecord = PeerRecord.decode(buf);
    const peerId2 = peerIdFromMultihash(decode40(peerRecord.peerId));
    const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
    const seqNumber = peerRecord.seq;
    return new _PeerRecord({ peerId: peerId2, multiaddrs, seqNumber });
  };
  static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
  static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
  peerId;
  multiaddrs;
  seqNumber;
  domain = _PeerRecord.DOMAIN;
  codec = _PeerRecord.CODEC;
  marshaled;
  constructor(init) {
    const { peerId: peerId2, multiaddrs, seqNumber } = init;
    this.peerId = peerId2;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  /**
   * Marshal a record to be used in an envelope
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord.encode({
        peerId: this.peerId.toMultihash().bytes,
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m) => ({
          multiaddr: m.bytes
        }))
      });
    }
    return this.marshaled;
  }
  /**
   * Returns true if `this` record equals the `other`
   */
  equals(other) {
    if (!(other instanceof _PeerRecord)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
};

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bytes.js
var empty12 = new Uint8Array(0);
function equals17(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce12(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/vendor/base-x.js
function base10(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src10 = base10;
var _brrp__multiformats_scope_baseX10 = src10;
var base_x_default11 = _brrp__multiformats_scope_baseX10;

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base.js
var Encoder11 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder11 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or12(this, decoder);
  }
};
var ComposedDecoder11 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or12(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or12(left, right) {
  return new ComposedDecoder11({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec11 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder11(name9, prefix, baseEncode);
    this.decoder = new Decoder11(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from15({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec11(name9, prefix, encode39, decode61);
}
function baseX10({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default11(alphabet2, name9);
  return from15({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce12(decode61(text))
  });
}
function decode41(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode27(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx10(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc464810({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx10(alphabet2);
  return from15({
    prefix,
    name: name9,
    encode(input) {
      return encode27(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode41(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base32.js
var base327 = rfc464810({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper7 = rfc464810({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad7 = rfc464810({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper7 = rfc464810({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex7 = rfc464810({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper7 = rfc464810({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad7 = rfc464810({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper7 = rfc464810({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z7 = rfc464810({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base36.js
var base367 = baseX10({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper7 = baseX10({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base58.js
var base58btc10 = baseX10({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr10 = baseX10({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/vendor/varint.js
var encode_110 = encode28;
var MSB10 = 128;
var REST10 = 127;
var MSBALL10 = ~REST10;
var INT10 = Math.pow(2, 31);
function encode28(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT10) {
    out[offset++] = num & 255 | MSB10;
    num /= 128;
  }
  while (num & MSBALL10) {
    out[offset++] = num & 255 | MSB10;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode28.bytes = offset - oldOffset + 1;
  return out;
}
var decode42 = read10;
var MSB$110 = 128;
var REST$110 = 127;
function read10(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read10.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$110) << shift : (b & REST$110) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$110);
  read10.bytes = counter - offset;
  return res;
}
var N110 = Math.pow(2, 7);
var N210 = Math.pow(2, 14);
var N310 = Math.pow(2, 21);
var N410 = Math.pow(2, 28);
var N510 = Math.pow(2, 35);
var N610 = Math.pow(2, 42);
var N710 = Math.pow(2, 49);
var N810 = Math.pow(2, 56);
var N910 = Math.pow(2, 63);
var length10 = function(value7) {
  return value7 < N110 ? 1 : value7 < N210 ? 2 : value7 < N310 ? 3 : value7 < N410 ? 4 : value7 < N510 ? 5 : value7 < N610 ? 6 : value7 < N710 ? 7 : value7 < N810 ? 8 : value7 < N910 ? 9 : 10;
};
var varint10 = {
  encode: encode_110,
  decode: decode42,
  encodingLength: length10
};
var _brrp_varint10 = varint10;
var varint_default10 = _brrp_varint10;

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/varint.js
function decode43(data, offset = 0) {
  const code17 = varint_default10.decode(data, offset);
  return [code17, varint_default10.decode.bytes];
}
function encodeTo10(int, target, offset = 0) {
  varint_default10.encode(int, target, offset);
  return target;
}
function encodingLength11(int) {
  return varint_default10.encodingLength(int);
}

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/hashes/digest.js
function create9(code17, digest5) {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength11(code17);
  const digestOffset = sizeOffset + encodingLength11(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo10(code17, bytes, 0);
  encodeTo10(size, bytes, sizeOffset);
  bytes.set(digest5, digestOffset);
  return new Digest10(code17, size, digest5, bytes);
}
function decode44(multihash) {
  const bytes = coerce12(multihash);
  const [code17, sizeOffset] = decode43(bytes);
  const [size, digestOffset] = decode43(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest10(code17, size, digest5, bytes);
}
function equals18(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals17(a.bytes, data.bytes);
  }
}
var Digest10 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/cid.js
function format7(link, base14) {
  const { bytes, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV07(bytes, baseCache7(link), base14 ?? base58btc10.encoder);
    default:
      return toStringV17(bytes, baseCache7(link), base14 ?? base327.encoder);
  }
}
var cache8 = /* @__PURE__ */ new WeakMap();
function baseCache7(cid) {
  const baseCache11 = cache8.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache8.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID7 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code17, multihash, bytes) {
    this.code = code17;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code17, multihash } = this;
        if (code17 !== DAG_PB_CODE7) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE7) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code17, digest: digest5 } = this.multihash;
        const multihash = create9(code17, digest5);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals18(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format7(this, base14);
  }
  toJSON() {
    return { "/": format7(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value7 = input;
    if (value7 instanceof _CID) {
      return value7;
    } else if (value7["/"] != null && value7["/"] === value7.bytes || value7.asCID === value7) {
      const { version: version3, code: code17, multihash, bytes } = value7;
      return new _CID(version3, code17, multihash, bytes ?? encodeCID7(version3, code17, multihash.bytes));
    } else if (value7[cidSymbol7] === true) {
      const { version: version3, multihash, code: code17 } = value7;
      const digest5 = decode44(multihash);
      return _CID.create(version3, code17, digest5);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code17, digest5) {
    if (typeof code17 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code17 !== DAG_PB_CODE7) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE7}) block encoding`);
        } else {
          return new _CID(version3, code17, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID7(version3, code17, digest5.bytes);
        return new _CID(version3, code17, digest5, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE7, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code17, digest5) {
    return _CID.create(1, code17, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce12(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest5 = new Digest10(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest5) : _CID.createV1(specs.codec, digest5);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length16] = decode43(initialBytes.subarray(offset));
      offset += length16;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE7;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes7(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache7(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes7(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc10;
      return [
        base58btc10.prefix,
        decoder.decode(`${base58btc10.prefix}${source}`)
      ];
    }
    case base58btc10.prefix: {
      const decoder = base14 ?? base58btc10;
      return [base58btc10.prefix, decoder.decode(source)];
    }
    case base327.prefix: {
      const decoder = base14 ?? base327;
      return [base327.prefix, decoder.decode(source)];
    }
    case base367.prefix: {
      const decoder = base14 ?? base367;
      return [base367.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV07(bytes, cache12, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc10.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV17(bytes, cache12, base14) {
  const { prefix } = base14;
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE7 = 112;
var SHA_256_CODE7 = 18;
function encodeCID7(version3, code17, multihash) {
  const codeOffset = encodingLength11(version3);
  const hashOffset = codeOffset + encodingLength11(code17);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo10(version3, bytes, 0);
  encodeTo10(code17, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol7 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/peer-store/dist/src/constants.js
var MAX_ADDRESS_AGE = 36e5;
var MAX_PEER_AGE = 216e5;

// node_modules/@libp2p/peer-store/dist/src/pb/peer.js
var Peer;
(function(Peer3) {
  let Peer$metadataEntry;
  (function(Peer$metadataEntry2) {
    let _codec2;
    Peer$metadataEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null && obj.value.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.value);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length16, opts = {}) => {
          const obj = {
            key: "",
            value: alloc(0)
          };
          const end = length16 == null ? reader.len : reader.pos + length16;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$metadataEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$metadataEntry2.codec());
    };
    Peer$metadataEntry2.decode = (buf, opts) => {
      return decodeMessage(buf, Peer$metadataEntry2.codec(), opts);
    };
  })(Peer$metadataEntry = Peer3.Peer$metadataEntry || (Peer3.Peer$metadataEntry = {}));
  let Peer$tagsEntry;
  (function(Peer$tagsEntry2) {
    let _codec2;
    Peer$tagsEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null) {
            w.uint32(18);
            Tag.codec().encode(obj.value, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length16, opts = {}) => {
          const obj = {
            key: ""
          };
          const end = length16 == null ? reader.len : reader.pos + length16;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = Tag.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.value
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$tagsEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$tagsEntry2.codec());
    };
    Peer$tagsEntry2.decode = (buf, opts) => {
      return decodeMessage(buf, Peer$tagsEntry2.codec(), opts);
    };
  })(Peer$tagsEntry = Peer3.Peer$tagsEntry || (Peer3.Peer$tagsEntry = {}));
  let _codec;
  Peer3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.addresses != null) {
          for (const value7 of obj.addresses) {
            w.uint32(10);
            Address.codec().encode(value7, w);
          }
        }
        if (obj.protocols != null) {
          for (const value7 of obj.protocols) {
            w.uint32(18);
            w.string(value7);
          }
        }
        if (obj.publicKey != null) {
          w.uint32(34);
          w.bytes(obj.publicKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w.uint32(42);
          w.bytes(obj.peerRecordEnvelope);
        }
        if (obj.metadata != null && obj.metadata.size !== 0) {
          for (const [key, value7] of obj.metadata.entries()) {
            w.uint32(50);
            Peer3.Peer$metadataEntry.codec().encode({ key, value: value7 }, w);
          }
        }
        if (obj.tags != null && obj.tags.size !== 0) {
          for (const [key, value7] of obj.tags.entries()) {
            w.uint32(58);
            Peer3.Peer$tagsEntry.codec().encode({ key, value: value7 }, w);
          }
        }
        if (obj.updated != null) {
          w.uint32(64);
          w.uint64Number(obj.updated);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          addresses: [],
          protocols: [],
          metadata: /* @__PURE__ */ new Map(),
          tags: /* @__PURE__ */ new Map()
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(Address.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.addresses$
              }));
              break;
            }
            case 2: {
              if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 4: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 5: {
              obj.peerRecordEnvelope = reader.bytes();
              break;
            }
            case 6: {
              if (opts.limits?.metadata != null && obj.metadata.size === opts.limits.metadata) {
                throw new MaxSizeError('Decode error - map field "metadata" had too many elements');
              }
              const entry = Peer3.Peer$metadataEntry.codec().decode(reader, reader.uint32());
              obj.metadata.set(entry.key, entry.value);
              break;
            }
            case 7: {
              if (opts.limits?.tags != null && obj.tags.size === opts.limits.tags) {
                throw new MaxSizeError('Decode error - map field "tags" had too many elements');
              }
              const entry = Peer3.Peer$tagsEntry.codec().decode(reader, reader.uint32(), {
                limits: {
                  value: opts.limits?.tags$value
                }
              });
              obj.tags.set(entry.key, entry.value);
              break;
            }
            case 8: {
              obj.updated = reader.uint64Number();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer3.encode = (obj) => {
    return encodeMessage(obj, Peer3.codec());
  };
  Peer3.decode = (buf, opts) => {
    return decodeMessage(buf, Peer3.codec(), opts);
  };
})(Peer || (Peer = {}));
var Address;
(function(Address2) {
  let _codec;
  Address2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w.uint32(16);
          w.bool(obj.isCertified);
        }
        if (obj.observed != null) {
          w.uint32(24);
          w.uint64Number(obj.observed);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          multiaddr: alloc(0)
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.multiaddr = reader.bytes();
              break;
            }
            case 2: {
              obj.isCertified = reader.bool();
              break;
            }
            case 3: {
              obj.observed = reader.uint64Number();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address2.encode = (obj) => {
    return encodeMessage(obj, Address2.codec());
  };
  Address2.decode = (buf, opts) => {
    return decodeMessage(buf, Address2.codec(), opts);
  };
})(Address || (Address = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.value != null && obj.value !== 0) {
          w.uint32(8);
          w.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w.uint32(16);
          w.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          value: 0
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.value = reader.uint32();
              break;
            }
            case 2: {
              obj.expiry = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf, opts) => {
    return decodeMessage(buf, Tag2.codec(), opts);
  };
})(Tag || (Tag = {}));

// node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js
function populatePublicKey(peerId2, protobuf) {
  if (peerId2.publicKey != null || protobuf.publicKey == null) {
    return peerId2;
  }
  let digest5;
  if (peerId2.type === "RSA") {
    digest5 = peerId2.toMultihash();
  }
  const publicKey2 = publicKeyFromProtobuf(protobuf.publicKey, digest5);
  return peerIdFromPublicKey(publicKey2);
}
function bytesToPeer(peerId2, buf, maxAddressAge) {
  const peer = Peer.decode(buf);
  return pbToPeer(peerId2, peer, maxAddressAge);
}
function pbToPeer(peerId2, peer, maxAddressAge) {
  const tags = /* @__PURE__ */ new Map();
  const now = BigInt(Date.now());
  for (const [key, tag] of peer.tags.entries()) {
    if (tag.expiry != null && tag.expiry < now) {
      continue;
    }
    tags.set(key, tag);
  }
  return {
    ...peer,
    id: populatePublicKey(peerId2, peer),
    addresses: peer.addresses.filter(({ observed }) => observed != null && observed > Date.now() - maxAddressAge).map(({ multiaddr: ma, isCertified }) => {
      return {
        multiaddr: multiaddr(ma),
        isCertified: isCertified ?? false
      };
    }),
    metadata: peer.metadata,
    peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
    tags
  };
}

// node_modules/@libp2p/peer-store/dist/src/utils/peer-equals.js
function peerEquals(peerA, peerB) {
  return addressesEqual(peerA.addresses, peerB.addresses) && protocolsEqual(peerA.protocols, peerB.protocols) && publicKeyEqual(peerA.publicKey, peerB.publicKey) && peerRecordEnvelope(peerA.peerRecordEnvelope, peerB.peerRecordEnvelope) && metadataEqual(peerA.metadata, peerB.metadata) && tagsEqual(peerA.tags, peerB.tags);
}
function addressesEqual(addressesA, addressesB) {
  return compareArrays(addressesA, addressesB, (a, b) => {
    if (a.isCertified !== b.isCertified) {
      return false;
    }
    if (!equals(a.multiaddr, b.multiaddr)) {
      return false;
    }
    return true;
  });
}
function protocolsEqual(protocolsA, protocolsB) {
  return compareArrays(protocolsA, protocolsB, (a, b) => a === b);
}
function publicKeyEqual(publicKeyA, publicKeyB) {
  return compareOptionalUint8Arrays(publicKeyA, publicKeyB);
}
function peerRecordEnvelope(envelopeA, envelopeB) {
  return compareOptionalUint8Arrays(envelopeA, envelopeB);
}
function metadataEqual(metadataA, metadataB) {
  return compareMaps(metadataA, metadataB, (a, b) => equals(a, b));
}
function tagsEqual(metadataA, metadataB) {
  return compareMaps(metadataA, metadataB, (a, b) => a.value === b.value && a.expiry === b.expiry);
}
function compareOptionalUint8Arrays(arrA, arrB) {
  if (arrA == null && arrB == null) {
    return true;
  }
  if (arrA != null && arrB != null) {
    return equals(arrA, arrB);
  }
  return false;
}
function compareArrays(arrA, arrB, compare2) {
  if (arrA.length !== arrB.length) {
    return false;
  }
  for (let i = 0; i < arrA.length; i++) {
    if (!compare2(arrA[i], arrB[i])) {
      return false;
    }
  }
  return true;
}
function compareMaps(mapA, mapB, compare2) {
  if (mapA.size !== mapB.size) {
    return false;
  }
  for (const [key, value7] of mapA.entries()) {
    const valueB = mapB.get(key);
    if (valueB == null) {
      return false;
    }
    if (!compare2(value7, valueB)) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
var NAMESPACE_COMMON = "/peers/";
function peerIdToDatastoreKey(peerId2) {
  if (!isPeerId(peerId2) || peerId2.type == null) {
    throw new InvalidParametersError("Invalid PeerId");
  }
  const b32key = peerId2.toCID().toString();
  return new Key(`${NAMESPACE_COMMON}${b32key}`);
}

// node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js
async function dedupeFilterAndSortAddresses(peerId2, filter, addresses, existingAddresses, options2) {
  const addressMap = /* @__PURE__ */ new Map();
  for (const addr of addresses) {
    if (addr == null) {
      continue;
    }
    if (addr.multiaddr instanceof Uint8Array) {
      addr.multiaddr = multiaddr(addr.multiaddr);
    }
    if (!isMultiaddr(addr.multiaddr)) {
      throw new InvalidParametersError("Multiaddr was invalid");
    }
    if (!await filter(peerId2, addr.multiaddr, options2)) {
      continue;
    }
    const isCertified = addr.isCertified ?? false;
    const maStr = addr.multiaddr.toString();
    const existingAddr = addressMap.get(maStr);
    if (existingAddr != null) {
      addr.isCertified = existingAddr.isCertified || isCertified;
    } else {
      addressMap.set(maStr, {
        multiaddr: addr.multiaddr,
        isCertified
      });
    }
  }
  return [...addressMap.values()].sort((a, b) => {
    return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
  }).map(({ isCertified, multiaddr: ma }) => {
    const addrPeer = ma.getPeerId();
    if (peerId2.equals(addrPeer)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId2}`));
    }
    return {
      isCertified,
      multiaddr: ma.bytes
    };
  });
}

// node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
async function toPeerPB(peerId2, data, strategy, options2) {
  if (data == null) {
    throw new InvalidParametersError("Invalid PeerData");
  }
  if (data.publicKey != null && peerId2.publicKey != null && !data.publicKey.equals(peerId2.publicKey)) {
    throw new InvalidParametersError("publicKey bytes do not match peer id publicKey bytes");
  }
  const existingPeer = options2.existingPeer?.peer;
  if (existingPeer != null && !peerId2.equals(existingPeer.id)) {
    throw new InvalidParametersError("peer id did not match existing peer id");
  }
  let addresses = existingPeer?.addresses ?? [];
  let protocols2 = new Set(existingPeer?.protocols ?? []);
  let metadata = existingPeer?.metadata ?? /* @__PURE__ */ new Map();
  let tags = existingPeer?.tags ?? /* @__PURE__ */ new Map();
  let peerRecordEnvelope2 = existingPeer?.peerRecordEnvelope;
  if (strategy === "patch") {
    if (data.multiaddrs != null || data.addresses != null) {
      addresses = [];
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
    }
    if (data.protocols != null) {
      protocols2 = new Set(data.protocols);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      metadata = createSortedMap(metadataEntries, {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      tags = createSortedMap(tagsEntries, {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope2 = data.peerRecordEnvelope;
    }
  }
  if (strategy === "merge") {
    if (data.multiaddrs != null) {
      addresses.push(...data.multiaddrs.map((multiaddr2) => ({
        isCertified: false,
        multiaddr: multiaddr2
      })));
    }
    if (data.addresses != null) {
      addresses.push(...data.addresses);
    }
    if (data.protocols != null) {
      protocols2 = /* @__PURE__ */ new Set([...protocols2, ...data.protocols]);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      for (const [key, value7] of metadataEntries) {
        if (value7 == null) {
          metadata.delete(key);
        } else {
          metadata.set(key, value7);
        }
      }
      metadata = createSortedMap([...metadata.entries()], {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      const mergedTags = new Map(tags);
      for (const [key, value7] of tagsEntries) {
        if (value7 == null) {
          mergedTags.delete(key);
        } else {
          mergedTags.set(key, value7);
        }
      }
      tags = createSortedMap([...mergedTags.entries()], {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope2 = data.peerRecordEnvelope;
    }
  }
  let publicKey2;
  if (existingPeer?.id.publicKey != null) {
    publicKey2 = publicKeyToProtobuf(existingPeer.id.publicKey);
  } else if (data.publicKey != null) {
    publicKey2 = publicKeyToProtobuf(data.publicKey);
  } else if (peerId2.publicKey != null) {
    publicKey2 = publicKeyToProtobuf(peerId2.publicKey);
  }
  const output = {
    addresses: await dedupeFilterAndSortAddresses(peerId2, options2.addressFilter ?? (async () => true), addresses, options2.existingPeer?.peerPB.addresses, options2),
    protocols: [...protocols2.values()].sort((a, b) => {
      return a.localeCompare(b);
    }),
    metadata,
    tags,
    publicKey: publicKey2,
    peerRecordEnvelope: peerRecordEnvelope2
  };
  output.addresses.forEach((addr) => {
    addr.observed = options2.existingPeer?.peerPB.addresses?.find((addr2) => equals(addr2.multiaddr, addr2.multiaddr))?.observed ?? Date.now();
  });
  if (peerId2.type !== "RSA") {
    delete output.publicKey;
  }
  return output;
}
function createSortedMap(entries, options2) {
  const output = /* @__PURE__ */ new Map();
  for (const [key, value7] of entries) {
    if (value7 == null) {
      continue;
    }
    options2.validate(key, value7);
  }
  for (const [key, value7] of entries.sort(([a], [b]) => {
    return a.localeCompare(b);
  })) {
    if (value7 != null) {
      output.set(key, options2.map?.(key, value7) ?? value7);
    }
  }
  return output;
}
function validateMetadata(key, value7) {
  if (typeof key !== "string") {
    throw new InvalidParametersError("Metadata key must be a string");
  }
  if (!(value7 instanceof Uint8Array)) {
    throw new InvalidParametersError("Metadata value must be a Uint8Array");
  }
}
function validateTag(key, tag) {
  if (typeof key !== "string") {
    throw new InvalidParametersError("Tag name must be a string");
  }
  if (tag.value != null) {
    if (parseInt(`${tag.value}`, 10) !== tag.value) {
      throw new InvalidParametersError("Tag value must be an integer");
    }
    if (tag.value < 0 || tag.value > 100) {
      throw new InvalidParametersError("Tag value must be between 0-100");
    }
  }
  if (tag.ttl != null) {
    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
      throw new InvalidParametersError("Tag ttl must be an integer");
    }
    if (tag.ttl < 0) {
      throw new InvalidParametersError("Tag ttl must be between greater than 0");
    }
  }
}
function mapTag(key, tag) {
  let expiry;
  if (tag.expiry != null) {
    expiry = tag.expiry;
  }
  if (tag.ttl != null) {
    expiry = BigInt(Date.now() + Number(tag.ttl));
  }
  const output = {
    value: tag.value ?? 0
  };
  if (expiry != null) {
    output.expiry = expiry;
  }
  return output;
}

// node_modules/@libp2p/peer-store/dist/src/store.js
function keyToPeerId(key) {
  const base32Str = key.toString().split("/")[2];
  const buf = CID7.parse(base32Str, base327);
  return peerIdFromCID(buf);
}
function decodePeer(key, value7, maxAddressAge) {
  const peerId2 = keyToPeerId(key);
  return bytesToPeer(peerId2, value7, maxAddressAge);
}
function mapQuery(query, maxAddressAge) {
  return {
    prefix: NAMESPACE_COMMON,
    filters: (query.filters ?? []).map((fn) => ({ key, value: value7 }) => {
      return fn(decodePeer(key, value7, maxAddressAge));
    }),
    orders: (query.orders ?? []).map((fn) => (a, b) => {
      return fn(decodePeer(a.key, a.value, maxAddressAge), decodePeer(b.key, b.value, maxAddressAge));
    })
  };
}
var PersistentStore = class {
  peerId;
  datastore;
  locks;
  addressFilter;
  log;
  maxAddressAge;
  maxPeerAge;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.peerId = components.peerId;
    this.datastore = components.datastore;
    this.addressFilter = init.addressFilter;
    this.locks = trackedPeerMap({
      name: "libp2p_peer_store_locks",
      metrics: components.metrics
    });
    this.maxAddressAge = init.maxAddressAge ?? MAX_ADDRESS_AGE;
    this.maxPeerAge = init.maxPeerAge ?? MAX_PEER_AGE;
  }
  getLock(peerId2) {
    let lock = this.locks.get(peerId2);
    if (lock == null) {
      lock = {
        refs: 0,
        lock: createMortice({
          name: peerId2.toString(),
          singleProcess: true
        })
      };
      this.locks.set(peerId2, lock);
    }
    lock.refs++;
    return lock;
  }
  maybeRemoveLock(peerId2, lock) {
    lock.refs--;
    if (lock.refs === 0) {
      lock.lock.finalize();
      this.locks.delete(peerId2);
    }
  }
  async getReadLock(peerId2, options2) {
    const lock = this.getLock(peerId2);
    try {
      const release = await lock.lock.readLock(options2);
      return () => {
        release();
        this.maybeRemoveLock(peerId2, lock);
      };
    } catch (err) {
      this.maybeRemoveLock(peerId2, lock);
      throw err;
    }
  }
  async getWriteLock(peerId2, options2) {
    const lock = this.getLock(peerId2);
    try {
      const release = await lock.lock.writeLock(options2);
      return () => {
        release();
        this.maybeRemoveLock(peerId2, lock);
      };
    } catch (err) {
      this.maybeRemoveLock(peerId2, lock);
      throw err;
    }
  }
  async has(peerId2, options2) {
    try {
      await this.load(peerId2, options2);
      return true;
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    return false;
  }
  async delete(peerId2, options2) {
    if (this.peerId.equals(peerId2)) {
      return;
    }
    await this.datastore.delete(peerIdToDatastoreKey(peerId2), options2);
  }
  async load(peerId2, options2) {
    const key = peerIdToDatastoreKey(peerId2);
    const buf = await this.datastore.get(key, options2);
    const peer = Peer.decode(buf);
    if (this.#peerIsExpired(peerId2, peer)) {
      await this.datastore.delete(key, options2);
      throw new NotFoundError();
    }
    return pbToPeer(peerId2, peer, this.peerId.equals(peerId2) ? Infinity : this.maxAddressAge);
  }
  async save(peerId2, data, options2) {
    const existingPeer = await this.#findExistingPeer(peerId2, options2);
    const peerPb = await toPeerPB(peerId2, data, "patch", {
      ...options2,
      addressFilter: this.addressFilter
    });
    return this.#saveIfDifferent(peerId2, peerPb, existingPeer);
  }
  async patch(peerId2, data, options2) {
    const existingPeer = await this.#findExistingPeer(peerId2, options2);
    const peerPb = await toPeerPB(peerId2, data, "patch", {
      ...options2,
      addressFilter: this.addressFilter,
      existingPeer
    });
    return this.#saveIfDifferent(peerId2, peerPb, existingPeer);
  }
  async merge(peerId2, data, options2) {
    const existingPeer = await this.#findExistingPeer(peerId2, options2);
    const peerPb = await toPeerPB(peerId2, data, "merge", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return this.#saveIfDifferent(peerId2, peerPb, existingPeer);
  }
  async *all(options2) {
    for await (const { key, value: value7 } of this.datastore.query(mapQuery(options2 ?? {}, this.maxAddressAge), options2)) {
      const peerId2 = keyToPeerId(key);
      if (peerId2.equals(this.peerId)) {
        continue;
      }
      const peer = Peer.decode(value7);
      if (this.#peerIsExpired(peerId2, peer)) {
        await this.datastore.delete(key, options2);
        continue;
      }
      yield pbToPeer(peerId2, peer, this.peerId.equals(peerId2) ? Infinity : this.maxAddressAge);
    }
  }
  async #findExistingPeer(peerId2, options2) {
    try {
      const key = peerIdToDatastoreKey(peerId2);
      const buf = await this.datastore.get(key, options2);
      const peerPB = Peer.decode(buf);
      if (this.#peerIsExpired(peerId2, peerPB)) {
        await this.datastore.delete(key, options2);
        throw new NotFoundError();
      }
      return {
        peerPB,
        peer: pbToPeer(peerId2, peerPB, this.maxAddressAge)
      };
    } catch (err) {
      if (err.name !== "NotFoundError") {
        this.log.error("invalid peer data found in peer store - %e", err);
      }
    }
  }
  async #saveIfDifferent(peerId2, peer, existingPeer, options2) {
    peer.updated = Date.now();
    const buf = Peer.encode(peer);
    await this.datastore.put(peerIdToDatastoreKey(peerId2), buf, options2);
    return {
      peer: pbToPeer(peerId2, peer, this.maxAddressAge),
      previous: existingPeer?.peer,
      updated: existingPeer == null || !peerEquals(peer, existingPeer.peerPB)
    };
  }
  #peerIsExpired(peerId2, peer) {
    if (peer.updated == null) {
      return true;
    }
    if (this.peerId.equals(peerId2)) {
      return false;
    }
    const expired = peer.updated < Date.now() - this.maxPeerAge;
    const minAddressObserved = Date.now() - this.maxAddressAge;
    const addrs = peer.addresses.filter((addr) => {
      return addr.observed != null && addr.observed > minAddressObserved;
    });
    return expired && addrs.length === 0;
  }
};

// node_modules/@libp2p/peer-store/dist/src/index.js
var PersistentPeerStore = class {
  store;
  events;
  peerId;
  log;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.events = components.events;
    this.peerId = components.peerId;
    this.store = new PersistentStore(components, init);
  }
  [Symbol.toStringTag] = "@libp2p/peer-store";
  async forEach(fn, query) {
    for await (const peer of this.store.all(query)) {
      fn(peer);
    }
  }
  async all(query) {
    return src_default8(this.store.all(query));
  }
  async delete(peerId2, options2) {
    const release = await this.store.getReadLock(peerId2, options2);
    try {
      await this.store.delete(peerId2, options2);
    } finally {
      release();
    }
  }
  async has(peerId2, options2) {
    const release = await this.store.getReadLock(peerId2, options2);
    try {
      return await this.store.has(peerId2, options2);
    } finally {
      this.log.trace("has release read lock");
      release?.();
    }
  }
  async get(peerId2, options2) {
    const release = await this.store.getReadLock(peerId2, options2);
    try {
      return await this.store.load(peerId2, options2);
    } finally {
      release?.();
    }
  }
  async getInfo(peerId2, options2) {
    const peer = await this.get(peerId2, options2);
    return {
      id: peer.id,
      multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
    };
  }
  async save(id, data, options2) {
    const release = await this.store.getWriteLock(id, options2);
    try {
      const result = await this.store.save(id, data, options2);
      this.#emitIfUpdated(id, result);
      return result.peer;
    } finally {
      release?.();
    }
  }
  async patch(id, data, options2) {
    const release = await this.store.getWriteLock(id, options2);
    try {
      const result = await this.store.patch(id, data, options2);
      this.#emitIfUpdated(id, result);
      return result.peer;
    } finally {
      release?.();
    }
  }
  async merge(id, data, options2) {
    const release = await this.store.getWriteLock(id, options2);
    try {
      const result = await this.store.merge(id, data, options2);
      this.#emitIfUpdated(id, result);
      return result.peer;
    } finally {
      release?.();
    }
  }
  async consumePeerRecord(buf, arg1, arg2) {
    const expectedPeer = isPeerId(arg1) ? arg1 : isPeerId(arg1?.expectedPeer) ? arg1.expectedPeer : void 0;
    const options2 = isPeerId(arg1) ? arg2 : arg1 === void 0 ? arg2 : arg1;
    const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord2.DOMAIN, options2);
    const peerId2 = peerIdFromCID(envelope.publicKey.toCID());
    if (expectedPeer?.equals(peerId2) === false) {
      this.log("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, peerId2);
      return false;
    }
    const peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    let peer;
    try {
      peer = await this.get(peerId2, options2);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if (peer?.peerRecordEnvelope != null) {
      const storedEnvelope = RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
      const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
      if (storedRecord.seqNumber >= peerRecord.seqNumber) {
        this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
        return false;
      }
    }
    await this.patch(peerRecord.peerId, {
      peerRecordEnvelope: buf,
      addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }))
    }, options2);
    return true;
  }
  #emitIfUpdated(id, result) {
    if (!result.updated) {
      return;
    }
    if (this.peerId.equals(id)) {
      this.events.safeDispatchEvent("self:peer:update", { detail: result });
    } else {
      this.events.safeDispatchEvent("peer:update", { detail: result });
    }
  }
};
function persistentPeerStore(components, init = {}) {
  return new PersistentPeerStore(components, init);
}

// node_modules/libp2p/node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
var code9 = (code17) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component == null) {
        return false;
      }
      if (component.code !== code17) {
        return false;
      }
      if (component.value != null) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var value = (code17, value7) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component?.code !== code17) {
        return false;
      }
      if (component.value == null) {
        return false;
      }
      if (value7 != null && component.value !== value7) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var optional2 = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    }
  };
};
var or13 = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    }
  };
};
var and2 = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    }
  };
};
function fmt2(...matchers) {
  function match(ma) {
    if (ma == null) {
      return false;
    }
    let parts = ma.getComponents();
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matchers,
    matches,
    exactMatch
  };
}

// node_modules/libp2p/node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var _PEER_ID2 = value(CODE_P2P);
var PEER_ID2 = fmt2(_PEER_ID2);
var _DNS42 = value(CODE_DNS4);
var _DNS62 = value(CODE_DNS6);
var _DNSADDR2 = value(CODE_DNSADDR);
var _DNS2 = value(CODE_DNS);
var DNS42 = fmt2(_DNS42, optional2(value(CODE_P2P)));
var DNS62 = fmt2(_DNS62, optional2(value(CODE_P2P)));
var DNSADDR2 = fmt2(_DNSADDR2, optional2(value(CODE_P2P)));
var DNS3 = fmt2(or13(_DNS2, _DNSADDR2, _DNS42, _DNS62), optional2(value(CODE_P2P)));
var _IP42 = and2(value(CODE_IP4), optional2(value(CODE_IPCIDR)));
var _IP62 = and2(optional2(value(CODE_IP6ZONE)), value(CODE_IP6), optional2(value(CODE_IPCIDR)));
var _IP2 = or13(_IP42, _IP62);
var _IP_OR_DOMAIN2 = or13(_IP2, _DNS2, _DNS42, _DNS62, _DNSADDR2);
var IP_OR_DOMAIN2 = fmt2(or13(_IP2, and2(or13(_DNS2, _DNSADDR2, _DNS42, _DNS62), optional2(value(CODE_P2P)))));
var IP42 = fmt2(_IP42);
var IP62 = fmt2(_IP62);
var IP2 = fmt2(_IP2);
var _TCP2 = and2(_IP_OR_DOMAIN2, value(CODE_TCP));
var _UDP2 = and2(_IP_OR_DOMAIN2, value(CODE_UDP));
var TCP2 = fmt2(and2(_TCP2, optional2(value(CODE_P2P))));
var UDP2 = fmt2(_UDP2);
var _QUIC2 = and2(_UDP2, code9(CODE_QUIC), optional2(value(CODE_P2P)));
var _QUIC_V1 = and2(_UDP2, code9(CODE_QUIC_V1), optional2(value(CODE_P2P)));
var QUIC_V0_OR_V12 = or13(_QUIC2, _QUIC_V1);
var QUIC2 = fmt2(_QUIC2);
var QUIC_V1 = fmt2(_QUIC_V1);
var _WEB2 = or13(_IP_OR_DOMAIN2, _TCP2, _UDP2, _QUIC2, _QUIC_V1);
var _WebSockets2 = or13(and2(_WEB2, code9(CODE_WS), optional2(value(CODE_P2P))));
var WebSockets2 = fmt2(_WebSockets2);
var _WebSocketsSecure2 = or13(and2(_WEB2, code9(CODE_WSS), optional2(value(CODE_P2P))), and2(_WEB2, code9(CODE_TLS), optional2(value(CODE_SNI)), code9(CODE_WS), optional2(value(CODE_P2P))));
var WebSocketsSecure2 = fmt2(_WebSocketsSecure2);
var _WebRTCDirect2 = and2(_UDP2, code9(CODE_WEBRTC_DIRECT), optional2(value(CODE_CERTHASH)), optional2(value(CODE_CERTHASH)), optional2(value(CODE_P2P)));
var WebRTCDirect2 = fmt2(_WebRTCDirect2);
var _WebTransport2 = and2(_QUIC_V1, code9(CODE_WEBTRANSPORT), optional2(value(CODE_CERTHASH)), optional2(value(CODE_CERTHASH)), optional2(value(CODE_P2P)));
var WebTransport2 = fmt2(_WebTransport2);
var _P2P2 = or13(_WebSockets2, _WebSocketsSecure2, and2(_TCP2, optional2(value(CODE_P2P))), and2(QUIC_V0_OR_V12, optional2(value(CODE_P2P))), and2(_IP_OR_DOMAIN2, optional2(value(CODE_P2P))), _WebRTCDirect2, _WebTransport2, value(CODE_P2P));
var P2P3 = fmt2(_P2P2);
var _Circuit2 = and2(_P2P2, code9(CODE_P2P_CIRCUIT), value(CODE_P2P));
var Circuit2 = fmt2(_Circuit2);
var _WebRTC2 = or13(and2(_P2P2, code9(CODE_P2P_CIRCUIT), code9(CODE_WEBRTC), optional2(value(CODE_P2P))), and2(_P2P2, code9(CODE_WEBRTC), optional2(value(CODE_P2P))), and2(code9(CODE_WEBRTC), optional2(value(CODE_P2P))));
var WebRTC2 = fmt2(_WebRTC2);
var _HTTP2 = or13(and2(_IP_OR_DOMAIN2, value(CODE_TCP), code9(CODE_HTTP), optional2(value(CODE_P2P))), and2(_IP_OR_DOMAIN2, code9(CODE_HTTP), optional2(value(CODE_P2P))));
var HTTP2 = fmt2(_HTTP2);
var _HTTPS2 = and2(_IP_OR_DOMAIN2, or13(and2(value(CODE_TCP, "443"), code9(CODE_HTTP)), and2(value(CODE_TCP), code9(CODE_HTTPS)), and2(value(CODE_TCP), code9(CODE_TLS), code9(CODE_HTTP)), and2(code9(CODE_TLS), code9(CODE_HTTP)), code9(CODE_TLS), code9(CODE_HTTPS)), optional2(value(CODE_P2P)));
var HTTPS2 = fmt2(_HTTPS2);
var _Memory2 = or13(and2(value(CODE_MEMORY), optional2(value(CODE_P2P))));
var Memory2 = fmt2(_Memory2);
var _Unix2 = or13(and2(value(CODE_UNIX), optional2(value(CODE_P2P))));
var Unix2 = fmt2(_Unix2);

// node_modules/libp2p/dist/src/address-manager/dns-mappings.js
var MAX_DATE = 864e13;
var CODEC_TLS = 448;
var CODEC_SNI = 449;
var CODEC_DNS = 53;
var CODEC_DNS4 = 54;
var CODEC_DNS6 = 55;
var CODEC_DNSADDR = 56;
var DNSMappings = class {
  log;
  mappings;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:address-manager:dns-mappings");
    this.mappings = trackedMap({
      name: "libp2p_address_manager_dns_mappings",
      metrics: components.metrics
    });
  }
  has(ma) {
    const host = this.findHost(ma);
    for (const mapping of this.mappings.values()) {
      if (mapping.domain === host) {
        return true;
      }
    }
    return false;
  }
  add(domain, addresses) {
    addresses.forEach((ip) => {
      this.log("add DNS mapping %s to %s", ip, domain);
      const verified = isPrivateIp(ip) === true;
      this.mappings.set(ip, {
        domain,
        verified,
        expires: verified ? MAX_DATE - Date.now() : 0,
        lastVerified: verified ? MAX_DATE - Date.now() : void 0
      });
    });
  }
  remove(ma) {
    const host = this.findHost(ma);
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("removing %s to %s DNS mapping %e", ip, mapping.domain, new Error("where"));
        this.mappings.delete(ip);
        wasConfident = wasConfident || mapping.verified;
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const dnsMappedAddresses = [];
    for (let i = 0; i < addresses.length; i++) {
      const address = addresses[i];
      const tuples = address.multiaddr.stringTuples();
      const host = tuples[0][1];
      if (host == null) {
        continue;
      }
      for (const [ip, mapping] of this.mappings.entries()) {
        if (host !== ip) {
          continue;
        }
        const mappedIp = this.maybeAddSNITuple(tuples, mapping.domain);
        if (mappedIp) {
          addresses.splice(i, 1);
          i--;
          dnsMappedAddresses.push({
            multiaddr: multiaddr(`/${tuples.map((tuple) => {
              return [
                protocols(tuple[0]).name,
                tuple[1]
              ].join("/");
            }).join("/")}`),
            verified: mapping.verified,
            type: "dns-mapping",
            expires: mapping.expires,
            lastVerified: mapping.lastVerified
          });
        }
      }
    }
    return dnsMappedAddresses;
  }
  maybeAddSNITuple(tuples, domain) {
    for (let j = 0; j < tuples.length; j++) {
      if (tuples[j][0] === CODEC_TLS && tuples[j + 1]?.[0] !== CODEC_SNI) {
        tuples.splice(j + 1, 0, [CODEC_SNI, domain]);
        return true;
      }
    }
    return false;
  }
  confirm(ma, ttl) {
    const host = this.findHost(ma);
    let startingConfidence = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("marking %s to %s DNS mapping as verified", ip, mapping.domain);
        startingConfidence = mapping.verified;
        mapping.verified = true;
        mapping.expires = Date.now() + ttl;
        mapping.lastVerified = Date.now();
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const host = this.findHost(ma);
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("removing verification of %s to %s DNS mapping", ip, mapping.domain);
        wasConfident = wasConfident || mapping.verified;
        mapping.verified = false;
        mapping.expires = Date.now() + ttl;
      }
    }
    return wasConfident;
  }
  findHost(ma) {
    for (const tuple of ma.stringTuples()) {
      if (tuple[0] === CODEC_SNI) {
        return tuple[1];
      }
      if (tuple[0] === CODEC_DNS || tuple[0] === CODEC_DNS4 || tuple[0] === CODEC_DNS6 || tuple[0] === CODEC_DNSADDR) {
        return tuple[1];
      }
    }
  }
};

// node_modules/libp2p/dist/src/address-manager/ip-mappings.js
var CODEC_IP4 = 4;
var CODEC_IP6 = 41;
var CODEC_TCP = 6;
var CODEC_UDP = 273;
var IPMappings = class {
  log;
  mappings;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:address-manager:ip-mappings");
    this.mappings = trackedMap({
      name: "libp2p_address_manager_ip_mappings",
      metrics: components.metrics
    });
  }
  has(ma) {
    const tuples = ma.stringTuples();
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === tuples[0][1]) {
          return true;
        }
      }
    }
    return false;
  }
  add(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    const key = `${internalIp}-${internalPort}-${protocol}`;
    const mappings = this.mappings.get(key) ?? [];
    const mapping = {
      internalIp,
      internalPort,
      externalIp,
      externalPort,
      externalFamily: isIPv4(externalIp) ? 4 : 6,
      protocol,
      verified: false,
      expires: 0
    };
    mappings.push(mapping);
    this.mappings.set(key, mappings);
  }
  remove(ma) {
    const tuples = ma.stringTuples();
    const host = tuples[0][1] ?? "";
    const protocol = tuples[1][0] === CODEC_TCP ? "tcp" : "udp";
    const port = parseInt(tuples[1][1] ?? "0");
    let wasConfident = false;
    for (const [key, mappings] of this.mappings.entries()) {
      for (let i = 0; i < mappings.length; i++) {
        const mapping = mappings[i];
        if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {
          this.log("removing %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, host, port, protocol);
          wasConfident = wasConfident || mapping.verified;
          mappings.splice(i, 1);
          i--;
        }
      }
      if (mappings.length === 0) {
        this.mappings.delete(key);
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const ipMappedAddresses = [];
    for (const { multiaddr: ma } of addresses) {
      const tuples = ma.stringTuples();
      let tuple;
      if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_TCP) {
        tuple = `${tuples[0][1]}-${tuples[1][1]}-tcp`;
      } else if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_UDP) {
        tuple = `${tuples[0][1]}-${tuples[1][1]}-udp`;
      }
      if (tuple == null) {
        continue;
      }
      const mappings = this.mappings.get(tuple);
      if (mappings == null) {
        continue;
      }
      for (const mapping of mappings) {
        tuples[0][0] = mapping.externalFamily === 4 ? CODEC_IP4 : CODEC_IP6;
        tuples[0][1] = mapping.externalIp;
        tuples[1][1] = `${mapping.externalPort}`;
        ipMappedAddresses.push({
          multiaddr: multiaddr(`/${tuples.map((tuple2) => {
            return [
              protocols(tuple2[0]).name,
              tuple2[1]
            ].join("/");
          }).join("/")}`),
          verified: mapping.verified,
          type: "ip-mapping",
          expires: mapping.expires,
          lastVerified: mapping.lastVerified
        });
      }
    }
    return ipMappedAddresses;
  }
  confirm(ma, ttl) {
    const tuples = ma.stringTuples();
    const host = tuples[0][1];
    let startingConfidence = false;
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === host) {
          this.log("marking %s to %s IP mapping as verified", mapping.internalIp, mapping.externalIp);
          startingConfidence = mapping.verified;
          mapping.verified = true;
          mapping.expires = Date.now() + ttl;
          mapping.lastVerified = Date.now();
        }
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const tuples = ma.stringTuples();
    const host = tuples[0][1] ?? "";
    const protocol = tuples[1][0] === CODEC_TCP ? "tcp" : "udp";
    const port = parseInt(tuples[1][1] ?? "0");
    let wasConfident = false;
    for (const mappings of this.mappings.values()) {
      for (let i = 0; i < mappings.length; i++) {
        const mapping = mappings[i];
        if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {
          this.log("removing verification of %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, host, port, protocol);
          wasConfident = wasConfident || mapping.verified;
          mapping.verified = false;
          mapping.expires = Date.now() + ttl;
        }
      }
    }
    return wasConfident;
  }
};

// node_modules/@libp2p/utils/dist/src/multiaddr/is-link-local.js
function isLinkLocal(ma) {
  try {
    for (const { code: code17, value: value7 } of ma.getComponents()) {
      if (code17 === CODE_IP6ZONE) {
        continue;
      }
      if (value7 == null) {
        continue;
      }
      if (code17 === CODE_IP4) {
        return value7.startsWith("169.254.");
      }
      if (code17 === CODE_IP6) {
        return value7.toLowerCase().startsWith("fe80");
      }
    }
  } catch {
  }
  return false;
}

// node_modules/@libp2p/utils/dist/src/multiaddr/is-ip-based.js
function isIpBased(ma) {
  try {
    for (const { code: code17 } of ma.getComponents()) {
      if (code17 === CODE_IP6ZONE) {
        continue;
      }
      return code17 === CODE_IP4 || code17 === CODE_IP6;
    }
  } catch {
  }
  return false;
}

// node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
function isPrivate(ma) {
  try {
    if (!isIpBased(ma)) {
      return false;
    }
    const [[, value7]] = ma.stringTuples();
    if (value7 == null) {
      return false;
    }
    return isPrivateIp(value7) ?? false;
  } catch {
  }
  return true;
}

// node_modules/libp2p/dist/src/address-manager/observed-addresses.js
var defaultValues2 = {
  maxObservedAddresses: 10
};
var ObservedAddresses = class {
  log;
  addresses;
  maxObservedAddresses;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = trackedMap({
      name: "libp2p_address_manager_observed_addresses",
      metrics: components.metrics
    });
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues2.maxObservedAddresses;
  }
  has(ma) {
    return this.addresses.has(ma.toString());
  }
  removePrefixed(prefix) {
    for (const key of this.addresses.keys()) {
      if (key.toString().startsWith(prefix)) {
        this.addresses.delete(key);
      }
    }
  }
  add(ma) {
    if (this.addresses.size === this.maxObservedAddresses) {
      return;
    }
    if (isPrivate(ma) || isLinkLocal(ma)) {
      return;
    }
    this.log("adding observed address %a", ma);
    this.addresses.set(ma.toString(), {
      verified: false,
      expires: 0
    });
  }
  getAll() {
    return Array.from(this.addresses).map(([ma, metadata]) => ({
      multiaddr: multiaddr(ma),
      verified: metadata.verified,
      type: "observed",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    }));
  }
  remove(ma) {
    const startingConfidence = this.addresses.get(ma.toString())?.verified ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(ma.toString());
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const addrString = ma.toString();
    const metadata = this.addresses.get(addrString) ?? {
      verified: false,
      expires: Date.now() + ttl,
      lastVerified: Date.now()
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.log("marking observed address %a as verified", addrString);
    this.addresses.set(addrString, metadata);
    return startingConfidence;
  }
};

// node_modules/@libp2p/utils/dist/src/multiaddr/is-network-address.js
var NETWORK_CODECS = [
  CODE_IP4,
  CODE_IP6,
  CODE_DNS,
  CODE_DNS4,
  CODE_DNS6,
  CODE_DNSADDR
];
function isNetworkAddress(ma) {
  try {
    for (const { code: code17 } of ma.getComponents()) {
      if (code17 === CODE_IP6ZONE) {
        continue;
      }
      return NETWORK_CODECS.includes(code17);
    }
  } catch {
  }
  return false;
}

// node_modules/libp2p/dist/src/address-manager/transport-addresses.js
var defaultValues3 = {
  maxObservedAddresses: 10
};
var TransportAddresses = class {
  log;
  addresses;
  maxObservedAddresses;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = trackedMap({
      name: "libp2p_address_manager_transport_addresses",
      metrics: components.metrics
    });
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues3.maxObservedAddresses;
  }
  get(multiaddr2, ttl) {
    if (isPrivate(multiaddr2)) {
      return {
        multiaddr: multiaddr2,
        verified: true,
        type: "transport",
        expires: Date.now() + ttl,
        lastVerified: Date.now()
      };
    }
    const key = this.toKey(multiaddr2);
    let metadata = this.addresses.get(key);
    if (metadata == null) {
      metadata = {
        verified: !isNetworkAddress(multiaddr2),
        expires: 0
      };
      this.addresses.set(key, metadata);
    }
    return {
      multiaddr: multiaddr2,
      verified: metadata.verified,
      type: "transport",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    };
  }
  has(ma) {
    const key = this.toKey(ma);
    return this.addresses.has(key);
  }
  remove(ma) {
    const key = this.toKey(ma);
    const startingConfidence = this.addresses.get(key)?.verified ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(key);
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const key = this.toKey(ma);
    const metadata = this.addresses.get(key) ?? {
      verified: false,
      expires: 0,
      lastVerified: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.addresses.set(key, metadata);
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const key = this.toKey(ma);
    const metadata = this.addresses.get(key) ?? {
      verified: false,
      expires: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = false;
    metadata.expires = Date.now() + ttl;
    this.addresses.set(key, metadata);
    return startingConfidence;
  }
  toKey(ma) {
    if (isNetworkAddress(ma)) {
      const options2 = ma.toOptions();
      return `${options2.host}-${options2.port}-${options2.transport}`;
    }
    return ma.toString();
  }
};

// node_modules/libp2p/dist/src/address-manager/index.js
var ONE_MINUTE = 6e4;
var defaultValues4 = {
  maxObservedAddresses: 10,
  addressVerificationTTL: ONE_MINUTE * 10,
  addressVerificationRetry: ONE_MINUTE * 5
};
var defaultAddressFilter = (addrs) => addrs;
function stripPeerId(ma, peerId2) {
  const observedPeerIdStr = ma.getPeerId();
  if (observedPeerIdStr != null) {
    const observedPeerId = peerIdFromString(observedPeerIdStr);
    if (observedPeerId.equals(peerId2)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId2.toString()}`));
    }
  }
  return ma;
}
var AddressManager = class {
  log;
  components;
  // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
  listen;
  announce;
  appendAnnounce;
  announceFilter;
  observed;
  dnsMappings;
  ipMappings;
  transportAddresses;
  observedAddressFilter;
  addressVerificationTTL;
  addressVerificationRetry;
  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   */
  constructor(components, init = {}) {
    const { listen = [], announce = [], appendAnnounce = [] } = init;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:address-manager");
    this.listen = listen.map((ma) => ma.toString());
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.appendAnnounce = new Set(appendAnnounce.map((ma) => ma.toString()));
    this.observed = new ObservedAddresses(components, init);
    this.dnsMappings = new DNSMappings(components, init);
    this.ipMappings = new IPMappings(components, init);
    this.transportAddresses = new TransportAddresses(components, init);
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
    this.observedAddressFilter = createScalableCuckooFilter(1024);
    this.addressVerificationTTL = init.addressVerificationTTL ?? defaultValues4.addressVerificationTTL;
    this.addressVerificationRetry = init.addressVerificationRetry ?? defaultValues4.addressVerificationRetry;
    this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1e3);
    components.events.addEventListener("transport:listening", () => {
      this._updatePeerStoreAddresses();
    });
    components.events.addEventListener("transport:close", () => {
      this._updatePeerStoreAddresses();
    });
  }
  [Symbol.toStringTag] = "@libp2p/address-manager";
  _updatePeerStoreAddresses() {
    const addrs = this.getAddresses().map((ma) => {
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
      }
      return ma;
    });
    this.components.peerStore.patch(this.components.peerId, {
      multiaddrs: addrs
    }).catch((err) => {
      this.log.error("error updating addresses", err);
    });
  }
  /**
   * Get peer listen multiaddrs
   */
  getListenAddrs() {
    return Array.from(this.listen).map((a) => multiaddr(a));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a) => multiaddr(a));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAppendAnnounceAddrs() {
    return Array.from(this.appendAnnounce).map((a) => multiaddr(a));
  }
  /**
   * Get observed multiaddrs
   */
  getObservedAddrs() {
    return this.observed.getAll().map((addr) => addr.multiaddr);
  }
  /**
   * Add peer observed addresses
   */
  addObservedAddr(addr) {
    const tuples = addr.stringTuples();
    const socketAddress = `${tuples[0][1]}:${tuples[1][1]}`;
    if (this.observedAddressFilter.has(socketAddress)) {
      return;
    }
    this.observedAddressFilter.add(socketAddress);
    addr = stripPeerId(addr, this.components.peerId);
    if (this.ipMappings.has(addr)) {
      return;
    }
    if (this.dnsMappings.has(addr)) {
      return;
    }
    this.observed.add(addr);
  }
  confirmObservedAddr(addr, options2) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = true;
    if (options2?.type === "transport" || this.transportAddresses.has(addr)) {
      const transportStartingConfidence = this.transportAddresses.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
      if (!transportStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (options2?.type === "dns-mapping" || this.dnsMappings.has(addr)) {
      const dnsMappingStartingConfidence = this.dnsMappings.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
      if (!dnsMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (options2?.type === "ip-mapping" || this.ipMappings.has(addr)) {
      const ipMappingStartingConfidence = this.ipMappings.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
      if (!ipMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (options2?.type === "observed" || this.observed.has(addr)) {
      if (this.maybeUpgradeToIPMapping(addr)) {
        this.ipMappings.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
        startingConfidence = false;
      } else {
        const observedStartingConfidence = this.observed.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
        if (!observedStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
    }
    if (!startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  removeObservedAddr(addr, options2) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = false;
    if (this.observed.has(addr)) {
      const observedStartingConfidence = this.observed.remove(addr);
      if (!observedStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.transportAddresses.has(addr)) {
      const transportStartingConfidence = this.transportAddresses.unconfirm(addr, options2?.ttl ?? this.addressVerificationRetry);
      if (!transportStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.dnsMappings.has(addr)) {
      const dnsMappingStartingConfidence = this.dnsMappings.unconfirm(addr, options2?.ttl ?? this.addressVerificationRetry);
      if (!dnsMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.ipMappings.has(addr)) {
      const ipMappingStartingConfidence = this.ipMappings.unconfirm(addr, options2?.ttl ?? this.addressVerificationRetry);
      if (!ipMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  getAddresses() {
    const addresses = /* @__PURE__ */ new Set();
    const multiaddrs = this.getAddressesWithMetadata().filter((addr) => {
      if (!addr.verified) {
        return false;
      }
      const maStr = addr.multiaddr.toString();
      if (addresses.has(maStr)) {
        return false;
      }
      addresses.add(maStr);
      return true;
    }).map((address) => address.multiaddr);
    return this.announceFilter(multiaddrs.map((str) => {
      const ma = multiaddr(str);
      const lastComponent = ma.getComponents().pop();
      if (lastComponent?.value === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    }));
  }
  getAddressesWithMetadata() {
    const announceMultiaddrs = this.getAnnounceAddrs();
    if (announceMultiaddrs.length > 0) {
      this.components.transportManager.getListeners().forEach((listener) => {
        listener.updateAnnounceAddrs(announceMultiaddrs);
      });
      return announceMultiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        verified: true,
        type: "announce",
        expires: Date.now() + this.addressVerificationTTL,
        lastVerified: Date.now()
      }));
    }
    let addresses = [];
    addresses = addresses.concat(this.components.transportManager.getAddrs().map((multiaddr2) => this.transportAddresses.get(multiaddr2, this.addressVerificationTTL)));
    const appendAnnounceMultiaddrs = this.getAppendAnnounceAddrs();
    if (appendAnnounceMultiaddrs.length > 0) {
      this.components.transportManager.getListeners().forEach((listener) => {
        listener.updateAnnounceAddrs(appendAnnounceMultiaddrs);
      });
      addresses = addresses.concat(appendAnnounceMultiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        verified: true,
        type: "announce",
        expires: Date.now() + this.addressVerificationTTL,
        lastVerified: Date.now()
      })));
    }
    addresses = addresses.concat(this.observed.getAll());
    addresses = addresses.concat(this.ipMappings.getAll(addresses));
    addresses = addresses.concat(this.dnsMappings.getAll(addresses));
    return addresses;
  }
  addDNSMapping(domain, addresses) {
    this.dnsMappings.add(domain, addresses);
  }
  removeDNSMapping(domain) {
    if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  addPublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol);
    this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`);
  }
  removePublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  /**
   * Where an external service (router, gateway, etc) is forwarding traffic to
   * us, attempt to add an IP mapping for the external address - this will
   * include the observed mapping in the address list where we also have a DNS
   * mapping for the external IP.
   *
   * Returns true if we added a new mapping
   */
  maybeUpgradeToIPMapping(ma) {
    if (this.ipMappings.has(ma)) {
      return false;
    }
    const maOptions = ma.toOptions();
    if (maOptions.family === 6 || maOptions.host === "127.0.0.1" || isPrivateIp(maOptions.host) === true) {
      return false;
    }
    const listeners = this.components.transportManager.getListeners();
    const transportMatchers = [
      (ma2) => WebSockets2.exactMatch(ma2) || WebSocketsSecure2.exactMatch(ma2),
      (ma2) => TCP2.exactMatch(ma2),
      (ma2) => QUIC_V1.exactMatch(ma2)
    ];
    for (const matcher of transportMatchers) {
      if (!matcher(ma)) {
        continue;
      }
      const transportListeners = listeners.filter((listener) => {
        return listener.getAddrs().filter((ma2) => {
          return ma2.toOptions().family === 4 && matcher(ma2);
        }).length > 0;
      });
      if (transportListeners.length !== 1) {
        continue;
      }
      const linkLocalAddr = transportListeners[0].getAddrs().filter((ma2) => {
        return ma2.toOptions().host !== "127.0.0.1";
      }).pop();
      if (linkLocalAddr == null) {
        continue;
      }
      const linkLocalOptions = linkLocalAddr.toOptions();
      this.observed.remove(ma);
      this.ipMappings.add(linkLocalOptions.host, linkLocalOptions.port, maOptions.host, maOptions.port, maOptions.transport);
      return true;
    }
    return false;
  }
};

// node_modules/libp2p/dist/src/errors.js
var messages;
(function(messages2) {
  messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages2["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
var MissingServiceError = class extends Error {
  constructor(message2 = "Missing service") {
    super(message2);
    this.name = "MissingServiceError";
  }
};
var UnmetServiceDependenciesError = class extends Error {
  constructor(message2 = "Unmet service dependencies") {
    super(message2);
    this.name = "UnmetServiceDependenciesError";
  }
};
var NoContentRoutersError = class extends Error {
  constructor(message2 = "No content routers available") {
    super(message2);
    this.name = "NoContentRoutersError";
  }
};
var NoPeerRoutersError = class extends Error {
  constructor(message2 = "No peer routers available") {
    super(message2);
    this.name = "NoPeerRoutersError";
  }
};
var QueriedForSelfError = class extends Error {
  constructor(message2 = "Should not try to find self") {
    super(message2);
    this.name = "QueriedForSelfError";
  }
};
var UnhandledProtocolError = class extends Error {
  constructor(message2 = "Unhandled protocol error") {
    super(message2);
    this.name = "UnhandledProtocolError";
  }
};
var DuplicateProtocolHandlerError = class extends Error {
  constructor(message2 = "Duplicate protocol handler error") {
    super(message2);
    this.name = "DuplicateProtocolHandlerError";
  }
};
var DialDeniedError = class extends Error {
  constructor(message2 = "Dial denied error") {
    super(message2);
    this.name = "DialDeniedError";
  }
};
var UnsupportedListenAddressError = class extends Error {
  constructor(message2 = "No transport was configured to listen on this address") {
    super(message2);
    this.name = "UnsupportedListenAddressError";
  }
};
var UnsupportedListenAddressesError = class extends Error {
  constructor(message2 = "Configured listen addresses could not be listened on") {
    super(message2);
    this.name = "UnsupportedListenAddressesError";
  }
};
var NoValidAddressesError = class extends Error {
  constructor(message2 = "No valid addresses") {
    super(message2);
    this.name = "NoValidAddressesError";
  }
};
var ConnectionInterceptedError = class extends Error {
  constructor(message2 = "Connection intercepted") {
    super(message2);
    this.name = "ConnectionInterceptedError";
  }
};
var ConnectionDeniedError = class extends Error {
  constructor(message2 = "Connection denied") {
    super(message2);
    this.name = "ConnectionDeniedError";
  }
};
var MuxerUnavailableError = class extends Error {
  constructor(message2 = "Stream is not multiplexed") {
    super(message2);
    this.name = "MuxerUnavailableError";
  }
};
var EncryptionFailedError = class extends Error {
  constructor(message2 = "Encryption failed") {
    super(message2);
    this.name = "EncryptionFailedError";
  }
};
var TransportUnavailableError = class extends Error {
  constructor(message2 = "Transport unavailable") {
    super(message2);
    this.name = "TransportUnavailableError";
  }
};
var RecursionLimitError = class extends Error {
  constructor(message2 = "Max recursive depth reached") {
    super(message2);
    this.name = "RecursionLimitError";
  }
};

// node_modules/libp2p/dist/src/components.js
var DefaultComponents = class {
  components = {};
  _started = false;
  constructor(init = {}) {
    this.components = {};
    for (const [key, value7] of Object.entries(init)) {
      this.components[key] = value7;
    }
    if (this.components.logger == null) {
      this.components.logger = defaultLogger();
    }
  }
  isStarted() {
    return this._started;
  }
  async _invokeStartableMethod(methodName) {
    await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable[methodName]?.();
    }));
  }
  async beforeStart() {
    await this._invokeStartableMethod("beforeStart");
  }
  async start() {
    await this._invokeStartableMethod("start");
    this._started = true;
  }
  async afterStart() {
    await this._invokeStartableMethod("afterStart");
  }
  async beforeStop() {
    await this._invokeStartableMethod("beforeStop");
  }
  async stop() {
    await this._invokeStartableMethod("stop");
    this._started = false;
  }
  async afterStop() {
    await this._invokeStartableMethod("afterStop");
  }
};
var OPTIONAL_SERVICES = [
  "metrics",
  "connectionProtector",
  "dns"
];
var NON_SERVICE_PROPERTIES = [
  "components",
  "isStarted",
  "beforeStart",
  "start",
  "afterStart",
  "beforeStop",
  "stop",
  "afterStop",
  "then",
  "_invokeStartableMethod"
];
function defaultComponents(init = {}) {
  const components = new DefaultComponents(init);
  const proxy = new Proxy(components, {
    get(target, prop, receiver) {
      if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
        const service = components.components[prop];
        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
          throw new MissingServiceError(`${prop} not set`);
        }
        return service;
      }
      return Reflect.get(target, prop, receiver);
    },
    set(target, prop, value7) {
      if (typeof prop === "string") {
        components.components[prop] = value7;
      } else {
        Reflect.set(target, prop, value7);
      }
      return true;
    }
  });
  return proxy;
}
function checkServiceDependencies(components) {
  const serviceCapabilities2 = {};
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceCapabilities(service)) {
      serviceCapabilities2[capability] = true;
    }
  }
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceDependencies(service)) {
      if (serviceCapabilities2[capability] !== true) {
        throw new UnmetServiceDependenciesError(`Service "${getServiceName(service)}" required capability "${capability}" but it was not provided by any component, you may need to add additional configuration when creating your node.`);
      }
    }
  }
}
function getServiceCapabilities(service) {
  if (Array.isArray(service?.[serviceCapabilities])) {
    return service[serviceCapabilities];
  }
  return [];
}
function getServiceDependencies(service) {
  if (Array.isArray(service?.[serviceDependencies])) {
    return service[serviceDependencies];
  }
  return [];
}
function getServiceName(service) {
  return service?.[Symbol.toStringTag] ?? service?.toString() ?? "unknown";
}

// node_modules/libp2p/dist/src/config/connection-gater.browser.js
var CODEC_IP42 = 4;
var CODEC_IP62 = 41;
function connectionGater(gater = {}) {
  return {
    denyDialPeer: async () => false,
    denyDialMultiaddr: async (multiaddr2) => {
      if (WebSockets2.matches(multiaddr2)) {
        return false;
      }
      const tuples = multiaddr2.stringTuples();
      if (tuples[0][0] === CODEC_IP42 || tuples[0][0] === CODEC_IP62) {
        return Boolean(isPrivateIp(`${tuples[0][1]}`));
      }
      return false;
    },
    denyInboundConnection: async () => false,
    denyOutboundConnection: async () => false,
    denyInboundEncryptedConnection: async () => false,
    denyOutboundEncryptedConnection: async () => false,
    denyInboundUpgradedConnection: async () => false,
    denyOutboundUpgradedConnection: async () => false,
    filterMultiaddrForPeer: async () => true,
    ...gater
  };
}

// node_modules/delay/index.js
var createAbortError = () => {
  const error = new Error("Delay aborted");
  error.name = "AbortError";
  return error;
};
var clearMethods = /* @__PURE__ */ new WeakMap();
function createDelay({ clearTimeout: defaultClear, setTimeout: defaultSet } = {}) {
  return (milliseconds, { value: value7, signal } = {}) => {
    if (signal?.aborted) {
      return Promise.reject(createAbortError());
    }
    let timeoutId;
    let settle;
    let rejectFunction;
    const clear = defaultClear ?? clearTimeout;
    const signalListener = () => {
      clear(timeoutId);
      rejectFunction(createAbortError());
    };
    const cleanup = () => {
      if (signal) {
        signal.removeEventListener("abort", signalListener);
      }
    };
    const delayPromise = new Promise((resolve, reject) => {
      settle = () => {
        cleanup();
        resolve(value7);
      };
      rejectFunction = reject;
      timeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);
    });
    if (signal) {
      signal.addEventListener("abort", signalListener, { once: true });
    }
    clearMethods.set(delayPromise, () => {
      clear(timeoutId);
      timeoutId = null;
      settle();
    });
    return delayPromise;
  };
}
var delay = createDelay();
var delay_default = delay;

// node_modules/@libp2p/utils/dist/src/rate-limiter.js
var RateLimiter = class {
  memoryStorage;
  points;
  duration;
  blockDuration;
  execEvenly;
  execEvenlyMinDelayMs;
  keyPrefix;
  constructor(opts = {}) {
    this.points = opts.points ?? 4;
    this.duration = opts.duration ?? 1;
    this.blockDuration = opts.blockDuration ?? 0;
    this.execEvenly = opts.execEvenly ?? false;
    this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs ?? this.duration * 1e3 / this.points;
    this.keyPrefix = opts.keyPrefix ?? "rlflx";
    this.memoryStorage = new MemoryStorage();
  }
  async consume(key, pointsToConsume = 1, options2 = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options2);
    let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    if (res.consumedPoints > this.points) {
      if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
        res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
      }
      throw new RateLimitError("Rate limit exceeded", res);
    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
      let delayMs = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
      if (delayMs < this.execEvenlyMinDelayMs) {
        delayMs = res.consumedPoints * this.execEvenlyMinDelayMs;
      }
      await delay_default(delayMs);
    }
    return res;
  }
  penalty(key, points = 1, options2 = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options2);
    const res = this.memoryStorage.incrby(rlKey, points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  reward(key, points = 1, options2 = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options2);
    const res = this.memoryStorage.incrby(rlKey, -points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  /**
   * Block any key for secDuration seconds
   *
   * @param key
   * @param secDuration
   */
  block(key, secDuration) {
    const msDuration = secDuration * 1e3;
    const initPoints = this.points + 1;
    this.memoryStorage.set(this.getKey(key), initPoints, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: initPoints,
      isFirstInDuration: false
    };
  }
  set(key, points, secDuration = 0) {
    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
    this.memoryStorage.set(this.getKey(key), points, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: points,
      isFirstInDuration: false
    };
  }
  get(key) {
    const res = this.memoryStorage.get(this.getKey(key));
    if (res != null) {
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    }
    return res;
  }
  delete(key) {
    this.memoryStorage.delete(this.getKey(key));
  }
  _getKeySecDuration(options2) {
    if (options2?.customDuration != null && options2.customDuration >= 0) {
      return options2.customDuration;
    }
    return this.duration;
  }
  getKey(key) {
    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
  }
  parseKey(rlKey) {
    return rlKey.substring(this.keyPrefix.length);
  }
};
var MemoryStorage = class {
  storage;
  constructor() {
    this.storage = /* @__PURE__ */ new Map();
  }
  incrby(key, value7, durationSec) {
    const existing = this.storage.get(key);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      if (existing.expiresAt == null || msBeforeExpires > 0) {
        existing.value += value7;
        return {
          remainingPoints: 0,
          msBeforeNext: msBeforeExpires,
          consumedPoints: existing.value,
          isFirstInDuration: false
        };
      }
      return this.set(key, value7, durationSec);
    }
    return this.set(key, value7, durationSec);
  }
  set(key, value7, durationSec) {
    const durationMs = durationSec * 1e3;
    const existing = this.storage.get(key);
    if (existing != null) {
      clearTimeout(existing.timeoutId);
    }
    const record = {
      value: value7,
      expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : void 0
    };
    this.storage.set(key, record);
    if (durationMs > 0) {
      record.timeoutId = setTimeout(() => {
        this.storage.delete(key);
      }, durationMs);
      if (record.timeoutId.unref != null) {
        record.timeoutId.unref();
      }
    }
    return {
      remainingPoints: 0,
      msBeforeNext: durationMs === 0 ? -1 : durationMs,
      consumedPoints: record.value,
      isFirstInDuration: true
    };
  }
  get(key) {
    const existing = this.storage.get(key);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      return {
        remainingPoints: 0,
        msBeforeNext: msBeforeExpires,
        consumedPoints: existing.value,
        isFirstInDuration: false
      };
    }
  }
  delete(key) {
    const record = this.storage.get(key);
    if (record != null) {
      if (record.timeoutId != null) {
        clearTimeout(record.timeoutId);
      }
      this.storage.delete(key);
      return true;
    }
    return false;
  }
};

// node_modules/libp2p/dist/src/get-peer.js
function getPeerAddress(peer) {
  if (isPeerId(peer)) {
    return { peerId: peer, multiaddrs: [] };
  }
  let multiaddrs = Array.isArray(peer) ? peer : [peer];
  let peerId2;
  if (multiaddrs.length > 0) {
    const peerIdStr = multiaddrs[0].getPeerId();
    peerId2 = peerIdStr == null ? void 0 : peerIdFromString(peerIdStr);
    multiaddrs.forEach((ma) => {
      if (!isMultiaddr(ma)) {
        throw new InvalidMultiaddrError("Invalid multiaddr");
      }
      const maPeerIdStr = ma.getPeerId();
      if (maPeerIdStr == null) {
        if (peerId2 != null) {
          throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
        }
      } else {
        const maPeerId = peerIdFromString(maPeerIdStr);
        if (peerId2?.equals(maPeerId) !== true) {
          throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
        }
      }
    });
  }
  multiaddrs = multiaddrs.filter((ma) => {
    return !PEER_ID2.exactMatch(ma);
  });
  return {
    peerId: peerId2,
    multiaddrs
  };
}

// node_modules/@libp2p/utils/dist/src/close.js
var DEFAULT_CLOSABLE_PROTOCOLS = [
  // identify
  "/ipfs/id/1.0.0",
  // identify-push
  "/ipfs/id/push/1.0.0",
  // autonat
  "/libp2p/autonat/1.0.0",
  // dcutr
  "/libp2p/dcutr"
];
async function safelyCloseConnectionIfUnused(connection, options2) {
  const streamProtocols = connection?.streams?.map((stream) => stream.protocol) ?? [];
  const closableProtocols = options2?.closableProtocols ?? DEFAULT_CLOSABLE_PROTOCOLS;
  if (streamProtocols.filter((proto) => proto != null && !closableProtocols.includes(proto)).length > 0) {
    return;
  }
  try {
    await connection?.close(options2);
  } catch (err) {
    connection?.abort(err);
  }
}

// node_modules/libp2p/dist/src/connection-manager/utils.js
function multiaddrToIpNet(ma) {
  try {
    let parsedMa;
    if (typeof ma === "string") {
      parsedMa = multiaddr(ma);
    } else {
      parsedMa = ma;
    }
    const protoNames = /* @__PURE__ */ new Set([...parsedMa.getComponents().map((component) => component.name)]);
    if (!protoNames.has("ipcidr")) {
      const isIPv63 = protoNames.has("ip6");
      const cidr = isIPv63 ? "/ipcidr/128" : "/ipcidr/32";
      parsedMa = parsedMa.encapsulate(cidr);
    }
    return convertToIpNet(parsedMa);
  } catch (error) {
    throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${ma}`);
  }
}

// node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
var ConnectionPruner = class {
  connectionManager;
  peerStore;
  allow;
  events;
  log;
  constructor(components, init = {}) {
    this.allow = (init.allow ?? []).map((ma) => multiaddrToIpNet(ma));
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager:connection-pruner");
    this.maybePruneConnections = this.maybePruneConnections.bind(this);
  }
  start() {
    this.events.addEventListener("connection:open", this.maybePruneConnections);
  }
  stop() {
    this.events.removeEventListener("connection:open", this.maybePruneConnections);
  }
  maybePruneConnections() {
    this._maybePruneConnections().catch((err) => {
      this.log.error("error while pruning connections %e", err);
    });
  }
  /**
   * If we have more connections than our maximum, select some excess connections
   * to prune based on peer value
   */
  async _maybePruneConnections() {
    const connections = this.connectionManager.getConnections();
    const numConnections = connections.length;
    const maxConnections = this.connectionManager.getMaxConnections();
    this.log("checking max connections limit %d/%d", numConnections, maxConnections);
    if (numConnections <= maxConnections) {
      return;
    }
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      peerValues.set(remotePeer, 0);
      try {
        const peer = await this.peerStore.get(remotePeer);
        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
          return acc + curr.value;
        }, 0));
      } catch (err) {
        if (err.name !== "NotFoundError") {
          this.log.error("error loading peer tags", err);
        }
      }
    }
    const sortedConnections = this.sortConnections(connections, peerValues);
    const toPrune = Math.max(numConnections - maxConnections, 0);
    const toClose = [];
    for (const connection of sortedConnections) {
      this.log("too many connections open - closing a connection to %p", connection.remotePeer);
      const connectionInAllowList = this.allow.some((ipNet) => {
        return ipNet.contains(connection.remoteAddr.nodeAddress().address);
      });
      if (!connectionInAllowList) {
        toClose.push(connection);
      }
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      await safelyCloseConnectionIfUnused(connection, {
        signal: AbortSignal.timeout(1e3)
      });
    }));
    this.events.safeDispatchEvent("connection:prune", { detail: toClose });
  }
  sortConnections(connections, peerValues) {
    return connections.sort((a, b) => {
      const connectionALifespan = a.timeline.open;
      const connectionBLifespan = b.timeline.open;
      if (connectionALifespan < connectionBLifespan) {
        return 1;
      }
      if (connectionALifespan > connectionBLifespan) {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      if (a.direction === "outbound" && b.direction === "inbound") {
        return 1;
      }
      if (a.direction === "inbound" && b.direction === "outbound") {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      if (a.streams.length > b.streams.length) {
        return 1;
      }
      if (a.streams.length < b.streams.length) {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      const peerAValue = peerValues.get(a.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      return 0;
    });
  }
};

// node_modules/libp2p/dist/src/connection-manager/constants.defaults.js
var DIAL_TIMEOUT = 1e4;
var INBOUND_UPGRADE_TIMEOUT = 1e4;
var PROTOCOL_NEGOTIATION_TIMEOUT = 1e4;
var MAX_PEER_ADDRS_TO_DIAL = 25;
var INBOUND_CONNECTION_THRESHOLD = 5;
var MAX_INCOMING_PENDING_CONNECTIONS = 10;
var MAX_PARALLEL_RECONNECTS = 5;
var LAST_DIAL_FAILURE_KEY = "last-dial-failure";
var LAST_DIAL_SUCCESS_KEY = "last-dial-success";
var MAX_DIAL_QUEUE_LENGTH = 500;
var MAX_RECURSIVE_DEPTH = 32;

// node_modules/libp2p/dist/src/connection-manager/constants.browser.js
var MAX_CONNECTIONS = 100;
var MAX_PARALLEL_DIALS = 50;

// node_modules/@libp2p/utils/dist/src/priority-queue.js
var PriorityQueue = class extends Queue {
  constructor(init = {}) {
    super({
      ...init,
      sort: (a, b) => {
        if (a.options.priority > b.options.priority) {
          return -1;
        }
        if (a.options.priority < b.options.priority) {
          return 1;
        }
        return 0;
      }
    });
  }
};

// node_modules/is-loopback-addr/dist/src/index.js
function isLoopbackAddr(ip) {
  return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
}

// node_modules/@libp2p/utils/dist/src/multiaddr/is-loopback.js
function isLoopback(ma) {
  if (!isIpBased(ma)) {
    return false;
  }
  const { address } = ma.nodeAddress();
  return isLoopbackAddr(address);
}

// node_modules/libp2p/dist/src/connection-manager/address-sorter.js
function reliableTransportsFirst(a, b) {
  const isATcp = TCP2.exactMatch(a.multiaddr);
  const isBTcp = TCP2.exactMatch(b.multiaddr);
  if (isATcp && !isBTcp) {
    return -1;
  }
  if (!isATcp && isBTcp) {
    return 1;
  }
  const isAWebSocketSecure = WebSocketsSecure2.exactMatch(a.multiaddr);
  const isBWebSocketSecure = WebSocketsSecure2.exactMatch(b.multiaddr);
  if (isAWebSocketSecure && !isBWebSocketSecure) {
    return -1;
  }
  if (!isAWebSocketSecure && isBWebSocketSecure) {
    return 1;
  }
  const isAWebSocket = WebSockets2.exactMatch(a.multiaddr);
  const isBWebSocket = WebSockets2.exactMatch(b.multiaddr);
  if (isAWebSocket && !isBWebSocket) {
    return -1;
  }
  if (!isAWebSocket && isBWebSocket) {
    return 1;
  }
  const isAWebRTC = WebRTC2.exactMatch(a.multiaddr);
  const isBWebRTC = WebRTC2.exactMatch(b.multiaddr);
  if (isAWebRTC && !isBWebRTC) {
    return -1;
  }
  if (!isAWebRTC && isBWebRTC) {
    return 1;
  }
  const isAWebRTCDirect = WebRTCDirect2.exactMatch(a.multiaddr);
  const isBWebRTCDirect = WebRTCDirect2.exactMatch(b.multiaddr);
  if (isAWebRTCDirect && !isBWebRTCDirect) {
    return -1;
  }
  if (!isAWebRTCDirect && isBWebRTCDirect) {
    return 1;
  }
  const isAWebTransport = WebTransport2.exactMatch(a.multiaddr);
  const isBWebTransport = WebTransport2.exactMatch(b.multiaddr);
  if (isAWebTransport && !isBWebTransport) {
    return -1;
  }
  if (!isAWebTransport && isBWebTransport) {
    return 1;
  }
  return 0;
}
function loopbackAddressLast(a, b) {
  const isALoopback = isLoopback(a.multiaddr);
  const isBLoopback = isLoopback(b.multiaddr);
  if (isALoopback && !isBLoopback) {
    return 1;
  } else if (!isALoopback && isBLoopback) {
    return -1;
  }
  return 0;
}
function publicAddressesFirst(a, b) {
  const isAPrivate = isPrivate(a.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  return 0;
}
function certifiedAddressesFirst(a, b) {
  if (a.isCertified && !b.isCertified) {
    return -1;
  } else if (!a.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}
function circuitRelayAddressesLast(a, b) {
  const isACircuit = Circuit2.exactMatch(a.multiaddr);
  const isBCircuit = Circuit2.exactMatch(b.multiaddr);
  if (isACircuit && !isBCircuit) {
    return 1;
  } else if (!isACircuit && isBCircuit) {
    return -1;
  }
  return 0;
}
function defaultAddressSorter(addresses) {
  return addresses.sort(reliableTransportsFirst).sort(certifiedAddressesFirst).sort(circuitRelayAddressesLast).sort(publicAddressesFirst).sort(loopbackAddressLast);
}

// node_modules/libp2p/dist/src/connection-manager/resolvers/index.js
async function resolveMultiaddr(address, resolvers, options2) {
  const depth = options2.depth ?? 0;
  if (depth > (options2.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH)) {
    throw new RecursionLimitError("Max recursive depth reached");
  }
  let resolved = false;
  const output = [];
  for (const resolver of Object.values(resolvers)) {
    if (resolver.canResolve(address)) {
      resolved = true;
      const addresses = await resolver.resolve(address, options2);
      for (const address2 of addresses) {
        output.push(...await resolveMultiaddr(address2, resolvers, {
          ...options2,
          depth: depth + 1
        }));
      }
    }
  }
  if (resolved === false) {
    output.push(address);
  }
  return output;
}

// node_modules/libp2p/dist/src/connection-manager/dial-queue.js
var defaultOptions4 = {
  maxParallelDials: MAX_PARALLEL_DIALS,
  maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,
  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
  dialTimeout: DIAL_TIMEOUT,
  resolvers: {
    dnsaddr: dnsaddrResolver
  }
};
var DialQueue = class {
  queue;
  components;
  addressSorter;
  maxPeerAddrsToDial;
  maxDialQueueLength;
  dialTimeout;
  shutDownController;
  connections;
  log;
  resolvers;
  constructor(components, init = {}) {
    this.addressSorter = init.addressSorter;
    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions4.maxPeerAddrsToDial;
    this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions4.maxDialQueueLength;
    this.dialTimeout = init.dialTimeout ?? defaultOptions4.dialTimeout;
    this.connections = init.connections ?? new PeerMap();
    this.log = components.logger.forComponent("libp2p:connection-manager:dial-queue");
    this.components = components;
    this.resolvers = init.resolvers ?? defaultOptions4.resolvers;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    this.queue = new PriorityQueue({
      concurrency: init.maxParallelDials ?? defaultOptions4.maxParallelDials,
      metricName: "libp2p_dial_queue",
      metrics: components.metrics
    });
    this.queue.addEventListener("error", (event) => {
      if (event.detail?.name !== AbortError.name) {
        this.log.error("error in dial queue - %e", event.detail);
      }
    });
  }
  start() {
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
  }
  /**
   * Clears any pending dials
   */
  stop() {
    this.shutDownController.abort();
    this.queue.abort();
  }
  /**
   * Connects to a given peer, multiaddr or list of multiaddrs.
   *
   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
   * multiaddrs are passed only those will be dialled.
   *
   * Where a list of multiaddrs is passed, if any contain a peer id then all
   * multiaddrs in the list must contain the same peer id.
   *
   * The dial to the first address that is successfully able to upgrade a
   * connection will be used, all other dials will be aborted when that happens.
   */
  async dial(peerIdOrMultiaddr, options2 = {}) {
    const { peerId: peerId2, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
    const existingConnection = Array.from(this.connections.values()).flat().find((conn) => {
      if (options2.force === true) {
        return false;
      }
      if (conn.limits != null) {
        return false;
      }
      if (conn.remotePeer.equals(peerId2)) {
        return true;
      }
      return multiaddrs.find((addr) => {
        return addr.equals(conn.remoteAddr);
      });
    });
    if (existingConnection?.status === "open") {
      this.log("already connected to %a", existingConnection.remoteAddr);
      options2.onProgress?.(new CustomProgressEvent("dial-queue:already-connected"));
      return existingConnection;
    }
    const existingDial = this.queue.queue.find((job) => {
      if (peerId2?.equals(job.options.peerId) === true) {
        return true;
      }
      const addresses = job.options.multiaddrs;
      if (addresses == null) {
        return false;
      }
      for (const multiaddr2 of multiaddrs) {
        if (addresses.has(multiaddr2.toString())) {
          return true;
        }
      }
      return false;
    });
    if (existingDial != null) {
      this.log("joining existing dial target for %p", peerId2);
      for (const multiaddr2 of multiaddrs) {
        existingDial.options.multiaddrs.add(multiaddr2.toString());
      }
      options2.onProgress?.(new CustomProgressEvent("dial-queue:already-in-dial-queue"));
      return existingDial.join(options2);
    }
    if (this.queue.size >= this.maxDialQueueLength) {
      throw new DialError("Dial queue is full");
    }
    this.log("creating dial target for %p", peerId2, multiaddrs.map((ma) => ma.toString()));
    options2.onProgress?.(new CustomProgressEvent("dial-queue:add-to-dial-queue"));
    return this.queue.add(async (options3) => {
      options3.onProgress?.(new CustomProgressEvent("dial-queue:start-dial"));
      const signal = anySignal([
        this.shutDownController.signal,
        options3.signal
      ]);
      setMaxListeners(Infinity, signal);
      try {
        return await this.dialPeer(options3, signal);
      } finally {
        signal.clear();
      }
    }, {
      peerId: peerId2,
      priority: options2.priority ?? DEFAULT_DIAL_PRIORITY,
      multiaddrs: new Set(multiaddrs.map((ma) => ma.toString())),
      signal: options2.signal ?? AbortSignal.timeout(this.dialTimeout),
      onProgress: options2.onProgress
    });
  }
  async dialPeer(options2, signal) {
    const peerId2 = options2.peerId;
    const multiaddrs = options2.multiaddrs;
    const failedMultiaddrs = /* @__PURE__ */ new Set();
    let forcePeerLookup = options2.multiaddrs.size === 0;
    let dialed = 0;
    let dialIteration = 0;
    const errors = [];
    this.log("starting dial to %p", peerId2);
    while (forcePeerLookup || multiaddrs.size > 0) {
      dialIteration++;
      forcePeerLookup = false;
      const addrsToDial = [];
      const addrs = new Set(options2.multiaddrs);
      multiaddrs.clear();
      this.log("calculating addrs to dial %p from %s", peerId2, [...addrs]);
      const calculatedAddrs = await this.calculateMultiaddrs(peerId2, addrs, {
        ...options2,
        signal
      });
      for (const addr of calculatedAddrs) {
        if (failedMultiaddrs.has(addr.multiaddr.toString())) {
          this.log.trace("skipping previously failed multiaddr %a while dialing %p", addr.multiaddr, peerId2);
          continue;
        }
        addrsToDial.push(addr);
      }
      this.log("%s dial to %p with %s", dialIteration === 1 ? "starting" : "continuing", peerId2, addrsToDial.map((ma) => ma.multiaddr.toString()));
      options2?.onProgress?.(new CustomProgressEvent("dial-queue:calculated-addresses", addrsToDial));
      for (const address of addrsToDial) {
        if (dialed === this.maxPeerAddrsToDial) {
          this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", dialed, options2.peerId);
          throw new DialError("Peer had more than maxPeerAddrsToDial");
        }
        dialed++;
        try {
          const conn = await this.components.transportManager.dial(address.multiaddr, {
            ...options2,
            signal
          });
          this.log("dial to %a succeeded", address.multiaddr);
          try {
            await this.components.peerStore.merge(conn.remotePeer, {
              multiaddrs: [
                conn.remoteAddr
              ],
              metadata: {
                [LAST_DIAL_SUCCESS_KEY]: fromString(Date.now().toString())
              }
            });
          } catch (err) {
            this.log.error("could not update last dial failure key for %p", peerId2, err);
          }
          return conn;
        } catch (err) {
          this.log.error("dial failed to %a", address.multiaddr, err);
          failedMultiaddrs.add(address.multiaddr.toString());
          if (peerId2 != null) {
            try {
              await this.components.peerStore.merge(peerId2, {
                metadata: {
                  [LAST_DIAL_FAILURE_KEY]: fromString(Date.now().toString())
                }
              });
            } catch (err2) {
              this.log.error("could not update last dial failure key for %p", peerId2, err2);
            }
          }
          if (signal.aborted) {
            throw new TimeoutError(err.message);
          }
          errors.push(err);
        }
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    throw new AggregateError(errors, "All multiaddr dials failed");
  }
  // eslint-disable-next-line complexity
  async calculateMultiaddrs(peerId2, multiaddrs = /* @__PURE__ */ new Set(), options2 = {}) {
    const addrs = [...multiaddrs].map((ma) => ({
      multiaddr: multiaddr(ma),
      isCertified: false
    }));
    if (peerId2 != null) {
      if (this.components.peerId.equals(peerId2)) {
        throw new DialError("Tried to dial self");
      }
      if (await this.components.connectionGater.denyDialPeer?.(peerId2) === true) {
        throw new DialDeniedError("The dial request is blocked by gater.allowDialPeer");
      }
      if (addrs.length === 0) {
        this.log("loading multiaddrs for %p", peerId2);
        try {
          const peer = await this.components.peerStore.get(peerId2);
          addrs.push(...peer.addresses);
          this.log("loaded multiaddrs for %p", peerId2, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
      }
      if (addrs.length === 0) {
        this.log("looking up multiaddrs for %p in the peer routing", peerId2);
        try {
          const peerInfo = await this.components.peerRouting.findPeer(peerId2, options2);
          this.log("found multiaddrs for %p in the peer routing", peerId2, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
          addrs.push(...peerInfo.multiaddrs.map((multiaddr2) => ({
            multiaddr: multiaddr2,
            isCertified: false
          })));
        } catch (err) {
          if (err.name === "NoPeerRoutersError") {
            this.log("no peer routers configured", peerId2);
          } else {
            this.log.error("looking up multiaddrs for %p in the peer routing failed - %e", peerId2, err);
          }
        }
      }
    }
    let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
      const result = await resolveMultiaddr(addr.multiaddr, this.resolvers, {
        dns: this.components.dns,
        log: this.log,
        ...options2
      });
      if (result.length === 1 && result[0].equals(addr.multiaddr)) {
        return addr;
      }
      return result.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        isCertified: false
      }));
    }))).flat();
    if (peerId2 != null) {
      const peerIdMultiaddr = `/p2p/${peerId2.toString()}`;
      resolvedAddresses = resolvedAddresses.map((addr) => {
        const lastComponent = addr.multiaddr.getComponents().pop();
        if (lastComponent?.name !== "p2p") {
          return {
            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
            isCertified: addr.isCertified
          };
        }
        return addr;
      });
    }
    const filteredAddrs = resolvedAddresses.filter((addr) => {
      if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {
        return false;
      }
      const addrPeerId = addr.multiaddr.getPeerId();
      if (peerId2 != null && addrPeerId != null) {
        return peerId2.equals(addrPeerId);
      }
      return true;
    });
    const dedupedAddrs = /* @__PURE__ */ new Map();
    for (const addr of filteredAddrs) {
      const maStr = addr.multiaddr.toString();
      const existing = dedupedAddrs.get(maStr);
      if (existing != null) {
        existing.isCertified = existing.isCertified || addr.isCertified || false;
        continue;
      }
      dedupedAddrs.set(maStr, addr);
    }
    const dedupedMultiaddrs = [...dedupedAddrs.values()];
    if (dedupedMultiaddrs.length === 0) {
      throw new NoValidAddressesError("The dial request has no valid addresses");
    }
    const gatedAddrs = [];
    for (const addr of dedupedMultiaddrs) {
      if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
        continue;
      }
      gatedAddrs.push(addr);
    }
    const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAddrs) : gatedAddrs.sort(this.addressSorter);
    if (sortedGatedAddrs.length === 0) {
      throw new DialDeniedError("The connection gater denied all addresses in the dial request");
    }
    this.log.trace("addresses for %p before filtering", peerId2 ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    this.log.trace("addresses for %p after filtering", peerId2 ?? "unknown peer", sortedGatedAddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    return sortedGatedAddrs;
  }
  async isDialable(multiaddr2, options2 = {}) {
    if (!Array.isArray(multiaddr2)) {
      multiaddr2 = [multiaddr2];
    }
    try {
      const addresses = await this.calculateMultiaddrs(void 0, new Set(multiaddr2.map((ma) => ma.toString())), options2);
      if (options2.runOnLimitedConnection === false) {
        return addresses.find((addr) => {
          return !Circuit2.matches(addr.multiaddr);
        }) != null;
      }
      return true;
    } catch (err) {
      this.log.trace("error calculating if multiaddr(s) were dialable", err);
    }
    return false;
  }
};

// node_modules/p-retry/index.js
var import_retry = __toESM(require_retry2());

// node_modules/is-network-error/index.js
var objectToString = Object.prototype.toString;
var isError = (value7) => objectToString.call(value7) === "[object Error]";
var errorMessages = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Load failed",
  // Safari 17+
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated"
  // Undici (Node.js)
]);
function isNetworkError(error) {
  const isValid = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid) {
    return false;
  }
  if (error.message === "Load failed") {
    return error.stack === void 0;
  }
  return errorMessages.has(error.message);
}

// node_modules/p-retry/index.js
var AbortError4 = class extends Error {
  constructor(message2) {
    super();
    if (message2 instanceof Error) {
      this.originalError = message2;
      ({ message: message2 } = message2);
    } else {
      this.originalError = new Error(message2);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message2;
  }
};
var decorateErrorWithCounts = (error, attemptNumber, options2) => {
  const retriesLeft = options2.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
async function pRetry(input, options2) {
  return new Promise((resolve, reject) => {
    options2 = { ...options2 };
    options2.onFailedAttempt ??= () => {
    };
    options2.shouldRetry ??= () => true;
    options2.retries ??= 10;
    const operation = import_retry.default.operation(options2);
    const abortHandler = () => {
      operation.stop();
      reject(options2.signal?.reason);
    };
    if (options2.signal && !options2.signal.aborted) {
      options2.signal.addEventListener("abort", abortHandler, { once: true });
    }
    const cleanUp = () => {
      options2.signal?.removeEventListener("abort", abortHandler);
      operation.stop();
    };
    operation.attempt(async (attemptNumber) => {
      try {
        const result = await input(attemptNumber);
        cleanUp();
        resolve(result);
      } catch (error) {
        try {
          if (!(error instanceof Error)) {
            throw new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
          }
          if (error instanceof AbortError4) {
            throw error.originalError;
          }
          if (error instanceof TypeError && !isNetworkError(error)) {
            throw error;
          }
          decorateErrorWithCounts(error, attemptNumber, options2);
          if (!await options2.shouldRetry(error)) {
            operation.stop();
            reject(error);
          }
          await options2.onFailedAttempt(error);
          if (!operation.retry(error)) {
            throw operation.mainError();
          }
        } catch (finalError) {
          decorateErrorWithCounts(finalError, attemptNumber, options2);
          cleanUp();
          reject(finalError);
        }
      }
    });
  });
}

// node_modules/libp2p/dist/src/connection-manager/reconnect-queue.js
var ReconnectQueue = class {
  log;
  queue;
  started;
  peerStore;
  retries;
  retryInterval;
  backoffFactor;
  connectionManager;
  events;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:reconnect-queue");
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.queue = new PeerQueue({
      concurrency: init.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,
      metricName: "libp2p_reconnect_queue",
      metrics: components.metrics
    });
    this.started = false;
    this.retries = init.retries ?? 5;
    this.backoffFactor = init.backoffFactor;
    this.retryInterval = init.retryInterval;
    this.events = components.events;
    components.events.addEventListener("peer:disconnect", (evt) => {
      this.maybeReconnect(evt.detail).catch((err) => {
        this.log.error("failed to maybe reconnect to %p - %e", evt.detail, err);
      });
    });
  }
  async maybeReconnect(peerId2) {
    if (!this.started) {
      return;
    }
    const peer = await this.peerStore.get(peerId2);
    if (!hasKeepAliveTag(peer)) {
      return;
    }
    if (this.queue.has(peerId2)) {
      return;
    }
    this.queue.add(async (options2) => {
      await pRetry(async (attempt) => {
        if (!this.started) {
          return;
        }
        try {
          await this.connectionManager.openConnection(peerId2, {
            signal: options2?.signal
          });
        } catch (err) {
          this.log("reconnecting to %p attempt %d of %d failed - %e", peerId2, attempt, this.retries, err);
          throw err;
        }
      }, {
        signal: options2?.signal,
        retries: this.retries,
        factor: this.backoffFactor,
        minTimeout: this.retryInterval
      });
    }, {
      peerId: peerId2
    }).catch(async (err) => {
      this.log.error("failed to reconnect to %p - %e", peerId2, err);
      const tags = {};
      [...peer.tags.keys()].forEach((key) => {
        if (key.startsWith(KEEP_ALIVE)) {
          tags[key] = void 0;
        }
      });
      await this.peerStore.merge(peerId2, {
        tags
      });
      this.events.safeDispatchEvent("peer:reconnect-failure", {
        detail: peerId2
      });
    }).catch(async (err) => {
      this.log.error("failed to remove keep-alive tag from %p - %e", peerId2, err);
    });
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    void Promise.resolve().then(async () => {
      const keepAlivePeers = await this.peerStore.all({
        filters: [
          (peer) => hasKeepAliveTag(peer)
        ]
      });
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.connectionManager.openConnection(peer.id).catch((err) => {
          this.log.error(err);
        });
      }));
    }).catch((err) => {
      this.log.error(err);
    });
  }
  stop() {
    this.started = false;
    this.queue.abort();
  }
};
function hasKeepAliveTag(peer) {
  for (const tag of peer.tags.keys()) {
    if (tag.startsWith(KEEP_ALIVE)) {
      return true;
    }
  }
  return false;
}

// node_modules/libp2p/dist/src/connection-manager/index.js
var DEFAULT_DIAL_PRIORITY = 50;
var defaultOptions5 = {
  maxConnections: MAX_CONNECTIONS,
  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS
};
var DefaultConnectionManager = class {
  started;
  connections;
  allow;
  deny;
  maxIncomingPendingConnections;
  incomingPendingConnections;
  outboundPendingConnections;
  maxConnections;
  dialQueue;
  reconnectQueue;
  connectionPruner;
  inboundConnectionRateLimiter;
  peerStore;
  metrics;
  events;
  log;
  peerId;
  constructor(components, init = {}) {
    this.maxConnections = init.maxConnections ?? defaultOptions5.maxConnections;
    if (this.maxConnections < 1) {
      throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
    }
    this.connections = new PeerMap();
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.metrics = components.metrics;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager");
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.allow = (init.allow ?? []).map((str) => multiaddrToIpNet(str));
    this.deny = (init.deny ?? []).map((str) => multiaddrToIpNet(str));
    this.incomingPendingConnections = 0;
    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions5.maxIncomingPendingConnections;
    this.outboundPendingConnections = 0;
    this.inboundConnectionRateLimiter = new RateLimiter({
      points: init.inboundConnectionThreshold ?? defaultOptions5.inboundConnectionThreshold,
      duration: 1
    });
    this.connectionPruner = new ConnectionPruner({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events,
      logger: components.logger
    }, {
      allow: init.allow?.map((a) => multiaddr(a))
    });
    this.dialQueue = new DialQueue(components, {
      addressSorter: init.addressSorter,
      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,
      maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,
      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,
      resolvers: init.resolvers ?? {
        dnsaddr: dnsaddrResolver
      },
      connections: this.connections
    });
    this.reconnectQueue = new ReconnectQueue({
      events: components.events,
      peerStore: components.peerStore,
      logger: components.logger,
      connectionManager: this
    }, {
      retries: init.reconnectRetries,
      retryInterval: init.reconnectRetryInterval,
      backoffFactor: init.reconnectBackoffFactor,
      maxParallelReconnects: init.maxParallelReconnects
    });
  }
  [Symbol.toStringTag] = "@libp2p/connection-manager";
  /**
   * Starts the Connection Manager. If Metrics are not enabled on libp2p
   * only event loop and connection limits will be monitored.
   */
  async start() {
    this.metrics?.registerMetricGroup("libp2p_connection_manager_connections", {
      calculate: () => {
        const metric = {
          inbound: 0,
          "inbound pending": this.incomingPendingConnections,
          outbound: 0,
          "outbound pending": this.outboundPendingConnections
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            metric[conn.direction]++;
          }
        }
        return metric;
      }
    });
    this.metrics?.registerMetricGroup("libp2p_protocol_streams_total", {
      label: "protocol",
      calculate: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
      label: "protocol",
      calculate: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol, count] of Object.entries(streams)) {
              allStreams[protocol] = allStreams[protocol] ?? [];
              allStreams[protocol].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a, b) => a - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol] = counts[index];
        }
        return metric;
      }
    });
    this.events.addEventListener("connection:open", this.onConnect);
    this.events.addEventListener("connection:close", this.onDisconnect);
    await start(this.dialQueue, this.reconnectQueue, this.connectionPruner);
    this.started = true;
    this.log("started");
  }
  /**
   * Stops the Connection Manager
   */
  async stop() {
    this.events.removeEventListener("connection:open", this.onConnect);
    this.events.removeEventListener("connection:close", this.onDisconnect);
    await stop(this.reconnectQueue, this.dialQueue, this.connectionPruner);
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push((async () => {
          try {
            await connection.close();
          } catch (err) {
            this.log.error(err);
          }
        })());
      }
    }
    this.log("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
    this.log("stopped");
  }
  getMaxConnections() {
    return this.maxConnections;
  }
  setMaxConnections(maxConnections) {
    if (this.maxConnections < 1) {
      throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
    }
    let needsPrune = false;
    if (maxConnections < this.maxConnections) {
      needsPrune = true;
    }
    this.maxConnections = maxConnections;
    if (needsPrune) {
      this.connectionPruner.maybePruneConnections();
    }
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err) => {
      this.log.error(err);
    });
  }
  /**
   * Tracks the incoming connection and check the connection limit
   */
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    if (connection.status !== "open") {
      return;
    }
    const peerId2 = connection.remotePeer;
    const isNewPeer = !this.connections.has(peerId2);
    const storedConns = this.connections.get(peerId2) ?? [];
    storedConns.push(connection);
    this.connections.set(peerId2, storedConns);
    if (peerId2.publicKey != null && peerId2.type === "RSA") {
      await this.peerStore.patch(peerId2, {
        publicKey: peerId2.publicKey
      });
    }
    if (isNewPeer) {
      this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
    }
  }
  /**
   * Removes the connection from tracking
   */
  onDisconnect(evt) {
    const { detail: connection } = evt;
    const peerId2 = connection.remotePeer;
    const peerConns = this.connections.get(peerId2) ?? [];
    const filteredPeerConns = peerConns.filter((conn) => conn.id !== connection.id);
    this.connections.set(peerId2, filteredPeerConns);
    if (filteredPeerConns.length === 0) {
      this.log("onDisconnect remove all connections for peer %p", peerId2);
      this.connections.delete(peerId2);
      this.events.safeDispatchEvent("peer:disconnect", { detail: connection.remotePeer });
    }
  }
  getConnections(peerId2) {
    if (peerId2 != null) {
      return this.connections.get(peerId2) ?? [];
    }
    let conns = [];
    for (const c of this.connections.values()) {
      conns = conns.concat(c);
    }
    return conns;
  }
  getConnectionsMap() {
    return this.connections;
  }
  async openConnection(peerIdOrMultiaddr, options2 = {}) {
    if (!this.started) {
      throw new NotStartedError("Not started");
    }
    this.outboundPendingConnections++;
    try {
      options2.signal?.throwIfAborted();
      const { peerId: peerId2 } = getPeerAddress(peerIdOrMultiaddr);
      if (this.peerId.equals(peerId2)) {
        throw new InvalidPeerIdError("Can not dial self");
      }
      if (peerId2 != null && options2.force !== true) {
        this.log("dial %p", peerId2);
        const existingConnection = this.getConnections(peerId2).find((conn) => conn.limits == null);
        if (existingConnection != null) {
          this.log("had an existing non-limited connection to %p", peerId2);
          options2.onProgress?.(new CustomProgressEvent("dial-queue:already-connected"));
          return existingConnection;
        }
      }
      const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
        ...options2,
        priority: options2.priority ?? DEFAULT_DIAL_PRIORITY
      });
      if (connection.status !== "open") {
        throw new ConnectionClosedError("Remote closed connection during opening");
      }
      let peerConnections = this.connections.get(connection.remotePeer);
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(connection.remotePeer, peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
        if (options2.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {
          connection.abort(new InvalidMultiaddrError("Duplicate multiaddr connection"));
          return conn;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    } finally {
      this.outboundPendingConnections--;
    }
  }
  async closeConnections(peerId2, options2 = {}) {
    const connections = this.connections.get(peerId2) ?? [];
    await Promise.all(connections.map(async (connection) => {
      try {
        await connection.close(options2);
      } catch (err) {
        connection.abort(err);
      }
    }));
  }
  async acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ma) => {
      return ma.contains(maConn.remoteAddr.nodeAddress().address);
    });
    if (denyConnection) {
      this.log("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ipNet) => {
      return ipNet.contains(maConn.remoteAddr.nodeAddress().address);
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
      this.log("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
      return false;
    }
    if (maConn.remoteAddr.isThinWaistAddress()) {
      const host = maConn.remoteAddr.nodeAddress().address;
      try {
        await this.inboundConnectionRateLimiter.consume(host, 1);
      } catch {
        this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, host);
        return false;
      }
    }
    if (this.getConnections().length < this.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    this.log("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
  getDialQueue() {
    const statusMap = {
      queued: "queued",
      running: "active",
      errored: "error",
      complete: "success"
    };
    return this.dialQueue.queue.queue.map((job) => {
      return {
        id: job.id,
        status: statusMap[job.status],
        peerId: job.options.peerId,
        multiaddrs: [...job.options.multiaddrs].map((ma) => multiaddr(ma))
      };
    });
  }
  async isDialable(multiaddr2, options2 = {}) {
    return this.dialQueue.isDialable(multiaddr2, options2);
  }
};

// node_modules/@libp2p/utils/dist/src/moving-average.js
var MovingAverage = class {
  movingAverage;
  variance;
  deviation;
  forecast;
  timeSpan;
  previousTime;
  constructor(timeSpan2) {
    this.timeSpan = timeSpan2;
    this.movingAverage = 0;
    this.variance = 0;
    this.deviation = 0;
    this.forecast = 0;
  }
  alpha(t, pt) {
    return 1 - Math.exp(-(t - pt) / this.timeSpan);
  }
  push(value7, time = Date.now()) {
    if (this.previousTime != null) {
      const a = this.alpha(time, this.previousTime);
      const diff = value7 - this.movingAverage;
      const incr = a * diff;
      this.movingAverage = a * value7 + (1 - a) * this.movingAverage;
      this.variance = (1 - a) * (this.variance + diff * incr);
      this.deviation = Math.sqrt(this.variance);
      this.forecast = this.movingAverage + a * diff;
    } else {
      this.movingAverage = value7;
    }
    this.previousTime = time;
  }
};

// node_modules/@libp2p/utils/dist/src/adaptive-timeout.js
var DEFAULT_TIMEOUT_MULTIPLIER = 1.2;
var DEFAULT_FAILURE_MULTIPLIER = 2;
var DEFAULT_MIN_TIMEOUT = 5e3;
var DEFAULT_MAX_TIMEOUT = 6e4;
var DEFAULT_INTERVAL = 5e3;
var AdaptiveTimeout = class {
  success;
  failure;
  next;
  metric;
  timeoutMultiplier;
  failureMultiplier;
  minTimeout;
  maxTimeout;
  constructor(init = {}) {
    const interval = init.interval ?? DEFAULT_INTERVAL;
    this.success = new MovingAverage(interval);
    this.failure = new MovingAverage(interval);
    this.next = new MovingAverage(interval);
    this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER;
    this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER;
    this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT;
    this.maxTimeout = init.maxTimeout ?? DEFAULT_MAX_TIMEOUT;
    if (init.metricName != null) {
      this.metric = init.metrics?.registerMetricGroup(init.metricName);
    }
  }
  getTimeoutSignal(options2 = {}) {
    let timeout = Math.round(this.next.movingAverage * (options2.timeoutFactor ?? this.timeoutMultiplier));
    if (timeout < this.minTimeout) {
      timeout = this.minTimeout;
    }
    if (timeout > this.maxTimeout) {
      timeout = this.maxTimeout;
    }
    const sendTimeout = AbortSignal.timeout(timeout);
    const timeoutSignal = anySignal([options2.signal, sendTimeout]);
    setMaxListeners(Infinity, timeoutSignal, sendTimeout);
    timeoutSignal.start = Date.now();
    timeoutSignal.timeout = timeout;
    return timeoutSignal;
  }
  cleanUp(signal) {
    const time = Date.now() - signal.start;
    if (signal.aborted) {
      this.failure.push(time);
      this.next.push(time * this.failureMultiplier);
      this.metric?.update({
        failureMovingAverage: this.failure.movingAverage,
        failureDeviation: this.failure.deviation,
        failureForecast: this.failure.forecast,
        failureVariance: this.failure.variance,
        failure: time
      });
    } else {
      this.success.push(time);
      this.next.push(time);
      this.metric?.update({
        successMovingAverage: this.success.movingAverage,
        successDeviation: this.success.deviation,
        successForecast: this.success.forecast,
        successVariance: this.success.variance,
        success: time
      });
    }
  }
};

// node_modules/it-byte-stream/dist/src/errors.js
var UnexpectedEOFError2 = class extends Error {
  name = "UnexpectedEOFError";
  code = "ERR_UNEXPECTED_EOF";
};

// node_modules/it-byte-stream/dist/src/index.js
function byteStream(duplex, opts) {
  const write2 = queuelessPushable();
  duplex.sink(write2).catch(async (err) => {
    await write2.end(err);
  });
  duplex.sink = async (source2) => {
    for await (const buf of source2) {
      await write2.push(buf);
    }
    await write2.end();
  };
  let source = duplex.source;
  if (duplex.source[Symbol.iterator] != null) {
    source = duplex.source[Symbol.iterator]();
  } else if (duplex.source[Symbol.asyncIterator] != null) {
    source = duplex.source[Symbol.asyncIterator]();
  }
  const readBuffer = new Uint8ArrayList();
  const W = {
    read: async (options2) => {
      options2?.signal?.throwIfAborted();
      if (options2?.bytes == null) {
        const { done, value: value7 } = await raceSignal(source.next(), options2?.signal);
        if (done === true) {
          return null;
        }
        return value7;
      }
      while (readBuffer.byteLength < options2.bytes) {
        const { value: value7, done } = await raceSignal(source.next(), options2?.signal);
        if (done === true) {
          throw new UnexpectedEOFError2("unexpected end of input");
        }
        readBuffer.append(value7);
      }
      const buf = readBuffer.sublist(0, options2.bytes);
      readBuffer.consume(options2.bytes);
      return buf;
    },
    write: async (data, options2) => {
      options2?.signal?.throwIfAborted();
      if (data instanceof Uint8Array) {
        await write2.push(data, options2);
      } else {
        await write2.push(data.subarray(), options2);
      }
    },
    unwrap: () => {
      if (readBuffer.byteLength > 0) {
        const originalStream = duplex.source;
        duplex.source = async function* () {
          if (opts?.yieldBytes === false) {
            yield readBuffer;
          } else {
            yield* readBuffer;
          }
          yield* originalStream;
        }();
      }
      return duplex;
    }
  };
  return W;
}

// node_modules/libp2p/dist/src/connection-monitor.js
var DEFAULT_PING_INTERVAL_MS = 1e4;
var PROTOCOL_VERSION = "1.0.0";
var PROTOCOL_NAME = "ping";
var PROTOCOL_PREFIX = "ipfs";
var PING_LENGTH = 32;
var DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true;
var ConnectionMonitor = class {
  protocol;
  components;
  log;
  heartbeatInterval;
  pingIntervalMs;
  abortController;
  timeout;
  abortConnectionOnPingFailure;
  constructor(components, init = {}) {
    this.components = components;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.log = components.logger.forComponent("libp2p:connection-monitor");
    this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS;
    this.abortConnectionOnPingFailure = init.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE;
    this.timeout = new AdaptiveTimeout({
      ...init.pingTimeout ?? {},
      metrics: components.metrics,
      metricName: "libp2p_connection_monitor_ping_time_milliseconds"
    });
  }
  [Symbol.toStringTag] = "@libp2p/connection-monitor";
  [serviceCapabilities] = [
    "@libp2p/connection-monitor"
  ];
  start() {
    this.abortController = new AbortController();
    setMaxListeners(Infinity, this.abortController.signal);
    this.heartbeatInterval = setInterval(() => {
      this.components.connectionManager.getConnections().forEach((conn) => {
        Promise.resolve().then(async () => {
          let start2 = Date.now();
          try {
            const signal = this.timeout.getTimeoutSignal({
              signal: this.abortController?.signal
            });
            const stream = await conn.newStream(this.protocol, {
              signal,
              runOnLimitedConnection: true
            });
            const bs = byteStream(stream);
            start2 = Date.now();
            await Promise.all([
              bs.write(randomBytes(PING_LENGTH), {
                signal
              }),
              bs.read({
                bytes: PING_LENGTH,
                signal
              })
            ]);
            conn.rtt = Date.now() - start2;
            await bs.unwrap().close({
              signal
            });
          } catch (err) {
            if (err.name !== "UnsupportedProtocolError") {
              throw err;
            }
            conn.rtt = (Date.now() - start2) / 2;
          }
        }).catch((err) => {
          this.log.error("error during heartbeat", err);
          if (this.abortConnectionOnPingFailure) {
            this.log.error("aborting connection due to ping failure");
            conn.abort(err);
          } else {
            this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag");
          }
        });
      });
    }, this.pingIntervalMs);
  }
  stop() {
    this.abortController?.abort();
    if (this.heartbeatInterval != null) {
      clearInterval(this.heartbeatInterval);
    }
  }
};

// node_modules/libp2p/dist/src/content-routing.js
var CompoundContentRouting = class {
  routers;
  started;
  components;
  constructor(components, init) {
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
    this.findProviders = components.metrics?.traceFunction("libp2p.contentRouting.findProviders", this.findProviders.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      },
      getAttributesFromYieldedValue: (value7, attrs) => {
        return {
          ...attrs,
          providers: [...Array.isArray(attrs.providers) ? attrs.providers : [], value7.id.toString()]
        };
      }
    }) ?? this.findProviders;
    this.provide = components.metrics?.traceFunction("libp2p.contentRouting.provide", this.provide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    }) ?? this.provide;
    this.cancelReprovide = components.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide", this.cancelReprovide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    }) ?? this.cancelReprovide;
    this.put = components.metrics?.traceFunction("libp2p.contentRouting.put", this.put.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs: ([key]) => {
        return {
          key: toString(key, "base36")
        };
      }
    }) ?? this.put;
    this.get = components.metrics?.traceFunction("libp2p.contentRouting.get", this.get.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key]) => {
        return {
          key: toString(key, "base36")
        };
      }
    }) ?? this.get;
  }
  [Symbol.toStringTag] = "@libp2p/content-routing";
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key
   */
  async *findProviders(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    const self2 = this;
    const seen = new PeerSet();
    for await (const peer of src_default2(...self2.routers.filter((router) => router.findProviders instanceof Function).map((router) => router.findProviders(key, options2)))) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.components.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options2);
      }
      if (seen.has(peer.id)) {
        continue;
      }
      seen.add(peer.id);
      yield peer;
    }
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.filter((router) => router.provide instanceof Function).map(async (router) => {
      await router.provide(key, options2);
    }));
  }
  async cancelReprovide(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.filter((router) => router.cancelReprovide instanceof Function).map(async (router) => {
      await router.cancelReprovide(key, options2);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value7, options2) {
    if (!this.isStarted()) {
      throw new NotStartedError();
    }
    await Promise.all(this.routers.filter((router) => router.put instanceof Function).map(async (router) => {
      await router.put(key, value7, options2);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options2) {
    if (!this.isStarted()) {
      throw new NotStartedError();
    }
    return Promise.any(this.routers.filter((router) => router.get instanceof Function).map(async (router) => {
      return router.get(key, options2);
    }));
  }
};

// node_modules/libp2p/dist/src/peer-routing.js
var DefaultPeerRouting = class {
  log;
  peerId;
  peerStore;
  routers;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:peer-routing");
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.routers = init.routers ?? [];
    this.findPeer = components.metrics?.traceFunction("libp2p.peerRouting.findPeer", this.findPeer.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([peer], attrs) => {
        return {
          ...attrs,
          peer: peer.toString()
        };
      }
    }) ?? this.findPeer;
    this.getClosestPeers = components.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers", this.getClosestPeers.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key], attrs) => {
        return {
          ...attrs,
          key: toString(key, "base36")
        };
      },
      getAttributesFromYieldedValue: (value7, attrs) => {
        return {
          ...attrs,
          peers: [...Array.isArray(attrs.peers) ? attrs.peers : [], value7.id.toString()]
        };
      }
    }) ?? this.getClosestPeers;
  }
  [Symbol.toStringTag] = "@libp2p/peer-routing";
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options2) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    if (id.toString() === this.peerId.toString()) {
      throw new QueriedForSelfError("Should not try to find self");
    }
    const self2 = this;
    const source = src_default2(...this.routers.filter((router) => router.findPeer instanceof Function).map((router) => async function* () {
      try {
        yield await router.findPeer(id, options2);
      } catch (err) {
        self2.log.error(err);
      }
    }()));
    for await (const peer of source) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options2);
      }
      return peer;
    }
    throw new NotFoundError();
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    const self2 = this;
    const seen = createScalableCuckooFilter(1024);
    for await (const peer of parallel(async function* () {
      const source = src_default2(...self2.routers.filter((router) => router.getClosestPeers instanceof Function).map((router) => router.getClosestPeers(key, options2)));
      for await (let peer2 of source) {
        yield async () => {
          if (peer2.multiaddrs.length === 0) {
            try {
              peer2 = await self2.findPeer(peer2.id, {
                ...options2,
                useCache: false
              });
            } catch (err) {
              self2.log.error("could not find peer multiaddrs", err);
              return;
            }
          }
          return peer2;
        };
      }
    }())) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options2);
      }
      if (seen.has(peer.id.toMultihash().bytes)) {
        continue;
      }
      seen.add(peer.id.toMultihash().bytes);
      yield peer;
    }
  }
};

// node_modules/libp2p/dist/src/random-walk.js
var RandomWalk = class extends TypedEventEmitter {
  peerRouting;
  log;
  walking;
  walkers;
  shutdownController;
  walkController;
  needNext;
  constructor(components) {
    super();
    this.log = components.logger.forComponent("libp2p:random-walk");
    this.peerRouting = components.peerRouting;
    this.walkers = 0;
    this.walking = false;
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  [Symbol.toStringTag] = "@libp2p/random-walk";
  start() {
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  stop() {
    this.shutdownController.abort();
  }
  async *walk(options2) {
    if (!this.walking) {
      this.startWalk();
    }
    this.walkers++;
    const signal = anySignal([this.shutdownController.signal, options2?.signal]);
    setMaxListeners(Infinity, signal);
    try {
      while (true) {
        this.needNext?.resolve();
        this.needNext = pDefer();
        const event = await raceEvent(this, "walk:peer", signal, {
          errorEvent: "walk:error"
        });
        yield event.detail;
      }
    } finally {
      signal.clear();
      this.walkers--;
      if (this.walkers === 0) {
        this.walkController?.abort();
        this.walkController = void 0;
      }
    }
  }
  startWalk() {
    this.walking = true;
    this.walkController = new AbortController();
    setMaxListeners(Infinity, this.walkController.signal);
    const signal = anySignal([this.walkController.signal, this.shutdownController.signal]);
    setMaxListeners(Infinity, signal);
    const start2 = Date.now();
    let found = 0;
    Promise.resolve().then(async () => {
      this.log("start walk");
      while (this.walkers > 0) {
        try {
          const data = randomBytes(32);
          let s = Date.now();
          for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {
            if (signal.aborted) {
              this.log("aborting walk");
            }
            signal.throwIfAborted();
            this.log("found peer %p after %dms for %d walkers", peer.id, Date.now() - s, this.walkers);
            found++;
            this.safeDispatchEvent("walk:peer", {
              detail: peer
            });
            if (this.walkers === 1 && this.needNext != null) {
              this.log("wait for need next");
              await raceSignal(this.needNext.promise, signal);
            }
            s = Date.now();
          }
          this.log("walk iteration for %b and %d walkers finished, found %d peers", data, this.walkers, found);
        } catch (err) {
          this.log.error("random walk errored", err);
          this.safeDispatchEvent("walk:error", {
            detail: err
          });
        }
      }
      this.log("no walkers left, ended walk");
    }).catch((err) => {
      this.log.error("random walk errored", err);
    }).finally(() => {
      this.log("finished walk, found %d peers after %dms", found, Date.now() - start2);
      this.walking = false;
    });
  }
};

// node_modules/libp2p/dist/src/registrar.js
var DEFAULT_MAX_INBOUND_STREAMS2 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS2 = 64;
var Registrar = class {
  log;
  topologies;
  handlers;
  components;
  constructor(components) {
    this.components = components;
    this.log = components.logger.forComponent("libp2p:registrar");
    this.topologies = /* @__PURE__ */ new Map();
    components.metrics?.registerMetricGroup("libp2p_registrar_topologies", {
      calculate: () => {
        const output = {};
        for (const [key, value7] of this.topologies) {
          output[key] = value7.size;
        }
        return output;
      }
    });
    this.handlers = trackedMap({
      name: "libp2p_registrar_protocol_handlers",
      metrics: components.metrics
    });
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onPeerUpdate = this._onPeerUpdate.bind(this);
    this._onPeerIdentify = this._onPeerIdentify.bind(this);
    this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.events.addEventListener("peer:update", this._onPeerUpdate);
    this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
  }
  [Symbol.toStringTag] = "@libp2p/registrar";
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol) {
    const handler = this.handlers.get(protocol);
    if (handler == null) {
      throw new UnhandledProtocolError(`No handler registered for protocol ${protocol}`);
    }
    return handler;
  }
  getTopologies(protocol) {
    const topologies = this.topologies.get(protocol);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  /**
   * Registers the `handler` for each protocol
   */
  async handle(protocol, handler, opts) {
    if (this.handlers.has(protocol) && opts?.force !== true) {
      throw new DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol}`);
    }
    const options2 = mergeOptions.bind({ ignoreUndefined: true })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS2,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS2
    }, opts);
    this.handlers.set(protocol, {
      handler,
      options: options2
    });
    await this.components.peerStore.merge(this.components.peerId, {
      protocols: [protocol]
    }, opts);
  }
  /**
   * Removes the handler for each protocol. The protocol
   * will no longer be supported on streams.
   */
  async unhandle(protocols2, options2) {
    const protocolList = Array.isArray(protocols2) ? protocols2 : [protocols2];
    protocolList.forEach((protocol) => {
      this.handlers.delete(protocol);
    });
    await this.components.peerStore.patch(this.components.peerId, {
      protocols: this.getProtocols()
    }, options2);
  }
  /**
   * Register handlers for a set of multicodecs given
   */
  async register(protocol, topology) {
    if (topology == null) {
      throw new InvalidParametersError("invalid topology");
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol, topologies);
    }
    topologies.set(id, topology);
    return id;
  }
  /**
   * Unregister topology
   */
  unregister(id) {
    for (const [protocol, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol);
        }
      }
    }
  }
  /**
   * Remove a disconnected peer from the record
   */
  _onDisconnect(evt) {
    const remotePeer = evt.detail;
    const options2 = {
      signal: AbortSignal.timeout(5e3)
    };
    void this.components.peerStore.get(remotePeer, options2).then((peer) => {
      for (const protocol of peer.protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          if (topology.filter?.has(remotePeer) === false) {
            continue;
          }
          topology.filter?.remove(remotePeer);
          topology.onDisconnect?.(remotePeer);
        }
      }
    }).catch((err) => {
      if (err.name === "NotFoundError") {
        return;
      }
      this.log.error("could not inform topologies of disconnecting peer %p", remotePeer, err);
    });
  }
  /**
   * When a peer is updated, if they have removed supported protocols notify any
   * topologies interested in the removed protocols.
   */
  _onPeerUpdate(evt) {
    const { peer, previous } = evt.detail;
    const removed = (previous?.protocols ?? []).filter((protocol) => !peer.protocols.includes(protocol));
    for (const protocol of removed) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        if (topology.filter?.has(peer.id) === false) {
          continue;
        }
        topology.filter?.remove(peer.id);
        topology.onDisconnect?.(peer.id);
      }
    }
  }
  /**
   * After identify has completed and we have received the list of supported
   * protocols, notify any topologies interested in those protocols.
   */
  _onPeerIdentify(evt) {
    const protocols2 = evt.detail.protocols;
    const connection = evt.detail.connection;
    const peerId2 = evt.detail.peerId;
    for (const protocol of protocols2) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {
          continue;
        }
        if (topology.filter?.has(peerId2) === true) {
          continue;
        }
        topology.filter?.add(peerId2);
        topology.onConnect?.(peerId2, connection);
      }
    }
  }
};

// node_modules/libp2p/dist/src/transport-manager.js
var DefaultTransportManager = class {
  log;
  components;
  transports;
  listeners;
  faultTolerance;
  started;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:transports");
    this.components = components;
    this.started = false;
    this.transports = trackedMap({
      name: "libp2p_transport_manager_transports",
      metrics: this.components.metrics
    });
    this.listeners = trackedMap({
      name: "libp2p_transport_manager_listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  [Symbol.toStringTag] = "@libp2p/transport-manager";
  /**
   * Adds a `Transport` to the manager
   */
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw new InvalidParametersError("Transport must have a valid tag");
    }
    if (this.transports.has(tag)) {
      throw new InvalidParametersError(`There is already a transport with the tag ${tag}`);
    }
    this.log("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
  }
  /**
   * Stops all listeners
   */
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      this.log("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    this.log("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  /**
   * Dials the given Multiaddr over it's supported transport
   */
  async dial(ma, options2) {
    const transport = this.dialTransportForMultiaddr(ma);
    if (transport == null) {
      throw new TransportUnavailableError(`No transport available for address ${String(ma)}`);
    }
    options2?.onProgress?.(new CustomProgressEvent("transport-manager:selected-transport", transport[Symbol.toStringTag]));
    return transport.dial(ma, {
      ...options2,
      upgrader: this.components.upgrader
    });
  }
  /**
   * Returns all Multiaddr's the listeners are using
   */
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  /**
   * Returns all the transports instances
   */
  getTransports() {
    return Array.of(...this.transports.values());
  }
  /**
   * Returns all the listener instances
   */
  getListeners() {
    return Array.of(...this.listeners.values()).flat();
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  dialTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.dialFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  listenTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.listenFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Starts listeners for each listen Multiaddr
   */
  async listen(addrs) {
    if (!this.isStarted()) {
      throw new NotStartedError("Not started");
    }
    if (addrs == null || addrs.length === 0) {
      this.log("no addresses were provided for listening, this node is dial only");
      return;
    }
    const listenStats = {
      errors: /* @__PURE__ */ new Map(),
      ipv4: {
        success: 0,
        attempts: 0
      },
      ipv6: {
        success: 0,
        attempts: 0
      }
    };
    addrs.forEach((ma) => {
      listenStats.errors.set(ma.toString(), new UnsupportedListenAddressError());
    });
    const tasks = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.listenFilter(addrs);
      for (const addr of supportedAddrs) {
        this.log("creating listener for %s on %a", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners = this.listeners.get(key) ?? [];
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.components.events.safeDispatchEvent("transport:listening", {
            detail: listener
          });
        });
        listener.addEventListener("close", () => {
          const index = listeners.findIndex((l) => l === listener);
          listeners.splice(index, 1);
          this.components.events.safeDispatchEvent("transport:close", {
            detail: listener
          });
        });
        if (IP42.matches(addr)) {
          listenStats.ipv4.attempts++;
        } else if (IP62.matches(addr)) {
          listenStats.ipv6.attempts++;
        }
        tasks.push(listener.listen(addr).then(() => {
          listenStats.errors.delete(addr.toString());
          if (IP42.matches(addr)) {
            listenStats.ipv4.success++;
          }
          if (IP62.matches(addr)) {
            listenStats.ipv6.success++;
          }
        }, (err) => {
          this.log.error("transport %s could not listen on address %a - %e", key, addr, err);
          listenStats.errors.set(addr.toString(), err);
          throw err;
        }));
      }
    }
    const results = await Promise.allSettled(tasks);
    if (results.length > 0 && results.every((res) => res.status === "fulfilled")) {
      return;
    }
    if (this.ipv6Unsupported(listenStats)) {
      this.log("all IPv4 addresses succeed but all IPv6 failed");
      return;
    }
    if (this.faultTolerance === FaultTolerance.NO_FATAL) {
      this.log("failed to listen on any address but fault tolerance allows this");
      return;
    }
    throw new UnsupportedListenAddressesError(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...listenStats.errors.entries()].map(([addr, err]) => {
      return `
  ${addr}: ${`${err.stack ?? err}`.split("\n").join("\n  ")}
`;
    }).join("")}`);
  }
  ipv6Unsupported(listenStats) {
    if (listenStats.ipv4.attempts === 0 || listenStats.ipv6.attempts === 0) {
      return false;
    }
    const allIpv4Succeeded = listenStats.ipv4.attempts === listenStats.ipv4.success;
    const allIpv6Failed = listenStats.ipv6.success === 0;
    return allIpv4Succeeded && allIpv6Failed;
  }
  /**
   * Removes the given transport from the manager.
   * If a transport has any running listeners, they will be closed.
   */
  async remove(key) {
    const listeners = this.listeners.get(key) ?? [];
    this.log.trace("removing transport %s", key);
    const tasks = [];
    this.log.trace("closing listeners for %s", key);
    while (listeners.length > 0) {
      const listener = listeners.pop();
      if (listener == null) {
        continue;
      }
      tasks.push(listener.close());
    }
    await Promise.all(tasks);
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  /**
   * Removes all transports from the manager.
   * If any listeners are running, they will be closed.
   *
   * @async
   */
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};

// node_modules/@libp2p/multistream-select/dist/src/constants.js
var PROTOCOL_ID = "/multistream/1.0.0";
var MAX_PROTOCOL_LENGTH = 1024;

// node_modules/it-length-prefixed-stream/dist/src/errors.js
var InvalidMessageLengthError3 = class extends Error {
  name = "InvalidMessageLengthError";
  code = "ERR_INVALID_MSG_LENGTH";
};
var InvalidDataLengthError2 = class extends Error {
  name = "InvalidDataLengthError";
  code = "ERR_MSG_DATA_TOO_LONG";
};
var InvalidDataLengthLengthError2 = class extends Error {
  name = "InvalidDataLengthLengthError";
  code = "ERR_MSG_LENGTH_TOO_LONG";
};

// node_modules/it-length-prefixed-stream/dist/src/index.js
function lpStream(duplex, opts = {}) {
  const bytes = byteStream(duplex, opts);
  if (opts.maxDataLength != null && opts.maxLengthLength == null) {
    opts.maxLengthLength = encodingLength(opts.maxDataLength);
  }
  const decodeLength = opts?.lengthDecoder ?? decode;
  const encodeLength = opts?.lengthEncoder ?? encode;
  const W = {
    read: async (options2) => {
      let dataLength = -1;
      const lengthBuffer = new Uint8ArrayList();
      while (true) {
        lengthBuffer.append(await bytes.read({
          ...options2,
          bytes: 1
        }));
        try {
          dataLength = decodeLength(lengthBuffer);
        } catch (err) {
          if (err instanceof RangeError) {
            continue;
          }
          throw err;
        }
        if (dataLength < 0) {
          throw new InvalidMessageLengthError3("Invalid message length");
        }
        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
          throw new InvalidDataLengthLengthError2("message length length too long");
        }
        if (dataLength > -1) {
          break;
        }
      }
      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
        throw new InvalidDataLengthError2("message length too long");
      }
      return bytes.read({
        ...options2,
        bytes: dataLength
      });
    },
    write: async (data, options2) => {
      await bytes.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options2);
    },
    writeV: async (data, options2) => {
      const list = new Uint8ArrayList(...data.flatMap((buf) => [encodeLength(buf.byteLength), buf]));
      await bytes.write(list, options2);
    },
    unwrap: () => {
      return bytes.unwrap();
    }
  };
  return W;
}

// node_modules/@libp2p/multistream-select/dist/src/multistream.js
var NewLine = fromString("\n");
async function write(writer, buffer, options2) {
  await writer.write(buffer, options2);
}
async function writeAll(writer, buffers, options2) {
  await writer.writeV(buffers, options2);
}
async function read11(reader, options2) {
  const buf = await reader.read(options2);
  if (buf.byteLength === 0 || buf.get(buf.byteLength - 1) !== NewLine[0]) {
    options2.log.error("Invalid mss message - missing newline", buf);
    throw new InvalidMessageError("Missing newline");
  }
  return buf.sublist(0, -1);
}
async function readString(reader, options2) {
  const buf = await read11(reader, options2);
  return toString(buf.subarray());
}

// node_modules/@libp2p/multistream-select/dist/src/select.js
async function select(stream, protocols2, options2) {
  protocols2 = Array.isArray(protocols2) ? [...protocols2] : [protocols2];
  if (protocols2.length === 1 && options2.negotiateFully === false) {
    return optimisticSelect(stream, protocols2[0], options2);
  }
  const lp = lpStream(stream, {
    ...options2,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  const protocol = protocols2.shift();
  if (protocol == null) {
    throw new Error("At least one protocol must be specified");
  }
  options2.log.trace('select: write ["%s", "%s"]', PROTOCOL_ID, protocol);
  const p1 = fromString(`${PROTOCOL_ID}
`);
  const p2 = fromString(`${protocol}
`);
  await writeAll(lp, [p1, p2], options2);
  options2.log.trace("select: reading multistream-select header");
  let response = await readString(lp, options2);
  options2.log.trace('select: read "%s"', response);
  if (response === PROTOCOL_ID) {
    options2.log.trace("select: reading protocol response");
    response = await readString(lp, options2);
    options2.log.trace('select: read "%s"', response);
  }
  if (response === protocol) {
    return { stream: lp.unwrap(), protocol };
  }
  for (const protocol2 of protocols2) {
    options2.log.trace('select: write "%s"', protocol2);
    await write(lp, fromString(`${protocol2}
`), options2);
    options2.log.trace("select: reading protocol response");
    const response2 = await readString(lp, options2);
    options2.log.trace('select: read "%s" for "%s"', response2, protocol2);
    if (response2 === protocol2) {
      return { stream: lp.unwrap(), protocol: protocol2 };
    }
  }
  throw new UnsupportedProtocolError("protocol selection failed");
}
function optimisticSelect(stream, protocol, options2) {
  const originalSink = stream.sink.bind(stream);
  const originalSource = stream.source;
  let negotiated = false;
  let negotiating = false;
  const doneNegotiating = pDefer();
  let sentProtocol = false;
  let sendingProtocol = false;
  const doneSendingProtocol = pDefer();
  let readProtocol = false;
  let readingProtocol = false;
  const doneReadingProtocol = pDefer();
  const lp = lpStream({
    sink: originalSink,
    source: originalSource
  }, {
    ...options2,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  stream.sink = async (source) => {
    const { sink } = lp.unwrap();
    await sink(async function* () {
      let sentData = false;
      for await (const buf of source) {
        if (sendingProtocol) {
          await doneSendingProtocol.promise;
        }
        if (!sentProtocol) {
          sendingProtocol = true;
          options2.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);
          const protocolString = `${protocol}
`;
          yield new Uint8ArrayList(
            Uint8Array.from([19]),
            // length of PROTOCOL_ID plus newline
            fromString(`${PROTOCOL_ID}
`),
            encode(protocolString.length),
            fromString(protocolString),
            buf
          ).subarray();
          options2.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);
          sentProtocol = true;
          sendingProtocol = false;
          doneSendingProtocol.resolve();
          negotiate().catch((err) => {
            options2.log.error("could not finish optimistic protocol negotiation of %s", protocol, err);
          });
        } else {
          yield buf;
        }
        sentData = true;
      }
      if (!sentData) {
        await negotiate();
      }
    }());
  };
  async function negotiate() {
    if (negotiating) {
      options2.log.trace("optimistic: already negotiating %s stream", protocol);
      await doneNegotiating.promise;
      return;
    }
    negotiating = true;
    try {
      if (!sentProtocol) {
        options2.log.trace("optimistic: doing send protocol for %s stream", protocol);
        await doSendProtocol();
      }
      if (!readProtocol) {
        options2.log.trace("optimistic: doing read protocol for %s stream", protocol);
        await doReadProtocol();
      }
    } finally {
      negotiating = false;
      negotiated = true;
      doneNegotiating.resolve();
    }
  }
  async function doSendProtocol() {
    if (sendingProtocol) {
      await doneSendingProtocol.promise;
      return;
    }
    sendingProtocol = true;
    try {
      options2.log.trace('optimistic: write ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
      await lp.writeV([
        fromString(`${PROTOCOL_ID}
`),
        fromString(`${protocol}
`)
      ]);
      options2.log.trace('optimistic: wrote ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
    } finally {
      sentProtocol = true;
      sendingProtocol = false;
      doneSendingProtocol.resolve();
    }
  }
  async function doReadProtocol() {
    if (readingProtocol) {
      await doneReadingProtocol.promise;
      return;
    }
    readingProtocol = true;
    try {
      options2.log.trace("optimistic: reading multistream select header");
      let response = await readString(lp, options2);
      options2.log.trace('optimistic: read multistream select header "%s"', response);
      if (response === PROTOCOL_ID) {
        response = await readString(lp, options2);
      }
      options2.log.trace('optimistic: read protocol "%s", expecting "%s"', response, protocol);
      if (response !== protocol) {
        throw new UnsupportedProtocolError("protocol selection failed");
      }
    } finally {
      readProtocol = true;
      readingProtocol = false;
      doneReadingProtocol.resolve();
    }
  }
  stream.source = async function* () {
    await negotiate();
    options2.log.trace('optimistic: reading data from "%s" stream', protocol);
    yield* lp.unwrap().source;
  }();
  if (stream.closeRead != null) {
    const originalCloseRead = stream.closeRead.bind(stream);
    stream.closeRead = async (opts) => {
      if (!negotiated) {
        await negotiate().catch((err) => {
          options2.log.error("could not negotiate protocol before close read", err);
        });
      }
      await originalCloseRead(opts);
    };
  }
  if (stream.closeWrite != null) {
    const originalCloseWrite = stream.closeWrite.bind(stream);
    stream.closeWrite = async (opts) => {
      if (!negotiated) {
        await negotiate().catch((err) => {
          options2.log.error("could not negotiate protocol before close write", err);
        });
      }
      await originalCloseWrite(opts);
    };
  }
  if (stream.close != null) {
    const originalClose = stream.close.bind(stream);
    stream.close = async (opts) => {
      const tasks = [];
      if (sendingProtocol) {
        tasks.push(doneSendingProtocol.promise);
      }
      if (readingProtocol) {
        tasks.push(doneReadingProtocol.promise);
      }
      if (tasks.length > 0) {
        await raceSignal(Promise.all(tasks), opts?.signal);
      } else {
        negotiated = true;
        negotiating = false;
        doneNegotiating.resolve();
      }
      await originalClose(opts);
    };
  }
  return {
    stream,
    protocol
  };
}

// node_modules/@libp2p/multistream-select/dist/src/handle.js
async function handle(stream, protocols2, options2) {
  protocols2 = Array.isArray(protocols2) ? protocols2 : [protocols2];
  options2.log.trace("handle: available protocols %s", protocols2);
  const lp = lpStream(stream, {
    ...options2,
    maxDataLength: MAX_PROTOCOL_LENGTH,
    maxLengthLength: 2
    // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH
  });
  while (true) {
    options2.log.trace("handle: reading incoming string");
    const protocol = await readString(lp, options2);
    options2.log.trace('handle: read "%s"', protocol);
    if (protocol === PROTOCOL_ID) {
      options2.log.trace('handle: respond with "%s" for "%s"', PROTOCOL_ID, protocol);
      await write(lp, fromString(`${PROTOCOL_ID}
`), options2);
      options2.log.trace('handle: responded with "%s" for "%s"', PROTOCOL_ID, protocol);
      continue;
    }
    if (protocols2.includes(protocol)) {
      options2.log.trace('handle: respond with "%s" for "%s"', protocol, protocol);
      await write(lp, fromString(`${protocol}
`), options2);
      options2.log.trace('handle: responded with "%s" for "%s"', protocol, protocol);
      return { stream: lp.unwrap(), protocol };
    }
    if (protocol === "ls") {
      const protos = new Uint8ArrayList(...protocols2.map((p) => encode8.single(fromString(`${p}
`))), fromString("\n"));
      options2.log.trace('handle: respond with "%s" for %s', protocols2, protocol);
      await write(lp, protos, options2);
      options2.log.trace('handle: responded with "%s" for %s', protocols2, protocol);
      continue;
    }
    options2.log.trace('handle: respond with "na" for "%s"', protocol);
    await write(lp, fromString("na\n"), options2);
    options2.log('handle: responded with "na" for "%s"', protocol);
  }
}

// node_modules/libp2p/dist/src/connection/index.js
var CLOSE_TIMEOUT = 500;
var ConnectionImpl = class {
  /**
   * Connection identifier.
   */
  id;
  /**
   * Observed multiaddr of the remote peer
   */
  remoteAddr;
  /**
   * Remote peer id
   */
  remotePeer;
  direction;
  timeline;
  multiplexer;
  encryption;
  status;
  limits;
  log;
  /**
   * User provided tags
   *
   */
  tags;
  /**
   * Reference to the new stream function of the multiplexer
   */
  _newStream;
  /**
   * Reference to the close function of the raw connection
   */
  _close;
  _abort;
  /**
   * Reference to the getStreams function of the muxer
   */
  _getStreams;
  /**
   * An implementation of the js-libp2p connection.
   * Any libp2p transport should use an upgrader to return this connection.
   */
  constructor(init) {
    const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    this.remoteAddr = remoteAddr;
    this.remotePeer = remotePeer;
    this.direction = init.direction;
    this.status = "open";
    this.timeline = init.timeline;
    this.multiplexer = init.multiplexer;
    this.encryption = init.encryption;
    this.limits = init.limits;
    this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`);
    if (this.remoteAddr.getPeerId() == null) {
      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
    }
    this._newStream = newStream;
    this._close = close;
    this._abort = abort;
    this._getStreams = getStreams;
    this.tags = [];
  }
  [Symbol.toStringTag] = "Connection";
  [connectionSymbol] = true;
  /**
   * Get all the streams of the muxer
   */
  get streams() {
    return this._getStreams();
  }
  /**
   * Create a new stream from this connection
   */
  async newStream(protocols2, options2) {
    if (this.status === "closing") {
      throw new ConnectionClosingError("the connection is being closed");
    }
    if (this.status === "closed") {
      throw new ConnectionClosedError("the connection is closed");
    }
    if (!Array.isArray(protocols2)) {
      protocols2 = [protocols2];
    }
    if (this.limits != null && options2?.runOnLimitedConnection !== true) {
      throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
    }
    const stream = await this._newStream(protocols2, options2);
    stream.direction = "outbound";
    return stream;
  }
  /**
   * Close the connection
   */
  async close(options2 = {}) {
    if (this.status === "closed" || this.status === "closing") {
      return;
    }
    this.log("closing connection to %a", this.remoteAddr);
    this.status = "closing";
    if (options2.signal == null) {
      const signal = AbortSignal.timeout(CLOSE_TIMEOUT);
      setMaxListeners(Infinity, signal);
      options2 = {
        ...options2,
        signal
      };
    }
    try {
      this.log.trace("closing underlying transport");
      await this._close(options2);
      this.log.trace("updating timeline with close time");
      this.status = "closed";
      this.timeline.close = Date.now();
    } catch (err) {
      this.log.error("error encountered during graceful close of connection to %a", this.remoteAddr, err);
      this.abort(err);
    }
  }
  abort(err) {
    if (this.status === "closed") {
      return;
    }
    this.log.error("aborting connection to %a due to error", this.remoteAddr, err);
    this.status = "closing";
    this._abort(err);
    this.status = "closed";
    this.timeline.close = Date.now();
  }
};
function createConnection(init) {
  return new ConnectionImpl(init);
}

// node_modules/libp2p/dist/src/upgrader.js
function findIncomingStreamLimit(protocol, registrar) {
  try {
    const { options: options2 } = registrar.getHandler(protocol);
    return options2.maxInboundStreams;
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS2;
}
function findOutgoingStreamLimit(protocol, registrar, options2 = {}) {
  try {
    const { options: options3 } = registrar.getHandler(protocol);
    if (options3.maxOutboundStreams != null) {
      return options3.maxOutboundStreams;
    }
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return options2.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS2;
}
function countStreams(protocol, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.direction === direction && stream.protocol === protocol) {
      streamCount++;
    }
  });
  return streamCount;
}
var Upgrader = class {
  components;
  connectionEncrypters;
  streamMuxers;
  inboundUpgradeTimeout;
  inboundStreamProtocolNegotiationTimeout;
  outboundStreamProtocolNegotiationTimeout;
  events;
  metrics;
  constructor(components, init) {
    this.components = components;
    this.connectionEncrypters = trackedMap({
      name: "libp2p_upgrader_connection_encrypters",
      metrics: this.components.metrics
    });
    init.connectionEncrypters.forEach((encrypter) => {
      this.connectionEncrypters.set(encrypter.protocol, encrypter);
    });
    this.streamMuxers = trackedMap({
      name: "libp2p_upgrader_stream_multiplexers",
      metrics: this.components.metrics
    });
    init.streamMuxers.forEach((muxer) => {
      this.streamMuxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
    this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.events = components.events;
    this.metrics = {
      dials: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),
      errors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),
      inboundErrors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),
      outboundErrors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")
    };
  }
  [Symbol.toStringTag] = "@libp2p/upgrader";
  async shouldBlockConnection(method, ...args) {
    const denyOperation = this.components.connectionGater[method];
    if (denyOperation == null) {
      return;
    }
    const result = await denyOperation.apply(this.components.connectionGater, args);
    if (result === true) {
      throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`);
    }
  }
  createInboundAbortSignal(signal) {
    const output = anySignal([
      AbortSignal.timeout(this.inboundUpgradeTimeout),
      signal
    ]);
    setMaxListeners(Infinity, output);
    return output;
  }
  /**
   * Upgrades an inbound connection
   */
  async upgradeInbound(maConn, opts) {
    let accepted = false;
    const signal = this.createInboundAbortSignal(opts.signal);
    try {
      this.metrics.dials?.increment({
        inbound: true
      });
      accepted = await raceSignal(this.components.connectionManager.acceptIncomingConnection(maConn), signal);
      if (!accepted) {
        throw new ConnectionDeniedError("Connection denied");
      }
      await raceSignal(this.shouldBlockConnection("denyInboundConnection", maConn), signal);
      await this._performUpgrade(maConn, "inbound", {
        ...opts,
        signal
      });
    } catch (err) {
      this.metrics.errors?.increment({
        inbound: true
      });
      this.metrics.inboundErrors?.increment({
        [err.name ?? "Error"]: true
      });
      throw err;
    } finally {
      signal.clear();
      if (accepted) {
        this.components.connectionManager.afterUpgradeInbound();
      }
    }
  }
  /**
   * Upgrades an outbound connection
   */
  async upgradeOutbound(maConn, opts) {
    try {
      this.metrics.dials?.increment({
        outbound: true
      });
      const idStr = maConn.remoteAddr.getPeerId();
      let remotePeerId;
      if (idStr != null) {
        remotePeerId = peerIdFromString(idStr);
        await raceSignal(this.shouldBlockConnection("denyOutboundConnection", remotePeerId, maConn), opts.signal);
      }
      let direction = "outbound";
      if (opts.initiator === false) {
        direction = "inbound";
      }
      return await this._performUpgrade(maConn, direction, opts);
    } catch (err) {
      this.metrics.errors?.increment({
        outbound: true
      });
      this.metrics.outboundErrors?.increment({
        [err.name ?? "Error"]: true
      });
      throw err;
    }
  }
  async _performUpgrade(maConn, direction, opts) {
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let muxerFactory;
    let cryptoProtocol;
    this.components.metrics?.trackMultiaddrConnection(maConn);
    maConn.log.trace("starting the %s connection upgrade", direction);
    let protectedConn = maConn;
    if (opts?.skipProtection !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        maConn.log("protecting the %s connection", direction);
        protectedConn = await protector.protect(maConn, opts);
      }
    }
    try {
      encryptedConn = protectedConn;
      if (opts?.skipEncryption !== true) {
        opts?.onProgress?.(new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol,
          streamMuxer: muxerFactory
        } = await (direction === "inbound" ? this._encryptInbound(protectedConn, opts) : this._encryptOutbound(protectedConn, opts)));
        const maConn2 = {
          ...protectedConn,
          ...encryptedConn
        };
        await this.shouldBlockConnection(direction === "inbound" ? "denyInboundEncryptedConnection" : "denyOutboundEncryptedConnection", remotePeer, maConn2);
      } else {
        const idStr = maConn.remoteAddr.getPeerId();
        if (idStr == null) {
          throw new InvalidMultiaddrError(`${direction} connection that skipped encryption must have a peer id`);
        }
        const remotePeerId = peerIdFromString(idStr);
        cryptoProtocol = "native";
        remotePeer = remotePeerId;
      }
      if (remotePeer.equals(this.components.peerId)) {
        const err = new InvalidPeerIdError("Can not dial self");
        maConn.abort(err);
        throw err;
      }
      upgradedConn = encryptedConn;
      if (opts?.muxerFactory != null) {
        muxerFactory = opts.muxerFactory;
      } else if (muxerFactory == null && this.streamMuxers.size > 0) {
        opts?.onProgress?.(new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`));
        const multiplexed = await (direction === "inbound" ? this._multiplexInbound({
          ...protectedConn,
          ...encryptedConn
        }, this.streamMuxers, opts) : this._multiplexOutbound({
          ...protectedConn,
          ...encryptedConn
        }, this.streamMuxers, opts));
        muxerFactory = multiplexed.muxerFactory;
        upgradedConn = multiplexed.stream;
      }
    } catch (err) {
      maConn.log.error("failed to upgrade inbound connection %s %a - %e", direction === "inbound" ? "from" : "to", maConn.remoteAddr, err);
      throw err;
    }
    await this.shouldBlockConnection(direction === "inbound" ? "denyInboundUpgradedConnection" : "denyOutboundUpgradedConnection", remotePeer, maConn);
    maConn.log("successfully upgraded %s connection", direction);
    return this._createConnection({
      cryptoProtocol,
      direction,
      maConn,
      upgradedConn,
      muxerFactory,
      remotePeer,
      limits: opts?.limits
    });
  }
  /**
   * A convenience method for generating a new `Connection`
   */
  _createConnection(opts) {
    const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, limits } = opts;
    let muxer;
    let newStream;
    let connection;
    if (muxerFactory != null) {
      muxer = muxerFactory.createStreamMuxer({
        direction,
        // Run anytime a remote stream is created
        onIncomingStream: (muxedStream) => {
          if (connection == null) {
            return;
          }
          const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);
          setMaxListeners(Infinity, signal);
          void Promise.resolve().then(async () => {
            const protocols2 = this.components.registrar.getProtocols();
            const { stream, protocol } = await handle(muxedStream, protocols2, {
              signal,
              log: muxedStream.log,
              yieldBytes: false
            });
            if (connection == null) {
              return;
            }
            connection.log("incoming stream opened on %s", protocol);
            const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);
            const streamCount = countStreams(protocol, "inbound", connection);
            if (streamCount === incomingLimit) {
              const err = new TooManyInboundProtocolStreamsError(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`);
              muxedStream.abort(err);
              throw err;
            }
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.protocol = protocol;
            if (stream.closeWrite != null) {
              muxedStream.closeWrite = stream.closeWrite;
            }
            if (stream.closeRead != null) {
              muxedStream.closeRead = stream.closeRead;
            }
            if (stream.close != null) {
              muxedStream.close = stream.close;
            }
            await this.components.peerStore.merge(remotePeer, {
              protocols: [protocol]
            }, {
              signal
            });
            this.components.metrics?.trackProtocolStream(muxedStream, connection);
            this._onStream({ connection, stream: muxedStream, protocol });
          }).catch(async (err) => {
            connection.log.error("error handling incoming stream id %s - %e", muxedStream.id, err);
            if (muxedStream.timeline.close == null) {
              await muxedStream.close({
                signal
              }).catch((err2) => muxedStream.abort(err2));
            }
          });
        }
      });
      newStream = async (protocols2, options2 = {}) => {
        if (muxer == null) {
          throw new MuxerUnavailableError("Connection is not multiplexed");
        }
        connection.log.trace("starting new stream for protocols %s", protocols2);
        const muxedStream = await muxer.newStream();
        connection.log.trace("started new stream %s for protocols %s", muxedStream.id, protocols2);
        try {
          if (options2.signal == null) {
            muxedStream.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols2);
            const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);
            setMaxListeners(Infinity, signal);
            options2 = {
              ...options2,
              signal
            };
          }
          muxedStream.log.trace("selecting protocol from protocols %s", protocols2);
          const { stream, protocol } = await select(muxedStream, protocols2, {
            ...options2,
            log: muxedStream.log,
            yieldBytes: true
          });
          muxedStream.log.trace("selected protocol %s", protocol);
          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options2);
          const streamCount = countStreams(protocol, "outbound", connection);
          if (streamCount >= outgoingLimit) {
            const err = new TooManyOutboundProtocolStreamsError(`Too many outbound protocol streams for protocol "${protocol}" - ${streamCount}/${outgoingLimit}`);
            muxedStream.abort(err);
            throw err;
          }
          await this.components.peerStore.merge(remotePeer, {
            protocols: [protocol]
          });
          muxedStream.source = stream.source;
          muxedStream.sink = stream.sink;
          muxedStream.protocol = protocol;
          if (stream.closeWrite != null) {
            muxedStream.closeWrite = stream.closeWrite;
          }
          if (stream.closeRead != null) {
            muxedStream.closeRead = stream.closeRead;
          }
          if (stream.close != null) {
            muxedStream.close = stream.close;
          }
          this.components.metrics?.trackProtocolStream(muxedStream, connection);
          return muxedStream;
        } catch (err) {
          connection.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e", direction === "inbound" ? "from" : "to", opts.maConn.remoteAddr, protocols2, err);
          if (muxedStream.timeline.close == null) {
            muxedStream.abort(err);
          }
          throw err;
        }
      };
      void Promise.all([
        muxer.sink(upgradedConn.source),
        upgradedConn.sink(muxer.source)
      ]).catch((err) => {
        connection.log.error("error piping data through muxer - %e", err);
      });
    }
    const _timeline = maConn.timeline;
    maConn.timeline = new Proxy(_timeline, {
      set: (...args) => {
        if (args[1] === "close" && args[2] != null && _timeline.close == null) {
          (async () => {
            try {
              if (connection.status === "open") {
                await connection.close();
              }
            } catch (err) {
              connection.log.error("error closing connection after timeline close %e", err);
            } finally {
              this.events.safeDispatchEvent("connection:close", {
                detail: connection
              });
            }
          })().catch((err) => {
            connection.log.error("error thrown while dispatching connection:close event %e", err);
          });
        }
        return Reflect.set(...args);
      }
    });
    maConn.timeline.upgraded = Date.now();
    const errConnectionNotMultiplexed = () => {
      throw new MuxerUnavailableError("Connection is not multiplexed");
    };
    connection = createConnection({
      remoteAddr: maConn.remoteAddr,
      remotePeer,
      status: "open",
      direction,
      timeline: maConn.timeline,
      multiplexer: muxer?.protocol,
      encryption: cryptoProtocol,
      limits,
      logger: this.components.logger,
      newStream: newStream ?? errConnectionNotMultiplexed,
      getStreams: () => {
        return muxer?.streams ?? [];
      },
      close: async (options2) => {
        await muxer?.close(options2);
        await maConn.close(options2);
      },
      abort: (err) => {
        maConn.abort(err);
        muxer?.abort(err);
      }
    });
    this.events.safeDispatchEvent("connection:open", {
      detail: connection
    });
    connection.__maConnTimeline = _timeline;
    return connection;
  }
  /**
   * Routes incoming streams to the correct handler
   */
  _onStream(opts) {
    const { connection, stream, protocol } = opts;
    const { handler, options: options2 } = this.components.registrar.getHandler(protocol);
    if (connection.limits != null && options2.runOnLimitedConnection !== true) {
      throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
    }
    handler({ connection, stream });
  }
  /**
   * Attempts to encrypt the incoming `connection` with the provided `cryptos`
   */
  async _encryptInbound(connection, options2) {
    const protocols2 = Array.from(this.connectionEncrypters.keys());
    try {
      const { stream, protocol } = await handle(connection, protocols2, {
        ...options2,
        log: connection.log
      });
      const encrypter = this.connectionEncrypters.get(protocol);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting inbound connection to %a using %s", connection.remoteAddr, protocol);
      return {
        ...await encrypter.secureInbound(stream, options2),
        protocol
      };
    } catch (err) {
      connection.log.error("encrypting inbound connection from %a failed", connection.remoteAddr, err);
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Attempts to encrypt the given `connection` with the provided connection encrypters.
   * The first `ConnectionEncrypter` module to succeed will be used
   */
  async _encryptOutbound(connection, options2) {
    const protocols2 = Array.from(this.connectionEncrypters.keys());
    try {
      connection.log.trace("selecting encrypter from %s", protocols2);
      const { stream, protocol } = await select(connection, protocols2, {
        ...options2,
        log: connection.log,
        yieldBytes: true
      });
      const encrypter = this.connectionEncrypters.get(protocol);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting outbound connection to %a using %s", connection.remoteAddr, protocol);
      return {
        ...await encrypter.secureOutbound(stream, options2),
        protocol
      };
    } catch (err) {
      connection.log.error("encrypting outbound connection to %a failed", connection.remoteAddr, err);
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Selects one of the given muxers via multistream-select. That
   * muxer will be used for all future streams on the connection.
   */
  async _multiplexOutbound(connection, muxers, options2) {
    const protocols2 = Array.from(muxers.keys());
    connection.log("outbound selecting muxer %s", protocols2);
    try {
      connection.log.trace("selecting stream muxer from %s", protocols2);
      const { stream, protocol } = await select(connection, protocols2, {
        ...options2,
        log: connection.log,
        yieldBytes: true
      });
      connection.log("selected %s as muxer protocol", protocol);
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      connection.log.error("error multiplexing outbound connection", err);
      throw new MuxerUnavailableError(String(err));
    }
  }
  /**
   * Registers support for one of the given muxers via multistream-select. The
   * selected muxer will be used for all future streams on the connection.
   */
  async _multiplexInbound(connection, muxers, options2) {
    const protocols2 = Array.from(muxers.keys());
    connection.log("inbound handling muxers %s", protocols2);
    try {
      const { stream, protocol } = await handle(connection, protocols2, {
        ...options2,
        log: connection.log
      });
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      connection.log.error("error multiplexing inbound connection", err);
      throw new MuxerUnavailableError(String(err));
    }
  }
  getConnectionEncrypters() {
    return this.connectionEncrypters;
  }
  getStreamMuxers() {
    return this.streamMuxers;
  }
};

// node_modules/libp2p/dist/src/version.js
var version = "2.9.0";
var name6 = "js-libp2p";

// node_modules/libp2p/dist/src/user-agent.browser.js
function userAgent(name9, version3) {
  return `${name9 ?? name6}/${version3 ?? version} browser/${globalThis.navigator.userAgent}`;
}

// node_modules/libp2p/dist/src/libp2p.js
var Libp2p = class extends TypedEventEmitter {
  peerId;
  peerStore;
  contentRouting;
  peerRouting;
  metrics;
  services;
  logger;
  status;
  components;
  log;
  // eslint-disable-next-line complexity
  constructor(init) {
    super();
    this.status = "stopped";
    const events = new TypedEventEmitter();
    const originalDispatch = events.dispatchEvent.bind(events);
    events.dispatchEvent = (evt) => {
      const internalResult = originalDispatch(evt);
      const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
      return internalResult || externalResult;
    };
    setMaxListeners(Infinity, events);
    this.peerId = init.peerId;
    this.logger = init.logger ?? defaultLogger();
    this.log = this.logger.forComponent("libp2p");
    this.services = {};
    const nodeInfoName = init.nodeInfo?.name ?? name6;
    const nodeInfoVersion = init.nodeInfo?.version ?? version;
    const components = this.components = defaultComponents({
      peerId: init.peerId,
      privateKey: init.privateKey,
      nodeInfo: {
        name: nodeInfoName,
        version: nodeInfoVersion,
        userAgent: init.nodeInfo?.userAgent ?? userAgent(nodeInfoName, nodeInfoVersion)
      },
      logger: this.logger,
      events,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: connectionGater(init.connectionGater),
      dns: init.dns
    });
    if (init.metrics != null) {
      this.metrics = this.configureComponent("metrics", init.metrics(this.components));
    }
    this.peerStore = this.configureComponent("peerStore", persistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init.peerStore
    }));
    components.events.addEventListener("peer:update", (evt) => {
      if (evt.detail.previous == null) {
        const peerInfo = {
          id: evt.detail.peer.id,
          multiaddrs: evt.detail.peer.addresses.map((a) => a.multiaddr)
        };
        components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
      }
    });
    if (init.connectionProtector != null) {
      this.configureComponent("connectionProtector", init.connectionProtector(components));
    }
    this.components.upgrader = new Upgrader(this.components, {
      connectionEncrypters: (init.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
      streamMuxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
      inboundUpgradeTimeout: init.connectionManager?.inboundUpgradeTimeout,
      inboundStreamProtocolNegotiationTimeout: init.connectionManager?.inboundStreamProtocolNegotiationTimeout ?? init.connectionManager?.protocolNegotiationTimeout,
      outboundStreamProtocolNegotiationTimeout: init.connectionManager?.outboundStreamProtocolNegotiationTimeout ?? init.connectionManager?.protocolNegotiationTimeout
    });
    this.configureComponent("transportManager", new DefaultTransportManager(this.components, init.transportManager));
    this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init.connectionManager));
    if (init.connectionMonitor?.enabled !== false) {
      this.configureComponent("connectionMonitor", new ConnectionMonitor(this.components, init.connectionMonitor));
    }
    this.configureComponent("registrar", new Registrar(this.components));
    this.configureComponent("addressManager", new AddressManager(this.components, init.addresses));
    const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
    this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
      routers: peerRouters
    }));
    const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
    this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    this.configureComponent("randomWalk", new RandomWalk(this.components));
    (init.peerDiscovery ?? []).forEach((fn, index) => {
      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
      service.addEventListener("peer", (evt) => {
        this.#onDiscoveryPeer(evt);
      });
    });
    init.transports?.forEach((fn, index) => {
      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
    });
    if (init.services != null) {
      for (const name9 of Object.keys(init.services)) {
        const createService = init.services[name9];
        const service = createService(this.components);
        if (service == null) {
          this.log.error("service factory %s returned null or undefined instance", name9);
          continue;
        }
        this.services[name9] = service;
        this.configureComponent(name9, service);
        if (service[contentRoutingSymbol] != null) {
          this.log("registering service %s for content routing", name9);
          contentRouters.push(service[contentRoutingSymbol]);
        }
        if (service[peerRoutingSymbol] != null) {
          this.log("registering service %s for peer routing", name9);
          peerRouters.push(service[peerRoutingSymbol]);
        }
        if (service[peerDiscoverySymbol] != null) {
          this.log("registering service %s for peer discovery", name9);
          service[peerDiscoverySymbol].addEventListener?.("peer", (evt) => {
            this.#onDiscoveryPeer(evt);
          });
        }
      }
    }
    checkServiceDependencies(components);
  }
  configureComponent(name9, component) {
    if (component == null) {
      this.log.error("component %s was null or undefined", name9);
    }
    this.components[name9] = component;
    return component;
  }
  /**
   * Starts the libp2p node and all its subsystems
   */
  async start() {
    if (this.status !== "stopped") {
      return;
    }
    this.status = "starting";
    this.log("libp2p is starting");
    try {
      await this.components.beforeStart?.();
      await this.components.start();
      await this.components.afterStart?.();
      this.status = "started";
      this.safeDispatchEvent("start", { detail: this });
      this.log("libp2p has started");
    } catch (err) {
      this.log.error("An error occurred starting libp2p", err);
      this.status = "started";
      await this.stop();
      throw err;
    }
  }
  /**
   * Stop the libp2p node by closing its listeners and open connections
   */
  async stop() {
    if (this.status !== "started") {
      return;
    }
    this.log("libp2p is stopping");
    this.status = "stopping";
    await this.components.beforeStop?.();
    await this.components.stop();
    await this.components.afterStop?.();
    this.status = "stopped";
    this.safeDispatchEvent("stop", { detail: this });
    this.log("libp2p has stopped");
  }
  getConnections(peerId2) {
    return this.components.connectionManager.getConnections(peerId2);
  }
  getDialQueue() {
    return this.components.connectionManager.getDialQueue();
  }
  getPeers() {
    const peerSet2 = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet2.add(conn.remotePeer);
    }
    return Array.from(peerSet2);
  }
  async dial(peer, options2 = {}) {
    return this.components.connectionManager.openConnection(peer, {
      // ensure any userland dials take top priority in the queue
      priority: 75,
      ...options2
    });
  }
  async dialProtocol(peer, protocols2, options2 = {}) {
    if (protocols2 == null) {
      throw new InvalidParametersError("no protocols were provided to open a stream");
    }
    protocols2 = Array.isArray(protocols2) ? protocols2 : [protocols2];
    if (protocols2.length === 0) {
      throw new InvalidParametersError("no protocols were provided to open a stream");
    }
    const connection = await this.dial(peer, options2);
    return connection.newStream(protocols2, options2);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  getProtocols() {
    return this.components.registrar.getProtocols();
  }
  async hangUp(peer, options2 = {}) {
    if (isMultiaddr(peer)) {
      peer = peerIdFromString(peer.getPeerId() ?? "");
    }
    await this.components.connectionManager.closeConnections(peer, options2);
  }
  async getPublicKey(peer, options2 = {}) {
    this.log("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    try {
      const peerInfo = await this.peerStore.get(peer, options2);
      if (peerInfo.id.publicKey != null) {
        return peerInfo.id.publicKey;
      }
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    const peerKey = concat([
      fromString("/pk/"),
      peer.toMultihash().bytes
    ]);
    const bytes = await this.contentRouting.get(peerKey, options2);
    const publicKey2 = publicKeyFromProtobuf(bytes);
    await this.peerStore.patch(peer, {
      publicKey: publicKey2
    }, options2);
    return publicKey2;
  }
  async handle(protocols2, handler, options2) {
    if (!Array.isArray(protocols2)) {
      protocols2 = [protocols2];
    }
    await Promise.all(protocols2.map(async (protocol) => {
      await this.components.registrar.handle(protocol, handler, options2);
    }));
  }
  async unhandle(protocols2, options2) {
    if (!Array.isArray(protocols2)) {
      protocols2 = [protocols2];
    }
    await Promise.all(protocols2.map(async (protocol) => {
      await this.components.registrar.unhandle(protocol, options2);
    }));
  }
  async register(protocol, topology, options2) {
    return this.components.registrar.register(protocol, topology, options2);
  }
  unregister(id) {
    this.components.registrar.unregister(id);
  }
  async isDialable(multiaddr2, options2 = {}) {
    return this.components.connectionManager.isDialable(multiaddr2, options2);
  }
  /**
   * Called whenever peer discovery services emit `peer` events and adds peers
   * to the peer store.
   */
  #onDiscoveryPeer(evt) {
    const { detail: peer } = evt;
    if (peer.id.toString() === this.peerId.toString()) {
      this.log.error("peer discovery mechanism discovered self");
      return;
    }
    void this.components.peerStore.merge(peer.id, {
      multiaddrs: peer.multiaddrs
    }).catch((err) => {
      this.log.error(err);
    });
  }
};

// node_modules/libp2p/dist/src/index.js
async function createLibp2p(options2 = {}) {
  options2.privateKey ??= await generateKeyPair("Ed25519");
  const node = new Libp2p({
    ...await validateConfig(options2),
    peerId: peerIdFromPrivateKey(options2.privateKey)
  });
  if (options2.start !== false) {
    await node.start();
  }
  return node;
}

// node_modules/it-pair/dist/src/index.js
function pair() {
  const deferred = pDefer();
  let piped = false;
  return {
    sink: async (source) => {
      if (piped) {
        throw new Error("already piped");
      }
      piped = true;
      deferred.resolve(source);
    },
    source: async function* () {
      const source = await deferred.promise;
      yield* source;
    }()
  };
}

// node_modules/it-pair/dist/src/duplex.js
function duplexPair() {
  const a = pair();
  const b = pair();
  return [
    {
      source: a.source,
      sink: b.sink
    },
    {
      source: b.source,
      sink: a.sink
    }
  ];
}

// node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
var DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);

// node_modules/@noble/ciphers/esm/utils.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abool(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function anumber2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance2) {
  abytes(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean2(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  else if (isBytes(data))
    data = copyBytes(data);
  else
    throw new Error("Uint8Array expected, got " + typeof data);
  return data;
}
function checkOpts(defaults2, opts) {
  if (opts == null || typeof opts !== "object")
    throw new Error("options must be defined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
var wrapCipher = (params, constructor) => {
  function wrappedCipher(key, ...args) {
    abytes(key);
    if (!isLE)
      throw new Error("Non little-endian hardware is not yet supported");
    if (params.nonceLength !== void 0) {
      const nonce = args[0];
      if (!nonce)
        throw new Error("nonce / iv required");
      if (params.varSizeNonce)
        abytes(nonce);
      else
        abytes(nonce, params.nonceLength);
    }
    const tagl = params.tagLength;
    if (tagl && args[1] !== void 0) {
      abytes(args[1]);
    }
    const cipher = constructor(key, ...args);
    const checkOutput = (fnLength, output) => {
      if (output !== void 0) {
        if (fnLength !== 2)
          throw new Error("cipher output not supported");
        abytes(output);
      }
    };
    let called = false;
    const wrCipher = {
      encrypt(data, output) {
        if (called)
          throw new Error("cannot encrypt() twice with same key + nonce");
        called = true;
        abytes(data);
        checkOutput(cipher.encrypt.length, output);
        return cipher.encrypt(data, output);
      },
      decrypt(data, output) {
        abytes(data);
        if (tagl && data.length < tagl)
          throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
        checkOutput(cipher.decrypt.length, output);
        return cipher.decrypt(data, output);
      }
    };
    return wrCipher;
  }
  Object.assign(wrappedCipher, params);
  return wrappedCipher;
};
function getOutput(expectedLength, out, onlyAligned = true) {
  if (out === void 0)
    return new Uint8Array(expectedLength);
  if (out.length !== expectedLength)
    throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
  if (onlyAligned && !isAligned32(out))
    throw new Error("invalid output, must be aligned");
  return out;
}
function setBigUint64(view, byteOffset, value7, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value7, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value7 >> _32n & _u32_max);
  const wl = Number(value7 & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
function u64Lengths(dataLength, aadLength, isLE2) {
  abool(isLE2);
  const num = new Uint8Array(16);
  const view = createView(num);
  setBigUint64(view, 0, BigInt(aadLength), isLE2);
  setBigUint64(view, 8, BigInt(dataLength), isLE2);
  return num;
}
function isAligned32(bytes) {
  return bytes.byteOffset % 4 === 0;
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}

// node_modules/@noble/ciphers/esm/_arx.js
var _utf8ToBytes = (str) => Uint8Array.from(str.split("").map((c) => c.charCodeAt(0)));
var sigma16 = _utf8ToBytes("expand 16-byte k");
var sigma32 = _utf8ToBytes("expand 32-byte k");
var sigma16_32 = u32(sigma16);
var sigma32_32 = u32(sigma32);
function rotl(a, b) {
  return a << b | a >>> 32 - b;
}
function isAligned322(b) {
  return b.byteOffset % 4 === 0;
}
var BLOCK_LEN = 64;
var BLOCK_LEN32 = 16;
var MAX_COUNTER = 2 ** 32 - 1;
var U32_EMPTY = new Uint32Array();
function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u32(block);
  const isAligned = isAligned322(data) && isAligned322(output);
  const d32 = isAligned ? u32(data) : U32_EMPTY;
  const o32 = isAligned ? u32(output) : U32_EMPTY;
  for (let pos = 0; pos < len; counter++) {
    core(sigma, key, nonce, b32, counter, rounds);
    if (counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take; j++) {
      posj = pos + j;
      output[posj] = data[posj] ^ block[j];
    }
    pos += take;
  }
}
function createCipher(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  anumber2(counterLength);
  anumber2(rounds);
  abool(counterRight);
  abool(allowShortKeys);
  return (key, nonce, data, output, counter = 0) => {
    abytes(key);
    abytes(nonce);
    abytes(data);
    const len = data.length;
    if (output === void 0)
      output = new Uint8Array(len);
    abytes(output);
    anumber2(counter);
    if (counter < 0 || counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output.length < len)
      throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
    const toClean = [];
    let l = key.length;
    let k;
    let sigma;
    if (l === 32) {
      toClean.push(k = copyBytes(key));
      sigma = sigma32_32;
    } else if (l === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma = sigma16_32;
      toClean.push(k);
    } else {
      throw new Error(`arx: invalid 32-byte key, got length=${l}`);
    }
    if (!isAligned322(nonce))
      toClean.push(nonce = copyBytes(nonce));
    const k32 = u32(k);
    if (extendNonceFn) {
      if (nonce.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
      nonce = nonce.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      nonce = nc;
      toClean.push(nonce);
    }
    const n32 = u32(nonce);
    runCipher(core, sigma, k32, n32, data, output, counter, rounds);
    clean2(...toClean);
    return output;
  };
}

// node_modules/@noble/ciphers/esm/_poly1305.js
var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
var Poly1305 = class {
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes2(key);
    abytes(key, 32);
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i = 0; i < 8; i++)
      this.pad[i] = u8to16(key, 16 + 2 * i);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r } = this;
    const r0 = r[0];
    const r1 = r[1];
    const r2 = r[2];
    const r3 = r[3];
    const r4 = r[4];
    const r5 = r[5];
    const r6 = r[6];
    const r7 = r[7];
    const r8 = r[8];
    const r9 = r[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c = 0;
    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 8191;
    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 8191;
    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 8191;
    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 8191;
    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
    c = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 8191;
    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
    c = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 8191;
    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
    c = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 8191;
    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 8191;
    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 8191;
    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
    c += d9 >>> 13;
    d9 &= 8191;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 8191;
    c = c >>> 13;
    d1 += c;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad } = this;
    const g = new Uint16Array(10);
    let c = h[1] >>> 13;
    h[1] &= 8191;
    for (let i = 2; i < 10; i++) {
      h[i] += c;
      c = h[i] >>> 13;
      h[i] &= 8191;
    }
    h[0] += c * 5;
    c = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c;
    c = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c;
    g[0] = h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for (let i = 1; i < 10; i++) {
      g[i] = h[i] + c;
      c = g[i] >>> 13;
      g[i] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c ^ 1) - 1;
    for (let i = 0; i < 10; i++)
      g[i] &= mask;
    mask = ~mask;
    for (let i = 0; i < 10; i++)
      h[i] = h[i] & mask | g[i];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f = h[0] + pad[0];
    h[0] = f & 65535;
    for (let i = 1; i < 8; i++) {
      f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;
      h[i] = f & 65535;
    }
    clean2(g);
  }
  update(data) {
    aexists(this);
    data = toBytes2(data);
    abytes(data);
    const { buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(buffer, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    clean2(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, h } = this;
    let { pos } = this;
    if (pos) {
      buffer[pos++] = 1;
      for (; pos < 16; pos++)
        buffer[pos] = 0;
      this.process(buffer, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i = 0; i < 8; i++) {
      out[opos++] = h[i] >>> 0;
      out[opos++] = h[i] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(toBytes2(msg)).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));

// node_modules/@noble/ciphers/esm/chacha.js
function chachaCore(s, k, n, out, cnt, rounds = 20) {
  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r = 0; r < rounds; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha(s, k, i, o32) {
  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
  for (let r = 0; r < 20; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  o32[oi++] = x00;
  o32[oi++] = x01;
  o32[oi++] = x02;
  o32[oi++] = x03;
  o32[oi++] = x12;
  o32[oi++] = x13;
  o32[oi++] = x14;
  o32[oi++] = x15;
}
var chacha20orig = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  allowShortKeys: true
});
var chacha20 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
var xchacha20 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha,
  allowShortKeys: false
});
var chacha8 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 8
});
var chacha12 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 12
});
var ZEROS16 = new Uint8Array(16);
var updatePadded = (h, msg) => {
  h.update(msg);
  const left = msg.length % 16;
  if (left)
    h.update(ZEROS16.subarray(left));
};
var ZEROS32 = new Uint8Array(32);
function computeTag(fn, key, nonce, data, AAD) {
  const authKey = fn(key, nonce, ZEROS32);
  const h = poly1305.create(authKey);
  if (AAD)
    updatePadded(h, AAD);
  updatePadded(h, data);
  const num = u64Lengths(data.length, AAD ? AAD.length : 0, true);
  h.update(num);
  const res = h.digest();
  clean2(authKey, num);
  return res;
}
var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
  const tagLength = 16;
  return {
    encrypt(plaintext, output) {
      const plength = plaintext.length;
      output = getOutput(plength + tagLength, output, false);
      output.set(plaintext);
      const oPlain = output.subarray(0, -tagLength);
      xorStream(key, nonce, oPlain, oPlain, 1);
      const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
      output.set(tag, plength);
      clean2(tag);
      return output;
    },
    decrypt(ciphertext, output) {
      output = getOutput(ciphertext.length - tagLength, output, false);
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = computeTag(xorStream, key, nonce, data, AAD);
      if (!equalBytes(passedTag, tag))
        throw new Error("invalid tag");
      output.set(ciphertext.subarray(0, -tagLength));
      xorStream(key, nonce, output, output, 1);
      clean2(tag);
      return output;
    }
  };
};
var chacha20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
var xchacha20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

// node_modules/@noble/hashes/esm/hkdf.js
function extract(hash, ikm, salt) {
  ahash(hash);
  if (salt === void 0)
    salt = new Uint8Array(hash.outputLen);
  return hmac(hash, toBytes(salt), toBytes(ikm));
}
var HKDF_COUNTER = Uint8Array.from([0]);
var EMPTY_BUFFER2 = Uint8Array.of();
function expand(hash, prk, info, length16 = 32) {
  ahash(hash);
  anumber(length16);
  const olen = hash.outputLen;
  if (length16 > 255 * olen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length16 / olen);
  if (info === void 0)
    info = EMPTY_BUFFER2;
  const okm = new Uint8Array(blocks * olen);
  const HMAC = hmac.create(hash, prk);
  const HMACTmp = HMAC._cloneInto();
  const T = new Uint8Array(HMAC.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER2 : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, olen * counter);
    HMAC._cloneInto(HMACTmp);
  }
  HMAC.destroy();
  HMACTmp.destroy();
  clean(T, HKDF_COUNTER);
  return okm.slice(0, length16);
}

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/js.js
var pureJsCrypto = {
  hashSHA256(data) {
    return sha256(data.subarray());
  },
  getHKDF(ck, ikm) {
    const prk = extract(sha256, ikm, ck);
    const okmU8Array = expand(sha256, prk, void 0, 96);
    const okm = okmU8Array;
    const k1 = okm.subarray(0, 32);
    const k2 = okm.subarray(32, 64);
    const k3 = okm.subarray(64, 96);
    return [k1, k2, k3];
  },
  generateX25519KeyPair() {
    const secretKey = x25519.utils.randomPrivateKey();
    const publicKey2 = x25519.getPublicKey(secretKey);
    return {
      publicKey: publicKey2,
      privateKey: secretKey
    };
  },
  generateX25519KeyPairFromSeed(seed) {
    const publicKey2 = x25519.getPublicKey(seed);
    return {
      publicKey: publicKey2,
      privateKey: seed
    };
  },
  generateX25519SharedKey(privateKey, publicKey2) {
    return x25519.getSharedSecret(privateKey.subarray(), publicKey2.subarray());
  },
  chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
    return chacha20poly1305(k, nonce, ad).encrypt(plaintext.subarray());
  },
  chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
    return chacha20poly1305(k, nonce, ad).decrypt(ciphertext.subarray(), dst);
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/index.browser.js
var defaultCrypto = pureJsCrypto;

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js
function wrapCrypto(crypto2) {
  return {
    generateKeypair: crypto2.generateX25519KeyPair,
    dh: (keypair, publicKey2) => crypto2.generateX25519SharedKey(keypair.privateKey, publicKey2).subarray(0, 32),
    encrypt: crypto2.chaCha20Poly1305Encrypt,
    decrypt: crypto2.chaCha20Poly1305Decrypt,
    hash: crypto2.hashSHA256,
    hkdf: crypto2.getHKDF
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
var uint16BEEncode = (value7) => {
  const target = allocUnsafe(2);
  target[0] = value7 >> 8;
  target[1] = value7;
  return target;
};
uint16BEEncode.bytes = 2;
var uint16BEDecode = (data) => {
  if (data.length < 2) {
    throw RangeError("Could not decode int16BE");
  }
  if (data instanceof Uint8Array) {
    let value7 = 0;
    value7 += data[0] << 8;
    value7 += data[1];
    return value7;
  }
  return data.getUint16(0);
};
uint16BEDecode.bytes = 2;

// node_modules/@chainsafe/libp2p-noise/dist/src/metrics.js
function registerMetrics(metrics) {
  return {
    xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
      help: "Total count of noise xxHandshakes successes_"
    }),
    xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
      help: "Total count of noise xxHandshakes errors"
    }),
    encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
      help: "Total count of noise encrypted packets successfully"
    }),
    decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
      help: "Total count of noise decrypted packets"
    }),
    decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
      help: "Total count of noise decrypt errors"
    })
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
function logLocalStaticKeys(s, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (s) {
    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString(s.publicKey, "hex")}`);
    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString(s.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local static keys.");
  }
}
function logLocalEphemeralKeys(e, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (e) {
    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString(e.publicKey, "hex")}`);
    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString(e.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local ephemeral keys.");
  }
}
function logRemoteStaticKey(rs, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (rs) {
    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString(rs.subarray(), "hex")}`);
  } else {
    keyLogger("Missing remote static public key.");
  }
}
function logRemoteEphemeralKey(re, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (re) {
    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString(re.subarray(), "hex")}`);
  } else {
    keyLogger("Missing remote ephemeral keys.");
  }
}
function logCipherState(cs1, cs2, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  keyLogger(`CIPHER_STATE_1 ${cs1.n.getUint64()} ${cs1.k && toString(cs1.k, "hex")}`);
  keyLogger(`CIPHER_STATE_2 ${cs2.n.getUint64()} ${cs2.k && toString(cs2.k, "hex")}`);
}

// node_modules/uint8arrays/dist/src/xor.js
function xor(a, b) {
  if (a.length !== b.length) {
    throw new Error("Inputs should have the same length");
  }
  const result = allocUnsafe(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = a[i] ^ b[i];
  }
  return asUint8Array(result);
}

// node_modules/@chainsafe/libp2p-noise/dist/src/errors.js
var InvalidCryptoExchangeError2 = class _InvalidCryptoExchangeError extends Error {
  code;
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    this.code = _InvalidCryptoExchangeError.code;
  }
  static code = "ERR_INVALID_CRYPTO_EXCHANGE";
};

// node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js
var MIN_NONCE = 0;
var MAX_NONCE = 4294967295;
var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
var Nonce = class {
  n;
  bytes;
  view;
  constructor(n = MIN_NONCE) {
    this.n = n;
    this.bytes = alloc(12);
    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
    this.view.setUint32(4, n, true);
  }
  increment() {
    this.n++;
    this.view.setUint32(4, this.n, true);
  }
  getBytes() {
    return this.bytes;
  }
  getUint64() {
    return this.n;
  }
  assertValue() {
    if (this.n > MAX_NONCE) {
      throw new Error(ERR_MAX_NONCE);
    }
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/protocol.js
var ZEROLEN = alloc(0);
var CipherState = class {
  k;
  n;
  crypto;
  constructor(crypto2, k = void 0, n = 0) {
    this.crypto = crypto2;
    this.k = k;
    this.n = new Nonce(n);
  }
  hasKey() {
    return Boolean(this.k);
  }
  encryptWithAd(ad, plaintext) {
    if (!this.hasKey()) {
      return plaintext;
    }
    this.n.assertValue();
    const e = this.crypto.encrypt(plaintext, this.n.getBytes(), ad, this.k);
    this.n.increment();
    return e;
  }
  decryptWithAd(ad, ciphertext, dst) {
    if (!this.hasKey()) {
      return ciphertext;
    }
    this.n.assertValue();
    const plaintext = this.crypto.decrypt(ciphertext, this.n.getBytes(), ad, this.k, dst);
    this.n.increment();
    return plaintext;
  }
};
var SymmetricState = class {
  cs;
  ck;
  h;
  crypto;
  constructor(crypto2, protocolName) {
    this.crypto = crypto2;
    const protocolNameBytes = fromString(protocolName, "utf-8");
    this.h = hashProtocolName(crypto2, protocolNameBytes);
    this.ck = this.h;
    this.cs = new CipherState(crypto2);
  }
  mixKey(ikm) {
    const [ck, tempK] = this.crypto.hkdf(this.ck, ikm);
    this.ck = ck;
    this.cs = new CipherState(this.crypto, tempK);
  }
  mixHash(data) {
    this.h = this.crypto.hash(new Uint8ArrayList(this.h, data));
  }
  encryptAndHash(plaintext) {
    const ciphertext = this.cs.encryptWithAd(this.h, plaintext);
    this.mixHash(ciphertext);
    return ciphertext;
  }
  decryptAndHash(ciphertext) {
    const plaintext = this.cs.decryptWithAd(this.h, ciphertext);
    this.mixHash(ciphertext);
    return plaintext;
  }
  split() {
    const [tempK1, tempK2] = this.crypto.hkdf(this.ck, ZEROLEN);
    return [new CipherState(this.crypto, tempK1), new CipherState(this.crypto, tempK2)];
  }
};
var AbstractHandshakeState = class {
  ss;
  s;
  e;
  rs;
  re;
  initiator;
  crypto;
  constructor(init) {
    const { crypto: crypto2, protocolName, prologue, initiator, s, e, rs, re } = init;
    this.crypto = crypto2;
    this.ss = new SymmetricState(crypto2, protocolName);
    this.ss.mixHash(prologue);
    this.initiator = initiator;
    this.s = s;
    this.e = e;
    this.rs = rs;
    this.re = re;
  }
  writeE() {
    if (this.e) {
      throw new Error("ephemeral keypair is already set");
    }
    const e = this.crypto.generateKeypair();
    this.ss.mixHash(e.publicKey);
    this.e = e;
    return e.publicKey;
  }
  writeS() {
    if (!this.s) {
      throw new Error("static keypair is not set");
    }
    return this.ss.encryptAndHash(this.s.publicKey);
  }
  writeEE() {
    if (!this.e) {
      throw new Error("ephemeral keypair is not set");
    }
    if (!this.re) {
      throw new Error("remote ephemeral public key is not set");
    }
    this.ss.mixKey(this.crypto.dh(this.e, this.re));
  }
  writeES() {
    if (this.initiator) {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.rs) {
        throw new Error("remote static public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.rs));
    } else {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.s, this.re));
    }
  }
  writeSE() {
    if (this.initiator) {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.s, this.re));
    } else {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.rs) {
        throw new Error("remote static public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.rs));
    }
  }
  readE(message2, offset = 0) {
    if (this.re) {
      throw new Error("remote ephemeral public key is already set");
    }
    if (message2.byteLength < offset + 32) {
      throw new Error("message is not long enough");
    }
    this.re = message2.sublist(offset, offset + 32);
    this.ss.mixHash(this.re);
  }
  readS(message2, offset = 0) {
    if (this.rs) {
      throw new Error("remote static public key is already set");
    }
    const cipherLength = 32 + (this.ss.cs.hasKey() ? 16 : 0);
    if (message2.byteLength < offset + cipherLength) {
      throw new Error("message is not long enough");
    }
    const temp = message2.sublist(offset, offset + cipherLength);
    this.rs = this.ss.decryptAndHash(temp);
    return cipherLength;
  }
  readEE() {
    this.writeEE();
  }
  readES() {
    this.writeES();
  }
  readSE() {
    this.writeSE();
  }
};
var XXHandshakeState = class extends AbstractHandshakeState {
  // e
  writeMessageA(payload) {
    return new Uint8ArrayList(this.writeE(), this.ss.encryptAndHash(payload));
  }
  // e, ee, s, es
  writeMessageB(payload) {
    const e = this.writeE();
    this.writeEE();
    const encS = this.writeS();
    this.writeES();
    return new Uint8ArrayList(e, encS, this.ss.encryptAndHash(payload));
  }
  // s, se
  writeMessageC(payload) {
    const encS = this.writeS();
    this.writeSE();
    return new Uint8ArrayList(encS, this.ss.encryptAndHash(payload));
  }
  // e
  readMessageA(message2) {
    try {
      this.readE(message2);
      return this.ss.decryptAndHash(message2.sublist(32));
    } catch (e) {
      throw new InvalidCryptoExchangeError2(`handshake stage 0 validation fail: ${e.message}`);
    }
  }
  // e, ee, s, es
  readMessageB(message2) {
    try {
      this.readE(message2);
      this.readEE();
      const consumed = this.readS(message2, 32);
      this.readES();
      return this.ss.decryptAndHash(message2.sublist(32 + consumed));
    } catch (e) {
      throw new InvalidCryptoExchangeError2(`handshake stage 1 validation fail: ${e.message}`);
    }
  }
  // s, se
  readMessageC(message2) {
    try {
      const consumed = this.readS(message2);
      this.readSE();
      return this.ss.decryptAndHash(message2.sublist(consumed));
    } catch (e) {
      throw new InvalidCryptoExchangeError2(`handshake stage 2 validation fail: ${e.message}`);
    }
  }
};
function hashProtocolName(crypto2, protocolName) {
  if (protocolName.length <= 32) {
    const h = alloc(32);
    h.set(protocolName);
    return h;
  } else {
    return crypto2.hash(protocolName);
  }
}

// node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
var NoiseExtensions;
(function(NoiseExtensions2) {
  let _codec;
  NoiseExtensions2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.webtransportCerthashes != null) {
          for (const value7 of obj.webtransportCerthashes) {
            w.uint32(10);
            w.bytes(value7);
          }
        }
        if (obj.streamMuxers != null) {
          for (const value7 of obj.streamMuxers) {
            w.uint32(18);
            w.string(value7);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          webtransportCerthashes: [],
          streamMuxers: []
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.webtransportCerthashes != null && obj.webtransportCerthashes.length === opts.limits.webtransportCerthashes) {
                throw new MaxLengthError('Decode error - map field "webtransportCerthashes" had too many elements');
              }
              obj.webtransportCerthashes.push(reader.bytes());
              break;
            }
            case 2: {
              if (opts.limits?.streamMuxers != null && obj.streamMuxers.length === opts.limits.streamMuxers) {
                throw new MaxLengthError('Decode error - map field "streamMuxers" had too many elements');
              }
              obj.streamMuxers.push(reader.string());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseExtensions2.encode = (obj) => {
    return encodeMessage(obj, NoiseExtensions2.codec());
  };
  NoiseExtensions2.decode = (buf, opts) => {
    return decodeMessage(buf, NoiseExtensions2.codec(), opts);
  };
})(NoiseExtensions || (NoiseExtensions = {}));
var NoiseHandshakePayload;
(function(NoiseHandshakePayload2) {
  let _codec;
  NoiseHandshakePayload2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.identityKey != null && obj.identityKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.identityKey);
        }
        if (obj.identitySig != null && obj.identitySig.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.identitySig);
        }
        if (obj.extensions != null) {
          w.uint32(34);
          NoiseExtensions.codec().encode(obj.extensions, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          identityKey: alloc(0),
          identitySig: alloc(0)
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.identityKey = reader.bytes();
              break;
            }
            case 2: {
              obj.identitySig = reader.bytes();
              break;
            }
            case 4: {
              obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.extensions
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseHandshakePayload2.encode = (obj) => {
    return encodeMessage(obj, NoiseHandshakePayload2.codec());
  };
  NoiseHandshakePayload2.decode = (buf, opts) => {
    return decodeMessage(buf, NoiseHandshakePayload2.codec(), opts);
  };
})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));

// node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
async function createHandshakePayload(privateKey, staticPublicKey, extensions) {
  const identitySig = await privateKey.sign(getSignaturePayload(staticPublicKey));
  return NoiseHandshakePayload.encode({
    identityKey: publicKeyToProtobuf(privateKey.publicKey),
    identitySig,
    extensions
  });
}
async function decodeHandshakePayload(payloadBytes, remoteStaticKey, remoteIdentityKey) {
  try {
    const payload = NoiseHandshakePayload.decode(payloadBytes);
    const publicKey2 = publicKeyFromProtobuf(payload.identityKey);
    if (remoteIdentityKey?.equals(publicKey2) === false) {
      throw new Error(`Payload identity key ${publicKey2} does not match expected remote identity key ${remoteIdentityKey}`);
    }
    if (!remoteStaticKey) {
      throw new Error("Remote static does not exist");
    }
    const signaturePayload = getSignaturePayload(remoteStaticKey);
    if (!await publicKey2.verify(signaturePayload, payload.identitySig)) {
      throw new Error("Invalid payload signature");
    }
    return payload;
  } catch (e) {
    throw new UnexpectedPeerError(e.message);
  }
}
function getSignaturePayload(publicKey2) {
  const prefix = fromString("noise-libp2p-static-key:");
  if (publicKey2 instanceof Uint8Array) {
    return concat([prefix, publicKey2], prefix.length + publicKey2.length);
  }
  publicKey2.prepend(prefix);
  return publicKey2;
}

// node_modules/@chainsafe/libp2p-noise/dist/src/performHandshake.js
async function performHandshakeInitiator(init, options2) {
  const { log: log5, connection, crypto: crypto2, privateKey, prologue, s, remoteIdentityKey, extensions } = init;
  const payload = await createHandshakePayload(privateKey, s.publicKey, extensions);
  const xx = new XXHandshakeState({
    crypto: crypto2,
    protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
    initiator: true,
    prologue,
    s
  });
  logLocalStaticKeys(xx.s, log5);
  log5.trace("Stage 0 - Initiator starting to send first message.");
  await connection.write(xx.writeMessageA(ZEROLEN), options2);
  log5.trace("Stage 0 - Initiator finished sending first message.");
  logLocalEphemeralKeys(xx.e, log5);
  log5.trace("Stage 1 - Initiator waiting to receive first message from responder...");
  const plaintext = xx.readMessageB(await connection.read(options2));
  log5.trace("Stage 1 - Initiator received the message.");
  logRemoteEphemeralKey(xx.re, log5);
  logRemoteStaticKey(xx.rs, log5);
  log5.trace("Initiator going to check remote's signature...");
  const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
  log5.trace("All good with the signature!");
  log5.trace("Stage 2 - Initiator sending third handshake message.");
  await connection.write(xx.writeMessageC(payload), options2);
  log5.trace("Stage 2 - Initiator sent message with signed payload.");
  const [cs1, cs2] = xx.ss.split();
  logCipherState(cs1, cs2, log5);
  return {
    payload: receivedPayload,
    encrypt: (plaintext2) => cs1.encryptWithAd(ZEROLEN, plaintext2),
    decrypt: (ciphertext, dst) => cs2.decryptWithAd(ZEROLEN, ciphertext, dst)
  };
}
async function performHandshakeResponder(init, options2) {
  const { log: log5, connection, crypto: crypto2, privateKey, prologue, s, remoteIdentityKey, extensions } = init;
  const payload = await createHandshakePayload(privateKey, s.publicKey, extensions);
  const xx = new XXHandshakeState({
    crypto: crypto2,
    protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
    initiator: false,
    prologue,
    s
  });
  logLocalStaticKeys(xx.s, log5);
  log5.trace("Stage 0 - Responder waiting to receive first message.");
  xx.readMessageA(await connection.read(options2));
  log5.trace("Stage 0 - Responder received first message.");
  logRemoteEphemeralKey(xx.re, log5);
  log5.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
  await connection.write(xx.writeMessageB(payload), options2);
  log5.trace("Stage 1 - Responder sent the second handshake message with signed payload.");
  logLocalEphemeralKeys(xx.e, log5);
  log5.trace("Stage 2 - Responder waiting for third handshake message...");
  const plaintext = xx.readMessageC(await connection.read(options2));
  log5.trace("Stage 2 - Responder received the message, finished handshake.");
  const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
  const [cs1, cs2] = xx.ss.split();
  logCipherState(cs1, cs2, log5);
  return {
    payload: receivedPayload,
    encrypt: (plaintext2) => cs2.encryptWithAd(ZEROLEN, plaintext2),
    decrypt: (ciphertext, dst) => cs1.decryptWithAd(ZEROLEN, ciphertext, dst)
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/streaming.js
var CHACHA_TAG_LENGTH = 16;
function encryptStream(handshake, metrics) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
        if (end > chunk.length) {
          end = chunk.length;
        }
        let data;
        if (chunk instanceof Uint8Array) {
          data = handshake.encrypt(chunk.subarray(i, end));
        } else {
          data = handshake.encrypt(chunk.sublist(i, end));
        }
        metrics?.encryptedPackets.increment();
        yield new Uint8ArrayList(uint16BEEncode(data.byteLength), data);
      }
    }
  };
}
function decryptStream(handshake, metrics) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {
        let end = i + NOISE_MSG_MAX_LENGTH_BYTES;
        if (end > chunk.length) {
          end = chunk.length;
        }
        if (end - CHACHA_TAG_LENGTH < i) {
          throw new Error("Invalid chunk");
        }
        const encrypted = chunk.sublist(i, end);
        const dst = chunk.subarray(i, end - CHACHA_TAG_LENGTH);
        try {
          const plaintext = handshake.decrypt(encrypted, dst);
          metrics?.decryptedPackets.increment();
          yield plaintext;
        } catch (e) {
          metrics?.decryptErrors.increment();
          throw e;
        }
      }
    }
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
var Noise = class {
  protocol = "/noise";
  crypto;
  prologue;
  staticKey;
  extensions;
  metrics;
  components;
  constructor(components, init = {}) {
    const { staticNoiseKey, extensions, crypto: crypto2, prologueBytes } = init;
    const { metrics } = components;
    this.components = components;
    const _crypto = crypto2 ?? defaultCrypto;
    this.crypto = wrapCrypto(_crypto);
    this.extensions = {
      webtransportCerthashes: [],
      ...extensions
    };
    this.metrics = metrics ? registerMetrics(metrics) : void 0;
    if (staticNoiseKey) {
      this.staticKey = _crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
    } else {
      this.staticKey = _crypto.generateX25519KeyPair();
    }
    this.prologue = prologueBytes ?? alloc(0);
  }
  [Symbol.toStringTag] = "@chainsafe/libp2p-noise";
  [serviceCapabilities] = [
    "@libp2p/connection-encryption",
    "@chainsafe/libp2p-noise"
  ];
  /**
   * Encrypt outgoing data to the remote party (handshake as initiator)
   *
   * @param connection - streaming iterable duplex that will be encrypted
   * @param options
   * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
   * @param options.signal - Used to abort the operation
   */
  async secureOutbound(connection, options2) {
    const wrappedConnection = lpStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake = await this.performHandshakeInitiator(wrappedConnection, this.components.privateKey, options2?.remotePeer?.publicKey, options2);
    const conn = await this.createSecureConnection(wrappedConnection, handshake);
    connection.source = conn.source;
    connection.sink = conn.sink;
    const publicKey2 = publicKeyFromProtobuf(handshake.payload.identityKey);
    return {
      conn: connection,
      remoteExtensions: handshake.payload.extensions,
      remotePeer: peerIdFromPublicKey(publicKey2),
      streamMuxer: options2?.skipStreamMuxerNegotiation === true ? void 0 : this.getStreamMuxer(handshake.payload.extensions?.streamMuxers)
    };
  }
  getStreamMuxer(protocols2) {
    if (protocols2 == null || protocols2.length === 0) {
      return;
    }
    const streamMuxers = this.components.upgrader.getStreamMuxers();
    if (streamMuxers != null) {
      for (const protocol of protocols2) {
        const streamMuxer = streamMuxers.get(protocol);
        if (streamMuxer != null) {
          return streamMuxer;
        }
      }
    }
    if (protocols2.length) {
      throw new InvalidCryptoExchangeError("Early muxer negotiation was requested but the initiator and responder had no common muxers");
    }
  }
  /**
   * Decrypt incoming data (handshake as responder).
   *
   * @param connection - streaming iterable duplex that will be encrypted
   * @param options
   * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
   * @param options.signal - Used to abort the operation
   */
  async secureInbound(connection, options2) {
    const wrappedConnection = lpStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake = await this.performHandshakeResponder(wrappedConnection, this.components.privateKey, options2?.remotePeer?.publicKey, options2);
    const conn = await this.createSecureConnection(wrappedConnection, handshake);
    connection.source = conn.source;
    connection.sink = conn.sink;
    const publicKey2 = publicKeyFromProtobuf(handshake.payload.identityKey);
    return {
      conn: connection,
      remoteExtensions: handshake.payload.extensions,
      remotePeer: peerIdFromPublicKey(publicKey2),
      streamMuxer: options2?.skipStreamMuxerNegotiation === true ? void 0 : this.getStreamMuxer(handshake.payload.extensions?.streamMuxers)
    };
  }
  /**
   * Perform XX handshake as initiator.
   */
  async performHandshakeInitiator(connection, privateKey, remoteIdentityKey, options2) {
    let result;
    const streamMuxers = options2?.skipStreamMuxerNegotiation === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
    try {
      result = await performHandshakeInitiator({
        connection,
        privateKey,
        remoteIdentityKey,
        log: this.components.logger.forComponent("libp2p:noise:xxhandshake"),
        crypto: this.crypto,
        prologue: this.prologue,
        s: this.staticKey,
        extensions: {
          streamMuxers,
          webtransportCerthashes: [],
          ...this.extensions
        }
      }, options2);
      this.metrics?.xxHandshakeSuccesses.increment();
    } catch (e) {
      this.metrics?.xxHandshakeErrors.increment();
      throw e;
    }
    return result;
  }
  /**
   * Perform XX handshake as responder.
   */
  async performHandshakeResponder(connection, privateKey, remoteIdentityKey, options2) {
    let result;
    const streamMuxers = options2?.skipStreamMuxerNegotiation === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
    try {
      result = await performHandshakeResponder({
        connection,
        privateKey,
        remoteIdentityKey,
        log: this.components.logger.forComponent("libp2p:noise:xxhandshake"),
        crypto: this.crypto,
        prologue: this.prologue,
        s: this.staticKey,
        extensions: {
          streamMuxers,
          webtransportCerthashes: [],
          ...this.extensions
        }
      }, options2);
      this.metrics?.xxHandshakeSuccesses.increment();
    } catch (e) {
      this.metrics?.xxHandshakeErrors.increment();
      throw e;
    }
    return result;
  }
  async createSecureConnection(connection, handshake) {
    const [secure, user] = duplexPair();
    const network = connection.unwrap();
    await pipe(
      secure,
      // write to wrapper
      encryptStream(handshake, this.metrics),
      // encrypt data + prefix with message length
      network,
      // send to the remote peer
      (source) => decode9(source, { lengthDecoder: uint16BEDecode }),
      // read message length prefix
      decryptStream(handshake, this.metrics),
      // decrypt the incoming data
      secure
      // pipe to the wrapper
    );
    return user;
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/index.js
function noise(init = {}) {
  return (components) => new Noise(components, init);
}

// node_modules/get-iterator/dist/src/index.js
function getIterator(obj) {
  if (obj != null) {
    if (typeof obj[Symbol.iterator] === "function") {
      return obj[Symbol.iterator]();
    }
    if (typeof obj[Symbol.asyncIterator] === "function") {
      return obj[Symbol.asyncIterator]();
    }
    if (typeof obj.next === "function") {
      return obj;
    }
  }
  throw new Error("argument is not an iterator or iterable");
}

// node_modules/@chainsafe/libp2p-yamux/dist/src/errors.js
var InvalidFrameError = class extends Error {
  static name = "InvalidFrameError";
  constructor(message2 = "The frame was invalid") {
    super(message2);
    this.name = "InvalidFrameError";
  }
};
var UnrequestedPingError = class extends Error {
  static name = "UnrequestedPingError";
  constructor(message2 = "Unrequested ping error") {
    super(message2);
    this.name = "UnrequestedPingError";
  }
};
var NotMatchingPingError = class extends Error {
  static name = "NotMatchingPingError";
  constructor(message2 = "Unrequested ping error") {
    super(message2);
    this.name = "NotMatchingPingError";
  }
};
var InvalidStateError = class extends Error {
  static name = "InvalidStateError";
  constructor(message2 = "Invalid state") {
    super(message2);
    this.name = "InvalidStateError";
  }
};
var StreamAlreadyExistsError = class extends Error {
  static name = "StreamAlreadyExistsError";
  constructor(message2 = "Strean already exists") {
    super(message2);
    this.name = "StreamAlreadyExistsError";
  }
};
var DecodeInvalidVersionError = class extends Error {
  static name = "DecodeInvalidVersionError";
  constructor(message2 = "Decode invalid version") {
    super(message2);
    this.name = "DecodeInvalidVersionError";
  }
};
var BothClientsError = class extends Error {
  static name = "BothClientsError";
  constructor(message2 = "Both clients") {
    super(message2);
    this.name = "BothClientsError";
  }
};
var ReceiveWindowExceededError = class extends Error {
  static name = "ReceiveWindowExceededError";
  constructor(message2 = "Receive window exceeded") {
    super(message2);
    this.name = "ReceiveWindowExceededError";
  }
};

// node_modules/@chainsafe/libp2p-yamux/dist/src/constants.js
var PROTOCOL_ERRORS = /* @__PURE__ */ new Set([
  InvalidFrameError.name,
  UnrequestedPingError.name,
  NotMatchingPingError.name,
  StreamAlreadyExistsError.name,
  DecodeInvalidVersionError.name,
  BothClientsError.name,
  ReceiveWindowExceededError.name
]);
var INITIAL_STREAM_WINDOW = 256 * 1024;
var MAX_STREAM_WINDOW = 16 * 1024 * 1024;

// node_modules/@chainsafe/libp2p-yamux/dist/src/config.js
var defaultConfig = {
  enableKeepAlive: true,
  keepAliveInterval: 3e4,
  maxInboundStreams: 1e3,
  maxOutboundStreams: 1e3,
  initialStreamWindowSize: INITIAL_STREAM_WINDOW,
  maxStreamWindowSize: MAX_STREAM_WINDOW,
  maxMessageSize: 64 * 1024
};
function verifyConfig(config) {
  if (config.keepAliveInterval <= 0) {
    throw new InvalidParametersError("keep-alive interval must be positive");
  }
  if (config.maxInboundStreams < 0) {
    throw new InvalidParametersError("max inbound streams must be larger or equal 0");
  }
  if (config.maxOutboundStreams < 0) {
    throw new InvalidParametersError("max outbound streams must be larger or equal 0");
  }
  if (config.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {
    throw new InvalidParametersError("InitialStreamWindowSize must be larger or equal 256 kB");
  }
  if (config.maxStreamWindowSize < config.initialStreamWindowSize) {
    throw new InvalidParametersError("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");
  }
  if (config.maxStreamWindowSize > 2 ** 32 - 1) {
    throw new InvalidParametersError("MaxStreamWindowSize must be less than equal MAX_UINT32");
  }
  if (config.maxMessageSize < 1024) {
    throw new InvalidParametersError("MaxMessageSize must be greater than a kilobyte");
  }
}

// node_modules/@chainsafe/libp2p-yamux/dist/src/frame.js
var FrameType;
(function(FrameType2) {
  FrameType2[FrameType2["Data"] = 0] = "Data";
  FrameType2[FrameType2["WindowUpdate"] = 1] = "WindowUpdate";
  FrameType2[FrameType2["Ping"] = 2] = "Ping";
  FrameType2[FrameType2["GoAway"] = 3] = "GoAway";
})(FrameType || (FrameType = {}));
var Flag;
(function(Flag2) {
  Flag2[Flag2["SYN"] = 1] = "SYN";
  Flag2[Flag2["ACK"] = 2] = "ACK";
  Flag2[Flag2["FIN"] = 4] = "FIN";
  Flag2[Flag2["RST"] = 8] = "RST";
})(Flag || (Flag = {}));
var flagCodes = Object.values(Flag).filter((x) => typeof x !== "string");
var YAMUX_VERSION = 0;
var GoAwayCode;
(function(GoAwayCode2) {
  GoAwayCode2[GoAwayCode2["NormalTermination"] = 0] = "NormalTermination";
  GoAwayCode2[GoAwayCode2["ProtocolError"] = 1] = "ProtocolError";
  GoAwayCode2[GoAwayCode2["InternalError"] = 2] = "InternalError";
})(GoAwayCode || (GoAwayCode = {}));
var HEADER_LENGTH = 12;

// node_modules/@chainsafe/libp2p-yamux/dist/src/decode.js
var twoPow24 = 2 ** 24;
function decodeHeader(data) {
  if (data[0] !== YAMUX_VERSION) {
    throw new InvalidFrameError("Invalid frame version");
  }
  return {
    type: data[1],
    flag: (data[2] << 8) + data[3],
    streamID: data[4] * twoPow24 + (data[5] << 16) + (data[6] << 8) + data[7],
    length: data[8] * twoPow24 + (data[9] << 16) + (data[10] << 8) + data[11]
  };
}
var Decoder12 = class {
  source;
  /** Buffer for in-progress frames */
  buffer;
  /** Used to sanity check against decoding while in an inconsistent state */
  frameInProgress;
  constructor(source) {
    this.source = returnlessSource(source);
    this.buffer = new Uint8ArrayList();
    this.frameInProgress = false;
  }
  /**
   * Emits frames from the decoder source.
   *
   * Note: If `readData` is emitted, it _must_ be called before the next iteration
   * Otherwise an error is thrown
   */
  async *emitFrames() {
    for await (const chunk of this.source) {
      this.buffer.append(chunk);
      while (true) {
        const header = this.readHeader();
        if (header === void 0) {
          break;
        }
        const { type, length: length16 } = header;
        if (type === FrameType.Data) {
          this.frameInProgress = true;
          yield {
            header,
            readData: this.readBytes.bind(this, length16)
          };
        } else {
          yield { header };
        }
      }
    }
  }
  readHeader() {
    if (this.frameInProgress) {
      throw new InvalidStateError("decoding frame already in progress");
    }
    if (this.buffer.length < HEADER_LENGTH) {
      return;
    }
    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH));
    this.buffer.consume(HEADER_LENGTH);
    return header;
  }
  async readBytes(length16) {
    if (this.buffer.length < length16) {
      for await (const chunk of this.source) {
        this.buffer.append(chunk);
        if (this.buffer.length >= length16) {
          break;
        }
      }
    }
    const out = this.buffer.sublist(0, length16);
    this.buffer.consume(length16);
    this.frameInProgress = false;
    return out;
  }
};
function returnlessSource(source) {
  if (source[Symbol.iterator] !== void 0) {
    const iterator = source[Symbol.iterator]();
    iterator.return = void 0;
    return {
      [Symbol.iterator]() {
        return iterator;
      }
    };
  } else if (source[Symbol.asyncIterator] !== void 0) {
    const iterator = source[Symbol.asyncIterator]();
    iterator.return = void 0;
    return {
      [Symbol.asyncIterator]() {
        return iterator;
      }
    };
  } else {
    throw new Error("a source must be either an iterable or an async iterable");
  }
}

// node_modules/@chainsafe/libp2p-yamux/dist/src/encode.js
function encodeHeader(header) {
  const frame = new Uint8Array(HEADER_LENGTH);
  frame[1] = header.type;
  frame[2] = header.flag >>> 8;
  frame[3] = header.flag;
  frame[4] = header.streamID >>> 24;
  frame[5] = header.streamID >>> 16;
  frame[6] = header.streamID >>> 8;
  frame[7] = header.streamID;
  frame[8] = header.length >>> 24;
  frame[9] = header.length >>> 16;
  frame[10] = header.length >>> 8;
  frame[11] = header.length;
  return frame;
}

// node_modules/@libp2p/utils/dist/src/is-promise.js
function isPromise3(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

// node_modules/@libp2p/utils/dist/src/close-source.js
function closeSource(source, log5) {
  const res = getIterator(source).return?.();
  if (isPromise3(res)) {
    res.catch((err) => {
      log5.error("could not cause iterator to return", err);
    });
  }
}

// node_modules/@libp2p/utils/dist/src/abstract-stream.js
var DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5e3;
function isPromise4(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}
var AbstractStream = class {
  id;
  direction;
  timeline;
  protocol;
  metadata;
  source;
  status;
  readStatus;
  writeStatus;
  log;
  sinkController;
  sinkEnd;
  closed;
  endErr;
  streamSource;
  onEnd;
  onCloseRead;
  onCloseWrite;
  onReset;
  onAbort;
  sendCloseWriteTimeout;
  sendingData;
  constructor(init) {
    this.sinkController = new AbortController();
    this.sinkEnd = pDefer();
    this.closed = pDefer();
    this.log = init.log;
    this.status = "open";
    this.readStatus = "ready";
    this.writeStatus = "ready";
    this.id = init.id;
    this.metadata = init.metadata ?? {};
    this.direction = init.direction;
    this.timeline = {
      open: Date.now()
    };
    this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT;
    this.onEnd = init.onEnd;
    this.onCloseRead = init.onCloseRead;
    this.onCloseWrite = init.onCloseWrite;
    this.onReset = init.onReset;
    this.onAbort = init.onAbort;
    this.source = this.streamSource = pushable({
      onEnd: (err) => {
        if (err != null) {
          this.log.trace("source ended with error", err);
        } else {
          this.log.trace("source ended");
        }
        this.onSourceEnd(err);
      }
    });
    this.sink = this.sink.bind(this);
  }
  async sink(source) {
    if (this.writeStatus !== "ready") {
      throw new StreamStateError(`writable end state is "${this.writeStatus}" not "ready"`);
    }
    try {
      this.writeStatus = "writing";
      const options2 = {
        signal: this.sinkController.signal
      };
      if (this.direction === "outbound") {
        const res = this.sendNewStream(options2);
        if (isPromise4(res)) {
          await res;
        }
      }
      const abortListener = () => {
        closeSource(source, this.log);
      };
      try {
        this.sinkController.signal.addEventListener("abort", abortListener);
        this.log.trace("sink reading from source");
        for await (let data of source) {
          data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;
          const res = this.sendData(data, options2);
          if (isPromise4(res)) {
            this.sendingData = pDefer();
            await res;
            this.sendingData.resolve();
            this.sendingData = void 0;
          }
        }
      } finally {
        this.sinkController.signal.removeEventListener("abort", abortListener);
      }
      this.log.trace('sink finished reading from source, write status is "%s"', this.writeStatus);
      if (this.writeStatus === "writing") {
        this.writeStatus = "closing";
        this.log.trace("send close write to remote");
        await this.sendCloseWrite({
          signal: AbortSignal.timeout(this.sendCloseWriteTimeout)
        });
        this.writeStatus = "closed";
      }
      this.onSinkEnd();
    } catch (err) {
      this.log.trace("sink ended with error, calling abort with error", err);
      this.abort(err);
      throw err;
    } finally {
      this.log.trace("resolve sink end");
      this.sinkEnd.resolve();
    }
  }
  onSourceEnd(err) {
    if (this.timeline.closeRead != null) {
      return;
    }
    this.timeline.closeRead = Date.now();
    this.readStatus = "closed";
    if (err != null && this.endErr == null) {
      this.endErr = err;
    }
    this.onCloseRead?.();
    if (this.timeline.closeWrite != null) {
      this.log.trace("source and sink ended");
      this.timeline.close = Date.now();
      if (this.status !== "aborted" && this.status !== "reset") {
        this.status = "closed";
      }
      if (this.onEnd != null) {
        this.onEnd(this.endErr);
      }
      this.closed.resolve();
    } else {
      this.log.trace("source ended, waiting for sink to end");
    }
  }
  onSinkEnd(err) {
    if (this.timeline.closeWrite != null) {
      return;
    }
    this.timeline.closeWrite = Date.now();
    this.writeStatus = "closed";
    if (err != null && this.endErr == null) {
      this.endErr = err;
    }
    this.onCloseWrite?.();
    if (this.timeline.closeRead != null) {
      this.log.trace("sink and source ended");
      this.timeline.close = Date.now();
      if (this.status !== "aborted" && this.status !== "reset") {
        this.status = "closed";
      }
      if (this.onEnd != null) {
        this.onEnd(this.endErr);
      }
      this.closed.resolve();
    } else {
      this.log.trace("sink ended, waiting for source to end");
    }
  }
  // Close for both Reading and Writing
  async close(options2) {
    if (this.status !== "open") {
      return;
    }
    this.log.trace("closing gracefully");
    this.status = "closing";
    await raceSignal(Promise.all([
      this.closeWrite(options2),
      this.closeRead(options2),
      this.closed.promise
    ]), options2?.signal);
    this.status = "closed";
    this.log.trace("closed gracefully");
  }
  async closeRead(options2 = {}) {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      return;
    }
    this.log.trace('closing readable end of stream with starting read status "%s"', this.readStatus);
    const readStatus = this.readStatus;
    this.readStatus = "closing";
    if (this.status !== "reset" && this.status !== "aborted" && this.timeline.closeRead == null) {
      this.log.trace("send close read to remote");
      await this.sendCloseRead(options2);
    }
    if (readStatus === "ready") {
      this.log.trace("ending internal source queue with %d queued bytes", this.streamSource.readableLength);
      this.streamSource.end();
    }
    this.log.trace("closed readable end of stream");
  }
  async closeWrite(options2 = {}) {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      return;
    }
    this.log.trace('closing writable end of stream with starting write status "%s"', this.writeStatus);
    if (this.writeStatus === "ready") {
      this.log.trace("sink was never sunk, sink an empty array");
      await raceSignal(this.sink([]), options2.signal);
    }
    if (this.writeStatus === "writing") {
      if (this.sendingData != null) {
        await raceSignal(this.sendingData.promise, options2.signal);
      }
      this.log.trace("aborting source passed to .sink");
      this.sinkController.abort();
      await raceSignal(this.sinkEnd.promise, options2.signal);
    }
    this.writeStatus = "closed";
    this.log.trace("closed writable end of stream");
  }
  /**
   * Close immediately for reading and writing and send a reset message (local
   * error)
   */
  abort(err) {
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      return;
    }
    this.log("abort with error", err);
    this.log("try to send reset to remote");
    const res = this.sendReset();
    if (isPromise4(res)) {
      res.catch((err2) => {
        this.log.error("error sending reset message", err2);
      });
    }
    this.status = "aborted";
    this.timeline.abort = Date.now();
    this._closeSinkAndSource(err);
    this.onAbort?.(err);
  }
  /**
   * Receive a reset message - close immediately for reading and writing (remote
   * error)
   */
  reset() {
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      return;
    }
    const err = new StreamResetError("stream reset");
    this.status = "reset";
    this.timeline.reset = Date.now();
    this._closeSinkAndSource(err);
    this.onReset?.();
  }
  _closeSinkAndSource(err) {
    this._closeSink(err);
    this._closeSource(err);
  }
  _closeSink(err) {
    if (this.writeStatus === "writing") {
      this.log.trace("end sink source");
      this.sinkController.abort();
    }
    this.onSinkEnd(err);
  }
  _closeSource(err) {
    if (this.readStatus !== "closing" && this.readStatus !== "closed") {
      this.log.trace("ending source with %d bytes to be read by consumer", this.streamSource.readableLength);
      this.readStatus = "closing";
      this.streamSource.end(err);
    }
  }
  /**
   * The remote closed for writing so we should expect to receive no more
   * messages
   */
  remoteCloseWrite() {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      this.log("received remote close write but local source is already closed");
      return;
    }
    this.log.trace("remote close write");
    this._closeSource();
  }
  /**
   * The remote closed for reading so we should not send any more
   * messages
   */
  remoteCloseRead() {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      this.log("received remote close read but local sink is already closed");
      return;
    }
    this.log.trace("remote close read");
    this._closeSink();
  }
  /**
   * The underlying muxer has closed, no more messages can be sent or will
   * be received, close immediately to free up resources
   */
  destroy() {
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      this.log("received destroy but we are already closed");
      return;
    }
    this.log.trace("stream destroyed");
    this._closeSinkAndSource();
  }
  /**
   * When an extending class reads data from it's implementation-specific source,
   * call this method to allow the stream consumer to read the data.
   */
  sourcePush(data) {
    this.streamSource.push(data);
  }
  /**
   * Returns the amount of unread data - can be used to prevent large amounts of
   * data building up when the stream consumer is too slow.
   */
  sourceReadableLength() {
    return this.streamSource.readableLength;
  }
};

// node_modules/@chainsafe/libp2p-yamux/dist/src/stream.js
var StreamState;
(function(StreamState2) {
  StreamState2[StreamState2["Init"] = 0] = "Init";
  StreamState2[StreamState2["SYNSent"] = 1] = "SYNSent";
  StreamState2[StreamState2["SYNReceived"] = 2] = "SYNReceived";
  StreamState2[StreamState2["Established"] = 3] = "Established";
  StreamState2[StreamState2["Finished"] = 4] = "Finished";
})(StreamState || (StreamState = {}));
var YamuxStream = class extends AbstractStream {
  name;
  state;
  config;
  _id;
  /** The number of available bytes to send */
  sendWindowCapacity;
  /** Callback to notify that the sendWindowCapacity has been updated */
  sendWindowCapacityUpdate;
  /** The number of bytes available to receive in a full window */
  recvWindow;
  /** The number of available bytes to receive */
  recvWindowCapacity;
  /**
   * An 'epoch' is the time it takes to process and read data
   *
   * Used in conjunction with RTT to determine whether to increase the recvWindow
   */
  epochStart;
  getRTT;
  sendFrame;
  constructor(init) {
    super({
      ...init,
      onEnd: (err) => {
        this.state = StreamState.Finished;
        init.onEnd?.(err);
      }
    });
    this.config = init.config;
    this._id = parseInt(init.id, 10);
    this.name = init.name;
    this.state = init.state;
    this.sendWindowCapacity = INITIAL_STREAM_WINDOW;
    this.recvWindow = this.config.initialStreamWindowSize;
    this.recvWindowCapacity = this.recvWindow;
    this.epochStart = Date.now();
    this.getRTT = init.getRTT;
    this.sendFrame = init.sendFrame;
    this.source = src_default9(this.source, () => {
      this.sendWindowUpdate();
    });
  }
  /**
   * Send a message to the remote muxer informing them a new stream is being
   * opened.
   *
   * This is a noop for Yamux because the first window update is sent when
   * .newStream is called on the muxer which opens the stream on the remote.
   */
  async sendNewStream() {
  }
  /**
   * Send a data message to the remote muxer
   */
  async sendData(buf, options2 = {}) {
    buf = buf.sublist();
    while (buf.byteLength !== 0) {
      if (this.sendWindowCapacity === 0) {
        this.log?.trace("wait for send window capacity, status %s", this.status);
        await this.waitForSendWindowCapacity(options2);
        if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
          this.log?.trace("%s while waiting for send window capacity", this.status);
          return;
        }
      }
      const toSend = Math.min(this.sendWindowCapacity, this.config.maxMessageSize - HEADER_LENGTH, buf.length);
      const flags = this.getSendFlags();
      this.sendFrame({
        type: FrameType.Data,
        flag: flags,
        streamID: this._id,
        length: toSend
      }, buf.sublist(0, toSend));
      this.sendWindowCapacity -= toSend;
      buf.consume(toSend);
    }
  }
  /**
   * Send a reset message to the remote muxer
   */
  async sendReset() {
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: Flag.RST,
      streamID: this._id,
      length: 0
    });
  }
  /**
   * Send a message to the remote muxer, informing them no more data messages
   * will be sent by this end of the stream
   */
  async sendCloseWrite() {
    const flags = this.getSendFlags() | Flag.FIN;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this._id,
      length: 0
    });
  }
  /**
   * Send a message to the remote muxer, informing them no more data messages
   * will be read by this end of the stream
   */
  async sendCloseRead() {
  }
  /**
   * Wait for the send window to be non-zero
   *
   * Will throw with ERR_STREAM_ABORT if the stream gets aborted
   */
  async waitForSendWindowCapacity(options2 = {}) {
    if (this.sendWindowCapacity > 0) {
      return;
    }
    let resolve;
    let reject;
    const abort = () => {
      if (this.status === "open" || this.status === "closing") {
        reject(new AbortError("Stream aborted"));
      } else {
        resolve();
      }
    };
    options2.signal?.addEventListener("abort", abort);
    try {
      await new Promise((_resolve, _reject) => {
        this.sendWindowCapacityUpdate = () => {
          _resolve();
        };
        reject = _reject;
        resolve = _resolve;
      });
    } finally {
      options2.signal?.removeEventListener("abort", abort);
    }
  }
  /**
   * handleWindowUpdate is called when the stream receives a window update frame
   */
  handleWindowUpdate(header) {
    this.log?.trace("stream received window update id=%s", this._id);
    this.processFlags(header.flag);
    const available = this.sendWindowCapacity;
    this.sendWindowCapacity += header.length;
    if (available === 0 && header.length > 0) {
      this.sendWindowCapacityUpdate?.();
    }
  }
  /**
   * handleData is called when the stream receives a data frame
   */
  async handleData(header, readData) {
    this.log?.trace("stream received data id=%s", this._id);
    this.processFlags(header.flag);
    if (this.recvWindowCapacity < header.length) {
      throw new ReceiveWindowExceededError("Receive window exceeded");
    }
    const data = await readData();
    this.recvWindowCapacity -= header.length;
    this.sourcePush(data);
  }
  /**
   * processFlags is used to update the state of the stream based on set flags, if any.
   */
  processFlags(flags) {
    if ((flags & Flag.ACK) === Flag.ACK) {
      if (this.state === StreamState.SYNSent) {
        this.state = StreamState.Established;
      }
    }
    if ((flags & Flag.FIN) === Flag.FIN) {
      this.remoteCloseWrite();
    }
    if ((flags & Flag.RST) === Flag.RST) {
      this.reset();
    }
  }
  /**
   * getSendFlags determines any flags that are appropriate
   * based on the current stream state.
   *
   * The state is updated as a side-effect.
   */
  getSendFlags() {
    switch (this.state) {
      case StreamState.Init:
        this.state = StreamState.SYNSent;
        return Flag.SYN;
      case StreamState.SYNReceived:
        this.state = StreamState.Established;
        return Flag.ACK;
      default:
        return 0;
    }
  }
  /**
   * potentially sends a window update enabling further writes to take place.
   */
  sendWindowUpdate() {
    const flags = this.getSendFlags();
    const now = Date.now();
    const rtt = this.getRTT();
    if (flags === 0 && rtt > -1 && now - this.epochStart < rtt * 4) {
      this.recvWindow = Math.min(this.recvWindow * 2, this.config.maxStreamWindowSize);
    }
    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {
      return;
    }
    const delta = this.recvWindow - this.recvWindowCapacity;
    this.recvWindowCapacity = this.recvWindow;
    this.epochStart = now;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this._id,
      length: delta
    });
  }
};

// node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js
var YAMUX_PROTOCOL_ID = "/yamux/1.0.0";
var CLOSE_TIMEOUT2 = 500;
var Yamux = class {
  protocol = YAMUX_PROTOCOL_ID;
  _components;
  _init;
  constructor(components, init = {}) {
    this._components = components;
    this._init = init;
  }
  [Symbol.toStringTag] = "@chainsafe/libp2p-yamux";
  [serviceCapabilities] = [
    "@libp2p/stream-multiplexing"
  ];
  createStreamMuxer(init) {
    return new YamuxMuxer(this._components, {
      ...this._init,
      ...init
    });
  }
};
var YamuxMuxer = class {
  protocol = YAMUX_PROTOCOL_ID;
  source;
  sink;
  config;
  log;
  logger;
  /** Used to close the muxer from either the sink or source */
  closeController;
  /** The next stream id to be used when initiating a new stream */
  nextStreamID;
  /** Primary stream mapping, streamID => stream */
  _streams;
  /** The next ping id to be used when pinging */
  nextPingID;
  /** Tracking info for the currently active ping */
  activePing;
  /** Round trip time */
  rtt;
  /** True if client, false if server */
  client;
  localGoAway;
  remoteGoAway;
  /** Number of tracked inbound streams */
  numInboundStreams;
  /** Number of tracked outbound streams */
  numOutboundStreams;
  onIncomingStream;
  onStreamEnd;
  constructor(components, init) {
    this.client = init.direction === "outbound";
    this.config = { ...defaultConfig, ...init };
    this.logger = components.logger;
    this.log = this.logger.forComponent("libp2p:yamux");
    verifyConfig(this.config);
    this.closeController = new AbortController();
    setMaxListeners(Infinity, this.closeController.signal);
    this.onIncomingStream = init.onIncomingStream;
    this.onStreamEnd = init.onStreamEnd;
    this._streams = /* @__PURE__ */ new Map();
    this.source = pushable({
      onEnd: () => {
        this.log?.trace("muxer source ended");
        this._streams.forEach((stream) => {
          stream.destroy();
        });
      }
    });
    this.sink = async (source) => {
      const shutDownListener = () => {
        const iterator = getIterator(source);
        if (iterator.return != null) {
          const res = iterator.return();
          if (isPromise5(res)) {
            res.catch((err) => {
              this.log?.("could not cause sink source to return", err);
            });
          }
        }
      };
      let reason, error;
      try {
        const decoder = new Decoder12(source);
        try {
          this.closeController.signal.addEventListener("abort", shutDownListener);
          for await (const frame of decoder.emitFrames()) {
            await this.handleFrame(frame.header, frame.readData);
          }
        } finally {
          this.closeController.signal.removeEventListener("abort", shutDownListener);
        }
        reason = GoAwayCode.NormalTermination;
      } catch (err) {
        if (PROTOCOL_ERRORS.has(err.name)) {
          this.log?.error("protocol error in sink", err);
          reason = GoAwayCode.ProtocolError;
        } else {
          this.log?.error("internal error in sink", err);
          reason = GoAwayCode.InternalError;
        }
        error = err;
      }
      this.log?.trace("muxer sink ended");
      if (error != null) {
        this.abort(error, reason);
      } else {
        await this.close({ reason });
      }
    };
    this.numInboundStreams = 0;
    this.numOutboundStreams = 0;
    this.nextStreamID = this.client ? 1 : 2;
    this.nextPingID = 0;
    this.rtt = -1;
    this.log?.trace("muxer created");
    if (this.config.enableKeepAlive) {
      this.keepAliveLoop().catch((e) => this.log?.error("keepalive error: %s", e));
    }
    this.ping().catch((e) => this.log?.error("ping error: %s", e));
  }
  get streams() {
    return Array.from(this._streams.values());
  }
  newStream(name9) {
    if (this.remoteGoAway !== void 0) {
      throw new MuxerClosedError("Muxer closed remotely");
    }
    if (this.localGoAway !== void 0) {
      throw new MuxerClosedError("Muxer closed locally");
    }
    const id = this.nextStreamID;
    this.nextStreamID += 2;
    if (this.numOutboundStreams >= this.config.maxOutboundStreams) {
      throw new TooManyOutboundProtocolStreamsError("max outbound streams exceeded");
    }
    this.log?.trace("new outgoing stream id=%s", id);
    const stream = this._newStream(id, name9, StreamState.Init, "outbound");
    this._streams.set(id, stream);
    this.numOutboundStreams++;
    stream.sendWindowUpdate();
    return stream;
  }
  /**
   * Initiate a ping and wait for a response
   *
   * Note: only a single ping will be initiated at a time.
   * If a ping is already in progress, a new ping will not be initiated.
   *
   * @returns the round-trip-time in milliseconds
   */
  async ping() {
    if (this.remoteGoAway !== void 0) {
      throw new MuxerClosedError("Muxer closed remotely");
    }
    if (this.localGoAway !== void 0) {
      throw new MuxerClosedError("Muxer closed locally");
    }
    if (this.activePing === void 0) {
      let _resolve = () => {
      };
      this.activePing = {
        id: this.nextPingID++,
        // this promise awaits resolution or the close controller aborting
        promise: new Promise((resolve, reject) => {
          const closed = () => {
            reject(new MuxerClosedError("Muxer closed locally"));
          };
          this.closeController.signal.addEventListener("abort", closed, { once: true });
          _resolve = () => {
            this.closeController.signal.removeEventListener("abort", closed);
            resolve();
          };
        }),
        resolve: _resolve
      };
      const start2 = Date.now();
      this.sendPing(this.activePing.id);
      try {
        await this.activePing.promise;
      } finally {
        delete this.activePing;
      }
      const end = Date.now();
      this.rtt = end - start2;
    } else {
      await this.activePing.promise;
    }
    return this.rtt;
  }
  /**
   * Get the ping round trip time
   *
   * Note: Will return 0 if no successful ping has yet been completed
   *
   * @returns the round-trip-time in milliseconds
   */
  getRTT() {
    return this.rtt;
  }
  /**
   * Close the muxer
   */
  async close(options2 = {}) {
    if (this.closeController.signal.aborted) {
      return;
    }
    const reason = options2?.reason ?? GoAwayCode.NormalTermination;
    this.log?.trace("muxer close reason=%s", reason);
    if (options2.signal == null) {
      const signal = AbortSignal.timeout(CLOSE_TIMEOUT2);
      setMaxListeners(Infinity, signal);
      options2 = {
        ...options2,
        signal
      };
    }
    try {
      await Promise.all([...this._streams.values()].map(async (s) => s.close(options2)));
      this.sendGoAway(reason);
      this._closeMuxer();
    } catch (err) {
      this.abort(err);
    }
  }
  abort(err, reason) {
    if (this.closeController.signal.aborted) {
      return;
    }
    reason = reason ?? GoAwayCode.InternalError;
    this.log?.error("muxer abort reason=%s error=%s", reason, err);
    for (const stream of this._streams.values()) {
      stream.abort(err);
    }
    this.sendGoAway(reason);
    this._closeMuxer();
  }
  isClosed() {
    return this.closeController.signal.aborted;
  }
  /**
   * Called when either the local or remote shuts down the muxer
   */
  _closeMuxer() {
    this.closeController.abort();
    this.source.end();
  }
  /** Create a new stream */
  _newStream(id, name9, state, direction) {
    if (this._streams.get(id) != null) {
      throw new InvalidParametersError("Stream already exists with that id");
    }
    const stream = new YamuxStream({
      id: id.toString(),
      name: name9,
      state,
      direction,
      sendFrame: this.sendFrame.bind(this),
      onEnd: () => {
        this.closeStream(id);
        this.onStreamEnd?.(stream);
      },
      log: this.logger.forComponent(`libp2p:yamux:${direction}:${id}`),
      config: this.config,
      getRTT: this.getRTT.bind(this)
    });
    return stream;
  }
  /**
   * closeStream is used to close a stream once both sides have
   * issued a close.
   */
  closeStream(id) {
    if (this.client === (id % 2 === 0)) {
      this.numInboundStreams--;
    } else {
      this.numOutboundStreams--;
    }
    this._streams.delete(id);
  }
  async keepAliveLoop() {
    this.log?.trace("muxer keepalive enabled interval=%s", this.config.keepAliveInterval);
    while (true) {
      let timeoutId;
      try {
        await raceSignal(new Promise((resolve) => {
          timeoutId = setTimeout(resolve, this.config.keepAliveInterval);
        }), this.closeController.signal);
        this.ping().catch((e) => this.log?.error("ping error: %s", e));
      } catch (e) {
        clearInterval(timeoutId);
        return;
      }
    }
  }
  async handleFrame(header, readData) {
    const { streamID, type, length: length16 } = header;
    this.log?.trace("received frame %o", header);
    if (streamID === 0) {
      switch (type) {
        case FrameType.Ping: {
          this.handlePing(header);
          return;
        }
        case FrameType.GoAway: {
          this.handleGoAway(length16);
          return;
        }
        default:
          throw new InvalidFrameError("Invalid frame type");
      }
    } else {
      switch (header.type) {
        case FrameType.Data:
        case FrameType.WindowUpdate: {
          await this.handleStreamMessage(header, readData);
          return;
        }
        default:
          throw new InvalidFrameError("Invalid frame type");
      }
    }
  }
  handlePing(header) {
    if (header.flag === Flag.SYN) {
      this.log?.trace("received ping request pingId=%s", header.length);
      this.sendPing(header.length, Flag.ACK);
    } else if (header.flag === Flag.ACK) {
      this.log?.trace("received ping response pingId=%s", header.length);
      this.handlePingResponse(header.length);
    } else {
      throw new InvalidFrameError("Invalid frame flag");
    }
  }
  handlePingResponse(pingId) {
    if (this.activePing === void 0) {
      throw new UnrequestedPingError("ping not requested");
    }
    if (this.activePing.id !== pingId) {
      throw new NotMatchingPingError("ping doesn't match our id");
    }
    this.activePing.resolve();
  }
  handleGoAway(reason) {
    this.log?.trace("received GoAway reason=%s", GoAwayCode[reason] ?? "unknown");
    this.remoteGoAway = reason;
    for (const stream of this._streams.values()) {
      stream.reset();
    }
    this._closeMuxer();
  }
  async handleStreamMessage(header, readData) {
    const { streamID, flag, type } = header;
    if ((flag & Flag.SYN) === Flag.SYN) {
      this.incomingStream(streamID);
    }
    const stream = this._streams.get(streamID);
    if (stream === void 0) {
      if (type === FrameType.Data) {
        this.log?.("discarding data for stream id=%s", streamID);
        if (readData === void 0) {
          throw new Error("unreachable");
        }
        await readData();
      } else {
        this.log?.trace("frame for missing stream id=%s", streamID);
      }
      return;
    }
    switch (type) {
      case FrameType.WindowUpdate: {
        stream.handleWindowUpdate(header);
        return;
      }
      case FrameType.Data: {
        if (readData === void 0) {
          throw new Error("unreachable");
        }
        await stream.handleData(header, readData);
        return;
      }
      default:
        throw new Error("unreachable");
    }
  }
  incomingStream(id) {
    if (this.client !== (id % 2 === 0)) {
      throw new InvalidParametersError("Both endpoints are clients");
    }
    if (this._streams.has(id)) {
      return;
    }
    this.log?.trace("new incoming stream id=%s", id);
    if (this.localGoAway !== void 0) {
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    if (this.numInboundStreams >= this.config.maxInboundStreams) {
      this.log?.("maxIncomingStreams exceeded, forcing stream reset");
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    const stream = this._newStream(id, void 0, StreamState.SYNReceived, "inbound");
    this.numInboundStreams++;
    this._streams.set(id, stream);
    this.onIncomingStream?.(stream);
  }
  sendFrame(header, data) {
    this.log?.trace("sending frame %o", header);
    if (header.type === FrameType.Data) {
      if (data === void 0) {
        throw new InvalidFrameError("Invalid frame");
      }
      this.source.push(new Uint8ArrayList(encodeHeader(header), data));
    } else {
      this.source.push(encodeHeader(header));
    }
  }
  sendPing(pingId, flag = Flag.SYN) {
    if (flag === Flag.SYN) {
      this.log?.trace("sending ping request pingId=%s", pingId);
    } else {
      this.log?.trace("sending ping response pingId=%s", pingId);
    }
    this.sendFrame({
      type: FrameType.Ping,
      flag,
      streamID: 0,
      length: pingId
    });
  }
  sendGoAway(reason = GoAwayCode.NormalTermination) {
    this.log?.("sending GoAway reason=%s", GoAwayCode[reason]);
    this.localGoAway = reason;
    this.sendFrame({
      type: FrameType.GoAway,
      flag: 0,
      streamID: 0,
      length: reason
    });
  }
};
function isPromise5(thing) {
  return thing != null && typeof thing.then === "function";
}

// node_modules/@chainsafe/libp2p-yamux/dist/src/index.js
function yamux(init = {}) {
  return (components) => new Yamux(components, init);
}

// node_modules/@libp2p/utils/dist/src/multiaddr/is-global-unicast.js
function isGlobalUnicast(ma) {
  try {
    for (const { code: code17, value: value7 } of ma.getComponents()) {
      if (value7 == null) {
        continue;
      }
      if (code17 === CODE_IP6) {
        return cidrContains("2000::/3", value7);
      }
    }
  } catch {
  }
  return false;
}

// node_modules/@libp2p/utils/dist/src/repeating-task.js
function repeatingTask(fn, interval, options2) {
  let timeout;
  let shutdownController;
  let running = false;
  function runTask() {
    const opts = {
      signal: shutdownController.signal
    };
    if (options2?.timeout != null) {
      const signal = anySignal([shutdownController.signal, AbortSignal.timeout(options2.timeout)]);
      setMaxListeners(Infinity, signal);
      opts.signal = signal;
    }
    running = true;
    Promise.resolve().then(async () => {
      await fn(opts);
    }).catch(() => {
    }).finally(() => {
      running = false;
      if (shutdownController.signal.aborted) {
        return;
      }
      timeout = setTimeout(runTask, interval);
    });
  }
  const runTaskDebounced = debounce(runTask, options2?.debounce ?? 100);
  let started = false;
  return {
    setInterval: (ms) => {
      if (interval === ms) {
        return;
      }
      interval = ms;
      if (timeout != null) {
        clearTimeout(timeout);
        timeout = setTimeout(runTask, interval);
      }
    },
    setTimeout: (ms) => {
      options2 ??= {};
      options2.timeout = ms;
    },
    run: () => {
      if (running) {
        return;
      }
      clearTimeout(timeout);
      runTaskDebounced();
    },
    start: () => {
      if (started) {
        return;
      }
      started = true;
      shutdownController = new AbortController();
      setMaxListeners(Infinity, shutdownController.signal);
      if (options2?.runImmediately === true) {
        queueMicrotask(() => {
          runTask();
        });
      } else {
        timeout = setTimeout(runTask, interval);
      }
    },
    stop: () => {
      clearTimeout(timeout);
      shutdownController?.abort();
      started = false;
    }
  };
}

// node_modules/it-protobuf-stream/dist/src/index.js
function pbStream(duplex, opts) {
  const lp = lpStream(duplex, opts);
  const W = {
    read: async (proto, options2) => {
      const value7 = await lp.read(options2);
      return proto.decode(value7);
    },
    write: async (message2, proto, options2) => {
      await lp.write(proto.encode(message2), options2);
    },
    writeV: async (messages2, proto, options2) => {
      await lp.writeV(messages2.map((message2) => proto.encode(message2)), options2);
    },
    pb: (proto) => {
      return {
        read: async (options2) => W.read(proto, options2),
        write: async (d, options2) => W.write(d, proto, options2),
        writeV: async (d, options2) => W.writeV(d, proto, options2),
        unwrap: () => W
      };
    },
    unwrap: () => {
      return lp.unwrap();
    }
  };
  return W;
}

// node_modules/@libp2p/autonat/node_modules/multiformats/dist/src/bytes.js
var empty13 = new Uint8Array(0);
function coerce13(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@libp2p/autonat/node_modules/multiformats/dist/src/vendor/varint.js
var encode_111 = encode29;
var MSB11 = 128;
var REST11 = 127;
var MSBALL11 = ~REST11;
var INT11 = Math.pow(2, 31);
function encode29(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT11) {
    out[offset++] = num & 255 | MSB11;
    num /= 128;
  }
  while (num & MSBALL11) {
    out[offset++] = num & 255 | MSB11;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode29.bytes = offset - oldOffset + 1;
  return out;
}
var decode45 = read12;
var MSB$111 = 128;
var REST$111 = 127;
function read12(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read12.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$111) << shift : (b & REST$111) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$111);
  read12.bytes = counter - offset;
  return res;
}
var N111 = Math.pow(2, 7);
var N211 = Math.pow(2, 14);
var N311 = Math.pow(2, 21);
var N411 = Math.pow(2, 28);
var N511 = Math.pow(2, 35);
var N611 = Math.pow(2, 42);
var N711 = Math.pow(2, 49);
var N811 = Math.pow(2, 56);
var N911 = Math.pow(2, 63);
var length11 = function(value7) {
  return value7 < N111 ? 1 : value7 < N211 ? 2 : value7 < N311 ? 3 : value7 < N411 ? 4 : value7 < N511 ? 5 : value7 < N611 ? 6 : value7 < N711 ? 7 : value7 < N811 ? 8 : value7 < N911 ? 9 : 10;
};
var varint11 = {
  encode: encode_111,
  decode: decode45,
  encodingLength: length11
};
var _brrp_varint11 = varint11;
var varint_default11 = _brrp_varint11;

// node_modules/@libp2p/autonat/node_modules/multiformats/dist/src/varint.js
function decode46(data, offset = 0) {
  const code17 = varint_default11.decode(data, offset);
  return [code17, varint_default11.decode.bytes];
}

// node_modules/@libp2p/autonat/node_modules/multiformats/dist/src/hashes/digest.js
function decode47(multihash) {
  const bytes = coerce13(multihash);
  const [code17, sizeOffset] = decode46(bytes);
  const [size, digestOffset] = decode46(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest11(code17, size, digest5, bytes);
}
var Digest11 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/@libp2p/autonat/dist/src/constants.js
var PROTOCOL_PREFIX2 = "libp2p";
var PROTOCOL_NAME2 = "autonat";
var PROTOCOL_VERSION2 = "1.0.0";
var TIMEOUT = 3e4;
var MAX_INBOUND_STREAMS = 2;
var MAX_OUTBOUND_STREAMS = 20;
var DEFAULT_CONNECTION_THRESHOLD = 80;
var MAX_MESSAGE_SIZE = 8192;

// node_modules/@libp2p/autonat/dist/src/pb/index.js
var Message;
(function(Message5) {
  let MessageType2;
  (function(MessageType3) {
    MessageType3["DIAL"] = "DIAL";
    MessageType3["DIAL_RESPONSE"] = "DIAL_RESPONSE";
  })(MessageType2 = Message5.MessageType || (Message5.MessageType = {}));
  let __MessageTypeValues2;
  (function(__MessageTypeValues3) {
    __MessageTypeValues3[__MessageTypeValues3["DIAL"] = 0] = "DIAL";
    __MessageTypeValues3[__MessageTypeValues3["DIAL_RESPONSE"] = 1] = "DIAL_RESPONSE";
  })(__MessageTypeValues2 || (__MessageTypeValues2 = {}));
  (function(MessageType3) {
    MessageType3.codec = () => {
      return enumeration(__MessageTypeValues2);
    };
  })(MessageType2 = Message5.MessageType || (Message5.MessageType = {}));
  let ResponseStatus;
  (function(ResponseStatus2) {
    ResponseStatus2["OK"] = "OK";
    ResponseStatus2["E_DIAL_ERROR"] = "E_DIAL_ERROR";
    ResponseStatus2["E_DIAL_REFUSED"] = "E_DIAL_REFUSED";
    ResponseStatus2["E_BAD_REQUEST"] = "E_BAD_REQUEST";
    ResponseStatus2["E_INTERNAL_ERROR"] = "E_INTERNAL_ERROR";
  })(ResponseStatus = Message5.ResponseStatus || (Message5.ResponseStatus = {}));
  let __ResponseStatusValues;
  (function(__ResponseStatusValues2) {
    __ResponseStatusValues2[__ResponseStatusValues2["OK"] = 0] = "OK";
    __ResponseStatusValues2[__ResponseStatusValues2["E_DIAL_ERROR"] = 100] = "E_DIAL_ERROR";
    __ResponseStatusValues2[__ResponseStatusValues2["E_DIAL_REFUSED"] = 101] = "E_DIAL_REFUSED";
    __ResponseStatusValues2[__ResponseStatusValues2["E_BAD_REQUEST"] = 200] = "E_BAD_REQUEST";
    __ResponseStatusValues2[__ResponseStatusValues2["E_INTERNAL_ERROR"] = 300] = "E_INTERNAL_ERROR";
  })(__ResponseStatusValues || (__ResponseStatusValues = {}));
  (function(ResponseStatus2) {
    ResponseStatus2.codec = () => {
      return enumeration(__ResponseStatusValues);
    };
  })(ResponseStatus = Message5.ResponseStatus || (Message5.ResponseStatus = {}));
  let PeerInfo2;
  (function(PeerInfo3) {
    let _codec2;
    PeerInfo3.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.id != null) {
            w.uint32(10);
            w.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value7 of obj.addrs) {
              w.uint32(18);
              w.bytes(value7);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length16, opts = {}) => {
          const obj = {
            addrs: []
          };
          const end = length16 == null ? reader.len : reader.pos + length16;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.id = reader.bytes();
                break;
              }
              case 2: {
                if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                  throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
                }
                obj.addrs.push(reader.bytes());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    PeerInfo3.encode = (obj) => {
      return encodeMessage(obj, PeerInfo3.codec());
    };
    PeerInfo3.decode = (buf, opts) => {
      return decodeMessage(buf, PeerInfo3.codec(), opts);
    };
  })(PeerInfo2 = Message5.PeerInfo || (Message5.PeerInfo = {}));
  let Dial;
  (function(Dial2) {
    let _codec2;
    Dial2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.peer != null) {
            w.uint32(10);
            Message5.PeerInfo.codec().encode(obj.peer, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length16, opts = {}) => {
          const obj = {};
          const end = length16 == null ? reader.len : reader.pos + length16;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.peer = Message5.PeerInfo.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.peer
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Dial2.encode = (obj) => {
      return encodeMessage(obj, Dial2.codec());
    };
    Dial2.decode = (buf, opts) => {
      return decodeMessage(buf, Dial2.codec(), opts);
    };
  })(Dial = Message5.Dial || (Message5.Dial = {}));
  let DialResponse;
  (function(DialResponse2) {
    let _codec2;
    DialResponse2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.status != null) {
            w.uint32(8);
            Message5.ResponseStatus.codec().encode(obj.status, w);
          }
          if (obj.statusText != null) {
            w.uint32(18);
            w.string(obj.statusText);
          }
          if (obj.addr != null) {
            w.uint32(26);
            w.bytes(obj.addr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length16, opts = {}) => {
          const obj = {};
          const end = length16 == null ? reader.len : reader.pos + length16;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.status = Message5.ResponseStatus.codec().decode(reader);
                break;
              }
              case 2: {
                obj.statusText = reader.string();
                break;
              }
              case 3: {
                obj.addr = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    DialResponse2.encode = (obj) => {
      return encodeMessage(obj, DialResponse2.codec());
    };
    DialResponse2.decode = (buf, opts) => {
      return decodeMessage(buf, DialResponse2.codec(), opts);
    };
  })(DialResponse = Message5.DialResponse || (Message5.DialResponse = {}));
  let _codec;
  Message5.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          Message5.MessageType.codec().encode(obj.type, w);
        }
        if (obj.dial != null) {
          w.uint32(18);
          Message5.Dial.codec().encode(obj.dial, w);
        }
        if (obj.dialResponse != null) {
          w.uint32(26);
          Message5.DialResponse.codec().encode(obj.dialResponse, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {};
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = Message5.MessageType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.dial = Message5.Dial.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.dial
              });
              break;
            }
            case 3: {
              obj.dialResponse = Message5.DialResponse.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.dialResponse
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message5.encode = (obj) => {
    return encodeMessage(obj, Message5.codec());
  };
  Message5.decode = (buf, opts) => {
    return decodeMessage(buf, Message5.codec(), opts);
  };
})(Message || (Message = {}));

// node_modules/@libp2p/autonat/dist/src/autonat.js
var REQUIRED_SUCCESSFUL_DIALS = 4;
var REQUIRED_FAILED_DIALS = 8;
var AutoNATService = class {
  components;
  protocol;
  timeout;
  maxInboundStreams;
  maxOutboundStreams;
  maxMessageSize;
  started;
  log;
  topologyId;
  dialResults;
  findPeers;
  addressFilter;
  connectionThreshold;
  constructor(components, init) {
    this.components = components;
    this.log = components.logger.forComponent("libp2p:auto-nat");
    this.started = false;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX2}/${PROTOCOL_NAME2}/${PROTOCOL_VERSION2}`;
    this.timeout = init.timeout ?? TIMEOUT;
    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
    this.connectionThreshold = init.connectionThreshold ?? DEFAULT_CONNECTION_THRESHOLD;
    this.maxMessageSize = init.maxMessageSize ?? MAX_MESSAGE_SIZE;
    this.dialResults = trackedMap({
      name: "libp2p_autonat_dial_results",
      metrics: components.metrics
    });
    this.findPeers = repeatingTask(this.findRandomPeers.bind(this), 6e4);
    this.addressFilter = createScalableCuckooFilter(1024);
  }
  [Symbol.toStringTag] = "@libp2p/autonat";
  [serviceCapabilities] = [
    "@libp2p/autonat"
  ];
  get [serviceDependencies]() {
    return [
      "@libp2p/identify"
    ];
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.components.registrar.handle(this.protocol, (data) => {
      void this.handleIncomingAutonatStream(data).catch((err) => {
        this.log.error("error handling incoming autonat stream - %e", err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams
    });
    this.topologyId = await this.components.registrar.register(this.protocol, {
      onConnect: (peerId2, connection) => {
        this.verifyExternalAddresses(connection).catch((err) => {
          this.log.error("could not verify addresses - %e", err);
        });
      }
    });
    this.findPeers.start();
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    if (this.topologyId != null) {
      await this.components.registrar.unhandle(this.topologyId);
    }
    this.dialResults.clear();
    this.findPeers.stop();
    this.started = false;
  }
  allAddressesAreVerified() {
    return this.components.addressManager.getAddressesWithMetadata().every((addr) => {
      if (addr.expires > Date.now()) {
        return true;
      }
      return addr.verified;
    });
  }
  async findRandomPeers(options2) {
    if (this.allAddressesAreVerified()) {
      return;
    }
    const signal = anySignal([
      AbortSignal.timeout(1e4),
      options2?.signal
    ]);
    try {
      this.log("starting random walk to find peers to run AutoNAT");
      for await (const peer of this.components.randomWalk.walk({ signal })) {
        if (!await this.components.connectionManager.isDialable(peer.multiaddrs)) {
          this.log.trace("random peer %p was not dialable %s", peer.id, peer.multiaddrs.map((ma) => ma.toString()).join(", "));
          continue;
        }
        try {
          this.log.trace("dial random peer %p", peer.id);
          await this.components.connectionManager.openConnection(peer.multiaddrs, {
            signal
          });
        } catch {
        }
        if (this.allAddressesAreVerified()) {
          this.log("stopping random walk, all addresses are verified");
          return;
        }
        if (!this.hasConnectionCapacity()) {
          this.log("stopping random walk, too close to max connections");
          return;
        }
      }
    } catch {
    }
  }
  /**
   * Handle an incoming AutoNAT request
   */
  async handleIncomingAutonatStream(data) {
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    const messages2 = pbStream(data.stream, {
      maxDataLength: this.maxMessageSize
    }).pb(Message);
    try {
      const request = await messages2.read({
        signal
      });
      const response = await this.handleAutonatMessage(request, data.connection, {
        signal
      });
      await messages2.write(response, {
        signal
      });
      await messages2.unwrap().unwrap().close({
        signal
      });
    } catch (err) {
      this.log.error("error handling incoming autonat stream - %e", err);
      data.stream.abort(err);
    }
  }
  async handleAutonatMessage(message2, connection, options2) {
    const ourHosts = this.components.addressManager.getAddresses().map((ma) => ma.toOptions().host);
    const dialRequest = message2.dial;
    if (dialRequest == null) {
      this.log.error("dial was missing from message");
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_BAD_REQUEST,
          statusText: "No Dial message found in message"
        }
      };
    }
    let peerId2;
    const peer = dialRequest.peer;
    if (peer?.id == null) {
      this.log.error("PeerId missing from message");
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_BAD_REQUEST,
          statusText: "missing peer info"
        }
      };
    }
    try {
      const digest5 = decode47(peer.id);
      peerId2 = peerIdFromMultihash(digest5);
    } catch (err) {
      this.log.error("invalid PeerId - %e", err);
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_BAD_REQUEST,
          statusText: "bad peer id"
        }
      };
    }
    this.log("incoming request from %p", peerId2);
    if (!connection.remotePeer.equals(peerId2)) {
      this.log("target peer %p did not equal sending peer %p", peerId2, connection.remotePeer);
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_BAD_REQUEST,
          statusText: "peer id mismatch"
        }
      };
    }
    const multiaddrs = peer.addrs.map((buf) => multiaddr(buf)).filter((ma) => {
      const options3 = ma.toOptions();
      if (isPrivate(ma)) {
        return false;
      }
      if (options3.host !== connection.remoteAddr.toOptions().host) {
        this.log.trace("not dialing %a - target host did not match remote host %a", ma, connection.remoteAddr);
        return false;
      }
      if (ourHosts.includes(options3.host)) {
        return false;
      }
      if (this.components.transportManager.dialTransportForMultiaddr(ma) == null) {
        this.log.trace("not dialing %a - transport unsupported", ma);
        return false;
      }
      return true;
    }).map((ma) => {
      if (ma.getPeerId() == null) {
        ma = ma.encapsulate(`/p2p/${peerId2.toString()}`);
      }
      return ma;
    });
    if (multiaddrs.length === 0) {
      this.log("refused to dial all multiaddrs for %p from message", peerId2);
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_DIAL_REFUSED,
          statusText: "no dialable addresses"
        }
      };
    }
    this.log("dial multiaddrs %s for peer %p", multiaddrs.map((ma) => ma.toString()).join(", "), peerId2);
    let errorMessage = "";
    let lastMultiaddr = multiaddrs[0];
    for (const multiaddr2 of multiaddrs) {
      let connection2;
      lastMultiaddr = multiaddr2;
      try {
        connection2 = await this.components.connectionManager.openConnection(multiaddr2, options2);
        if (!connection2.remoteAddr.equals(multiaddr2)) {
          this.log.error("tried to dial %a but dialed %a", multiaddr2, connection2.remoteAddr);
          throw new Error("Unexpected remote address");
        }
        this.log("successfully dialed %p via %a", peerId2, multiaddr2);
        return {
          type: Message.MessageType.DIAL_RESPONSE,
          dialResponse: {
            status: Message.ResponseStatus.OK,
            addr: connection2.remoteAddr.decapsulateCode(protocols("p2p").code).bytes
          }
        };
      } catch (err) {
        this.log.error("could not dial %p - %e", peerId2, err);
        errorMessage = err.message;
      } finally {
        if (connection2 != null) {
          await connection2.close();
        }
      }
    }
    return {
      type: Message.MessageType.DIAL_RESPONSE,
      dialResponse: {
        status: Message.ResponseStatus.E_DIAL_ERROR,
        statusText: errorMessage,
        addr: lastMultiaddr.bytes
      }
    };
  }
  /**
   * The AutoNAT v1 server is not required to send us the address that it
   * dialed successfully.
   *
   * When addresses fail, it can be because they are NATed, or because the peer
   * did't support the transport, we have no way of knowing, so just send them
   * one address so we can treat the response as:
   *
   * - OK - the dial request worked and the address is not NATed
   * - E_DIAL_ERROR - the dial request failed and the address may be NATed
   * - E_DIAL_REFUSED/E_BAD_REQUEST/E_INTERNAL_ERROR - the remote didn't dial the address
   */
  getFirstUnverifiedMultiaddr(segment, supportsIPv6) {
    const addrs = this.components.addressManager.getAddressesWithMetadata().sort((a, b) => {
      if (a.type === "observed" && b.type !== "observed") {
        return 1;
      }
      if (b.type === "observed" && a.type !== "observed") {
        return -1;
      }
      return 0;
    }).filter((addr) => {
      const expired = addr.expires < Date.now();
      if (!expired) {
        return false;
      }
      const options2 = addr.multiaddr.toOptions();
      if (options2.family === 6) {
        if (!supportsIPv6) {
          return false;
        }
        if (!isGlobalUnicast(addr.multiaddr)) {
          return false;
        }
      }
      if (isPrivate(addr.multiaddr)) {
        return false;
      }
      return true;
    });
    for (const addr of addrs) {
      const addrString = addr.multiaddr.toString();
      let results = this.dialResults.get(addrString);
      if (results != null) {
        if (results.networkSegments.includes(segment)) {
          this.log.trace("%a already has a network segment result from %s", results.multiaddr, segment);
          continue;
        }
        if (results.queue.size > 10) {
          this.log.trace("%a already has enough peers queued", results.multiaddr);
          continue;
        }
      }
      if (results == null) {
        const needsRevalidating = addr.expires < Date.now();
        if (needsRevalidating) {
          this.addressFilter.remove?.(addrString);
        }
        if (this.addressFilter.has(addrString)) {
          continue;
        }
        this.addressFilter.add(addrString);
        this.log.trace("creating dial result %s %s", needsRevalidating ? "to revalidate" : "for", addrString);
        results = {
          multiaddr: addr.multiaddr,
          success: 0,
          failure: 0,
          networkSegments: [],
          verifyingPeers: peerSet(),
          queue: new PeerQueue({
            concurrency: 3,
            maxSize: 50
          }),
          type: addr.type,
          lastVerified: addr.lastVerified
        };
        this.dialResults.set(addrString, results);
      }
      return results;
    }
  }
  /**
   * Removes any multiaddr result objects created for old multiaddrs that we are
   * no longer waiting on
   */
  removeOutdatedMultiaddrResults() {
    const unverifiedMultiaddrs = new Set(this.components.addressManager.getAddressesWithMetadata().filter(({ expires }) => {
      if (expires < Date.now()) {
        return true;
      }
      return false;
    }).map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    for (const multiaddr2 of this.dialResults.keys()) {
      if (!unverifiedMultiaddrs.has(multiaddr2)) {
        this.log.trace("remove results for %a", multiaddr2);
        this.dialResults.delete(multiaddr2);
      }
    }
  }
  /**
   * Our multicodec topology noticed a new peer that supports autonat
   */
  async verifyExternalAddresses(connection) {
    if (!this.isStarted()) {
      return;
    }
    this.removeOutdatedMultiaddrResults();
    const peer = await this.components.peerStore.get(connection.remotePeer);
    const supportsIPv6 = peer.addresses.some(({ multiaddr: multiaddr2 }) => {
      return multiaddr2.toOptions().family === 6;
    });
    const segment = this.getNetworkSegment(connection.remoteAddr);
    const results = this.getFirstUnverifiedMultiaddr(segment, supportsIPv6);
    if (results == null) {
      this.log.trace("no unverified public addresses found for peer %p to verify, not requesting verification", connection.remotePeer);
      return;
    }
    if (!this.hasConnectionCapacity()) {
      if (results.lastVerified != null) {
        this.log("automatically re-verifying %a because we are too close to the connection limit", results.multiaddr);
        this.confirmAddress(results);
      } else {
        this.log("skipping verifying %a because we are too close to the connection limit", results.multiaddr);
      }
      return;
    }
    results.queue.add(async (options2) => {
      await this.askPeerToVerify(connection, segment, options2);
    }, {
      peerId: connection.remotePeer,
      multiaddr: results.multiaddr
    }).catch((err) => {
      if (results?.result == null) {
        this.log.error("error from %p verifying address %a - %e", connection.remotePeer, results?.multiaddr, err);
      }
    });
  }
  async askPeerToVerify(connection, segment, options2) {
    let results = this.dialResults.get(options2.multiaddr.toString());
    if (results == null) {
      this.log("%a was verified while %p was queued", options2.multiaddr, connection.remotePeer);
      return;
    }
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    this.log.trace("asking %p to verify multiaddr %s", connection.remotePeer, options2.multiaddr);
    const stream = await connection.newStream(this.protocol, {
      signal
    });
    try {
      const messages2 = pbStream(stream).pb(Message);
      const [, response] = await Promise.all([
        messages2.write({
          type: Message.MessageType.DIAL,
          dial: {
            peer: {
              id: this.components.peerId.toMultihash().bytes,
              addrs: [options2.multiaddr.bytes]
            }
          }
        }, { signal }),
        messages2.read({ signal })
      ]);
      if (response.type !== Message.MessageType.DIAL_RESPONSE || response.dialResponse == null) {
        this.log("invalid autonat response from %p - %j", connection.remotePeer, response);
        return;
      }
      const status = response.dialResponse.status;
      this.log.trace("autonat response from %p for %a is %s", connection.remotePeer, options2.multiaddr, status);
      if (status !== Message.ResponseStatus.OK && status !== Message.ResponseStatus.E_DIAL_ERROR) {
        return;
      }
      results = this.dialResults.get(options2.multiaddr.toString());
      if (results == null) {
        this.log.trace("peer reported %a as %s but there is no result object", options2.multiaddr, response.dialResponse.status);
        return;
      }
      if (results.networkSegments.includes(segment)) {
        this.log.trace("%a results included network segment %s", options2.multiaddr, segment);
        return;
      }
      if (results.result != null) {
        this.log.trace("already resolved result for %a, ignoring response from", options2.multiaddr, connection.remotePeer);
        return;
      }
      if (results.verifyingPeers.has(connection.remotePeer)) {
        this.log.trace("peer %p has already verified %a, ignoring response", connection.remotePeer, options2.multiaddr);
        return;
      }
      results.verifyingPeers.add(connection.remotePeer);
      results.networkSegments.push(segment);
      if (status === Message.ResponseStatus.OK) {
        results.success++;
        if (results.type !== "observed") {
          this.confirmAddress(results);
          return;
        }
      } else if (status === Message.ResponseStatus.E_DIAL_ERROR) {
        results.failure++;
      }
      this.log("%a success %d failure %d", results.multiaddr, results.success, results.failure);
      if (results.success === REQUIRED_SUCCESSFUL_DIALS) {
        this.confirmAddress(results);
      }
      if (results.failure === REQUIRED_FAILED_DIALS) {
        this.unconfirmAddress(results);
      }
    } finally {
      try {
        await stream.close({
          signal
        });
      } catch (err) {
        stream.abort(err);
      }
    }
  }
  hasConnectionCapacity() {
    const connections = this.components.connectionManager.getConnections();
    const currentConnectionCount = connections.length;
    const maxConnections = this.components.connectionManager.getMaxConnections();
    return currentConnectionCount / maxConnections * 100 < this.connectionThreshold;
  }
  confirmAddress(results) {
    this.log("%s address %a is externally dialable", results.type, results.multiaddr);
    this.components.addressManager.confirmObservedAddr(results.multiaddr);
    this.dialResults.delete(results.multiaddr.toString());
    results.result = true;
    results.queue.abort();
  }
  unconfirmAddress(results) {
    this.log("%s address %a is not externally dialable", results.type, results.multiaddr);
    this.components.addressManager.removeObservedAddr(results.multiaddr);
    this.dialResults.delete(results.multiaddr.toString());
    results.result = false;
    results.queue.abort();
  }
  getNetworkSegment(ma) {
    const options2 = ma.toOptions();
    if (options2.family === 4) {
      const octets2 = options2.host.split(".");
      return octets2[0].padStart(3, "0");
    }
    const octets = options2.host.split(":");
    return octets[0].padStart(4, "0");
  }
};

// node_modules/@libp2p/autonat/dist/src/index.js
function autoNAT(init = {}) {
  return (components) => {
    return new AutoNATService(components, init);
  };
}

// node_modules/@libp2p/bootstrap/dist/src/index.js
var DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
var DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
var DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
var Bootstrap = class extends TypedEventEmitter {
  static tag = "bootstrap";
  log;
  timer;
  list;
  timeout;
  components;
  _init;
  constructor(components, options2 = { list: [] }) {
    if (options2.list == null || options2.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    this.components = components;
    this.log = components.logger.forComponent("libp2p:bootstrap");
    this.timeout = options2.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
    this.list = [];
    for (const candidate of options2.list) {
      if (!P2P.matches(candidate)) {
        this.log.error("Invalid multiaddr");
        continue;
      }
      const ma = multiaddr(candidate);
      const peerIdStr = ma.getPeerId();
      if (peerIdStr == null) {
        this.log.error("Invalid bootstrap multiaddr without peer id");
        continue;
      }
      const peerData = {
        id: peerIdFromString(peerIdStr),
        multiaddrs: [ma]
      };
      this.list.push(peerData);
    }
    this._init = options2;
  }
  [peerDiscoverySymbol] = this;
  [Symbol.toStringTag] = "@libp2p/bootstrap";
  [serviceCapabilities] = [
    "@libp2p/peer-discovery"
  ];
  isStarted() {
    return Boolean(this.timer);
  }
  /**
   * Start emitting events
   */
  start() {
    if (this.isStarted()) {
      return;
    }
    this.log("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
    this.timer = setTimeout(() => {
      void this._discoverBootstrapPeers().catch((err) => {
        this.log.error(err);
      });
    }, this.timeout);
  }
  /**
   * Emit each address in the list as a PeerInfo
   */
  async _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    for (const peerData of this.list) {
      await this.components.peerStore.merge(peerData.id, {
        tags: {
          [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
            value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
            ttl: this._init.tagTTL
          }
        },
        multiaddrs: peerData.multiaddrs
      });
      if (this.timer == null) {
        return;
      }
      this.safeDispatchEvent("peer", { detail: peerData });
      this.components.connectionManager.openConnection(peerData.id).catch((err) => {
        this.log.error("could not dial bootstrap peer %p", peerData.id, err);
      });
    }
  }
  /**
   * Stop emitting events
   */
  stop() {
    if (this.timer != null) {
      clearTimeout(this.timer);
    }
    this.timer = void 0;
  }
};
function bootstrap(init) {
  return (components) => new Bootstrap(components, init);
}

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/bytes.js
var empty14 = new Uint8Array(0);
function equals20(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce14(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/vendor/varint.js
var encode_112 = encode30;
var MSB12 = 128;
var REST12 = 127;
var MSBALL12 = ~REST12;
var INT12 = Math.pow(2, 31);
function encode30(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT12) {
    out[offset++] = num & 255 | MSB12;
    num /= 128;
  }
  while (num & MSBALL12) {
    out[offset++] = num & 255 | MSB12;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode30.bytes = offset - oldOffset + 1;
  return out;
}
var decode48 = read13;
var MSB$112 = 128;
var REST$112 = 127;
function read13(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read13.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$112) << shift : (b & REST$112) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$112);
  read13.bytes = counter - offset;
  return res;
}
var N112 = Math.pow(2, 7);
var N212 = Math.pow(2, 14);
var N312 = Math.pow(2, 21);
var N412 = Math.pow(2, 28);
var N512 = Math.pow(2, 35);
var N612 = Math.pow(2, 42);
var N712 = Math.pow(2, 49);
var N812 = Math.pow(2, 56);
var N912 = Math.pow(2, 63);
var length12 = function(value7) {
  return value7 < N112 ? 1 : value7 < N212 ? 2 : value7 < N312 ? 3 : value7 < N412 ? 4 : value7 < N512 ? 5 : value7 < N612 ? 6 : value7 < N712 ? 7 : value7 < N812 ? 8 : value7 < N912 ? 9 : 10;
};
var varint12 = {
  encode: encode_112,
  decode: decode48,
  encodingLength: length12
};
var _brrp_varint12 = varint12;
var varint_default12 = _brrp_varint12;

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/varint.js
function decode49(data, offset = 0) {
  const code17 = varint_default12.decode(data, offset);
  return [code17, varint_default12.decode.bytes];
}
function encodeTo12(int, target, offset = 0) {
  varint_default12.encode(int, target, offset);
  return target;
}
function encodingLength13(int) {
  return varint_default12.encodingLength(int);
}

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/hashes/digest.js
function create10(code17, digest5) {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength13(code17);
  const digestOffset = sizeOffset + encodingLength13(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo12(code17, bytes, 0);
  encodeTo12(size, bytes, sizeOffset);
  bytes.set(digest5, digestOffset);
  return new Digest12(code17, size, digest5, bytes);
}
function decode50(multihash) {
  const bytes = coerce14(multihash);
  const [code17, sizeOffset] = decode49(bytes);
  const [size, digestOffset] = decode49(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest12(code17, size, digest5, bytes);
}
function equals21(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals20(a.bytes, data.bytes);
  }
}
var Digest12 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/constants.js
var second = 1e3;
var minute = 60 * second;
var CIRCUIT_PROTO_CODE = 290;
var DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute;
var DEFAULT_RESERVATION_CONCURRENCY = 1;
var DEFAULT_RESERVATION_COMPLETION_TIMEOUT = 2e3;
var DEFAULT_MAX_RESERVATION_QUEUE_LENGTH = 100;
var KEEP_ALIVE_TAG = `${KEEP_ALIVE}-circuit-relay`;
var KEEP_ALIVE_SOURCE_TAG = `${KEEP_ALIVE}-circuit-relay-source`;
var DEFAULT_DURATION_LIMIT = 2 * minute;
var DEFAULT_DATA_LIMIT = BigInt(1 << 17);
var RELAY_V2_HOP_CODEC = "/libp2p/circuit/relay/0.2.0/hop";
var RELAY_V2_STOP_CODEC = "/libp2p/circuit/relay/0.2.0/stop";
var DEFAULT_HOP_TIMEOUT = 30 * second;
var DEFAULT_ADVERT_BOOT_DELAY = 30 * second;
var MAX_CONNECTIONS2 = 300;
var DEFAULT_DISCOVERY_FILTER_SIZE = 4096;
var DEFAULT_DISCOVERY_FILTER_ERROR_RATE = 1e-3;

// node_modules/@libp2p/circuit-relay-v2/dist/src/pb/index.js
var HopMessage;
(function(HopMessage2) {
  let Type;
  (function(Type2) {
    Type2["RESERVE"] = "RESERVE";
    Type2["CONNECT"] = "CONNECT";
    Type2["STATUS"] = "STATUS";
  })(Type = HopMessage2.Type || (HopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["RESERVE"] = 0] = "RESERVE";
    __TypeValues2[__TypeValues2["CONNECT"] = 1] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 2] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = HopMessage2.Type || (HopMessage2.Type = {}));
  let _codec;
  HopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          HopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer2.codec().encode(obj.peer, w);
        }
        if (obj.reservation != null) {
          w.uint32(26);
          Reservation.codec().encode(obj.reservation, w);
        }
        if (obj.limit != null) {
          w.uint32(34);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(40);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {};
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = HopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer2.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.peer
              });
              break;
            }
            case 3: {
              obj.reservation = Reservation.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.reservation
              });
              break;
            }
            case 4: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.limit
              });
              break;
            }
            case 5: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HopMessage2.encode = (obj) => {
    return encodeMessage(obj, HopMessage2.codec());
  };
  HopMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, HopMessage2.codec(), opts);
  };
})(HopMessage || (HopMessage = {}));
var StopMessage;
(function(StopMessage2) {
  let Type;
  (function(Type2) {
    Type2["CONNECT"] = "CONNECT";
    Type2["STATUS"] = "STATUS";
  })(Type = StopMessage2.Type || (StopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["CONNECT"] = 0] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 1] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = StopMessage2.Type || (StopMessage2.Type = {}));
  let _codec;
  StopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          StopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer2.codec().encode(obj.peer, w);
        }
        if (obj.limit != null) {
          w.uint32(26);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(32);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {};
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = StopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer2.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.peer
              });
              break;
            }
            case 3: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.limit
              });
              break;
            }
            case 4: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  StopMessage2.encode = (obj) => {
    return encodeMessage(obj, StopMessage2.codec());
  };
  StopMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, StopMessage2.codec(), opts);
  };
})(StopMessage || (StopMessage = {}));
var Peer2;
(function(Peer3) {
  let _codec;
  Peer3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.addrs != null) {
          for (const value7 of obj.addrs) {
            w.uint32(18);
            w.bytes(value7);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          id: alloc(0),
          addrs: []
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.id = reader.bytes();
              break;
            }
            case 2: {
              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer3.encode = (obj) => {
    return encodeMessage(obj, Peer3.codec());
  };
  Peer3.decode = (buf, opts) => {
    return decodeMessage(buf, Peer3.codec(), opts);
  };
})(Peer2 || (Peer2 = {}));
var Reservation;
(function(Reservation2) {
  let _codec;
  Reservation2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.expire != null && obj.expire !== 0n) {
          w.uint32(8);
          w.uint64(obj.expire);
        }
        if (obj.addrs != null) {
          for (const value7 of obj.addrs) {
            w.uint32(18);
            w.bytes(value7);
          }
        }
        if (obj.voucher != null) {
          w.uint32(26);
          Envelope2.codec().encode(obj.voucher, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          expire: 0n,
          addrs: []
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.expire = reader.uint64();
              break;
            }
            case 2: {
              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            case 3: {
              obj.voucher = Envelope2.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.voucher
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Reservation2.encode = (obj) => {
    return encodeMessage(obj, Reservation2.codec());
  };
  Reservation2.decode = (buf, opts) => {
    return decodeMessage(buf, Reservation2.codec(), opts);
  };
})(Reservation || (Reservation = {}));
var Limit;
(function(Limit2) {
  let _codec;
  Limit2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.duration != null) {
          w.uint32(8);
          w.uint32(obj.duration);
        }
        if (obj.data != null) {
          w.uint32(16);
          w.uint64(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {};
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.duration = reader.uint32();
              break;
            }
            case 2: {
              obj.data = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Limit2.encode = (obj) => {
    return encodeMessage(obj, Limit2.codec());
  };
  Limit2.decode = (buf, opts) => {
    return decodeMessage(buf, Limit2.codec(), opts);
  };
})(Limit || (Limit = {}));
var Status;
(function(Status2) {
  Status2["UNUSED"] = "UNUSED";
  Status2["OK"] = "OK";
  Status2["RESERVATION_REFUSED"] = "RESERVATION_REFUSED";
  Status2["RESOURCE_LIMIT_EXCEEDED"] = "RESOURCE_LIMIT_EXCEEDED";
  Status2["PERMISSION_DENIED"] = "PERMISSION_DENIED";
  Status2["CONNECTION_FAILED"] = "CONNECTION_FAILED";
  Status2["NO_RESERVATION"] = "NO_RESERVATION";
  Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  Status2["UNEXPECTED_MESSAGE"] = "UNEXPECTED_MESSAGE";
})(Status || (Status = {}));
var __StatusValues;
(function(__StatusValues2) {
  __StatusValues2[__StatusValues2["UNUSED"] = 0] = "UNUSED";
  __StatusValues2[__StatusValues2["OK"] = 100] = "OK";
  __StatusValues2[__StatusValues2["RESERVATION_REFUSED"] = 200] = "RESERVATION_REFUSED";
  __StatusValues2[__StatusValues2["RESOURCE_LIMIT_EXCEEDED"] = 201] = "RESOURCE_LIMIT_EXCEEDED";
  __StatusValues2[__StatusValues2["PERMISSION_DENIED"] = 202] = "PERMISSION_DENIED";
  __StatusValues2[__StatusValues2["CONNECTION_FAILED"] = 203] = "CONNECTION_FAILED";
  __StatusValues2[__StatusValues2["NO_RESERVATION"] = 204] = "NO_RESERVATION";
  __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  __StatusValues2[__StatusValues2["UNEXPECTED_MESSAGE"] = 401] = "UNEXPECTED_MESSAGE";
})(__StatusValues || (__StatusValues = {}));
(function(Status2) {
  Status2.codec = () => {
    return enumeration(__StatusValues);
  };
})(Status || (Status = {}));
var ReservationVoucher;
(function(ReservationVoucher2) {
  let _codec;
  ReservationVoucher2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.relay != null && obj.relay.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.relay);
        }
        if (obj.peer != null && obj.peer.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.peer);
        }
        if (obj.expiration != null && obj.expiration !== 0n) {
          w.uint32(24);
          w.uint64(obj.expiration);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          relay: alloc(0),
          peer: alloc(0),
          expiration: 0n
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.relay = reader.bytes();
              break;
            }
            case 2: {
              obj.peer = reader.bytes();
              break;
            }
            case 3: {
              obj.expiration = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ReservationVoucher2.encode = (obj) => {
    return encodeMessage(obj, ReservationVoucher2.codec());
  };
  ReservationVoucher2.decode = (buf, opts) => {
    return decodeMessage(buf, ReservationVoucher2.codec(), opts);
  };
})(ReservationVoucher || (ReservationVoucher = {}));
var Envelope2;
(function(Envelope3) {
  let _codec;
  Envelope3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (obj.payload != null) {
          w.uint32(26);
          ReservationVoucher.codec().encode(obj.payload, w);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          publicKey: alloc(0),
          payloadType: alloc(0),
          signature: alloc(0)
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              obj.payloadType = reader.bytes();
              break;
            }
            case 3: {
              obj.payload = ReservationVoucher.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.payload
              });
              break;
            }
            case 5: {
              obj.signature = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope3.encode = (obj) => {
    return encodeMessage(obj, Envelope3.codec());
  };
  Envelope3.decode = (buf, opts) => {
    return decodeMessage(buf, Envelope3.codec(), opts);
  };
})(Envelope2 || (Envelope2 = {}));

// node_modules/@libp2p/circuit-relay-v2/node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
var code10 = (code17) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component == null) {
        return false;
      }
      if (component.code !== code17) {
        return false;
      }
      if (component.value != null) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var value2 = (code17, value7) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component?.code !== code17) {
        return false;
      }
      if (component.value == null) {
        return false;
      }
      if (value7 != null && component.value !== value7) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var optional3 = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    }
  };
};
var or14 = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    }
  };
};
var and3 = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    }
  };
};
function fmt3(...matchers) {
  function match(ma) {
    if (ma == null) {
      return false;
    }
    let parts = ma.getComponents();
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matchers,
    matches,
    exactMatch
  };
}

// node_modules/@libp2p/circuit-relay-v2/node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var _PEER_ID3 = value2(CODE_P2P);
var PEER_ID3 = fmt3(_PEER_ID3);
var _DNS43 = value2(CODE_DNS4);
var _DNS63 = value2(CODE_DNS6);
var _DNSADDR3 = value2(CODE_DNSADDR);
var _DNS3 = value2(CODE_DNS);
var DNS43 = fmt3(_DNS43, optional3(value2(CODE_P2P)));
var DNS63 = fmt3(_DNS63, optional3(value2(CODE_P2P)));
var DNSADDR3 = fmt3(_DNSADDR3, optional3(value2(CODE_P2P)));
var DNS5 = fmt3(or14(_DNS3, _DNSADDR3, _DNS43, _DNS63), optional3(value2(CODE_P2P)));
var _IP43 = and3(value2(CODE_IP4), optional3(value2(CODE_IPCIDR)));
var _IP63 = and3(optional3(value2(CODE_IP6ZONE)), value2(CODE_IP6), optional3(value2(CODE_IPCIDR)));
var _IP3 = or14(_IP43, _IP63);
var _IP_OR_DOMAIN3 = or14(_IP3, _DNS3, _DNS43, _DNS63, _DNSADDR3);
var IP_OR_DOMAIN3 = fmt3(or14(_IP3, and3(or14(_DNS3, _DNSADDR3, _DNS43, _DNS63), optional3(value2(CODE_P2P)))));
var IP43 = fmt3(_IP43);
var IP63 = fmt3(_IP63);
var IP3 = fmt3(_IP3);
var _TCP3 = and3(_IP_OR_DOMAIN3, value2(CODE_TCP));
var _UDP3 = and3(_IP_OR_DOMAIN3, value2(CODE_UDP));
var TCP3 = fmt3(and3(_TCP3, optional3(value2(CODE_P2P))));
var UDP3 = fmt3(_UDP3);
var _QUIC3 = and3(_UDP3, code10(CODE_QUIC), optional3(value2(CODE_P2P)));
var _QUIC_V12 = and3(_UDP3, code10(CODE_QUIC_V1), optional3(value2(CODE_P2P)));
var QUIC_V0_OR_V13 = or14(_QUIC3, _QUIC_V12);
var QUIC3 = fmt3(_QUIC3);
var QUIC_V12 = fmt3(_QUIC_V12);
var _WEB3 = or14(_IP_OR_DOMAIN3, _TCP3, _UDP3, _QUIC3, _QUIC_V12);
var _WebSockets3 = or14(and3(_WEB3, code10(CODE_WS), optional3(value2(CODE_P2P))));
var WebSockets3 = fmt3(_WebSockets3);
var _WebSocketsSecure3 = or14(and3(_WEB3, code10(CODE_WSS), optional3(value2(CODE_P2P))), and3(_WEB3, code10(CODE_TLS), optional3(value2(CODE_SNI)), code10(CODE_WS), optional3(value2(CODE_P2P))));
var WebSocketsSecure3 = fmt3(_WebSocketsSecure3);
var _WebRTCDirect3 = and3(_UDP3, code10(CODE_WEBRTC_DIRECT), optional3(value2(CODE_CERTHASH)), optional3(value2(CODE_CERTHASH)), optional3(value2(CODE_P2P)));
var WebRTCDirect3 = fmt3(_WebRTCDirect3);
var _WebTransport3 = and3(_QUIC_V12, code10(CODE_WEBTRANSPORT), optional3(value2(CODE_CERTHASH)), optional3(value2(CODE_CERTHASH)), optional3(value2(CODE_P2P)));
var WebTransport3 = fmt3(_WebTransport3);
var _P2P3 = or14(_WebSockets3, _WebSocketsSecure3, and3(_TCP3, optional3(value2(CODE_P2P))), and3(QUIC_V0_OR_V13, optional3(value2(CODE_P2P))), and3(_IP_OR_DOMAIN3, optional3(value2(CODE_P2P))), _WebRTCDirect3, _WebTransport3, value2(CODE_P2P));
var P2P4 = fmt3(_P2P3);
var _Circuit3 = and3(_P2P3, code10(CODE_P2P_CIRCUIT), value2(CODE_P2P));
var Circuit3 = fmt3(_Circuit3);
var _WebRTC3 = or14(and3(_P2P3, code10(CODE_P2P_CIRCUIT), code10(CODE_WEBRTC), optional3(value2(CODE_P2P))), and3(_P2P3, code10(CODE_WEBRTC), optional3(value2(CODE_P2P))), and3(code10(CODE_WEBRTC), optional3(value2(CODE_P2P))));
var WebRTC3 = fmt3(_WebRTC3);
var _HTTP3 = or14(and3(_IP_OR_DOMAIN3, value2(CODE_TCP), code10(CODE_HTTP), optional3(value2(CODE_P2P))), and3(_IP_OR_DOMAIN3, code10(CODE_HTTP), optional3(value2(CODE_P2P))));
var HTTP3 = fmt3(_HTTP3);
var _HTTPS3 = and3(_IP_OR_DOMAIN3, or14(and3(value2(CODE_TCP, "443"), code10(CODE_HTTP)), and3(value2(CODE_TCP), code10(CODE_HTTPS)), and3(value2(CODE_TCP), code10(CODE_TLS), code10(CODE_HTTP)), and3(code10(CODE_TLS), code10(CODE_HTTP)), code10(CODE_TLS), code10(CODE_HTTPS)), optional3(value2(CODE_P2P)));
var HTTPS3 = fmt3(_HTTPS3);
var _Memory3 = or14(and3(value2(CODE_MEMORY), optional3(value2(CODE_P2P))));
var Memory3 = fmt3(_Memory3);
var _Unix3 = or14(and3(value2(CODE_UNIX), optional3(value2(CODE_P2P))));
var Unix3 = fmt3(_Unix3);

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/vendor/base-x.js
function base11(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src11 = base11;
var _brrp__multiformats_scope_baseX11 = src11;
var base_x_default12 = _brrp__multiformats_scope_baseX11;

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/bases/base.js
var Encoder12 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder13 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or15(this, decoder);
  }
};
var ComposedDecoder12 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or15(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or15(left, right) {
  return new ComposedDecoder12({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec12 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder12(name9, prefix, baseEncode);
    this.decoder = new Decoder13(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from16({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec12(name9, prefix, encode39, decode61);
}
function baseX11({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default12(alphabet2, name9);
  return from16({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce14(decode61(text))
  });
}
function decode51(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode31(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx11(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc464811({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx11(alphabet2);
  return from16({
    prefix,
    name: name9,
    encode(input) {
      return encode31(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode51(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/bases/base32.js
var base328 = rfc464811({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper8 = rfc464811({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad8 = rfc464811({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper8 = rfc464811({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex8 = rfc464811({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper8 = rfc464811({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad8 = rfc464811({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper8 = rfc464811({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z8 = rfc464811({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/bases/base36.js
var base368 = baseX11({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper8 = baseX11({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/bases/base58.js
var base58btc11 = baseX11({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr11 = baseX11({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/cid.js
function format8(link, base14) {
  const { bytes, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV08(bytes, baseCache8(link), base14 ?? base58btc11.encoder);
    default:
      return toStringV18(bytes, baseCache8(link), base14 ?? base328.encoder);
  }
}
var cache9 = /* @__PURE__ */ new WeakMap();
function baseCache8(cid) {
  const baseCache11 = cache9.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache9.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID8 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code17, multihash, bytes) {
    this.code = code17;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code17, multihash } = this;
        if (code17 !== DAG_PB_CODE8) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE8) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code17, digest: digest5 } = this.multihash;
        const multihash = create10(code17, digest5);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals21(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format8(this, base14);
  }
  toJSON() {
    return { "/": format8(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value7 = input;
    if (value7 instanceof _CID) {
      return value7;
    } else if (value7["/"] != null && value7["/"] === value7.bytes || value7.asCID === value7) {
      const { version: version3, code: code17, multihash, bytes } = value7;
      return new _CID(version3, code17, multihash, bytes ?? encodeCID8(version3, code17, multihash.bytes));
    } else if (value7[cidSymbol8] === true) {
      const { version: version3, multihash, code: code17 } = value7;
      const digest5 = decode50(multihash);
      return _CID.create(version3, code17, digest5);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code17, digest5) {
    if (typeof code17 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code17 !== DAG_PB_CODE8) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE8}) block encoding`);
        } else {
          return new _CID(version3, code17, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID8(version3, code17, digest5.bytes);
        return new _CID(version3, code17, digest5, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE8, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code17, digest5) {
    return _CID.create(1, code17, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce14(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest5 = new Digest12(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest5) : _CID.createV1(specs.codec, digest5);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length16] = decode49(initialBytes.subarray(offset));
      offset += length16;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE8;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes8(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache8(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes8(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc11;
      return [
        base58btc11.prefix,
        decoder.decode(`${base58btc11.prefix}${source}`)
      ];
    }
    case base58btc11.prefix: {
      const decoder = base14 ?? base58btc11;
      return [base58btc11.prefix, decoder.decode(source)];
    }
    case base328.prefix: {
      const decoder = base14 ?? base328;
      return [base328.prefix, decoder.decode(source)];
    }
    case base368.prefix: {
      const decoder = base14 ?? base368;
      return [base368.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV08(bytes, cache12, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc11.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV18(bytes, cache12, base14) {
  const { prefix } = base14;
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE8 = 112;
var SHA_256_CODE8 = 18;
function encodeCID8(version3, code17, multihash) {
  const codeOffset = encodingLength13(version3);
  const hashOffset = codeOffset + encodingLength13(code17);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo12(version3, bytes, 0);
  encodeTo12(code17, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol8 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/hashes/hasher.js
function from17({ name: name9, code: code17, encode: encode39 }) {
  return new Hasher5(name9, code17, encode39);
}
var Hasher5 = class {
  name;
  code;
  encode;
  constructor(name9, code17, encode39) {
    this.name = name9;
    this.code = code17;
    this.encode = encode39;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create10(this.code, result) : result.then((digest5) => create10(this.code, digest5));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/circuit-relay-v2/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha5(name9) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name9, data));
}
var sha2566 = from17({
  name: "sha2-256",
  code: 18,
  encode: sha5("SHA-256")
});
var sha5126 = from17({
  name: "sha2-512",
  code: 19,
  encode: sha5("SHA-512")
});

// node_modules/@libp2p/circuit-relay-v2/dist/src/errors.js
var HadEnoughRelaysError = class extends Error {
  static name = "HadEnoughRelaysError";
  name = "HadEnoughRelaysError";
};
var DoubleRelayError = class extends Error {
  static name = "DoubleRelayError";
  name = "DoubleRelayError";
};
var RelayQueueFullError = class extends Error {
  static name = "RelayQueueFullError";
  name = "RelayQueueFullError";
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/utils.js
function getExpirationMilliseconds(expireTimeSeconds) {
  const expireTimeMillis = expireTimeSeconds * BigInt(1e3);
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  return Number(expireTimeMillis - BigInt(currentTime));
}
var LimitTracker = class {
  expires;
  bytes;
  constructor(limits) {
    if (limits?.duration != null && limits?.duration !== 0) {
      this.expires = Date.now() + limits.duration * 1e3;
    }
    this.bytes = limits?.data;
    if (this.bytes === 0n) {
      this.bytes = void 0;
    }
    this.onData = this.onData.bind(this);
  }
  onData(buf) {
    if (this.bytes == null) {
      return;
    }
    this.bytes -= BigInt(buf.byteLength);
    if (this.bytes < 0n) {
      this.bytes = 0n;
    }
  }
  getLimits() {
    if (this.expires == null && this.bytes == null) {
      return;
    }
    const output = {};
    if (this.bytes != null) {
      const self2 = this;
      Object.defineProperty(output, "bytes", {
        get() {
          return self2.bytes;
        }
      });
    }
    if (this.expires != null) {
      const self2 = this;
      Object.defineProperty(output, "seconds", {
        get() {
          return Math.round(((self2.expires ?? 0) - Date.now()) / 1e3);
        }
      });
    }
    return output;
  }
};
var CircuitListen = fmt3(and3(P2P4.matchers[0], code10(CODE_P2P_CIRCUIT)));
var CircuitSearch = fmt3(code10(CODE_P2P_CIRCUIT));

// node_modules/@libp2p/utils/dist/src/stream-to-ma-conn.js
function streamToMaConnection(props) {
  const { stream, remoteAddr, logger: logger2, onDataRead, onDataWrite } = props;
  const log5 = logger2.forComponent("libp2p:stream:converter");
  let closedRead = false;
  let closedWrite = false;
  const streamClose = stream.close.bind(stream);
  stream.close = async (options2) => {
    await streamClose(options2);
    close(true);
  };
  const streamAbort = stream.abort.bind(stream);
  stream.abort = (err) => {
    streamAbort(err);
    close(true);
  };
  const streamSink = stream.sink.bind(stream);
  stream.sink = async (source) => {
    try {
      await streamSink(pipe(source, (source2) => src_default9(source2, (buf) => onDataWrite?.(buf))));
    } catch (err) {
      if (err.type !== "aborted") {
        log5.error("%s error in sink", remoteAddr, err);
      }
    } finally {
      closedWrite = true;
      close();
    }
  };
  const maConn = {
    log: log5,
    sink: stream.sink,
    source: async function* () {
      try {
        for await (const buf of stream.source) {
          onDataRead?.(buf);
          yield buf;
        }
      } finally {
        closedRead = true;
        close();
      }
    }(),
    remoteAddr,
    timeline: { open: Date.now(), close: void 0 },
    close: stream.close,
    abort: stream.abort
  };
  function close(force) {
    if (force === true) {
      closedRead = true;
      closedWrite = true;
    }
    if (closedRead && closedWrite && maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }
  return maConn;
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/discovery.js
var RelayDiscovery = class extends TypedEventEmitter {
  components;
  started;
  running;
  topologyId;
  log;
  discoveryController;
  filter;
  queue;
  constructor(components, init = {}) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:discover-relays");
    this.components = components;
    this.started = false;
    this.running = false;
    this.filter = init.filter;
    this.discoveryController = new AbortController();
    setMaxListeners(Infinity, this.discoveryController.signal);
    this.dialPeer = this.dialPeer.bind(this);
    this.onPeer = this.onPeer.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.topologyId = await this.components.registrar.register(RELAY_V2_HOP_CODEC, {
      filter: this.filter,
      onConnect: (peerId2) => {
        this.log.trace("discovered relay %p queue (length: %d, active %d)", peerId2, this.queue?.size, this.queue?.running);
        this.safeDispatchEvent("relay:discover", { detail: peerId2 });
      }
    });
    this.started = true;
  }
  stop() {
    if (this.topologyId != null) {
      this.components.registrar.unregister(this.topologyId);
    }
    if (this.running) {
      this.stopDiscovery();
    }
    this.started = false;
  }
  /**
   * Try to listen on available hop relay connections.
   * The following order will happen while we do not have enough relays:
   *
   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected to
   * 2. Dial and try to listen on the peers we know that support hop but are not connected
   * 3. Search the network - this requires a peer routing implementation to be configured but will fail gracefully
   * 4. Dial any peers discovered - this covers when no peer routing implementation has been configured but some peer discovery mechanism is also present
   */
  startDiscovery() {
    if (this.running) {
      return;
    }
    this.log("start discovery");
    this.running = true;
    this.discoveryController = new AbortController();
    setMaxListeners(Infinity, this.discoveryController.signal);
    this.components.events.addEventListener("peer:discovery", this.onPeer);
    Promise.resolve().then(async () => {
      this.log("searching peer store for relays");
      const peers = await this.components.peerStore.all({
        filters: [
          // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on
          (peer) => {
            return peer.protocols.includes(RELAY_V2_HOP_CODEC);
          }
        ],
        orders: [
          // randomize
          () => Math.random() < 0.5 ? 1 : -1,
          // prefer peers we've connected to in the past
          (a, b) => {
            const lastDialA = getLastDial(a);
            const lastDialB = getLastDial(b);
            if (lastDialA > lastDialB) {
              return -1;
            }
            if (lastDialB > lastDialA) {
              return 1;
            }
            return 0;
          }
        ]
      });
      for (const peer of peers) {
        this.log.trace("found relay peer %p in peer store", peer.id);
        this.safeDispatchEvent("relay:discover", { detail: peer.id });
      }
      this.log("found %d relay peers in peer store", peers.length);
      const queue = this.queue = new PeerQueue({
        concurrency: 5
      });
      this.log("start random walk");
      for await (const peer of this.components.randomWalk.walk({ signal: this.discoveryController.signal })) {
        this.log.trace("found random peer %p", peer.id);
        if (queue.has(peer.id)) {
          this.log.trace("random peer %p was already in queue", peer.id);
          continue;
        }
        if (this.components.connectionManager.getConnections(peer.id)?.length > 0) {
          this.log.trace("random peer %p was already connected", peer.id);
          continue;
        }
        if (!await this.components.connectionManager.isDialable(peer.multiaddrs)) {
          this.log.trace("random peer %p was not dialable", peer.id, peer.multiaddrs.map((ma) => ma.toString()));
          continue;
        }
        if (queue.queued > 10) {
          this.log.trace("wait for space in queue for %p", peer.id);
          await queue.onSizeLessThan(10, {
            signal: this.discoveryController.signal
          });
        }
        this.log("adding random peer %p to dial queue (length: %d, active %d)", peer.id, queue.size, queue.running);
        queue.add(this.dialPeer, {
          peerId: peer.id,
          signal: this.discoveryController.signal
        }).catch((err) => {
          this.log.error("error opening connection to random peer %p", peer.id, err);
        });
      }
      this.log("stop random walk");
      await queue.onIdle();
    }).catch((err) => {
      if (!this.discoveryController.signal.aborted) {
        this.log.error("failed when finding relays on the network", err);
      }
    });
  }
  stopDiscovery() {
    this.log("stop discovery");
    this.running = false;
    this.discoveryController?.abort();
    this.queue?.clear();
    this.components.events.removeEventListener("peer:discovery", this.onPeer);
  }
  onPeer(evt) {
    this.log.trace("maybe dialing discovered peer %p - %e", evt.detail.id);
    this.maybeDialPeer(evt).catch((err) => {
      this.log.trace("error dialing discovered peer %p - %e", evt.detail.id, err);
    });
  }
  async maybeDialPeer(evt) {
    if (this.queue == null) {
      return;
    }
    const peerId2 = evt.detail.id;
    const multiaddrs = evt.detail.multiaddrs;
    if (this.queue.has(peerId2)) {
      this.log.trace("random peer %p was already in queue", peerId2);
      return;
    }
    if (this.components.connectionManager.getConnections(peerId2)?.length > 0) {
      this.log.trace("random peer %p was already connected", peerId2);
      return;
    }
    if (!await this.components.connectionManager.isDialable(multiaddrs)) {
      this.log.trace("random peer %p was not dialable", peerId2);
      return;
    }
    this.queue?.add(this.dialPeer, {
      peerId: evt.detail.id,
      signal: this.discoveryController.signal
    }).catch((err) => {
      this.log.error("error opening connection to discovered peer %p", evt.detail.id, err);
    });
  }
  async dialPeer({ peerId: peerId2, signal }) {
    const combinedSignal = anySignal([AbortSignal.timeout(5e3), signal]);
    setMaxListeners(Infinity, combinedSignal);
    try {
      await this.components.connectionManager.openConnection(peerId2, {
        signal: combinedSignal
      });
    } finally {
      combinedSignal.clear();
    }
  }
};
function getLastDial(peer) {
  const lastDial = peer.metadata.get("last-dial-success");
  if (lastDial == null) {
    return 0;
  }
  return new Date(toString(lastDial)).getTime();
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/listener.js
var CircuitRelayTransportListener = class extends TypedEventEmitter {
  connectionManager;
  addressManager;
  reservationStore;
  listeningAddrs;
  log;
  listenTimeout;
  reservationId;
  relay;
  constructor(components, init = {}) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:listener");
    this.connectionManager = components.connectionManager;
    this.addressManager = components.addressManager;
    this.reservationStore = components.reservationStore;
    this.listeningAddrs = [];
    this.listenTimeout = init.listenTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
    this.reservationStore.addEventListener("relay:removed", this._onRemoveRelayPeer);
    this.reservationStore.addEventListener("relay:created-reservation", this._onAddRelayPeer);
  }
  _onRemoveRelayPeer = (evt) => {
    this.log("relay removed %p our relay %p", evt.detail.relay, this.relay, this.relay?.equals(evt.detail.relay));
    if (this.relay?.equals(evt.detail.relay) !== true) {
      return;
    }
    this.log("relay peer removed %p", evt.detail.relay);
    this.listeningAddrs.forEach((ma) => {
      this.addressManager.removeObservedAddr(ma);
    });
    this.listeningAddrs = [];
    this.safeDispatchEvent("listening");
  };
  _onAddRelayPeer = (evt) => {
    const { details } = evt.detail;
    if (details.type === "configured") {
      return;
    }
    if (details.id !== this.reservationId) {
      return;
    }
    this.addedRelay(evt.detail);
  };
  async listen(addr) {
    if (CircuitSearch.exactMatch(addr)) {
      this.log("searching for circuit relay servers");
      this.reservationId = this.reservationStore.reserveRelay();
    } else if (CircuitListen.exactMatch(addr)) {
      this.log("listen on specific relay server %a", addr);
      const signal = AbortSignal.timeout(this.listenTimeout);
      setMaxListeners(Infinity, signal);
      const relayAddr = addr.decapsulate("/p2p-circuit");
      const relayConn = await this.connectionManager.openConnection(relayAddr, {
        signal
      });
      if (!this.reservationStore.hasReservation(relayConn.remotePeer)) {
        this.log("making reservation on peer %p", relayConn.remotePeer);
        const reservation = await this.reservationStore.addRelay(relayConn.remotePeer, "configured");
        this.addedRelay(reservation);
      }
    } else {
      throw new ListenError(`Could not listen on p2p-circuit address "${addr}"`);
    }
  }
  getAddrs() {
    return [...this.listeningAddrs.values()].flat();
  }
  updateAnnounceAddrs() {
  }
  async close() {
    this.reservationStore.cancelReservations();
    this.listeningAddrs = [];
    this.reservationStore.removeEventListener("relay:removed", this._onRemoveRelayPeer);
    queueMicrotask(() => {
      this.safeDispatchEvent("close");
    });
  }
  addedRelay(reservation) {
    this.log("relay peer added %p", reservation.relay);
    this.relay = reservation.relay;
    this.listeningAddrs = reservation.details.reservation.addrs.map((buf) => multiaddr(buf).encapsulate("/p2p-circuit"));
    this.listeningAddrs.forEach((ma) => {
      this.addressManager.confirmObservedAddr(ma, {
        type: "transport"
      });
    });
    queueMicrotask(() => {
      this.safeDispatchEvent("listening");
    });
  }
};
function createListener(options2) {
  return new CircuitRelayTransportListener(options2);
}

// node_modules/@libp2p/circuit-relay-v2/node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/@libp2p/circuit-relay-v2/node_modules/nanoid/index.browser.js
var nanoid2 = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/reservation-store.js
var REFRESH_WINDOW = 60 * 1e3 * 10;
var REFRESH_TIMEOUT = 60 * 1e3 * 5;
var REFRESH_TIMEOUT_MIN = 30 * 1e3;
var ReservationStore2 = class extends TypedEventEmitter {
  peerId;
  connectionManager;
  peerStore;
  events;
  reserveQueue;
  reservations;
  pendingReservations;
  maxReservationQueueLength;
  reservationCompletionTimeout;
  started;
  log;
  relayFilter;
  constructor(components, init) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:reservation-store");
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.reservations = new PeerMap();
    this.pendingReservations = [];
    this.maxReservationQueueLength = init?.maxReservationQueueLength ?? DEFAULT_MAX_RESERVATION_QUEUE_LENGTH;
    this.reservationCompletionTimeout = init?.reservationCompletionTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
    this.started = false;
    this.relayFilter = createScalableCuckooFilter(100);
    this.reserveQueue = new PeerQueue({
      concurrency: init?.reservationConcurrency ?? DEFAULT_RESERVATION_CONCURRENCY,
      metricName: "libp2p_relay_reservation_queue",
      metrics: components.metrics
    });
    this.events.addEventListener("connection:close", (evt) => {
      const reservation = [...this.reservations.values()].find((reservation2) => reservation2.connection === evt.detail.id);
      if (reservation == null) {
        return;
      }
      this.#removeReservation(evt.detail.remotePeer).catch((err) => {
        this.log("could not remove relay %p - %e", evt.detail, err);
      });
    });
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  afterStart() {
    void Promise.resolve().then(async () => {
      const relayPeers = await this.peerStore.all({
        filters: [(peer) => {
          return peer.tags.has(KEEP_ALIVE_TAG);
        }]
      });
      this.log("removing tag from %d old relays", relayPeers.length);
      await Promise.all(relayPeers.map(async (peer) => {
        await this.peerStore.merge(peer.id, {
          tags: {
            [KEEP_ALIVE_TAG]: void 0
          }
        });
      }));
      this.log("redialing %d old relays", relayPeers.length);
      await Promise.all(relayPeers.map(async (peer) => this.addRelay(peer.id, "discovered")));
      this.#checkReservationCount();
    }).catch((err) => {
      this.log.error(err);
    });
  }
  stop() {
    this.reserveQueue.clear();
    this.reservations.forEach(({ timeout }) => {
      clearTimeout(timeout);
    });
    this.reservations.clear();
    this.started = false;
  }
  reserveRelay() {
    const id = nanoid2();
    this.pendingReservations.push(id);
    this.#checkReservationCount();
    return id;
  }
  /**
   * If the number of current relays is beneath the configured `maxReservations`
   * value, and the passed peer id is not our own, and we have a non-relayed
   * connection to the remote, and the remote peer speaks the hop protocol, try
   * to reserve a slot on the remote peer
   */
  async addRelay(peerId2, type) {
    if (this.peerId.equals(peerId2)) {
      this.log.trace("not trying to use self as relay");
      throw new ListenError("Cannot use self as relay");
    }
    if (this.reserveQueue.size > this.maxReservationQueueLength) {
      throw new RelayQueueFullError("The reservation queue is full");
    }
    const existingJob = this.reserveQueue.find(peerId2);
    if (existingJob != null) {
      this.log.trace("potential relay peer %p is already in the reservation queue", peerId2);
      return existingJob.join();
    }
    if (this.relayFilter.has(peerId2.toMultihash().bytes)) {
      throw new ListenError("The relay was previously invalid");
    }
    this.log.trace("try to reserve relay slot with %p", peerId2);
    return this.reserveQueue.add(async () => {
      const start2 = Date.now();
      try {
        const existingReservation = this.reservations.get(peerId2);
        if (existingReservation != null) {
          const connections = this.connectionManager.getConnections(peerId2);
          let connected = false;
          if (connections.length === 0) {
            this.log("already have relay reservation with %p but we are no longer connected", peerId2);
          }
          if (connections.map((conn) => conn.id).includes(existingReservation.connection)) {
            this.log("already have relay reservation with %p and the original connection is still open", peerId2);
            connected = true;
          }
          if (connected && getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {
            this.log("already have relay reservation with %p but we are still connected and it does not expire soon", peerId2);
            return {
              relay: peerId2,
              details: existingReservation
            };
          }
          await this.#removeReservation(peerId2);
        }
        if (type === "discovered" && this.pendingReservations.length === 0) {
          throw new HadEnoughRelaysError("Not making reservation on discovered relay because we do not need any more relays");
        }
        const signal = AbortSignal.timeout(this.reservationCompletionTimeout);
        setMaxListeners(Infinity, signal);
        const connection = await this.connectionManager.openConnection(peerId2, {
          signal
        });
        if (Circuit3.matches(connection.remoteAddr)) {
          throw new DoubleRelayError("not creating reservation over relayed connection");
        }
        const reservation = await this.#createReservation(connection, {
          signal
        });
        const expiration = getExpirationMilliseconds(reservation.expire);
        this.log("created reservation on relay peer %p, expiry date is %s", peerId2, new Date(Date.now() + expiration).toString());
        const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1);
        const timeout = setTimeout(() => {
          this.log("refresh reservation to relay %p", peerId2);
          this.addRelay(peerId2, type).catch(async (err) => {
            this.log.error("could not refresh reservation to relay %p - %e", peerId2, err);
            await this.#removeReservation(peerId2);
          }).catch((err) => {
            this.log.error("could not remove expired reservation to relay %p - %e", peerId2, err);
          });
        }, timeoutDuration);
        let res;
        if (type === "discovered") {
          const id = this.pendingReservations.pop();
          if (id == null) {
            throw new HadEnoughRelaysError("Made reservation on relay but did not need any more discovered relays");
          }
          res = {
            timeout,
            reservation,
            type,
            connection: connection.id,
            id
          };
        } else {
          res = {
            timeout,
            reservation,
            type,
            connection: connection.id
          };
        }
        this.reservations.set(peerId2, res);
        await this.peerStore.merge(peerId2, {
          tags: {
            [KEEP_ALIVE_TAG]: {
              value: 1,
              ttl: expiration
            }
          }
        });
        this.#checkReservationCount();
        const result = {
          relay: peerId2,
          details: res
        };
        this.safeDispatchEvent("relay:created-reservation", {
          detail: result
        });
        return result;
      } catch (err) {
        if (!(type === "discovered" && err.name === "HadEnoughRelaysError")) {
          this.log.error("could not reserve slot on %p after %dms - %e", peerId2, Date.now() - start2, err);
        }
        if (err.name === "DialError" || err.name === "UnsupportedProtocolError") {
          this.relayFilter.add(peerId2.toMultihash().bytes);
        }
        this.#removeReservation(peerId2).catch((err2) => {
          this.log.error("could not remove reservation on %p after reserving slot failed - %e", peerId2, err2);
        });
        throw err;
      }
    }, {
      peerId: peerId2
    });
  }
  hasReservation(peerId2) {
    return this.reservations.has(peerId2);
  }
  getReservation(peerId2) {
    return this.reservations.get(peerId2)?.reservation;
  }
  reservationCount(type) {
    if (type == null) {
      return this.reservations.size;
    }
    return [...this.reservations.values()].reduce((acc, curr) => {
      if (curr.type === type) {
        acc++;
      }
      return acc;
    }, 0);
  }
  cancelReservations() {
    [...this.reservations.values()].forEach((reservation) => {
      clearTimeout(reservation.timeout);
    });
    this.reservations.clear();
  }
  async #createReservation(connection, options2) {
    options2.signal?.throwIfAborted();
    this.log("requesting reservation from %p", connection.remotePeer);
    const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options2);
    const pbstr = pbStream(stream);
    const hopstr = pbstr.pb(HopMessage);
    this.log.trace("send RESERVE to %p", connection.remotePeer);
    await hopstr.write({ type: HopMessage.Type.RESERVE }, options2);
    let response;
    try {
      this.log.trace("reading response from %p", connection.remotePeer);
      response = await hopstr.read(options2);
    } catch (err) {
      stream.abort(err);
      throw err;
    } finally {
      if (stream.status !== "closed") {
        await stream.close(options2);
      }
    }
    this.log.trace("read response %o", response);
    if (response.status === Status.OK && response.reservation != null) {
      const addresses = /* @__PURE__ */ new Set();
      addresses.add(connection.remoteAddr.toString());
      for (const buf of response.reservation.addrs) {
        let ma = multiaddr(buf);
        if (ma.getPeerId() == null) {
          ma = ma.encapsulate(`/p2p/${connection.remotePeer}`);
        }
        ma = multiaddr(ma.toString().replace(`/p2p/${connection.remotePeer}/p2p/${connection.remotePeer}`, `/p2p/${connection.remotePeer}`));
        addresses.add(ma.toString());
      }
      response.reservation.addrs = [...addresses].map((str) => multiaddr(str).bytes);
      return response.reservation;
    }
    const errMsg = `reservation failed with status ${response.status ?? "undefined"}`;
    this.log.error(errMsg);
    throw new Error(errMsg);
  }
  /**
   * Remove listen relay
   */
  async #removeReservation(peerId2) {
    const reservation = this.reservations.get(peerId2);
    if (reservation == null) {
      return;
    }
    this.log("removing relay reservation with %p from local store", peerId2);
    clearTimeout(reservation.timeout);
    this.reservations.delete(peerId2);
    if (reservation.type === "discovered") {
      this.pendingReservations.push(reservation.id);
    }
    await this.peerStore.merge(peerId2, {
      tags: {
        [KEEP_ALIVE_TAG]: void 0
      }
    });
    this.safeDispatchEvent("relay:removed", {
      detail: {
        relay: peerId2,
        details: reservation
      }
    });
    this.#checkReservationCount();
  }
  #checkReservationCount() {
    if (this.pendingReservations.length === 0) {
      this.log.trace("have discovered enough relays");
      this.reserveQueue.clear();
      this.safeDispatchEvent("relay:found-enough-relays");
      return;
    }
    this.relayFilter = createScalableCuckooFilter(100);
    this.log("not discovered enough relays %d/%d", this.reservations.size, this.pendingReservations.length);
    this.safeDispatchEvent("relay:not-enough-relays");
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/transport.js
var isValidStop = (request) => {
  if (request.peer == null) {
    return false;
  }
  try {
    request.peer.addrs.forEach(multiaddr);
  } catch {
    return false;
  }
  return true;
};
var defaults = {
  maxInboundStopStreams: MAX_CONNECTIONS2,
  maxOutboundStopStreams: MAX_CONNECTIONS2,
  stopTimeout: 3e4
};
var CircuitRelayTransport = class {
  discovery;
  registrar;
  peerStore;
  connectionManager;
  transportManager;
  peerId;
  upgrader;
  addressManager;
  connectionGater;
  reservationStore;
  logger;
  maxInboundStopStreams;
  maxOutboundStopStreams;
  started;
  log;
  shutdownController;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport");
    this.registrar = components.registrar;
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.logger = components.logger;
    this.peerId = components.peerId;
    this.upgrader = components.upgrader;
    this.addressManager = components.addressManager;
    this.connectionGater = components.connectionGater;
    this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults.maxInboundStopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;
    this.shutdownController = new AbortController();
    this.discovery = new RelayDiscovery(components, {
      filter: init.discoveryFilter ?? peerFilter(DEFAULT_DISCOVERY_FILTER_SIZE, DEFAULT_DISCOVERY_FILTER_ERROR_RATE)
    });
    this.discovery.addEventListener("relay:discover", (evt) => {
      this.reservationStore.addRelay(evt.detail, "discovered").catch((err) => {
        if (err.name !== "HadEnoughRelaysError" && err.name !== "RelayQueueFullError") {
          this.log.error("could not add discovered relay %p", evt.detail, err);
        }
      });
    });
    this.reservationStore = new ReservationStore2(components, init);
    this.reservationStore.addEventListener("relay:not-enough-relays", () => {
      this.discovery?.startDiscovery();
    });
    this.reservationStore.addEventListener("relay:found-enough-relays", () => {
      this.discovery?.stopDiscovery();
    });
    this.started = false;
  }
  [Symbol.toStringTag] = "@libp2p/circuit-relay-v2-transport";
  [serviceCapabilities] = [
    "@libp2p/transport",
    "@libp2p/circuit-relay-v2-transport"
  ];
  get [serviceDependencies]() {
    if (this.discovery != null) {
      return [
        "@libp2p/identify"
      ];
    }
    return [];
  }
  [transportSymbol] = true;
  isStarted() {
    return this.started;
  }
  async start() {
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    await this.registrar.handle(RELAY_V2_STOP_CODEC, (data) => {
      const signal = this.upgrader.createInboundAbortSignal(this.shutdownController.signal);
      void this.onStop(data, signal).catch((err) => {
        this.log.error("error while handling STOP protocol", err);
        data.stream.abort(err);
      }).finally(() => {
        signal.clear();
      });
    }, {
      maxInboundStreams: this.maxInboundStopStreams,
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnLimitedConnection: true
    });
    await start(this.discovery, this.reservationStore);
    this.started = true;
  }
  async stop() {
    this.shutdownController.abort();
    await stop(this.discovery, this.reservationStore);
    await this.registrar.unhandle(RELAY_V2_STOP_CODEC);
    this.started = false;
  }
  /**
   * Dial a peer over a relay
   */
  async dial(ma, options2) {
    if (ma.protoCodes().filter((code17) => code17 === CIRCUIT_PROTO_CODE).length !== 1) {
      const errMsg = "Invalid circuit relay address";
      this.log.error(errMsg, ma);
      throw new DialError(errMsg);
    }
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getPeerId();
    const destinationId = destinationAddr.getPeerId();
    if (relayId == null || destinationId == null) {
      const errMsg = `ircuit relay dial to ${ma.toString()} failed as address did not have both relay and destination PeerIDs`;
      this.log.error(`c${errMsg}`);
      throw new DialError(`C${errMsg}`);
    }
    const relayPeer = peerIdFromString(relayId);
    const destinationPeer = peerIdFromString(destinationId);
    const relayConnections = this.connectionManager.getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.peerStore.merge(relayPeer, {
        multiaddrs: [relayAddr]
      });
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:open-connection"));
      relayConnection = await this.connectionManager.openConnection(relayPeer, options2);
    } else {
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:reuse-connection"));
    }
    let stream;
    try {
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:open-hop-stream"));
      stream = await relayConnection.newStream(RELAY_V2_HOP_CODEC, options2);
      const pbstr = pbStream(stream);
      const hopstr = pbstr.pb(HopMessage);
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:write-connect-message"));
      await hopstr.write({
        type: HopMessage.Type.CONNECT,
        peer: {
          id: destinationPeer.toMultihash().bytes,
          addrs: [multiaddr(destinationAddr).bytes]
        }
      }, options2);
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:read-connect-response"));
      const status = await hopstr.read(options2);
      if (status.status !== Status.OK) {
        throw new InvalidMessageError(`failed to connect via relay with status ${status?.status?.toString() ?? "undefined"}`);
      }
      const limits = new LimitTracker(status.limit);
      const maConn = streamToMaConnection({
        stream: pbstr.unwrap(),
        remoteAddr: ma,
        localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),
        logger: this.logger,
        onDataRead: limits.onData,
        onDataWrite: limits.onData
      });
      this.log("new outbound relayed connection %a", maConn.remoteAddr);
      return await this.upgrader.upgradeOutbound(maConn, {
        ...options2,
        limits: limits.getLimits()
      });
    } catch (err) {
      this.log.error("circuit relay dial to destination %p via relay %p failed", destinationPeer, relayPeer, err);
      stream?.abort(err);
      throw err;
    }
  }
  /**
   * Create a listener
   */
  createListener(options2) {
    return createListener({
      peerId: this.peerId,
      connectionManager: this.connectionManager,
      addressManager: this.addressManager,
      reservationStore: this.reservationStore,
      logger: this.logger
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return CircuitListen.exactMatch(ma) || CircuitSearch.exactMatch(ma);
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit3.exactMatch(ma);
    });
  }
  /**
   * An incoming STOP request means a remote peer wants to dial us via a relay
   */
  async onStop({ connection, stream }, signal) {
    if (!this.reservationStore.hasReservation(connection.remotePeer)) {
      try {
        this.log("dialed via relay we did not have a reservation on, start listening on that relay address");
        await this.transportManager.listen([connection.remoteAddr.encapsulate("/p2p-circuit")]);
      } catch (err) {
        this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on", err);
      }
    }
    const pbstr = pbStream(stream).pb(StopMessage);
    const request = await pbstr.read({
      signal
    });
    this.log("new circuit relay v2 stop stream from %p with type %s", connection.remotePeer, request.type);
    if (request?.type === void 0) {
      this.log.error("type was missing from circuit v2 stop protocol request from %s", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    if (request.type !== StopMessage.Type.CONNECT) {
      this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    if (!isValidStop(request)) {
      this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
        signal
      });
      await stream.close({
        signal
      });
      return;
    }
    const remotePeerId = peerIdFromMultihash(decode50(request.peer.id));
    if (await this.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId) === true) {
      this.log.error("connection gater denied inbound relayed connection from %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {
        signal
      });
      await stream.close({
        signal
      });
      return;
    }
    this.log.trace("sending success response to %p", connection.remotePeer);
    await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {
      signal
    });
    const limits = new LimitTracker(request.limit);
    const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`);
    const localAddr = this.addressManager.getAddresses()[0];
    const maConn = streamToMaConnection({
      stream: pbstr.unwrap().unwrap(),
      remoteAddr,
      localAddr,
      logger: this.logger,
      onDataRead: limits.onData,
      onDataWrite: limits.onData
    });
    this.log("new inbound relayed connection %a", maConn.remoteAddr);
    await this.upgrader.upgradeInbound(maConn, {
      limits: limits.getLimits(),
      signal
    });
    this.log("%s connection %a upgraded", "inbound", maConn.remoteAddr);
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/index.js
function circuitRelayTransport(init = {}) {
  return (components) => {
    return new CircuitRelayTransport(components, init);
  };
}

// node_modules/@libp2p/dcutr/node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
var code11 = (code17) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component == null) {
        return false;
      }
      if (component.code !== code17) {
        return false;
      }
      if (component.value != null) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var value3 = (code17, value7) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component?.code !== code17) {
        return false;
      }
      if (component.value == null) {
        return false;
      }
      if (value7 != null && component.value !== value7) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var optional4 = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    }
  };
};
var or16 = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    }
  };
};
var and4 = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    }
  };
};
function fmt4(...matchers) {
  function match(ma) {
    if (ma == null) {
      return false;
    }
    let parts = ma.getComponents();
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matchers,
    matches,
    exactMatch
  };
}

// node_modules/@libp2p/dcutr/node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var _PEER_ID4 = value3(CODE_P2P);
var PEER_ID4 = fmt4(_PEER_ID4);
var _DNS44 = value3(CODE_DNS4);
var _DNS64 = value3(CODE_DNS6);
var _DNSADDR4 = value3(CODE_DNSADDR);
var _DNS5 = value3(CODE_DNS);
var DNS44 = fmt4(_DNS44, optional4(value3(CODE_P2P)));
var DNS64 = fmt4(_DNS64, optional4(value3(CODE_P2P)));
var DNSADDR4 = fmt4(_DNSADDR4, optional4(value3(CODE_P2P)));
var DNS7 = fmt4(or16(_DNS5, _DNSADDR4, _DNS44, _DNS64), optional4(value3(CODE_P2P)));
var _IP44 = and4(value3(CODE_IP4), optional4(value3(CODE_IPCIDR)));
var _IP64 = and4(optional4(value3(CODE_IP6ZONE)), value3(CODE_IP6), optional4(value3(CODE_IPCIDR)));
var _IP5 = or16(_IP44, _IP64);
var _IP_OR_DOMAIN4 = or16(_IP5, _DNS5, _DNS44, _DNS64, _DNSADDR4);
var IP_OR_DOMAIN4 = fmt4(or16(_IP5, and4(or16(_DNS5, _DNSADDR4, _DNS44, _DNS64), optional4(value3(CODE_P2P)))));
var IP44 = fmt4(_IP44);
var IP64 = fmt4(_IP64);
var IP5 = fmt4(_IP5);
var _TCP4 = and4(_IP_OR_DOMAIN4, value3(CODE_TCP));
var _UDP4 = and4(_IP_OR_DOMAIN4, value3(CODE_UDP));
var TCP4 = fmt4(and4(_TCP4, optional4(value3(CODE_P2P))));
var UDP4 = fmt4(_UDP4);
var _QUIC4 = and4(_UDP4, code11(CODE_QUIC), optional4(value3(CODE_P2P)));
var _QUIC_V13 = and4(_UDP4, code11(CODE_QUIC_V1), optional4(value3(CODE_P2P)));
var QUIC_V0_OR_V14 = or16(_QUIC4, _QUIC_V13);
var QUIC4 = fmt4(_QUIC4);
var QUIC_V13 = fmt4(_QUIC_V13);
var _WEB4 = or16(_IP_OR_DOMAIN4, _TCP4, _UDP4, _QUIC4, _QUIC_V13);
var _WebSockets4 = or16(and4(_WEB4, code11(CODE_WS), optional4(value3(CODE_P2P))));
var WebSockets4 = fmt4(_WebSockets4);
var _WebSocketsSecure4 = or16(and4(_WEB4, code11(CODE_WSS), optional4(value3(CODE_P2P))), and4(_WEB4, code11(CODE_TLS), optional4(value3(CODE_SNI)), code11(CODE_WS), optional4(value3(CODE_P2P))));
var WebSocketsSecure4 = fmt4(_WebSocketsSecure4);
var _WebRTCDirect4 = and4(_UDP4, code11(CODE_WEBRTC_DIRECT), optional4(value3(CODE_CERTHASH)), optional4(value3(CODE_CERTHASH)), optional4(value3(CODE_P2P)));
var WebRTCDirect4 = fmt4(_WebRTCDirect4);
var _WebTransport4 = and4(_QUIC_V13, code11(CODE_WEBTRANSPORT), optional4(value3(CODE_CERTHASH)), optional4(value3(CODE_CERTHASH)), optional4(value3(CODE_P2P)));
var WebTransport4 = fmt4(_WebTransport4);
var _P2P4 = or16(_WebSockets4, _WebSocketsSecure4, and4(_TCP4, optional4(value3(CODE_P2P))), and4(QUIC_V0_OR_V14, optional4(value3(CODE_P2P))), and4(_IP_OR_DOMAIN4, optional4(value3(CODE_P2P))), _WebRTCDirect4, _WebTransport4, value3(CODE_P2P));
var P2P5 = fmt4(_P2P4);
var _Circuit4 = and4(_P2P4, code11(CODE_P2P_CIRCUIT), value3(CODE_P2P));
var Circuit4 = fmt4(_Circuit4);
var _WebRTC4 = or16(and4(_P2P4, code11(CODE_P2P_CIRCUIT), code11(CODE_WEBRTC), optional4(value3(CODE_P2P))), and4(_P2P4, code11(CODE_WEBRTC), optional4(value3(CODE_P2P))), and4(code11(CODE_WEBRTC), optional4(value3(CODE_P2P))));
var WebRTC4 = fmt4(_WebRTC4);
var _HTTP4 = or16(and4(_IP_OR_DOMAIN4, value3(CODE_TCP), code11(CODE_HTTP), optional4(value3(CODE_P2P))), and4(_IP_OR_DOMAIN4, code11(CODE_HTTP), optional4(value3(CODE_P2P))));
var HTTP4 = fmt4(_HTTP4);
var _HTTPS4 = and4(_IP_OR_DOMAIN4, or16(and4(value3(CODE_TCP, "443"), code11(CODE_HTTP)), and4(value3(CODE_TCP), code11(CODE_HTTPS)), and4(value3(CODE_TCP), code11(CODE_TLS), code11(CODE_HTTP)), and4(code11(CODE_TLS), code11(CODE_HTTP)), code11(CODE_TLS), code11(CODE_HTTPS)), optional4(value3(CODE_P2P)));
var HTTPS4 = fmt4(_HTTPS4);
var _Memory4 = or16(and4(value3(CODE_MEMORY), optional4(value3(CODE_P2P))));
var Memory4 = fmt4(_Memory4);
var _Unix4 = or16(and4(value3(CODE_UNIX), optional4(value3(CODE_P2P))));
var Unix4 = fmt4(_Unix4);

// node_modules/@libp2p/dcutr/dist/src/pb/message.js
var HolePunch;
(function(HolePunch2) {
  let Type;
  (function(Type2) {
    Type2["UNUSED"] = "UNUSED";
    Type2["CONNECT"] = "CONNECT";
    Type2["SYNC"] = "SYNC";
  })(Type = HolePunch2.Type || (HolePunch2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["UNUSED"] = 0] = "UNUSED";
    __TypeValues2[__TypeValues2["CONNECT"] = 100] = "CONNECT";
    __TypeValues2[__TypeValues2["SYNC"] = 300] = "SYNC";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = HolePunch2.Type || (HolePunch2.Type = {}));
  let _codec;
  HolePunch2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          HolePunch2.Type.codec().encode(obj.type, w);
        }
        if (obj.observedAddresses != null) {
          for (const value7 of obj.observedAddresses) {
            w.uint32(18);
            w.bytes(value7);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          observedAddresses: []
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = HolePunch2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              if (opts.limits?.observedAddresses != null && obj.observedAddresses.length === opts.limits.observedAddresses) {
                throw new MaxLengthError('Decode error - map field "observedAddresses" had too many elements');
              }
              obj.observedAddresses.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HolePunch2.encode = (obj) => {
    return encodeMessage(obj, HolePunch2.codec());
  };
  HolePunch2.decode = (buf, opts) => {
    return decodeMessage(buf, HolePunch2.codec(), opts);
  };
})(HolePunch || (HolePunch = {}));

// node_modules/@libp2p/dcutr/dist/src/utils.js
function isPublicAndDialable(ma, transportManager) {
  if (Circuit4.matches(ma)) {
    return false;
  }
  const transport = transportManager.dialTransportForMultiaddr(ma);
  if (transport == null) {
    return false;
  }
  if (DNS7.matches(ma)) {
    return true;
  }
  if (!IP5.matches(ma)) {
    return false;
  }
  return isPrivateIp(ma.toOptions().host) === false;
}

// node_modules/@libp2p/dcutr/dist/src/dcutr.js
var MAX_DCUTR_MESSAGE_SIZE = 1024 * 4;
var DCUTR_DIAL_PRIORITY = 100;
var defaultValues5 = {
  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L27
  timeout: 5e3,
  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L28
  retries: 3,
  maxInboundStreams: 1,
  maxOutboundStreams: 1
};
var DefaultDCUtRService = class {
  started;
  timeout;
  retries;
  maxInboundStreams;
  maxOutboundStreams;
  peerStore;
  registrar;
  connectionManager;
  addressManager;
  transportManager;
  topologyId;
  log;
  constructor(components, init) {
    this.log = components.logger.forComponent("libp2p:dcutr");
    this.started = false;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.addressManager = components.addressManager;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.timeout = init.timeout ?? defaultValues5.timeout;
    this.retries = init.retries ?? defaultValues5.retries;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues5.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues5.maxOutboundStreams;
  }
  [Symbol.toStringTag] = "@libp2p/dcutr";
  [serviceDependencies] = [
    "@libp2p/identify"
  ];
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    this.topologyId = await this.registrar.register(multicodec, {
      notifyOnLimitedConnection: true,
      onConnect: (peerId2, connection) => {
        if (!Circuit4.exactMatch(connection.remoteAddr)) {
          return;
        }
        if (connection.direction !== "inbound") {
          return;
        }
        this.upgradeInbound(connection).catch((err) => {
          this.log.error("error during outgoing DCUtR attempt", err);
        });
      }
    });
    await this.registrar.handle(multicodec, (data) => {
      void this.handleIncomingUpgrade(data.stream, data.connection).catch((err) => {
        this.log.error("error during incoming DCUtR attempt", err);
        data.stream.abort(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: true
    });
    this.started = true;
  }
  async stop() {
    await this.registrar.unhandle(multicodec);
    if (this.topologyId != null) {
      this.registrar.unregister(this.topologyId);
    }
    this.started = false;
  }
  /**
   * Perform the inbound connection upgrade as B
   *
   * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol
   */
  async upgradeInbound(relayedConnection) {
    if (await this.attemptUnilateralConnectionUpgrade(relayedConnection)) {
      return;
    }
    let stream;
    for (let i = 0; i < this.retries; i++) {
      const options2 = {
        signal: AbortSignal.timeout(this.timeout)
      };
      try {
        stream = await relayedConnection.newStream([multicodec], {
          signal: options2.signal,
          runOnLimitedConnection: true
        });
        const pb = pbStream(stream, {
          maxDataLength: MAX_DCUTR_MESSAGE_SIZE
        }).pb(HolePunch);
        this.log("B sending connect to %p", relayedConnection.remotePeer);
        const connectTimer = Date.now();
        await pb.write({
          type: HolePunch.Type.CONNECT,
          observedAddresses: this.addressManager.getAddresses().map((ma) => ma.bytes)
        }, options2);
        this.log("B receiving connect from %p", relayedConnection.remotePeer);
        const connect3 = await pb.read(options2);
        if (connect3.type !== HolePunch.Type.CONNECT) {
          this.log("A sent wrong message type");
          throw new InvalidMessageError("DCUtR message type was incorrect");
        }
        const multiaddrs = this.getDialableMultiaddrs(connect3.observedAddresses);
        if (multiaddrs.length === 0) {
          this.log("A did not have any dialable multiaddrs");
          throw new InvalidMessageError("DCUtR connect message had no multiaddrs");
        }
        const rtt = Date.now() - connectTimer;
        this.log("A sending sync, rtt %dms", rtt);
        await pb.write({
          type: HolePunch.Type.SYNC,
          observedAddresses: []
        }, options2);
        this.log("A waiting for half RTT");
        await delay_default(rtt / 2);
        this.log("B dialing", multiaddrs);
        const conn = await this.connectionManager.openConnection(multiaddrs, {
          signal: options2.signal,
          priority: DCUTR_DIAL_PRIORITY,
          force: true,
          initiator: false
        });
        this.log("DCUtR to %p succeeded to address %a, closing relayed connection", relayedConnection.remotePeer, conn.remoteAddr);
        await relayedConnection.close(options2);
        break;
      } catch (err) {
        this.log.error("error while attempting DCUtR on attempt %d of %d", i + 1, this.retries, err);
        stream?.abort(err);
        if (i === this.retries) {
          throw err;
        }
      } finally {
        if (stream != null) {
          await stream.close(options2);
        }
      }
    }
  }
  /**
   * This is performed when A has dialed B via a relay but A also has a public
   * address that B can dial directly
   */
  async attemptUnilateralConnectionUpgrade(relayedConnection) {
    const peerInfo = await this.peerStore.get(relayedConnection.remotePeer);
    const publicAddresses = peerInfo.addresses.map((address) => {
      const ma = address.multiaddr;
      if (ma.getPeerId() == null) {
        return ma.encapsulate(`/p2p/${relayedConnection.remotePeer}`);
      }
      return ma;
    }).filter((ma) => {
      return isPublicAndDialable(ma, this.transportManager);
    });
    if (publicAddresses.length > 0) {
      const signal = AbortSignal.timeout(this.timeout);
      try {
        this.log("attempting unilateral connection upgrade to %a", publicAddresses);
        const connection = await this.connectionManager.openConnection(publicAddresses, {
          signal,
          force: true
        });
        if (Circuit4.exactMatch(connection.remoteAddr)) {
          throw new Error("Could not open a new, non-limited, connection");
        }
        this.log("unilateral connection upgrade to %p succeeded via %a, closing relayed connection", relayedConnection.remotePeer, connection.remoteAddr);
        await relayedConnection.close({
          signal
        });
        return true;
      } catch (err) {
        this.log.error("unilateral connection upgrade to %p on addresses %a failed", relayedConnection.remotePeer, publicAddresses, err);
      }
    } else {
      this.log("peer %p has no public addresses, not attempting unilateral connection upgrade", relayedConnection.remotePeer);
    }
    return false;
  }
  /**
   * Perform the connection upgrade as A
   *
   * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol
   */
  async handleIncomingUpgrade(stream, relayedConnection) {
    const options2 = {
      signal: AbortSignal.timeout(this.timeout)
    };
    try {
      const pb = pbStream(stream, {
        maxDataLength: MAX_DCUTR_MESSAGE_SIZE
      }).pb(HolePunch);
      this.log("A receiving connect");
      const connect3 = await pb.read(options2);
      if (connect3.type !== HolePunch.Type.CONNECT) {
        this.log("B sent wrong message type");
        throw new InvalidMessageError("DCUtR message type was incorrect");
      }
      if (connect3.observedAddresses.length === 0) {
        this.log("B sent no multiaddrs");
        throw new InvalidMessageError("DCUtR connect message had no multiaddrs");
      }
      const multiaddrs = this.getDialableMultiaddrs(connect3.observedAddresses);
      if (multiaddrs.length === 0) {
        this.log("B had no dialable multiaddrs");
        throw new InvalidMessageError("DCUtR connect message had no dialable multiaddrs");
      }
      this.log("A sending connect");
      await pb.write({
        type: HolePunch.Type.CONNECT,
        observedAddresses: this.addressManager.getAddresses().map((ma) => ma.bytes)
      });
      this.log("A receiving sync");
      const sync = await pb.read(options2);
      if (sync.type !== HolePunch.Type.SYNC) {
        throw new InvalidMessageError("DCUtR message type was incorrect");
      }
      this.log("A dialing", multiaddrs);
      const connection = await this.connectionManager.openConnection(multiaddrs, {
        signal: options2.signal,
        priority: DCUTR_DIAL_PRIORITY,
        force: true
      });
      this.log("DCUtR to %p succeeded via %a, closing relayed connection", relayedConnection.remotePeer, connection.remoteAddr);
      await relayedConnection.close(options2);
    } catch (err) {
      this.log.error("incoming DCUtR from %p failed", relayedConnection.remotePeer, err);
      stream.abort(err);
    } finally {
      await stream.close(options2);
    }
  }
  /**
   * Takes the `addr` and converts it to a Multiaddr if possible
   */
  getDialableMultiaddrs(addrs) {
    const output = [];
    for (const addr of addrs) {
      if (addr == null || addr.length === 0) {
        continue;
      }
      try {
        const ma = multiaddr(addr);
        if (!isPublicAndDialable(ma, this.transportManager)) {
          continue;
        }
        output.push(ma);
      } catch {
      }
    }
    return output;
  }
};

// node_modules/@libp2p/dcutr/dist/src/index.js
var multicodec = "/libp2p/dcutr";
function dcutr(init = {}) {
  return (components) => new DefaultDCUtRService(components, init);
}

// node_modules/@libp2p/identify/dist/src/consts.js
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var MAX_PUSH_CONCURRENCY = 32;
var PUSH_DEBOUNCE_MS = 1e3;

// node_modules/@libp2p/identify/dist/src/pb/message.js
var Identify;
(function(Identify3) {
  let _codec;
  Identify3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.protocolVersion != null) {
          w.uint32(42);
          w.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w.uint32(50);
          w.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value7 of obj.listenAddrs) {
            w.uint32(18);
            w.bytes(value7);
          }
        }
        if (obj.observedAddr != null) {
          w.uint32(34);
          w.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value7 of obj.protocols) {
            w.uint32(26);
            w.string(value7);
          }
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(66);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 5: {
              obj.protocolVersion = reader.string();
              break;
            }
            case 6: {
              obj.agentVersion = reader.string();
              break;
            }
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              if (opts.limits?.listenAddrs != null && obj.listenAddrs.length === opts.limits.listenAddrs) {
                throw new MaxLengthError('Decode error - map field "listenAddrs" had too many elements');
              }
              obj.listenAddrs.push(reader.bytes());
              break;
            }
            case 4: {
              obj.observedAddr = reader.bytes();
              break;
            }
            case 3: {
              if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 8: {
              obj.signedPeerRecord = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify3.encode = (obj) => {
    return encodeMessage(obj, Identify3.codec());
  };
  Identify3.decode = (buf, opts) => {
    return decodeMessage(buf, Identify3.codec(), opts);
  };
})(Identify || (Identify = {}));

// node_modules/@libp2p/identify/dist/src/utils.js
var defaultValues6 = {
  protocolPrefix: "ipfs",
  timeout: 5e3,
  maxInboundStreams: 1,
  maxOutboundStreams: 1,
  maxObservedAddresses: 10,
  maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,
  runOnConnectionOpen: true,
  runOnSelfUpdate: true,
  runOnLimitedConnection: true,
  concurrency: MAX_PUSH_CONCURRENCY
};
function getCleanMultiaddr(addr) {
  if (addr != null && addr.length > 0) {
    try {
      return multiaddr(addr);
    } catch {
    }
  }
}
function getAgentVersion(nodeInfo, agentVersion) {
  if (agentVersion != null) {
    return agentVersion;
  }
  return nodeInfo.userAgent;
}
async function consumeIdentifyMessage(peerStore, events, log5, connection, message2) {
  log5("received identify from %p", connection.remotePeer);
  if (message2 == null) {
    throw new InvalidMessageError("message was null or undefined");
  }
  const peer = {};
  if (message2.listenAddrs.length > 0) {
    peer.addresses = message2.listenAddrs.map((buf) => ({
      isCertified: false,
      multiaddr: multiaddr(buf)
    }));
  }
  if (message2.protocols.length > 0) {
    peer.protocols = message2.protocols;
  }
  if (message2.publicKey != null) {
    const publicKey2 = publicKeyFromProtobuf(message2.publicKey);
    const peerId2 = peerIdFromPublicKey(publicKey2);
    if (!peerId2.equals(connection.remotePeer)) {
      throw new InvalidMessageError("public key did not match remote PeerId");
    }
    peer.publicKey = publicKey2;
  }
  let output;
  if (message2.signedPeerRecord != null) {
    log5.trace("received signedPeerRecord from %p", connection.remotePeer);
    let peerRecordEnvelope2 = message2.signedPeerRecord;
    const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope2, PeerRecord2.DOMAIN);
    let peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    const envelopePeer = peerIdFromCID(envelope.publicKey.toCID());
    if (!peerRecord.peerId.equals(envelopePeer)) {
      throw new InvalidMessageError("signing key does not match PeerId in the PeerRecord");
    }
    if (!connection.remotePeer.equals(peerRecord.peerId)) {
      throw new InvalidMessageError("signing key does not match remote PeerId");
    }
    let existingPeer;
    try {
      existingPeer = await peerStore.get(peerRecord.peerId);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if (existingPeer != null) {
      peer.metadata = existingPeer.metadata;
      if (existingPeer.peerRecordEnvelope != null) {
        const storedEnvelope = RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
        const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          log5("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          peerRecord = storedRecord;
          peerRecordEnvelope2 = existingPeer.peerRecordEnvelope;
        }
      }
    }
    peer.peerRecordEnvelope = peerRecordEnvelope2;
    peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
      isCertified: true,
      multiaddr: multiaddr2
    }));
    output = {
      seq: peerRecord.seqNumber,
      addresses: peerRecord.multiaddrs
    };
  } else {
    log5("%p did not send a signed peer record", connection.remotePeer);
  }
  log5.trace("patching %p with", connection.remotePeer, peer);
  await peerStore.patch(connection.remotePeer, peer);
  if (message2.agentVersion != null || message2.protocolVersion != null) {
    const metadata = {};
    if (message2.agentVersion != null) {
      metadata.AgentVersion = fromString(message2.agentVersion);
    }
    if (message2.protocolVersion != null) {
      metadata.ProtocolVersion = fromString(message2.protocolVersion);
    }
    log5.trace("merging %p metadata", connection.remotePeer, metadata);
    await peerStore.merge(connection.remotePeer, {
      metadata
    });
  }
  const result = {
    peerId: connection.remotePeer,
    protocolVersion: message2.protocolVersion,
    agentVersion: message2.agentVersion,
    publicKey: message2.publicKey,
    listenAddrs: message2.listenAddrs.map((buf) => multiaddr(buf)),
    observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
    protocols: message2.protocols,
    signedPeerRecord: output,
    connection
  };
  events.safeDispatchEvent("peer:identify", { detail: result });
  return result;
}
var AbstractIdentify = class {
  host;
  protocol;
  started;
  timeout;
  peerId;
  privateKey;
  peerStore;
  registrar;
  addressManager;
  maxInboundStreams;
  maxOutboundStreams;
  maxMessageSize;
  maxObservedAddresses;
  events;
  runOnLimitedConnection;
  log;
  constructor(components, init) {
    this.protocol = init.protocol;
    this.started = false;
    this.peerId = components.peerId;
    this.privateKey = components.privateKey;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.addressManager = components.addressManager;
    this.events = components.events;
    this.log = init.log;
    this.timeout = init.timeout ?? defaultValues6.timeout;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues6.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues6.maxOutboundStreams;
    this.maxMessageSize = init.maxMessageSize ?? defaultValues6.maxMessageSize;
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues6.maxObservedAddresses;
    this.runOnLimitedConnection = init.runOnLimitedConnection ?? defaultValues6.runOnLimitedConnection;
    this.host = {
      protocolVersion: `${init.protocolPrefix ?? defaultValues6.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      agentVersion: getAgentVersion(components.nodeInfo, init.agentVersion)
    };
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.peerStore.merge(this.peerId, {
      metadata: {
        AgentVersion: fromString(this.host.agentVersion),
        ProtocolVersion: fromString(this.host.protocolVersion)
      }
    });
    await this.registrar.handle(this.protocol, (data) => {
      void this.handleProtocol(data).catch((err) => {
        this.log.error(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    });
    this.started = true;
  }
  async stop() {
    await this.registrar.unhandle(this.protocol);
    this.started = false;
  }
};

// node_modules/@libp2p/identify/dist/src/identify-push.js
var IdentifyPush = class extends AbstractIdentify {
  connectionManager;
  concurrency;
  _push;
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues6.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify-push")
    });
    this.connectionManager = components.connectionManager;
    this.concurrency = init.concurrency ?? defaultValues6.concurrency;
    this._push = debounce(this.sendPushMessage.bind(this), init.debounce ?? PUSH_DEBOUNCE_MS);
    if (init.runOnSelfUpdate ?? defaultValues6.runOnSelfUpdate) {
      components.events.addEventListener("self:peer:update", (evt) => {
        this.push().catch((err) => {
          this.log.error("error pushing updates to peers - %e", err);
        });
      });
    }
  }
  [serviceCapabilities] = [
    "@libp2p/identify-push"
  ];
  /**
   * Calls `push` on all peer connections
   */
  async push() {
    this._push();
  }
  async sendPushMessage() {
    if (!this.isStarted()) {
      return;
    }
    try {
      const listenAddresses = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(protocols("p2p").code));
      const peerRecord = new PeerRecord2({
        peerId: this.peerId,
        multiaddrs: listenAddresses
      });
      const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.privateKey);
      const supportedProtocols = this.registrar.getProtocols();
      const peer = await this.peerStore.get(this.peerId);
      const agentVersion = toString(peer.metadata.get("AgentVersion") ?? fromString(this.host.agentVersion));
      const protocolVersion = toString(peer.metadata.get("ProtocolVersion") ?? fromString(this.host.protocolVersion));
      const self2 = this;
      async function* pushToConnections() {
        for (const connection of self2.connectionManager.getConnections()) {
          const peer2 = await self2.peerStore.get(connection.remotePeer);
          if (!peer2.protocols.includes(self2.protocol)) {
            continue;
          }
          yield async () => {
            let stream;
            const signal = AbortSignal.timeout(self2.timeout);
            setMaxListeners(Infinity, signal);
            try {
              stream = await connection.newStream(self2.protocol, {
                signal,
                runOnLimitedConnection: self2.runOnLimitedConnection
              });
              const pb = pbStream(stream, {
                maxDataLength: self2.maxMessageSize
              }).pb(Identify);
              await pb.write({
                listenAddrs: listenAddresses.map((ma) => ma.bytes),
                signedPeerRecord: signedPeerRecord.marshal(),
                protocols: supportedProtocols,
                agentVersion,
                protocolVersion
              }, {
                signal
              });
              await stream.close({
                signal
              });
            } catch (err) {
              self2.log.error("could not push identify update to peer", err);
              stream?.abort(err);
            }
          };
        }
      }
      await src_default(parallel(pushToConnections(), {
        concurrency: this.concurrency
      }));
    } catch (err) {
      this.log.error("error pushing updates to peers - %e", err);
    }
  }
  /**
   * Reads the Identify Push message from the given `connection`
   */
  async handleProtocol(data) {
    const { connection, stream } = data;
    try {
      if (this.peerId.equals(connection.remotePeer)) {
        throw new Error("received push from ourselves?");
      }
      const options2 = {
        signal: AbortSignal.timeout(this.timeout)
      };
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options2);
      await stream.close(options2);
      await consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message2);
    } catch (err) {
      this.log.error("received invalid message", err);
      stream.abort(err);
      return;
    }
    this.log.trace("handled push from %p", connection.remotePeer);
  }
};

// node_modules/@libp2p/identify/node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
var code12 = (code17) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component == null) {
        return false;
      }
      if (component.code !== code17) {
        return false;
      }
      if (component.value != null) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var value4 = (code17, value7) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component?.code !== code17) {
        return false;
      }
      if (component.value == null) {
        return false;
      }
      if (value7 != null && component.value !== value7) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var optional5 = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    }
  };
};
var or17 = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    }
  };
};
var and5 = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    }
  };
};
function fmt5(...matchers) {
  function match(ma) {
    if (ma == null) {
      return false;
    }
    let parts = ma.getComponents();
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matchers,
    matches,
    exactMatch
  };
}

// node_modules/@libp2p/identify/node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var _PEER_ID5 = value4(CODE_P2P);
var PEER_ID5 = fmt5(_PEER_ID5);
var _DNS45 = value4(CODE_DNS4);
var _DNS65 = value4(CODE_DNS6);
var _DNSADDR5 = value4(CODE_DNSADDR);
var _DNS7 = value4(CODE_DNS);
var DNS45 = fmt5(_DNS45, optional5(value4(CODE_P2P)));
var DNS65 = fmt5(_DNS65, optional5(value4(CODE_P2P)));
var DNSADDR5 = fmt5(_DNSADDR5, optional5(value4(CODE_P2P)));
var DNS8 = fmt5(or17(_DNS7, _DNSADDR5, _DNS45, _DNS65), optional5(value4(CODE_P2P)));
var _IP45 = and5(value4(CODE_IP4), optional5(value4(CODE_IPCIDR)));
var _IP65 = and5(optional5(value4(CODE_IP6ZONE)), value4(CODE_IP6), optional5(value4(CODE_IPCIDR)));
var _IP7 = or17(_IP45, _IP65);
var _IP_OR_DOMAIN5 = or17(_IP7, _DNS7, _DNS45, _DNS65, _DNSADDR5);
var IP_OR_DOMAIN5 = fmt5(or17(_IP7, and5(or17(_DNS7, _DNSADDR5, _DNS45, _DNS65), optional5(value4(CODE_P2P)))));
var IP45 = fmt5(_IP45);
var IP65 = fmt5(_IP65);
var IP7 = fmt5(_IP7);
var _TCP5 = and5(_IP_OR_DOMAIN5, value4(CODE_TCP));
var _UDP5 = and5(_IP_OR_DOMAIN5, value4(CODE_UDP));
var TCP5 = fmt5(and5(_TCP5, optional5(value4(CODE_P2P))));
var UDP5 = fmt5(_UDP5);
var _QUIC5 = and5(_UDP5, code12(CODE_QUIC), optional5(value4(CODE_P2P)));
var _QUIC_V14 = and5(_UDP5, code12(CODE_QUIC_V1), optional5(value4(CODE_P2P)));
var QUIC_V0_OR_V15 = or17(_QUIC5, _QUIC_V14);
var QUIC5 = fmt5(_QUIC5);
var QUIC_V14 = fmt5(_QUIC_V14);
var _WEB5 = or17(_IP_OR_DOMAIN5, _TCP5, _UDP5, _QUIC5, _QUIC_V14);
var _WebSockets5 = or17(and5(_WEB5, code12(CODE_WS), optional5(value4(CODE_P2P))));
var WebSockets5 = fmt5(_WebSockets5);
var _WebSocketsSecure5 = or17(and5(_WEB5, code12(CODE_WSS), optional5(value4(CODE_P2P))), and5(_WEB5, code12(CODE_TLS), optional5(value4(CODE_SNI)), code12(CODE_WS), optional5(value4(CODE_P2P))));
var WebSocketsSecure5 = fmt5(_WebSocketsSecure5);
var _WebRTCDirect5 = and5(_UDP5, code12(CODE_WEBRTC_DIRECT), optional5(value4(CODE_CERTHASH)), optional5(value4(CODE_CERTHASH)), optional5(value4(CODE_P2P)));
var WebRTCDirect5 = fmt5(_WebRTCDirect5);
var _WebTransport5 = and5(_QUIC_V14, code12(CODE_WEBTRANSPORT), optional5(value4(CODE_CERTHASH)), optional5(value4(CODE_CERTHASH)), optional5(value4(CODE_P2P)));
var WebTransport5 = fmt5(_WebTransport5);
var _P2P5 = or17(_WebSockets5, _WebSocketsSecure5, and5(_TCP5, optional5(value4(CODE_P2P))), and5(QUIC_V0_OR_V15, optional5(value4(CODE_P2P))), and5(_IP_OR_DOMAIN5, optional5(value4(CODE_P2P))), _WebRTCDirect5, _WebTransport5, value4(CODE_P2P));
var P2P6 = fmt5(_P2P5);
var _Circuit5 = and5(_P2P5, code12(CODE_P2P_CIRCUIT), value4(CODE_P2P));
var Circuit5 = fmt5(_Circuit5);
var _WebRTC5 = or17(and5(_P2P5, code12(CODE_P2P_CIRCUIT), code12(CODE_WEBRTC), optional5(value4(CODE_P2P))), and5(_P2P5, code12(CODE_WEBRTC), optional5(value4(CODE_P2P))), and5(code12(CODE_WEBRTC), optional5(value4(CODE_P2P))));
var WebRTC5 = fmt5(_WebRTC5);
var _HTTP5 = or17(and5(_IP_OR_DOMAIN5, value4(CODE_TCP), code12(CODE_HTTP), optional5(value4(CODE_P2P))), and5(_IP_OR_DOMAIN5, code12(CODE_HTTP), optional5(value4(CODE_P2P))));
var HTTP5 = fmt5(_HTTP5);
var _HTTPS5 = and5(_IP_OR_DOMAIN5, or17(and5(value4(CODE_TCP, "443"), code12(CODE_HTTP)), and5(value4(CODE_TCP), code12(CODE_HTTPS)), and5(value4(CODE_TCP), code12(CODE_TLS), code12(CODE_HTTP)), and5(code12(CODE_TLS), code12(CODE_HTTP)), code12(CODE_TLS), code12(CODE_HTTPS)), optional5(value4(CODE_P2P)));
var HTTPS5 = fmt5(_HTTPS5);
var _Memory5 = or17(and5(value4(CODE_MEMORY), optional5(value4(CODE_P2P))));
var Memory5 = fmt5(_Memory5);
var _Unix5 = or17(and5(value4(CODE_UNIX), optional5(value4(CODE_P2P))));
var Unix5 = fmt5(_Unix5);

// node_modules/@libp2p/identify/dist/src/identify.js
var Identify2 = class extends AbstractIdentify {
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues6.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify")
    });
    if (init.runOnConnectionOpen ?? defaultValues6.runOnConnectionOpen) {
      components.events.addEventListener("connection:open", (evt) => {
        const connection = evt.detail;
        this.identify(connection).catch((err) => {
          if (err.name === UnsupportedProtocolError.name) {
            return;
          }
          this.log.error("error during identify trigged by connection:open", err);
        });
      });
    }
  }
  [serviceCapabilities] = [
    "@libp2p/identify"
  ];
  async _identify(connection, options2 = {}) {
    let stream;
    if (options2.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      options2 = {
        ...options2,
        signal
      };
    }
    try {
      stream = await connection.newStream(this.protocol, {
        ...options2,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options2);
      await stream.close(options2);
      return message2;
    } catch (err) {
      stream?.abort(err);
      throw err;
    }
  }
  async identify(connection, options2 = {}) {
    const message2 = await this._identify(connection, options2);
    const { publicKey: publicKey2, protocols: protocols2, observedAddr } = message2;
    if (publicKey2 == null) {
      throw new InvalidMessageError("public key was missing from identify message");
    }
    const key = publicKeyFromProtobuf(publicKey2);
    const id = peerIdFromCID(key.toCID());
    if (!connection.remotePeer.equals(id)) {
      throw new InvalidMessageError("identified peer does not match the expected peer");
    }
    if (this.peerId.equals(id)) {
      throw new InvalidMessageError("identified peer is our own peer id?");
    }
    this.maybeAddObservedAddress(observedAddr);
    this.log("identify completed for peer %p and protocols %o", id, protocols2);
    return consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message2);
  }
  maybeAddObservedAddress(observedAddr) {
    const cleanObservedAddr = getCleanMultiaddr(observedAddr);
    if (cleanObservedAddr == null) {
      return;
    }
    this.log.trace("our observed address was %a", cleanObservedAddr);
    if (isPrivate(cleanObservedAddr)) {
      this.log.trace("our observed address was private");
      return;
    }
    const tuples = cleanObservedAddr.getComponents();
    if ((tuples[0].code === CODE_IP6 || tuples[0].code === CODE_IP6ZONE && tuples[1].code === CODE_IP6) && !isGlobalUnicast(cleanObservedAddr)) {
      this.log.trace("our observed address was IPv6 but not a global unicast address");
      return;
    }
    if (TCP5.exactMatch(cleanObservedAddr)) {
      return;
    }
    this.log.trace("storing the observed address");
    this.addressManager.addObservedAddr(cleanObservedAddr);
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async handleProtocol(data) {
    const { connection, stream } = data;
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    try {
      const peerData = await this.peerStore.get(this.peerId);
      const multiaddrs = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(protocols("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord2({
          peerId: this.peerId,
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.privateKey);
        signedPeerRecord = envelope.marshal().subarray();
      }
      let observedAddr = connection.remoteAddr.bytes;
      if (!IP_OR_DOMAIN5.matches(connection.remoteAddr)) {
        observedAddr = void 0;
      }
      const pb = pbStream(stream).pb(Identify);
      await pb.write({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey: publicKeyToProtobuf(this.privateKey.publicKey),
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr,
        protocols: peerData.protocols
      }, {
        signal
      });
      await stream.close({
        signal
      });
    } catch (err) {
      this.log.error("could not respond to identify request", err);
      stream.abort(err);
    }
  }
};

// node_modules/@libp2p/identify/dist/src/index.js
function identify(init = {}) {
  return (components) => new Identify2(components, init);
}
function identifyPush(init = {}) {
  return (components) => new IdentifyPush(components, init);
}

// node_modules/@libp2p/kad-dht/dist/src/constants.js
var second2 = 1e3;
var minute2 = 60 * second2;
var hour = 60 * minute2;
var MAX_RECORD_AGE = 36 * hour;
var PROTOCOL = "/ipfs/kad/1.0.0";
var PROVIDERS_VALIDITY = 48 * hour;
var REPROVIDE_THRESHOLD = 24 * hour;
var REPROVIDE_CONCURRENCY = 10;
var REPROVIDE_MAX_QUEUE_SIZE = 16384;
var REPROVIDE_INTERVAL = hour;
var REPROVIDE_TIMEOUT = hour;
var READ_MESSAGE_TIMEOUT = 10 * second2;
var ON_PEER_CONNECT_TIMEOUT = 10 * second2;
var K = 20;
var ALPHA = 10;
var QUERY_SELF_INTERVAL = 5 * minute2;
var QUERY_SELF_INITIAL_INTERVAL = second2;
var QUERY_SELF_TIMEOUT = 5 * second2;
var TABLE_REFRESH_INTERVAL = 5 * minute2;
var TABLE_REFRESH_QUERY_TIMEOUT = 30 * second2;
var DEFAULT_QUERY_TIMEOUT = 180 * second2;
var KEEP_ALIVE_TAG2 = `${KEEP_ALIVE}-kad-dht`;

// node_modules/@libp2p/record/dist/src/record.js
var Record;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.key != null && obj.key.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.key);
        }
        if (obj.value != null && obj.value.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.value);
        }
        if (obj.timeReceived != null && obj.timeReceived !== "") {
          w.uint32(42);
          w.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          key: alloc(0),
          value: alloc(0),
          timeReceived: ""
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.key = reader.bytes();
              break;
            }
            case 2: {
              obj.value = reader.bytes();
              break;
            }
            case 5: {
              obj.timeReceived = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf, opts) => {
    return decodeMessage(buf, Record3.codec(), opts);
  };
})(Record || (Record = {}));

// node_modules/@libp2p/record/dist/src/utils.js
function toRFC3339(time) {
  const year = time.getUTCFullYear();
  const month = String(time.getUTCMonth() + 1).padStart(2, "0");
  const day = String(time.getUTCDate()).padStart(2, "0");
  const hour2 = String(time.getUTCHours()).padStart(2, "0");
  const minute3 = String(time.getUTCMinutes()).padStart(2, "0");
  const seconds = String(time.getUTCSeconds()).padStart(2, "0");
  const milliseconds = time.getUTCMilliseconds();
  const nanoseconds = String(milliseconds * 1e3 * 1e3).padStart(9, "0");
  return `${year}-${month}-${day}T${hour2}:${minute3}:${seconds}.${nanoseconds}Z`;
}
function parseRFC3339(time) {
  const rfc3339Matcher = new RegExp(
    // 2006-01-02T
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m = String(time).trim().match(rfc3339Matcher);
  if (m == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m[1], 10);
  const month = parseInt(m[2], 10) - 1;
  const date = parseInt(m[3], 10);
  const hour2 = parseInt(m[4], 10);
  const minute3 = parseInt(m[5], 10);
  const second3 = parseInt(m[6], 10);
  const millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour2, minute3, second3, millisecond));
}

// node_modules/@libp2p/record/dist/src/index.js
var Libp2pRecord = class _Libp2pRecord {
  key;
  value;
  timeReceived;
  constructor(key, value7, timeReceived) {
    if (!(key instanceof Uint8Array)) {
      throw new Error("key must be a Uint8Array");
    }
    if (!(value7 instanceof Uint8Array)) {
      throw new Error("value must be a Uint8Array");
    }
    this.key = key;
    this.value = value7;
    this.timeReceived = timeReceived;
  }
  serialize() {
    return Record.encode(this.prepareSerialize());
  }
  /**
   * Return the object format ready to be given to the protobuf library.
   */
  prepareSerialize() {
    return {
      key: this.key,
      value: this.value,
      timeReceived: toRFC3339(this.timeReceived)
    };
  }
  /**
   * Decode a protobuf encoded record
   */
  static deserialize(raw) {
    const rec = Record.decode(raw);
    return new _Libp2pRecord(rec.key, rec.value, new Date(rec.timeReceived));
  }
  /**
   * Create a record from the raw object returned from the protobuf library
   */
  static fromDeserialized(obj) {
    const receivedTime = parseRFC3339(obj.timeReceived);
    if (obj.key == null) {
      throw new Error("key missing from deserialized object");
    }
    if (obj.value == null) {
      throw new Error("value missing from deserialized object");
    }
    const rec = new _Libp2pRecord(obj.key, obj.value, receivedTime);
    return rec;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/errors.js
var QueryError = class extends Error {
  constructor(message2 = "Query error") {
    super(message2);
    this.name = "QueryError";
  }
};
var InvalidRecordError = class extends Error {
  constructor(message2 = "Invalid record") {
    super(message2);
    this.name = "InvalidRecordError";
  }
};
var MissingSelectorError = class extends Error {
  constructor(message2 = "No selector function configured for prefix") {
    super(message2);
    this.name = "MissingSelectorError";
  }
};

// node_modules/@libp2p/kad-dht/dist/src/message/dht.js
var Record2;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.key != null) {
          w.uint32(10);
          w.bytes(obj.key);
        }
        if (obj.value != null) {
          w.uint32(18);
          w.bytes(obj.value);
        }
        if (obj.author != null) {
          w.uint32(26);
          w.bytes(obj.author);
        }
        if (obj.signature != null) {
          w.uint32(34);
          w.bytes(obj.signature);
        }
        if (obj.timeReceived != null) {
          w.uint32(42);
          w.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {};
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.key = reader.bytes();
              break;
            }
            case 2: {
              obj.value = reader.bytes();
              break;
            }
            case 3: {
              obj.author = reader.bytes();
              break;
            }
            case 4: {
              obj.signature = reader.bytes();
              break;
            }
            case 5: {
              obj.timeReceived = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf, opts) => {
    return decodeMessage(buf, Record3.codec(), opts);
  };
})(Record2 || (Record2 = {}));
var MessageType;
(function(MessageType2) {
  MessageType2["PUT_VALUE"] = "PUT_VALUE";
  MessageType2["GET_VALUE"] = "GET_VALUE";
  MessageType2["ADD_PROVIDER"] = "ADD_PROVIDER";
  MessageType2["GET_PROVIDERS"] = "GET_PROVIDERS";
  MessageType2["FIND_NODE"] = "FIND_NODE";
  MessageType2["PING"] = "PING";
})(MessageType || (MessageType = {}));
var __MessageTypeValues;
(function(__MessageTypeValues2) {
  __MessageTypeValues2[__MessageTypeValues2["PUT_VALUE"] = 0] = "PUT_VALUE";
  __MessageTypeValues2[__MessageTypeValues2["GET_VALUE"] = 1] = "GET_VALUE";
  __MessageTypeValues2[__MessageTypeValues2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
  __MessageTypeValues2[__MessageTypeValues2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
  __MessageTypeValues2[__MessageTypeValues2["FIND_NODE"] = 4] = "FIND_NODE";
  __MessageTypeValues2[__MessageTypeValues2["PING"] = 5] = "PING";
})(__MessageTypeValues || (__MessageTypeValues = {}));
(function(MessageType2) {
  MessageType2.codec = () => {
    return enumeration(__MessageTypeValues);
  };
})(MessageType || (MessageType = {}));
var ConnectionType;
(function(ConnectionType2) {
  ConnectionType2["NOT_CONNECTED"] = "NOT_CONNECTED";
  ConnectionType2["CONNECTED"] = "CONNECTED";
  ConnectionType2["CAN_CONNECT"] = "CAN_CONNECT";
  ConnectionType2["CANNOT_CONNECT"] = "CANNOT_CONNECT";
})(ConnectionType || (ConnectionType = {}));
var __ConnectionTypeValues;
(function(__ConnectionTypeValues2) {
  __ConnectionTypeValues2[__ConnectionTypeValues2["NOT_CONNECTED"] = 0] = "NOT_CONNECTED";
  __ConnectionTypeValues2[__ConnectionTypeValues2["CONNECTED"] = 1] = "CONNECTED";
  __ConnectionTypeValues2[__ConnectionTypeValues2["CAN_CONNECT"] = 2] = "CAN_CONNECT";
  __ConnectionTypeValues2[__ConnectionTypeValues2["CANNOT_CONNECT"] = 3] = "CANNOT_CONNECT";
})(__ConnectionTypeValues || (__ConnectionTypeValues = {}));
(function(ConnectionType2) {
  ConnectionType2.codec = () => {
    return enumeration(__ConnectionTypeValues);
  };
})(ConnectionType || (ConnectionType = {}));
var PeerInfo;
(function(PeerInfo2) {
  let _codec;
  PeerInfo2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.multiaddrs != null) {
          for (const value7 of obj.multiaddrs) {
            w.uint32(18);
            w.bytes(value7);
          }
        }
        if (obj.connection != null) {
          w.uint32(24);
          ConnectionType.codec().encode(obj.connection, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          id: alloc(0),
          multiaddrs: []
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.id = reader.bytes();
              break;
            }
            case 2: {
              if (opts.limits?.multiaddrs != null && obj.multiaddrs.length === opts.limits.multiaddrs) {
                throw new MaxLengthError('Decode error - map field "multiaddrs" had too many elements');
              }
              obj.multiaddrs.push(reader.bytes());
              break;
            }
            case 3: {
              obj.connection = ConnectionType.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerInfo2.encode = (obj) => {
    return encodeMessage(obj, PeerInfo2.codec());
  };
  PeerInfo2.decode = (buf, opts) => {
    return decodeMessage(buf, PeerInfo2.codec(), opts);
  };
})(PeerInfo || (PeerInfo = {}));
var Message2;
(function(Message5) {
  let _codec;
  Message5.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null && __MessageTypeValues[obj.type] !== 0) {
          w.uint32(8);
          MessageType.codec().encode(obj.type, w);
        }
        if (obj.clusterLevel != null) {
          w.uint32(80);
          w.int32(obj.clusterLevel);
        }
        if (obj.key != null) {
          w.uint32(18);
          w.bytes(obj.key);
        }
        if (obj.record != null) {
          w.uint32(26);
          w.bytes(obj.record);
        }
        if (obj.closer != null) {
          for (const value7 of obj.closer) {
            w.uint32(66);
            PeerInfo.codec().encode(value7, w);
          }
        }
        if (obj.providers != null) {
          for (const value7 of obj.providers) {
            w.uint32(74);
            PeerInfo.codec().encode(value7, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {
          type: MessageType.PUT_VALUE,
          closer: [],
          providers: []
        };
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = MessageType.codec().decode(reader);
              break;
            }
            case 10: {
              obj.clusterLevel = reader.int32();
              break;
            }
            case 2: {
              obj.key = reader.bytes();
              break;
            }
            case 3: {
              obj.record = reader.bytes();
              break;
            }
            case 8: {
              if (opts.limits?.closer != null && obj.closer.length === opts.limits.closer) {
                throw new MaxLengthError('Decode error - map field "closer" had too many elements');
              }
              obj.closer.push(PeerInfo.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.closer$
              }));
              break;
            }
            case 9: {
              if (opts.limits?.providers != null && obj.providers.length === opts.limits.providers) {
                throw new MaxLengthError('Decode error - map field "providers" had too many elements');
              }
              obj.providers.push(PeerInfo.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.providers$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message5.encode = (obj) => {
    return encodeMessage(obj, Message5.codec());
  };
  Message5.decode = (buf, opts) => {
    return decodeMessage(buf, Message5.codec(), opts);
  };
})(Message2 || (Message2 = {}));

// node_modules/@libp2p/kad-dht/dist/src/query/events.js
function sendQueryEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "SEND_QUERY",
    type: 0,
    messageName: fields.type,
    messageType: fields.type
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:send-query", { detail: event }));
  return event;
}
function peerResponseEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "PEER_RESPONSE",
    type: 1,
    messageName: fields.messageType,
    closer: fields.closer ?? [],
    providers: fields.providers ?? []
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:peer-response", { detail: event }));
  return event;
}
function finalPeerEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "FINAL_PEER",
    type: 2
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:final-peer", { detail: event }));
  return event;
}
function queryErrorEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "QUERY_ERROR",
    type: 3
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:query-error", { detail: event }));
  return event;
}
function providerEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "PROVIDER",
    type: 4
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:provider", { detail: event }));
  return event;
}
function valueEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "VALUE",
    type: 5
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:value", { detail: event }));
  return event;
}
function dialPeerEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "DIAL_PEER",
    type: 7
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:dial-peer", { detail: event }));
  return event;
}
function pathEndedEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "PATH_ENDED",
    type: 8
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:path-ended", { detail: event }));
  return event;
}

// node_modules/@libp2p/kad-dht/dist/src/record/selectors.js
function bestRecord(selectors2, k, records) {
  if (records.length === 0) {
    throw new InvalidParametersError("No records given");
  }
  const kStr = toString(k);
  const parts = kStr.split("/");
  if (parts.length < 3) {
    throw new InvalidParametersError("Record key does not have a selector function");
  }
  const selector = selectors2[parts[1].toString()];
  if (selector == null) {
    throw new MissingSelectorError(`No selector function configured for key type "${parts[1]}"`);
  }
  if (records.length === 1) {
    return 0;
  }
  return selector(k, records);
}
function publicKey(k, records) {
  return 0;
}
var selectors = {
  pk: publicKey
};

// node_modules/@libp2p/kad-dht/dist/src/record/validators.js
async function verifyRecord(validators2, record, options2) {
  const key = record.key;
  const keyString = toString(key);
  const parts = keyString.split("/");
  if (parts.length < 3) {
    return;
  }
  const validator = validators2[parts[1].toString()];
  if (validator == null) {
    throw new InvalidParametersError(`No validator available for key type "${parts[1]}"`);
  }
  await validator(key, record.value, options2);
}
var validatePublicKeyRecord = async (key, publicKey2, options2) => {
  if (!(key instanceof Uint8Array)) {
    throw new InvalidParametersError('"key" must be a Uint8Array');
  }
  if (key.byteLength < 5) {
    throw new InvalidParametersError("Invalid public key record");
  }
  const prefix = toString(key.subarray(0, 4));
  if (prefix !== "/pk/") {
    throw new InvalidParametersError("key was not prefixed with /pk/");
  }
  const pubKey = publicKeyFromProtobuf(publicKey2);
  const keyHash = key.slice(4);
  if (!equals(keyHash, pubKey.toMultihash().bytes)) {
    throw new InvalidParametersError("public key does not match passed in key");
  }
};
var validators = {
  pk: validatePublicKeyRecord
};

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bytes.js
var empty15 = new Uint8Array(0);
function equals22(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce15(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/vendor/base-x.js
function base12(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src12 = base12;
var _brrp__multiformats_scope_baseX12 = src12;
var base_x_default13 = _brrp__multiformats_scope_baseX12;

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base.js
var Encoder13 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder14 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or18(this, decoder);
  }
};
var ComposedDecoder13 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or18(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or18(left, right) {
  return new ComposedDecoder13({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec13 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder13(name9, prefix, baseEncode);
    this.decoder = new Decoder14(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from18({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec13(name9, prefix, encode39, decode61);
}
function baseX12({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default13(alphabet2, name9);
  return from18({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce15(decode61(text))
  });
}
function decode52(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode32(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx12(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc464812({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx12(alphabet2);
  return from18({
    prefix,
    name: name9,
    encode(input) {
      return encode32(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode52(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base32.js
var base329 = rfc464812({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper9 = rfc464812({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad9 = rfc464812({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper9 = rfc464812({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex9 = rfc464812({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper9 = rfc464812({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad9 = rfc464812({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper9 = rfc464812({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z9 = rfc464812({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base36.js
var base369 = baseX12({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper9 = baseX12({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/bases/base58.js
var base58btc12 = baseX12({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr12 = baseX12({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/vendor/varint.js
var encode_113 = encode33;
var MSB13 = 128;
var REST13 = 127;
var MSBALL13 = ~REST13;
var INT13 = Math.pow(2, 31);
function encode33(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT13) {
    out[offset++] = num & 255 | MSB13;
    num /= 128;
  }
  while (num & MSBALL13) {
    out[offset++] = num & 255 | MSB13;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode33.bytes = offset - oldOffset + 1;
  return out;
}
var decode53 = read14;
var MSB$113 = 128;
var REST$113 = 127;
function read14(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read14.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$113) << shift : (b & REST$113) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$113);
  read14.bytes = counter - offset;
  return res;
}
var N113 = Math.pow(2, 7);
var N213 = Math.pow(2, 14);
var N313 = Math.pow(2, 21);
var N413 = Math.pow(2, 28);
var N513 = Math.pow(2, 35);
var N613 = Math.pow(2, 42);
var N713 = Math.pow(2, 49);
var N813 = Math.pow(2, 56);
var N913 = Math.pow(2, 63);
var length13 = function(value7) {
  return value7 < N113 ? 1 : value7 < N213 ? 2 : value7 < N313 ? 3 : value7 < N413 ? 4 : value7 < N513 ? 5 : value7 < N613 ? 6 : value7 < N713 ? 7 : value7 < N813 ? 8 : value7 < N913 ? 9 : 10;
};
var varint13 = {
  encode: encode_113,
  decode: decode53,
  encodingLength: length13
};
var _brrp_varint13 = varint13;
var varint_default13 = _brrp_varint13;

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/varint.js
function decode54(data, offset = 0) {
  const code17 = varint_default13.decode(data, offset);
  return [code17, varint_default13.decode.bytes];
}
function encodeTo13(int, target, offset = 0) {
  varint_default13.encode(int, target, offset);
  return target;
}
function encodingLength14(int) {
  return varint_default13.encodingLength(int);
}

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/hashes/digest.js
function create11(code17, digest5) {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength14(code17);
  const digestOffset = sizeOffset + encodingLength14(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo13(code17, bytes, 0);
  encodeTo13(size, bytes, sizeOffset);
  bytes.set(digest5, digestOffset);
  return new Digest13(code17, size, digest5, bytes);
}
function decode55(multihash) {
  const bytes = coerce15(multihash);
  const [code17, sizeOffset] = decode54(bytes);
  const [size, digestOffset] = decode54(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest13(code17, size, digest5, bytes);
}
function equals23(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals22(a.bytes, data.bytes);
  }
}
var Digest13 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/cid.js
function format9(link, base14) {
  const { bytes, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV09(bytes, baseCache9(link), base14 ?? base58btc12.encoder);
    default:
      return toStringV19(bytes, baseCache9(link), base14 ?? base329.encoder);
  }
}
var cache10 = /* @__PURE__ */ new WeakMap();
function baseCache9(cid) {
  const baseCache11 = cache10.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache10.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID9 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code17, multihash, bytes) {
    this.code = code17;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code17, multihash } = this;
        if (code17 !== DAG_PB_CODE9) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE9) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code17, digest: digest5 } = this.multihash;
        const multihash = create11(code17, digest5);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals23(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format9(this, base14);
  }
  toJSON() {
    return { "/": format9(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value7 = input;
    if (value7 instanceof _CID) {
      return value7;
    } else if (value7["/"] != null && value7["/"] === value7.bytes || value7.asCID === value7) {
      const { version: version3, code: code17, multihash, bytes } = value7;
      return new _CID(version3, code17, multihash, bytes ?? encodeCID9(version3, code17, multihash.bytes));
    } else if (value7[cidSymbol9] === true) {
      const { version: version3, multihash, code: code17 } = value7;
      const digest5 = decode55(multihash);
      return _CID.create(version3, code17, digest5);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code17, digest5) {
    if (typeof code17 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code17 !== DAG_PB_CODE9) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE9}) block encoding`);
        } else {
          return new _CID(version3, code17, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID9(version3, code17, digest5.bytes);
        return new _CID(version3, code17, digest5, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE9, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code17, digest5) {
    return _CID.create(1, code17, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce15(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest5 = new Digest13(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest5) : _CID.createV1(specs.codec, digest5);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length16] = decode54(initialBytes.subarray(offset));
      offset += length16;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE9;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes9(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache9(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes9(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc12;
      return [
        base58btc12.prefix,
        decoder.decode(`${base58btc12.prefix}${source}`)
      ];
    }
    case base58btc12.prefix: {
      const decoder = base14 ?? base58btc12;
      return [base58btc12.prefix, decoder.decode(source)];
    }
    case base329.prefix: {
      const decoder = base14 ?? base329;
      return [base329.prefix, decoder.decode(source)];
    }
    case base369.prefix: {
      const decoder = base14 ?? base369;
      return [base369.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV09(bytes, cache12, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc12.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV19(bytes, cache12, base14) {
  const { prefix } = base14;
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE9 = 112;
var SHA_256_CODE9 = 18;
function encodeCID9(version3, code17, multihash) {
  const codeOffset = encodingLength14(version3);
  const hashOffset = codeOffset + encodingLength14(code17);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo13(version3, bytes, 0);
  encodeTo13(code17, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol9 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/codecs/raw.js
var code13 = 85;

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/hashes/hasher.js
function from19({ name: name9, code: code17, encode: encode39 }) {
  return new Hasher6(name9, code17, encode39);
}
var Hasher6 = class {
  name;
  code;
  encode;
  constructor(name9, code17, encode39) {
    this.name = name9;
    this.code = code17;
    this.encode = encode39;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create11(this.code, result) : result.then((digest5) => create11(this.code, digest5));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/kad-dht/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha6(name9) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name9, data));
}
var sha2567 = from19({
  name: "sha2-256",
  code: 18,
  encode: sha6("SHA-256")
});
var sha5127 = from19({
  name: "sha2-512",
  code: 19,
  encode: sha6("SHA-512")
});

// node_modules/@libp2p/kad-dht/dist/src/utils.js
var PK_PREFIX = fromString("/pk/");
function removePrivateAddressesMapper(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (type === 53 || type === 54 || type === 55) {
        if (addr === "localhost") {
          return false;
        }
        return true;
      }
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      const isPrivate2 = isPrivateIp(addr);
      if (isPrivate2 == null) {
        return true;
      }
      return !isPrivate2;
    })
  };
}
async function convertBuffer(buf, options2) {
  const multihash = await sha2567.digest(buf);
  options2?.signal?.throwIfAborted();
  return multihash.digest;
}
async function convertPeerId(peerId2, options2) {
  return convertBuffer(peerId2.toMultihash().bytes, options2);
}
function bufferToRecordKey(prefix, buf) {
  return new Key(`${prefix}/${toString(buf, "base32")}`, false);
}
function keyForPublicKey(peerId2) {
  return concat([
    PK_PREFIX,
    peerId2.toMultihash().bytes
  ]);
}
function isPublicKeyKey(key) {
  return toString(key.subarray(0, 4)) === "/pk/";
}
function fromPublicKeyKey(key) {
  const multihash = decode55(key.subarray(4));
  return peerIdFromMultihash(multihash);
}
function createPutRecord(key, value7) {
  const timeReceived = /* @__PURE__ */ new Date();
  const rec = new Libp2pRecord(key, value7, timeReceived);
  return rec.serialize();
}
var P2P_CIRCUIT_CODE = 290;
var DNS4_CODE = 54;
var DNS6_CODE = 55;
var DNSADDR_CODE = 56;
var IP4_CODE = 4;
var IP6_CODE = 41;
function multiaddrIsPublic(multiaddr2) {
  const tuples = multiaddr2.stringTuples();
  for (const tuple of tuples) {
    if (tuple[0] === P2P_CIRCUIT_CODE) {
      return false;
    }
  }
  if (tuples[0][0] === DNS4_CODE || tuples[0][0] === DNS6_CODE || tuples[0][0] === DNSADDR_CODE) {
    return true;
  }
  if (tuples[0][0] === IP4_CODE || tuples[0][0] === IP6_CODE) {
    const result = isPrivateIp(`${tuples[0][1]}`);
    const isPublic = result == null || !result;
    return isPublic;
  }
  return false;
}
function parseProviderKey(key) {
  const parts = key.toString().split("/");
  const peerIdStr = parts.pop();
  const cidStr = parts.pop();
  if (peerIdStr == null || cidStr == null) {
    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);
  }
  return {
    cid: CID9.createV1(code13, decode55(fromString(cidStr, "base32"))),
    peerId: peerIdFromString(peerIdStr)
  };
}
function toProviderKey(prefix, cid, peerId2) {
  const cidStr = typeof cid === "string" ? cid : toString(cid.multihash.bytes, "base32");
  const parts = [
    prefix,
    cidStr
  ];
  if (peerId2 != null) {
    parts.push(peerId2.toString());
  }
  return new Key(parts.join("/"));
}
function readProviderTime(buf) {
  return new Date(decode(buf));
}
function timeOperationGenerator(fn, operationMetrics, type) {
  return async function* (...args) {
    const stopSuccessTimer = operationMetrics.queryTime?.timer(type);
    const stopErrorTimer = operationMetrics.errorTime?.timer(type);
    let errored = false;
    try {
      operationMetrics.queries?.increment({ [type]: true });
      yield* fn(...args);
    } catch (err) {
      errored = true;
      stopErrorTimer?.();
      operationMetrics.errors?.increment({ [type]: true });
      throw err;
    } finally {
      operationMetrics.queries?.decrement({ [type]: true });
      if (!errored) {
        stopSuccessTimer?.();
      }
    }
  };
}
function timeOperationMethod(fn, operationMetrics, type) {
  return async function(...args) {
    const stopSuccessTimer = operationMetrics?.queryTime?.timer(type);
    const stopErrorTimer = operationMetrics?.errorTime?.timer(type);
    let errored = false;
    try {
      operationMetrics.queries?.increment({ [type]: true });
      return await fn(...args);
    } catch (err) {
      errored = true;
      stopErrorTimer?.();
      operationMetrics.errors?.increment({ [type]: true });
      throw err;
    } finally {
      operationMetrics.queries?.decrement({ [type]: true });
      if (!errored) {
        stopSuccessTimer?.();
      }
    }
  };
}

// node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js
var ContentFetching = class {
  log;
  components;
  validators;
  selectors;
  peerRouting;
  queryManager;
  network;
  datastorePrefix;
  constructor(components, init) {
    const { validators: validators2, selectors: selectors2, peerRouting, queryManager, network, logPrefix } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${logPrefix}:content-fetching`);
    this.datastorePrefix = `${init.datastorePrefix}/record`;
    this.validators = validators2;
    this.selectors = selectors2;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.network = network;
    this.get = components.metrics?.traceFunction("libp2p.kadDHT.get", this.get.bind(this), {
      optionsIndex: 1
    }) ?? this.get;
    this.put = components.metrics?.traceFunction("libp2p.kadDHT.put", this.put.bind(this), {
      optionsIndex: 2
    }) ?? this.put;
  }
  /**
   * Attempt to retrieve the value for the given key from
   * the local datastore
   */
  async getLocal(key, options2) {
    this.log("getLocal %b", key);
    const dsKey = bufferToRecordKey(this.datastorePrefix, key);
    this.log("fetching record for key %k", dsKey);
    const raw = await this.components.datastore.get(dsKey, options2);
    this.log("found %k in local datastore", dsKey);
    const rec = Libp2pRecord.deserialize(raw);
    await verifyRecord(this.validators, rec, options2);
    return rec;
  }
  /**
   * Send the best record found to any peers that have an out of date record
   */
  async *sendCorrectionRecord(key, vals, best, options2) {
    this.log("sendCorrection for %b", key);
    const fixupRec = createPutRecord(key, best);
    for (const { value: value7, from: from22 } of vals) {
      if (equals(value7, best)) {
        this.log("record was ok");
        continue;
      }
      if (this.components.peerId.equals(from22)) {
        try {
          const dsKey = bufferToRecordKey(this.datastorePrefix, key);
          this.log(`Storing corrected record for key ${dsKey.toString()}`);
          await this.components.datastore.put(dsKey, fixupRec.subarray(), options2);
        } catch (err) {
          this.log.error("Failed error correcting self", err);
        }
        continue;
      }
      let sentCorrection = false;
      const request = {
        type: MessageType.PUT_VALUE,
        key,
        record: fixupRec
      };
      for await (const event of this.network.sendRequest(from22, request, options2)) {
        if (event.name === "PEER_RESPONSE" && event.record != null && equals(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {
          sentCorrection = true;
        }
        yield event;
      }
      if (!sentCorrection) {
        throw new QueryError("Could not send correction");
      }
      this.log.error("Failed error correcting entry");
    }
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value7, options2) {
    this.log("put key %b value %b", key, value7);
    const record = createPutRecord(key, value7);
    const dsKey = bufferToRecordKey(this.datastorePrefix, key);
    this.log(`storing record for key ${dsKey.toString()}`);
    await this.components.datastore.put(dsKey, record.subarray(), options2);
    yield* pipe(this.peerRouting.getClosestPeers(key, {
      ...options2,
      signal: options2.signal
    }), (source) => src_default5(source, (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events = [];
        const msg = {
          type: MessageType.PUT_VALUE,
          key,
          record
        };
        this.log("send put to %p", event.peer.id);
        for await (const putEvent of this.network.sendRequest(event.peer.id, msg, {
          ...options2,
          path: event.path
        })) {
          events.push(putEvent);
          if (putEvent.name !== "PEER_RESPONSE") {
            continue;
          }
          if (!(putEvent.record != null && equals(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {
            events.push(queryErrorEvent({
              from: event.peer.id,
              error: new QueryError("Value not put correctly"),
              path: putEvent.path
            }, options2));
          }
        }
        return events;
      };
    }), (source) => parallel(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events of source) {
        yield* events;
      }
    });
  }
  /**
   * Get the value to the given key
   */
  async *get(key, options2) {
    this.log("get %b", key);
    const vals = [];
    for await (const event of this.getMany(key, options2)) {
      if (event.name === "VALUE") {
        vals.push(event);
        continue;
      }
      yield event;
    }
    if (vals.length === 0) {
      return;
    }
    const records = vals.map((v) => v.value);
    let i = 0;
    try {
      i = bestRecord(this.selectors, key, records);
    } catch (err) {
      if (err.name !== "InvalidParametersError") {
        throw err;
      }
    }
    const best = records[i];
    this.log("GetValue %b %b", key, best);
    if (best == null) {
      throw new NotFoundError("Best value was not found");
    }
    yield* this.sendCorrectionRecord(key, vals, best, {
      ...options2,
      path: {
        index: -1,
        queued: 0,
        running: 0,
        total: 0
      }
    });
    yield vals[i];
  }
  /**
   * Get the `n` values to the given key without sorting
   */
  async *getMany(key, options2 = {}) {
    this.log("getMany values for %b", key);
    try {
      const localRec = await this.getLocal(key, options2);
      yield valueEvent({
        value: localRec.value,
        from: this.components.peerId,
        path: {
          index: -1,
          running: 0,
          queued: 0,
          total: 0
        }
      }, options2);
    } catch (err) {
      this.log("error getting local value for %b", key, err);
    }
    const self2 = this;
    const getValueQuery = async function* ({ peer, signal, path }) {
      for await (const event of self2.peerRouting.getValueOrPeers(peer.id, key, {
        ...options2,
        signal,
        path
      })) {
        yield event;
        if (event.name === "PEER_RESPONSE" && event.record != null) {
          yield valueEvent({
            from: peer.id,
            value: event.record.value,
            path
          }, options2);
        }
      }
    };
    yield* this.queryManager.run(key, getValueQuery, options2);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/message/utils.js
function toPbPeerInfo(peer, connection) {
  const output = {
    id: peer.id.toMultihash().bytes,
    multiaddrs: (peer.multiaddrs ?? []).map((m) => m.bytes),
    connection
  };
  return output;
}
function fromPbPeerInfo(peer) {
  if (peer.id == null) {
    throw new Error("Invalid peer in message");
  }
  const multihash = decode55(peer.id);
  return {
    id: peerIdFromMultihash(multihash),
    multiaddrs: (peer.multiaddrs ?? []).map((a) => multiaddr(a))
  };
}

// node_modules/@libp2p/kad-dht/dist/src/content-routing/index.js
var ContentRouting = class {
  log;
  components;
  network;
  peerRouting;
  queryManager;
  routingTable;
  providers;
  constructor(components, init) {
    const { network, peerRouting, queryManager, routingTable, providers, logPrefix } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${logPrefix}:content-routing`);
    this.network = network;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.providers = providers;
    this.findProviders = components.metrics?.traceFunction("libp2p.kadDHT.findProviders", this.findProviders.bind(this), {
      optionsIndex: 1,
      getAttributesFromYieldedValue: (event, attrs) => {
        if (event.name === "PROVIDER") {
          attrs.providers ??= [];
          attrs.providers.push(...event.providers.map((info) => info.id.toString()));
        }
        return attrs;
      }
    }) ?? this.findProviders;
    this.provide = components.metrics?.traceFunction("libp2p.kadDHT.provide", this.provide.bind(this), {
      optionsIndex: 1,
      getAttributesFromYieldedValue: (event, attrs) => {
        if (event.name === "PEER_RESPONSE" && event.messageName === "ADD_PROVIDER") {
          attrs.providers ??= [];
          attrs.providers.push(event.from.toString());
        }
        return attrs;
      }
    }) ?? this.provide;
  }
  /**
   * Announce to the network that we can provide the value for a given key and
   * are contactable on the given multiaddrs
   */
  async *provide(key, multiaddrs, options2 = {}) {
    this.log("provide %s", key);
    const target = key.multihash.bytes;
    await this.providers.addProvider(key, this.components.peerId, options2);
    const msg = {
      type: MessageType.ADD_PROVIDER,
      key: target,
      providers: [
        toPbPeerInfo({
          id: this.components.peerId,
          multiaddrs
        })
      ]
    };
    let sent = 0;
    const self2 = this;
    async function* publishProviderRecord(event) {
      try {
        self2.log("sending provider record for %s to %p", key, event.peer.id);
        for await (const addProviderEvent of self2.network.sendMessage(event.peer.id, msg, {
          ...options2,
          path: event.path
        })) {
          if (addProviderEvent.name === "PEER_RESPONSE") {
            self2.log("sent provider record for %s to %p", key, event.peer.id);
            sent++;
          }
          yield addProviderEvent;
        }
      } catch (err) {
        self2.log.error("error sending provide record to peer %p", event.peer.id, err);
        yield queryErrorEvent({
          from: event.peer.id,
          error: err,
          path: event.path
        }, options2);
      }
    }
    const events = pushable({
      objectMode: true
    });
    const queue = new Queue({
      concurrency: ALPHA
    });
    queue.addEventListener("idle", () => {
      events.end();
    });
    queue.addEventListener("error", (err) => {
      this.log.error("error publishing provider record to peer - %e", err);
    });
    queue.add(async () => {
      const finalPeerEvents = [];
      for await (const event of this.peerRouting.getClosestPeers(target, options2)) {
        events.push(event);
        if (event.name !== "FINAL_PEER") {
          continue;
        }
        finalPeerEvents.push(event);
      }
      finalPeerEvents.forEach((event) => {
        queue.add(async () => {
          for await (const notifyEvent of publishProviderRecord(event)) {
            events.push(notifyEvent);
          }
        }).catch((err) => {
          this.log.error("error publishing provider record to peer - %e", err);
        });
      });
    }).catch((err) => {
      events.end(err);
    });
    yield* events;
    this.log("sent provider records to %d peers", sent);
  }
  /**
   * Search the dht for up to `K` providers of the given CID.
   */
  async *findProviders(key, options2) {
    const toFind = this.routingTable.kBucketSize;
    let found = 0;
    const target = key.multihash.bytes;
    const self2 = this;
    this.log("findProviders %c", key);
    const provs = await this.providers.getProviders(key, options2);
    if (provs.length > 0) {
      const providers2 = [];
      for (const peerId2 of provs.slice(0, toFind)) {
        try {
          const peer = await this.components.peerStore.get(peerId2, options2);
          providers2.push({
            id: peerId2,
            multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
          });
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
          this.log("no peer store entry for %p", peerId2);
        }
      }
      yield peerResponseEvent({
        from: this.components.peerId,
        messageType: MessageType.GET_PROVIDERS,
        providers: providers2,
        path: {
          index: -1,
          queued: 0,
          running: 0,
          total: 0
        }
      }, options2);
      yield providerEvent({
        from: this.components.peerId,
        providers: providers2,
        path: {
          index: -1,
          queued: 0,
          running: 0,
          total: 0
        }
      }, options2);
      found += providers2.length;
      if (found >= toFind) {
        return;
      }
    }
    const findProvidersQuery = async function* ({ peer, signal, path }) {
      const request = {
        type: MessageType.GET_PROVIDERS,
        key: target
      };
      yield* self2.network.sendRequest(peer.id, request, {
        ...options2,
        signal,
        path
      });
    };
    const providers = new PeerSet(provs);
    for await (const event of this.queryManager.run(target, findProvidersQuery, options2)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        this.log("Found %d provider entries for %c and %d closer peers", event.providers.length, key, event.closer.length);
        const newProviders = [];
        for (const peer of event.providers) {
          if (providers.has(peer.id)) {
            continue;
          }
          providers.add(peer.id);
          newProviders.push(peer);
        }
        if (newProviders.length > 0) {
          yield providerEvent({
            from: event.from,
            providers: newProviders,
            path: event.path
          }, options2);
          found += newProviders.length;
          if (found >= toFind) {
            return;
          }
        }
      }
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/network.js
var Network2 = class extends TypedEventEmitter {
  log;
  protocol;
  running;
  components;
  timeout;
  metrics;
  /**
   * Create a new network
   */
  constructor(components, init) {
    super();
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:network`);
    this.running = false;
    this.protocol = init.protocol;
    this.timeout = new AdaptiveTimeout({
      ...init.timeout ?? {},
      metrics: components.metrics,
      metricName: `${init.metricsPrefix}_network_message_send_times_milliseconds`
    });
    this.metrics = {
      operations: components.metrics?.registerCounterGroup(`${init.metricsPrefix}_outbound_rpc_requests_total`),
      errors: components.metrics?.registerCounterGroup(`${init.metricsPrefix}_outbound_rpc_errors_total`)
    };
    this.sendRequest = components.metrics?.traceFunction("libp2p.kadDHT.sendRequest", this.sendRequest.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs([to, message2], attrs) {
        return {
          ...attrs,
          to: to.toString(),
          "message type": `${message2.type}`
        };
      },
      getAttributesFromYieldedValue: (event, attrs) => {
        if (event.name === "PEER_RESPONSE") {
          if (event.providers.length > 0) {
            event.providers.forEach((value7, index) => {
              attrs[`providers-${index}`] = value7.id.toString();
            });
          }
          if (event.closer.length > 0) {
            event.closer.forEach((value7, index) => {
              attrs[`closer-${index}`] = value7.id.toString();
            });
          }
        }
        return attrs;
      }
    }) ?? this.sendRequest;
    this.sendMessage = components.metrics?.traceFunction("libp2p.kadDHT.sendMessage", this.sendMessage.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs([to, message2], attrs) {
        return {
          ...attrs,
          to: to.toString(),
          "message type": `${message2.type}`
        };
      },
      getAttributesFromYieldedValue: (event, attrs) => {
        if (event.name === "PEER_RESPONSE") {
          if (event.providers.length > 0) {
            event.providers.forEach((value7, index) => {
              attrs[`providers-${index}`] = value7.id.toString();
            });
          }
          if (event.closer.length > 0) {
            event.closer.forEach((value7, index) => {
              attrs[`closer-${index}`] = value7.id.toString();
            });
          }
        }
        return attrs;
      }
    }) ?? this.sendMessage;
  }
  /**
   * Start the network
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
  }
  /**
   * Stop all network activity
   */
  async stop() {
    this.running = false;
  }
  /**
   * Is the network online?
   */
  isStarted() {
    return this.running;
  }
  /**
   * Send a request and read a response
   */
  async *sendRequest(to, msg, options2) {
    if (!this.running) {
      return;
    }
    const type = msg.type;
    if (type == null) {
      throw new InvalidParametersError("Message type was missing");
    }
    let stream;
    const signal = this.timeout.getTimeoutSignal(options2);
    options2 = {
      ...options2,
      signal
    };
    try {
      this.metrics.operations?.increment({ [type]: true });
      this.log("dialling %p", to);
      yield dialPeerEvent({ peer: to, path: options2.path }, options2);
      const connection = await this.components.connectionManager.openConnection(to, options2);
      stream = await connection.newStream(this.protocol, options2);
      this.log("sending %s to %p", msg.type, to);
      yield sendQueryEvent({ to, type, path: options2.path }, options2);
      const response = await this._writeReadMessage(stream, msg, options2);
      stream.close(options2).catch((err) => {
        this.log.error("error closing stream to %p", to, err);
        stream?.abort(err);
      });
      yield peerResponseEvent({
        from: to,
        messageType: response.type,
        closer: response.closer.map(fromPbPeerInfo),
        providers: response.providers.map(fromPbPeerInfo),
        record: response.record == null ? void 0 : Libp2pRecord.deserialize(response.record),
        path: options2.path
      }, options2);
    } catch (err) {
      this.metrics.errors?.increment({ [type]: true });
      stream?.abort(err);
      if (options2.signal?.aborted !== true) {
        this.log.error("could not send %s to %p - %e", msg.type, to, err);
      }
      yield queryErrorEvent({ from: to, error: err, path: options2.path }, options2);
    } finally {
      this.timeout.cleanUp(signal);
    }
  }
  /**
   * Sends a message without expecting an answer
   */
  async *sendMessage(to, msg, options2) {
    if (!this.running) {
      return;
    }
    const type = msg.type;
    if (type == null) {
      throw new InvalidParametersError("Message type was missing");
    }
    let stream;
    const signal = this.timeout.getTimeoutSignal(options2);
    options2 = {
      ...options2,
      signal
    };
    try {
      this.metrics.operations?.increment({ [type]: true });
      this.log("dialling %p", to);
      yield dialPeerEvent({ peer: to, path: options2.path }, options2);
      const connection = await this.components.connectionManager.openConnection(to, options2);
      stream = await connection.newStream(this.protocol, options2);
      this.log("sending %s to %p", msg.type, to);
      yield sendQueryEvent({ to, type, path: options2.path }, options2);
      await this._writeMessage(stream, msg, options2);
      stream.close(options2).catch((err) => {
        this.log.error("error closing stream to %p", to, err);
        stream?.abort(err);
      });
      yield peerResponseEvent({ from: to, messageType: type, path: options2.path }, options2);
    } catch (err) {
      this.metrics.errors?.increment({ [type]: true });
      stream?.abort(err);
      yield queryErrorEvent({ from: to, error: err, path: options2.path }, options2);
    } finally {
      this.timeout.cleanUp(signal);
    }
  }
  /**
   * Write a message to the given stream
   */
  async _writeMessage(stream, msg, options2) {
    const pb = pbStream(stream);
    await pb.write(msg, Message2, options2);
  }
  /**
   * Write a message and read a response
   */
  async _writeReadMessage(stream, msg, options2) {
    const pb = pbStream(stream);
    await pb.write(msg, Message2, options2);
    const message2 = await pb.read(Message2, options2);
    message2.closer.forEach((peerData) => {
      this.safeDispatchEvent("peer", {
        detail: fromPbPeerInfo(peerData)
      });
    });
    message2.providers.forEach((peerData) => {
      this.safeDispatchEvent("peer", {
        detail: fromPbPeerInfo(peerData)
      });
    });
    return message2;
  }
};

// node_modules/uint8arrays/dist/src/xor-compare.js
function xorCompare(a, b) {
  if (a.byteLength !== b.byteLength) {
    throw new Error("Inputs should have the same length");
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] === b[i]) {
      continue;
    }
    return a[i] < b[i] ? -1 : 1;
  }
  return 0;
}

// node_modules/@libp2p/kad-dht/dist/src/peer-distance-list.js
var PeerDistanceList = class {
  /**
   * The DHT key from which distance is calculated
   */
  originDhtKey;
  /**
   * The maximum size of the list
   */
  capacity;
  peerDistances;
  constructor(originDhtKey, capacity) {
    this.originDhtKey = originDhtKey;
    this.capacity = capacity;
    this.peerDistances = [];
  }
  /**
   * The length of the list
   */
  get length() {
    return this.peerDistances.length;
  }
  /**
   * The peers in the list, in order of distance from the origin key
   */
  get peers() {
    return [...this.peerDistances];
  }
  /**
   * Add a peerId to the list.
   */
  async add(peer, path = { index: -1, queued: 0, running: 0, total: 0 }, options2) {
    const dhtKey = await convertPeerId(peer.id, options2);
    this.addWithKadId(peer, dhtKey, path);
  }
  /**
   * Add a peerId to the list.
   */
  addWithKadId(peer, kadId, path = { index: -1, queued: 0, running: 0, total: 0 }) {
    if (this.peerDistances.find((pd) => pd.peer.id.equals(peer.id)) != null) {
      return;
    }
    const el = {
      peer,
      distance: xor(this.originDhtKey, kadId),
      path
    };
    if (this.peerDistances.length === this.capacity) {
      const lastPeer = this.peerDistances[this.peerDistances.length - 1];
      if (lastPeer != null && xorCompare(el.distance, lastPeer.distance) !== -1) {
        return;
      }
    }
    let added = false;
    for (let j = 0; j < this.peerDistances.length; j++) {
      const distance = xorCompare(this.peerDistances[j].distance, el.distance);
      if (distance === 0 || distance === 1) {
        added = true;
        this.peerDistances.splice(j, 0, el);
        break;
      }
    }
    if (!added) {
      this.peerDistances.push(el);
    }
    this.peerDistances = this.peerDistances.slice(0, this.capacity);
  }
  /**
   * Indicates whether any of the peerIds passed as a parameter are closer
   * to the origin key than the furthest peerId in the PeerDistanceList.
   */
  async isCloser(peerId2, options2) {
    if (this.length === 0) {
      return true;
    }
    const dhtKey = await convertPeerId(peerId2, options2);
    const dhtKeyXor = xor(dhtKey, this.originDhtKey);
    const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
    return xorCompare(dhtKeyXor, furthestDistance) === -1;
  }
  /**
   * Indicates whether any of the peerIds passed as a parameter are closer
   * to the origin key than the furthest peerId in the PeerDistanceList.
   */
  async anyCloser(peerIds, options2) {
    if (peerIds.length === 0) {
      return false;
    }
    return Promise.any(peerIds.map(async (peerId2) => this.isCloser(peerId2, options2)));
  }
};

// node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js
var PeerRouting = class {
  log;
  routingTable;
  network;
  validators;
  queryManager;
  components;
  constructor(components, init) {
    this.routingTable = init.routingTable;
    this.network = init.network;
    this.validators = init.validators;
    this.queryManager = init.queryManager;
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:peer-routing`);
    this.findPeer = components.metrics?.traceFunction("libp2p.kadDHT.findPeer", this.findPeer.bind(this), {
      optionsIndex: 1
    }) ?? this.findPeer;
    this.getClosestPeers = components.metrics?.traceFunction("libp2p.kadDHT.getClosestPeers", this.getClosestPeers.bind(this), {
      optionsIndex: 1
    }) ?? this.getClosestPeers;
  }
  /**
   * Look if we are connected to a peer with the given id.
   * Returns its id and addresses, if found, otherwise `undefined`.
   */
  async findPeerLocal(peer, options2) {
    let peerData;
    const p = await this.routingTable.find(peer, options2);
    if (p != null) {
      this.log("findPeerLocal found %p in routing table", peer);
      try {
        peerData = await this.components.peerStore.get(p, options2);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
    }
    if (peerData == null) {
      try {
        peerData = await this.components.peerStore.get(peer, options2);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
    }
    if (peerData != null) {
      this.log("findPeerLocal found %p in peer store", peer);
      return {
        id: peerData.id,
        multiaddrs: peerData.addresses.map((address) => address.multiaddr)
      };
    }
    return void 0;
  }
  /**
   * Get a value via rpc call for the given parameters
   */
  async *_getValueSingle(peer, key, options2) {
    const msg = {
      type: MessageType.GET_VALUE,
      key
    };
    yield* this.network.sendRequest(peer, msg, options2);
  }
  /**
   * Get the public key directly from a node
   */
  async *getPublicKeyFromNode(peer, options2 = {}) {
    const pkKey = keyForPublicKey(peer);
    const path = {
      index: -1,
      queued: 0,
      running: 0,
      total: 0
    };
    for await (const event of this._getValueSingle(peer, pkKey, {
      ...options2,
      path
    })) {
      yield event;
      if (event.name === "PEER_RESPONSE" && event.record != null) {
        const publicKey2 = publicKeyFromProtobuf(event.record.value);
        const recPeer = peerIdFromPublicKey(publicKey2);
        if (!recPeer.equals(peer)) {
          throw new InvalidPublicKeyError("public key does not match id");
        }
        if (recPeer.publicKey == null) {
          throw new InvalidPublicKeyError("public key missing");
        }
        yield valueEvent({
          from: peer,
          value: event.record.value,
          path
        }, options2);
      }
    }
    throw new QueryError(`Node not responding with its public key: ${peer.toString()}`);
  }
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options2 = {}) {
    this.log("findPeer %p", id);
    if (options2.useCache !== false) {
      const pi = await this.findPeerLocal(id, options2);
      if (pi != null) {
        this.log("found local");
        yield finalPeerEvent({
          from: this.components.peerId,
          peer: pi,
          path: {
            index: -1,
            queued: 0,
            running: 0,
            total: 0
          }
        }, options2);
        return;
      }
    }
    let foundPeer = false;
    if (options2.useNetwork !== false) {
      const self2 = this;
      const findPeerQuery = async function* ({ peer, signal, path }) {
        const request = {
          type: MessageType.FIND_NODE,
          key: id.toMultihash().bytes
        };
        for await (const event of self2.network.sendRequest(peer.id, request, {
          ...options2,
          signal,
          path
        })) {
          yield event;
          if (event.name === "PEER_RESPONSE") {
            const match = event.closer.find((p) => p.id.equals(id));
            if (match != null) {
              yield finalPeerEvent({
                from: event.from,
                peer: match,
                path: event.path
              }, options2);
            }
          }
        }
      };
      for await (const event of this.queryManager.run(id.toMultihash().bytes, findPeerQuery, options2)) {
        if (event.name === "FINAL_PEER") {
          foundPeer = true;
        }
        yield event;
      }
    }
    if (!foundPeer) {
      throw new NotFoundError("Not found");
    }
  }
  /**
   * Kademlia 'FIND_NODE' operation on a key, which could be the bytes from a
   * multihash or a peer ID
   */
  async *getClosestPeers(key, options2 = {}) {
    this.log("getClosestPeers to %b", key);
    const kadId = await convertBuffer(key, options2);
    const peers = new PeerDistanceList(kadId, this.routingTable.kBucketSize);
    const self2 = this;
    const getCloserPeersQuery = async function* ({ peer, path, peerKadId, signal }) {
      self2.log("getClosestPeers asking %p", peer.id);
      const request = {
        type: MessageType.FIND_NODE,
        key
      };
      yield* self2.network.sendRequest(peer.id, request, {
        ...options2,
        signal,
        path
      });
      peers.addWithKadId(peer, peerKadId, path);
    };
    yield* this.queryManager.run(key, getCloserPeersQuery, options2);
    this.log("found %d peers close to %b", peers.length, key);
    for (let { peer, path } of peers.peers) {
      try {
        if (peer.multiaddrs.length === 0) {
          peer = await self2.components.peerStore.getInfo(peer.id, options2);
        }
        if (peer.multiaddrs.length === 0) {
          continue;
        }
        yield finalPeerEvent({
          from: this.components.peerId,
          peer: await self2.components.peerStore.getInfo(peer.id, options2),
          path: {
            index: path.index,
            queued: 0,
            running: 0,
            total: 0
          }
        }, options2);
      } catch {
        continue;
      }
    }
  }
  /**
   * Query a particular peer for the value for the given key.
   * It will either return the value or a list of closer peers.
   *
   * Note: The peerStore is updated with new addresses found for the given peer.
   */
  async *getValueOrPeers(peer, key, options2) {
    for await (const event of this._getValueSingle(peer, key, options2)) {
      if (event.name === "PEER_RESPONSE") {
        if (event.record != null) {
          try {
            await this._verifyRecordOnline(event.record, options2);
          } catch (err) {
            const errMsg = "invalid record received, discarded";
            this.log(errMsg);
            yield queryErrorEvent({
              from: event.from,
              error: new QueryError(errMsg),
              path: options2.path
            }, options2);
            continue;
          }
        }
      }
      yield event;
    }
  }
  /**
   * Verify a record, fetching missing public keys from the network.
   * Throws an error if the record is invalid.
   */
  async _verifyRecordOnline(record, options2) {
    if (record.timeReceived == null) {
      throw new InvalidRecordError("invalid record received");
    }
    await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived), options2);
  }
  /**
   * Get the peers in our routing table that are closest to the passed key
   */
  async getClosestPeersOffline(key, options2) {
    const output = [];
    try {
      const multihash = decode55(key);
      const targetPeerId = peerIdFromMultihash(multihash);
      const peer = await this.components.peerStore.get(targetPeerId, options2);
      output.push({
        id: peer.id,
        multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      });
    } catch {
    }
    const keyKadId = await convertBuffer(key, options2);
    const ids = this.routingTable.closestPeers(keyKadId, options2);
    for (const peerId2 of ids) {
      try {
        output.push(await this.components.peerStore.getInfo(peerId2, options2));
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
    }
    if (output.length > 0) {
      this.log("getClosestPeersOffline returning the %d closest peer(s) %b we know", output.length, key);
    } else {
      this.log("getClosestPeersOffline could not any peers close to %b with %d peers in the routing table", key, this.routingTable.size);
    }
    return output;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/providers.js
var Providers = class {
  log;
  datastore;
  datastorePrefix;
  constructor(components, init) {
    this.log = components.logger.forComponent(`${init.logPrefix}:providers`);
    this.datastorePrefix = `${init.datastorePrefix}/provider`;
    this.datastore = components.datastore;
  }
  /**
   * Add a new provider for the given CID
   */
  async addProvider(cid, provider, options2) {
    this.log.trace("%p provides %s", provider, cid);
    await this.writeProviderEntry(cid, provider, options2);
  }
  /**
   * Remove a provider for the given CID
   */
  async removeProvider(cid, provider, options2) {
    const key = toProviderKey(this.datastorePrefix, cid, provider);
    this.log.trace("%p no longer provides %s", provider, cid);
    await this.datastore.delete(key, options2);
  }
  /**
   * Get a list of providers for the given CID
   */
  async getProviders(cid, options2) {
    this.log.trace("get providers for %c", cid);
    const provs = await this.loadProviders(cid, options2);
    this.log.trace("got %d providers for %c", provs.size, cid);
    return [...provs.keys()];
  }
  /**
   * Write a provider into the given store
   */
  async writeProviderEntry(cid, peerId2, options2) {
    const key = toProviderKey(this.datastorePrefix, cid, peerId2);
    const buffer = encode(options2?.time?.getTime() ?? Date.now());
    await this.datastore.put(key, buffer, options2);
  }
  /**
   * Load providers for the given CID from the store
   */
  async loadProviders(cid, options2) {
    const providers = new PeerMap();
    const key = toProviderKey(this.datastorePrefix, cid);
    for await (const entry of this.datastore.query({ prefix: key.toString() }, options2)) {
      const { peerId: peerId2 } = parseProviderKey(entry.key);
      providers.set(peerId2, readProviderTime(entry.value));
    }
    return providers;
  }
};

// node_modules/p-event/index.js
var normalizeEmitter = (emitter) => {
  const addListener = emitter.addEventListener || emitter.on || emitter.addListener;
  const removeListener = emitter.removeEventListener || emitter.off || emitter.removeListener;
  if (!addListener || !removeListener) {
    throw new TypeError("Emitter is not compatible");
  }
  return {
    addListener: addListener.bind(emitter),
    removeListener: removeListener.bind(emitter)
  };
};
function pEventMultiple(emitter, event, options2) {
  let cancel;
  const returnValue = new Promise((resolve, reject) => {
    options2 = {
      rejectionEvents: ["error"],
      multiArgs: false,
      resolveImmediately: false,
      ...options2
    };
    if (!(options2.count >= 0 && (options2.count === Number.POSITIVE_INFINITY || Number.isInteger(options2.count)))) {
      throw new TypeError("The `count` option should be at least 0 or more");
    }
    options2.signal?.throwIfAborted();
    const events = [event].flat();
    const items = [];
    const { addListener, removeListener } = normalizeEmitter(emitter);
    const onItem = (...arguments_) => {
      const value7 = options2.multiArgs ? arguments_ : arguments_[0];
      if (options2.filter && !options2.filter(value7)) {
        return;
      }
      items.push(value7);
      if (options2.count === items.length) {
        cancel();
        resolve(items);
      }
    };
    const rejectHandler = (error) => {
      cancel();
      reject(error);
    };
    cancel = () => {
      for (const event2 of events) {
        removeListener(event2, onItem);
      }
      for (const rejectionEvent of options2.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    };
    for (const event2 of events) {
      addListener(event2, onItem);
    }
    for (const rejectionEvent of options2.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }
    if (options2.signal) {
      options2.signal.addEventListener("abort", () => {
        rejectHandler(options2.signal.reason);
      }, { once: true });
    }
    if (options2.resolveImmediately) {
      resolve(items);
    }
  });
  returnValue.cancel = cancel;
  if (typeof options2.timeout === "number") {
    const timeout = pTimeout(returnValue, { milliseconds: options2.timeout });
    timeout.cancel = cancel;
    return timeout;
  }
  return returnValue;
}
function pEvent(emitter, event, options2) {
  if (typeof options2 === "function") {
    options2 = { filter: options2 };
  }
  options2 = {
    ...options2,
    count: 1,
    resolveImmediately: false
  };
  const arrayPromise = pEventMultiple(emitter, event, options2);
  const promise = arrayPromise.then((array) => array[0]);
  promise.cancel = arrayPromise.cancel;
  return promise;
}

// node_modules/@libp2p/kad-dht/dist/src/query/query-path.js
async function* queryPath(options2) {
  const { key, startingPeers, ourPeerId, query, alpha, path, numPaths, log: log5, peersSeen, connectionManager, signal } = options2;
  const events = pushable({
    objectMode: true
  });
  const queue = new Queue({
    concurrency: alpha,
    sort: (a, b) => xorCompare(a.options.distance, b.options.distance)
  });
  queue.addEventListener("idle", () => {
    events.push(pathEndedEvent({
      path: {
        index: path,
        queued: queue.queued,
        running: queue.running,
        total: queue.size
      }
    }, options2));
    events.end();
  });
  queue.addEventListener("error", (evt) => {
    log5.error("error during query - %e", evt.detail);
  });
  const onAbort = () => {
    queue.abort();
    events.end(new AbortError());
  };
  signal.addEventListener("abort", onAbort);
  try {
    let queryPeer = function(peer, peerKadId) {
      if (peer == null) {
        return;
      }
      peersSeen.add(peer.id.toMultihash().bytes);
      const peerXor = xor(peerKadId, kadId);
      queue.add(async () => {
        try {
          for await (const event of query({
            ...options2,
            key,
            peer,
            path: {
              index: path,
              queued: queue.queued,
              running: queue.running,
              total: queue.size
            },
            numPaths,
            peerKadId,
            signal
          })) {
            if (event.name === "PEER_RESPONSE") {
              for (const closerPeer of event.closer) {
                if (peersSeen.has(closerPeer.id.toMultihash().bytes)) {
                  log5("already seen %p in query", closerPeer.id);
                  continue;
                }
                if (ourPeerId.equals(closerPeer.id)) {
                  log5("not querying ourselves");
                  continue;
                }
                if (!await connectionManager.isDialable(closerPeer.multiaddrs)) {
                  log5("not querying undialable peer");
                  continue;
                }
                const closerPeerKadId = await convertPeerId(closerPeer.id, {
                  signal
                });
                const closerPeerXor = xor(closerPeerKadId, kadId);
                if (xorCompare(closerPeerXor, peerXor) !== -1) {
                  log5("skipping %p as they are not closer to %b than %p", closerPeer.id, key, peer);
                  continue;
                }
                log5("querying closer peer %p", closerPeer.id);
                queryPeer(closerPeer, closerPeerKadId);
              }
            }
            events.push({
              ...event,
              path: {
                index: path,
                queued: queue.queued,
                running: queue.running,
                total: queue.size
              }
            });
          }
        } catch (err) {
          events.push(queryErrorEvent({
            from: peer.id,
            error: err,
            path: {
              index: path,
              queued: queue.queued,
              running: queue.running - 1,
              total: queue.size - 1
            }
          }, options2));
        }
      }, {
        distance: peerXor
      }).catch((err) => {
        log5.error("error during query - %e", err);
      });
    };
    const kadId = await convertBuffer(key, {
      signal
    });
    await Promise.all(startingPeers.map(async (startingPeer) => {
      queryPeer({ id: startingPeer, multiaddrs: [] }, await convertPeerId(startingPeer, {
        signal
      }));
    }));
    yield* events;
  } finally {
    signal.removeEventListener("abort", onAbort);
  }
}

// node_modules/@libp2p/kad-dht/dist/src/query/manager.js
var QueryManager = class {
  disjointPaths;
  alpha;
  shutDownController;
  running;
  logger;
  peerId;
  connectionManager;
  routingTable;
  initialQuerySelfHasRun;
  logPrefix;
  allowQueryWithZeroPeers;
  constructor(components, init) {
    this.logPrefix = init.logPrefix;
    this.disjointPaths = init.disjointPaths ?? K;
    this.alpha = init.alpha ?? ALPHA;
    this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
    this.routingTable = init.routingTable;
    this.logger = components.logger;
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.allowQueryWithZeroPeers = init.allowQueryWithZeroPeers ?? false;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    this.running = false;
  }
  isStarted() {
    return this.running;
  }
  /**
   * Starts the query manager
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
  }
  /**
   * Stops all queries
   */
  async stop() {
    this.running = false;
    this.shutDownController.abort();
  }
  async *run(key, queryFunc, options2 = {}) {
    if (!this.running) {
      throw new Error("QueryManager not started");
    }
    if (options2.signal == null) {
      const signal2 = AbortSignal.timeout(DEFAULT_QUERY_TIMEOUT);
      setMaxListeners(Infinity, signal2);
      options2 = {
        ...options2,
        signal: signal2
      };
    }
    const queryEarlyExitController = new AbortController();
    const signal = anySignal([
      this.shutDownController.signal,
      queryEarlyExitController.signal,
      options2.signal
    ]);
    setMaxListeners(Infinity, signal, queryEarlyExitController.signal);
    const log5 = this.logger.forComponent(`${this.logPrefix}:query:` + toString(key, "base58btc"));
    let queryFinished = false;
    try {
      if (this.routingTable.size === 0 && !this.allowQueryWithZeroPeers) {
        log5("routing table was empty, waiting for some peers before running%s query", options2.isSelfQuery === true ? " self" : "");
        await pEvent(this.routingTable, "peer:add", {
          signal,
          filter: (event) => !this.peerId.equals(event.detail)
        });
        log5("routing table has peers, continuing with%s query", options2.isSelfQuery === true ? " self" : "");
      }
      if (options2.isSelfQuery !== true && this.initialQuerySelfHasRun != null) {
        log5("waiting for initial self query before continuing");
        await raceSignal(this.initialQuerySelfHasRun.promise, signal);
        this.initialQuerySelfHasRun = void 0;
      }
      log5("query:start");
      const id = await convertBuffer(key, {
        signal
      });
      const peers = this.routingTable.closestPeers(id, {
        count: this.routingTable.kBucketSize
      });
      const peersToQuery = peers.sort(() => {
        if (Math.random() > 0.5) {
          return 1;
        }
        return -1;
      }).reduce((acc, curr, index) => {
        acc[index % this.disjointPaths].push(curr);
        return acc;
      }, new Array(this.disjointPaths).fill(0).map(() => [])).filter((peers2) => peers2.length > 0);
      if (peers.length === 0) {
        log5.error("running query with no peers");
        return;
      }
      const peersSeen = createScalableCuckooFilter(1024);
      const paths = peersToQuery.map((peer, index) => {
        return queryPath({
          ...options2,
          key,
          startingPeers: peer,
          ourPeerId: this.peerId,
          signal,
          query: queryFunc,
          path: index,
          numPaths: peersToQuery.length,
          alpha: this.alpha,
          log: log5,
          peersSeen,
          onProgress: options2.onProgress,
          connectionManager: this.connectionManager
        });
      });
      for await (const event of src_default2(...paths)) {
        if (event.name === "QUERY_ERROR") {
          log5.error("query error", event.error);
        }
        if (event.name === "PEER_RESPONSE") {
          for (const peer of [...event.closer, ...event.providers]) {
            if (!await this.connectionManager.isDialable(peer.multiaddrs, {
              signal
            })) {
              continue;
            }
            await this.routingTable.add(peer.id, {
              signal
            });
          }
        }
        signal.throwIfAborted();
        yield event;
      }
      queryFinished = true;
    } catch (err) {
      if (this.running) {
        throw err;
      }
    } finally {
      if (!queryFinished) {
        log5("query exited early");
        queryEarlyExitController.abort();
      }
      signal.clear();
      log5("query finished");
    }
  }
};

// node_modules/it-length/dist/src/index.js
function isAsyncIterable3(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function length14(source) {
  if (isAsyncIterable3(source)) {
    return (async () => {
      let count = 0;
      for await (const _ of source) {
        count++;
      }
      return count;
    })();
  } else {
    let count = 0;
    for (const _ of source) {
      count++;
    }
    return count;
  }
}
var src_default10 = length14;

// node_modules/@libp2p/kad-dht/dist/src/query-self.js
var QuerySelf = class {
  log;
  peerId;
  peerRouting;
  events;
  count;
  interval;
  initialInterval;
  queryTimeout;
  running;
  timeoutId;
  controller;
  initialQuerySelfHasRun;
  querySelfPromise;
  constructor(components, init) {
    this.peerId = components.peerId;
    this.log = components.logger.forComponent(`${init.logPrefix}:query-self`);
    this.events = components.events;
    this.running = false;
    this.peerRouting = init.peerRouting;
    this.count = init.count ?? K;
    this.interval = init.interval ?? QUERY_SELF_INTERVAL;
    this.initialInterval = init.initialInterval ?? QUERY_SELF_INITIAL_INTERVAL;
    this.queryTimeout = init.queryTimeout ?? QUERY_SELF_TIMEOUT;
    this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
    this.querySelf = timeOperationMethod(this.querySelf.bind(this), init.operationMetrics, "SELF_QUERY");
  }
  isStarted() {
    return this.running;
  }
  start() {
    if (this.running) {
      return;
    }
    this.running = true;
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      this.querySelf().catch((err) => {
        this.log.error("error running self-query", err);
      });
    }, this.initialInterval);
  }
  stop() {
    this.running = false;
    if (this.timeoutId != null) {
      clearTimeout(this.timeoutId);
    }
    if (this.controller != null) {
      this.controller.abort();
    }
  }
  async querySelf() {
    if (!this.running) {
      this.log("skip self-query because we are not started");
      return;
    }
    if (this.querySelfPromise != null) {
      this.log("joining existing self query");
      return this.querySelfPromise.promise;
    }
    this.querySelfPromise = pDefer();
    if (this.running) {
      this.controller = new AbortController();
      const signals = [this.controller.signal];
      if (this.initialQuerySelfHasRun == null) {
        const timeoutSignal = AbortSignal.timeout(this.queryTimeout);
        setMaxListeners(Infinity, timeoutSignal);
        signals.push(timeoutSignal);
      }
      const signal = anySignal(signals);
      setMaxListeners(Infinity, signal, this.controller.signal);
      try {
        this.log("run self-query, look for %d peers timing out after %dms", this.count, this.queryTimeout);
        const start2 = Date.now();
        const peers = await pipe(this.peerRouting.getClosestPeers(this.peerId.toMultihash().bytes, {
          signal,
          isSelfQuery: true
        }), (source) => src_default6(source, this.count), async (source) => src_default10(source));
        signal?.throwIfAborted();
        const duration = Date.now() - start2;
        this.log("self-query found %d peers in %dms", peers, duration);
        this.events.dispatchEvent(new CustomEvent("kad-dht:query:self", {
          detail: {
            peers,
            duration
          }
        }));
      } catch (err) {
        this.log.error("self-query error", err);
      } finally {
        signal.clear();
        if (this.initialQuerySelfHasRun != null) {
          this.initialQuerySelfHasRun.resolve();
          this.initialQuerySelfHasRun = void 0;
        }
      }
    }
    this.querySelfPromise.resolve();
    this.querySelfPromise = void 0;
    if (!this.running) {
      return;
    }
    this.timeoutId = setTimeout(() => {
      this.querySelf().catch((err) => {
        this.log.error("error running self-query", err);
      });
    }, this.interval);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/reprovider.js
var Reprovider = class extends TypedEventEmitter {
  log;
  reprovideQueue;
  maxQueueSize;
  datastore;
  timeout;
  reprovideTimeout;
  running;
  shutdownController;
  reprovideThreshold;
  contentRouting;
  datastorePrefix;
  addressManager;
  validity;
  interval;
  peerId;
  constructor(components, init) {
    super();
    this.log = components.logger.forComponent(`${init.logPrefix}:reprovider`);
    this.peerId = components.peerId;
    this.reprovideQueue = new Queue({
      concurrency: init.concurrency ?? REPROVIDE_CONCURRENCY,
      metrics: components.metrics,
      metricName: `${init.metricsPrefix}_reprovide_queue`
    });
    this.reprovideTimeout = new AdaptiveTimeout({
      ...init.timeout ?? {},
      metrics: components.metrics,
      metricName: `${init.metricsPrefix}_reprovide_timeout_milliseconds`
    });
    this.datastore = components.datastore;
    this.addressManager = components.addressManager;
    this.datastorePrefix = `${init.datastorePrefix}/provider`;
    this.reprovideThreshold = init.threshold ?? REPROVIDE_THRESHOLD;
    this.maxQueueSize = init.maxQueueSize ?? REPROVIDE_MAX_QUEUE_SIZE;
    this.validity = init.validity ?? PROVIDERS_VALIDITY;
    this.interval = init.interval ?? REPROVIDE_INTERVAL;
    this.contentRouting = init.contentRouting;
    this.running = false;
    this.reprovide = timeOperationMethod(this.reprovide.bind(this), init.operationMetrics, "PROVIDE");
  }
  start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    this.timeout = setTimeout(() => {
      this.cleanUp({
        signal: AbortSignal.timeout(REPROVIDE_TIMEOUT)
      }).catch((err) => {
        this.log.error("error running reprovide/cleanup - %e", err);
      });
    }, this.interval);
  }
  stop() {
    this.running = false;
    this.reprovideQueue.clear();
    clearTimeout(this.timeout);
    this.shutdownController?.abort();
  }
  /**
   * Check all provider records. Delete them if they have expired, reprovide
   * them if the provider is us and the expiry is within the reprovide window.
   */
  async cleanUp(options2) {
    try {
      this.safeDispatchEvent("reprovide:start");
      for await (const entry of this.datastore.query({
        prefix: this.datastorePrefix
      }, options2)) {
        try {
          const { cid, peerId: peerId2 } = parseProviderKey(entry.key);
          const created = readProviderTime(entry.value).getTime();
          const expires = created + this.validity;
          const now = Date.now();
          const expired = now > expires;
          this.log.trace("comparing: %d < %d = %s %s", created, now - this.validity, expired, expired ? "(expired)" : "");
          if (expired) {
            await this.datastore.delete(entry.key, options2);
          }
          if (this.peerId.equals(peerId2) && now - expires < this.reprovideThreshold) {
            this.queueReprovide(cid).catch((err) => {
              this.log.error("could not reprovide %c - %e", cid, err);
            });
          }
        } catch (err) {
          this.log.error("error processing datastore key %s - %e", entry.key, err.message);
        }
      }
      this.log("reprovide/cleanup successful");
    } finally {
      this.safeDispatchEvent("reprovide:end");
      if (this.running) {
        this.timeout = setTimeout(() => {
          this.cleanUp({
            signal: AbortSignal.timeout(REPROVIDE_TIMEOUT)
          }).catch((err) => {
            this.log.error("error running re-provide - %e", err);
          });
        }, this.interval);
      }
    }
  }
  async queueReprovide(cid, options2) {
    if (!this.running) {
      return;
    }
    this.log.trace("waiting for queue capacity before adding %c to re-provide queue", cid);
    await this.reprovideQueue.onSizeLessThan(this.maxQueueSize, options2);
    const existingJob = this.reprovideQueue.queue.find((job) => job.options.cid.equals(cid));
    if (existingJob != null) {
      this.log.trace("not adding %c to re-provide queue - already in queue", cid);
      return existingJob.join();
    }
    this.log.trace("adding %c to re-provide queue", cid);
    this.reprovideQueue.add(async (options3) => {
      options3.signal?.throwIfAborted();
      if (!this.running) {
        return;
      }
      this.log.trace("re-providing %c", cid);
      const signal = this.reprovideTimeout.getTimeoutSignal(options3);
      try {
        await this.reprovide(options3.cid, options3);
      } finally {
        this.reprovideTimeout.cleanUp(signal);
      }
      this.log.trace("re-provided %c", cid);
    }, {
      signal: this.shutdownController?.signal,
      cid
    }).catch((err) => {
      this.log.error("could not re-provide key %c - %e", cid, err);
    });
  }
  async reprovide(cid, options2) {
    await src_default(this.contentRouting.provide(cid, this.addressManager.getAddresses(), options2));
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/closest-peers.js
var PEER_SET_SIZE = 20;
var REFRESH_INTERVAL = 5e3;
var KAD_CLOSE_TAG_NAME = "kad-close";
var KAD_CLOSE_TAG_VALUE = 50;
var ClosestPeers = class {
  routingTable;
  components;
  closestPeers;
  newPeers;
  refreshInterval;
  peerSetSize;
  timeout;
  closeTagName;
  closeTagValue;
  log;
  running;
  constructor(components, init) {
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:routing-table`);
    this.routingTable = init.routingTable;
    this.refreshInterval = init.refreshInterval ?? REFRESH_INTERVAL;
    this.peerSetSize = init.peerSetSize ?? PEER_SET_SIZE;
    this.closeTagName = init.closeTagName ?? KAD_CLOSE_TAG_NAME;
    this.closeTagValue = init.closeTagValue ?? KAD_CLOSE_TAG_VALUE;
    this.closestPeers = new PeerSet();
    this.onPeerPing = this.onPeerPing.bind(this);
    this.running = false;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    const targetKadId = await convertPeerId(this.components.peerId);
    this.newPeers = new PeerDistanceList(targetKadId, this.peerSetSize);
    this.routingTable.addEventListener("peer:ping", this.onPeerPing);
    this.timeout = setInterval(() => {
      this.updatePeerTags().catch((err) => {
        this.log.error("error updating peer tags - %e", err);
      });
    }, this.refreshInterval);
  }
  stop() {
    this.running = false;
    this.routingTable.removeEventListener("peer:ping", this.onPeerPing);
    clearTimeout(this.timeout);
  }
  onPeerPing(event) {
    this.newPeers?.add({ id: event.detail, multiaddrs: [] }).catch((err) => {
      this.log.error("error adding peer to distance list - %e", err);
    });
  }
  async updatePeerTags() {
    const newClosest = new PeerSet(this.newPeers?.peers.map(({ peer }) => peer.id));
    const added = newClosest.difference(this.closestPeers);
    const removed = this.closestPeers.difference(newClosest);
    this.closestPeers = newClosest;
    await Promise.all([
      ...[...added].map(async (peerId2) => {
        await this.components.peerStore.merge(peerId2, {
          tags: {
            [this.closeTagName]: {
              value: this.closeTagValue
            },
            [KEEP_ALIVE_TAG2]: {
              value: 1
            }
          }
        });
      }),
      ...[...removed].map(async (peerId2) => {
        await this.components.peerStore.merge(peerId2, {
          tags: {
            [this.closeTagName]: void 0,
            [KEEP_ALIVE_TAG2]: void 0
          }
        });
      })
    ]);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/k-bucket.js
function isLeafBucket(obj) {
  return Array.isArray(obj?.peers);
}
var KBucket = class {
  peerId;
  root;
  localPeer;
  prefixLength;
  splitThreshold;
  kBucketSize;
  numberOfNodesToPing;
  lastPingThreshold;
  ping;
  verify;
  onAdd;
  onRemove;
  onMove;
  addingPeerMap;
  constructor(components, options2) {
    this.peerId = components.peerId;
    this.prefixLength = options2.prefixLength ?? PREFIX_LENGTH;
    this.kBucketSize = options2.kBucketSize ?? KBUCKET_SIZE;
    this.splitThreshold = options2.splitThreshold ?? this.kBucketSize;
    this.numberOfNodesToPing = options2.numberOfOldContactsToPing ?? PING_OLD_CONTACT_COUNT;
    this.lastPingThreshold = options2.lastPingThreshold ?? LAST_PING_THRESHOLD;
    this.ping = options2.ping;
    this.verify = options2.verify;
    this.onAdd = options2.onAdd;
    this.onRemove = options2.onRemove;
    this.addingPeerMap = trackedPeerMap({
      name: `${options2.metricsPrefix}_adding_peer_map`,
      metrics: components.metrics
    });
    this.root = {
      prefix: "",
      depth: 0,
      peers: []
    };
  }
  async start() {
    await this.addSelfPeer(this.peerId);
  }
  stop() {
    this.addingPeerMap.clear();
    this.root = {
      prefix: "",
      depth: 0,
      peers: []
    };
  }
  async addSelfPeer(peerId2, options2) {
    this.localPeer = {
      peerId: peerId2,
      kadId: await convertPeerId(peerId2, options2),
      lastPing: Date.now()
    };
  }
  /**
   * Adds a contact to the trie
   */
  async add(peerId2, options2) {
    const peer = {
      peerId: peerId2,
      kadId: await convertPeerId(peerId2, options2),
      lastPing: 0
    };
    const existingPromise = this.addingPeerMap.get(peerId2);
    if (existingPromise != null) {
      return existingPromise;
    }
    try {
      const p = this._add(peer, options2);
      this.addingPeerMap.set(peerId2, p);
      await p;
    } finally {
      this.addingPeerMap.delete(peerId2);
    }
  }
  async _add(peer, options2) {
    const bucket = this._determineBucket(peer.kadId);
    if (this._indexOf(bucket, peer.kadId) > -1) {
      return;
    }
    if (bucket.peers.length === this.splitThreshold && bucket.depth < this.prefixLength) {
      await this._split(bucket, options2);
      await this._add(peer, options2);
      return;
    }
    if (bucket.peers.length < this.kBucketSize) {
      if (!needsPing(peer, this.lastPingThreshold)) {
        bucket.peers.push(peer);
        await this.onAdd?.(peer, bucket, options2);
        return;
      }
      const result = await this.verify(peer, options2);
      if (result) {
        peer.lastPing = Date.now();
        await this._add(peer, options2);
      }
      return;
    }
    const toPing = bucket.peers.filter((peer2) => {
      if (peer2.peerId.equals(this.localPeer?.peerId)) {
        return false;
      }
      if (peer2.lastPing > Date.now() - this.lastPingThreshold) {
        return false;
      }
      return true;
    }).sort((a, b) => {
      if (a.lastPing < b.lastPing) {
        return -1;
      }
      if (a.lastPing > b.lastPing) {
        return 1;
      }
      return 0;
    }).slice(0, this.numberOfNodesToPing);
    let evicted = false;
    for await (const toEvict of this.ping(toPing, options2)) {
      evicted = true;
      await this.remove(toEvict.kadId, options2);
    }
    if (!evicted) {
      return;
    }
    await this._add(peer, options2);
  }
  /**
   * Get 0-n closest contacts to the provided node id. "Closest" here means:
   * closest according to the XOR metric of the contact node id.
   *
   * @param {Uint8Array} id - Contact node id
   * @returns {Generator<Peer, void, undefined>} Array Maximum of n closest contacts to the node id
   */
  *closest(id, options2) {
    const list = new PeerDistanceList(id, options2?.count ?? this.kBucketSize);
    for (const peer of this.toIterable()) {
      if (options2?.exclude?.some((p) => p.equals(peer.peerId)) === true) {
        continue;
      }
      list.addWithKadId({ id: peer.peerId, multiaddrs: [] }, peer.kadId);
    }
    yield* src_default5(list.peers, ({ peer }) => peer.id);
  }
  /**
   * Counts the total number of contacts in the tree.
   *
   * @returns {number} The number of contacts held in the tree
   */
  count() {
    function countBucket(bucket) {
      if (isLeafBucket(bucket)) {
        return bucket.peers.length;
      }
      let count = 0;
      if (bucket.left != null) {
        count += countBucket(bucket.left);
      }
      if (bucket.right != null) {
        count += countBucket(bucket.right);
      }
      return count;
    }
    return countBucket(this.root);
  }
  /**
   * Get a contact by its exact ID.
   * If this is a leaf, loop through the bucket contents and return the correct
   * contact if we have it or null if not. If this is an inner node, determine
   * which branch of the tree to traverse and repeat.
   *
   * @param {Uint8Array} kadId - The ID of the contact to fetch.
   * @returns {Peer | undefined} The contact if available, otherwise null
   */
  get(kadId) {
    const bucket = this._determineBucket(kadId);
    const index = this._indexOf(bucket, kadId);
    return bucket.peers[index];
  }
  /**
   * Removes contact with the provided id.
   *
   * @param {Uint8Array} kadId - The ID of the contact to remove
   */
  async remove(kadId, options2) {
    const bucket = this._determineBucket(kadId);
    const index = this._indexOf(bucket, kadId);
    if (index > -1) {
      const peer = bucket.peers.splice(index, 1)[0];
      await this.onRemove?.(peer, bucket, options2);
    }
  }
  /**
   * Similar to `toArray()` but instead of buffering everything up into an
   * array before returning it, yields contacts as they are encountered while
   * walking the tree.
   *
   * @returns {Iterable} All of the contacts in the tree, as an iterable
   */
  *toIterable() {
    function* iterate(bucket) {
      if (isLeafBucket(bucket)) {
        yield* bucket.peers;
        return;
      }
      yield* iterate(bucket.left);
      yield* iterate(bucket.right);
    }
    yield* iterate(this.root);
  }
  /**
   * Default distance function. Finds the XOR distance between firstId and
   * secondId.
   *
   * @param  {Uint8Array} firstId - Uint8Array containing first id.
   * @param  {Uint8Array} secondId - Uint8Array containing second id.
   * @returns {number} Integer The XOR distance between firstId and secondId.
   */
  distance(firstId, secondId) {
    return BigInt("0x" + toString(xor(firstId, secondId), "base16"));
  }
  /**
   * Determines whether the id at the bitIndex is 0 or 1
   * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
   *
   * @param {Uint8Array} kadId - Id to compare localNodeId with
   * @returns {LeafBucket} left leaf if id at bitIndex is 0, right leaf otherwise.
   */
  _determineBucket(kadId) {
    const bitString = toString(kadId, "base2");
    function findBucket(bucket, bitIndex = 0) {
      if (isLeafBucket(bucket)) {
        return bucket;
      }
      const bit = bitString[bitIndex];
      if (bit === "0") {
        return findBucket(bucket.left, bitIndex + 1);
      }
      return findBucket(bucket.right, bitIndex + 1);
    }
    return findBucket(this.root);
  }
  /**
   * Returns the index of the contact with provided
   * id if it exists, returns -1 otherwise.
   *
   * @param {object} bucket - internal object that has 2 leafs: left and right
   * @param {Uint8Array} kadId - KadId of peer
   * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.
   */
  _indexOf(bucket, kadId) {
    return bucket.peers.findIndex((peer) => equals(peer.kadId, kadId));
  }
  /**
   * Modify the bucket, turn it from a leaf bucket to an internal bucket
   *
   * @param {any} bucket - bucket for splitting
   */
  async _split(bucket, options2) {
    const left = {
      prefix: "0",
      depth: bucket.depth + 1,
      peers: []
    };
    const right = {
      prefix: "1",
      depth: bucket.depth + 1,
      peers: []
    };
    for (const peer of bucket.peers) {
      const bitString = toString(peer.kadId, "base2");
      if (bitString[bucket.depth] === "0") {
        left.peers.push(peer);
        await this.onMove?.(peer, bucket, left, options2);
      } else {
        right.peers.push(peer);
        await this.onMove?.(peer, bucket, right, options2);
      }
    }
    convertToInternalBucket(bucket, left, right);
  }
};
function convertToInternalBucket(bucket, left, right) {
  delete bucket.peers;
  bucket.left = left;
  bucket.right = right;
  if (bucket.prefix === "") {
    delete bucket.depth;
    delete bucket.prefix;
  }
  return true;
}
function needsPing(peer, threshold) {
  return peer.lastPing < Date.now() - threshold;
}

// node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js
var KBUCKET_SIZE = 20;
var PREFIX_LENGTH = 6;
var PING_NEW_CONTACT_CONCURRENCY = 20;
var PING_NEW_CONTACT_MAX_QUEUE_SIZE = 100;
var PING_OLD_CONTACT_COUNT = 3;
var PING_OLD_CONTACT_CONCURRENCY = 20;
var PING_OLD_CONTACT_MAX_QUEUE_SIZE = 100;
var KAD_PEER_TAG_NAME = "kad-peer";
var KAD_PEER_TAG_VALUE = 1;
var LAST_PING_THRESHOLD = 6e5;
var POPULATE_FROM_DATASTORE_ON_START = true;
var POPULATE_FROM_DATASTORE_LIMIT = 1e3;
var RoutingTable = class extends TypedEventEmitter {
  kBucketSize;
  kb;
  network;
  closestPeerTagger;
  log;
  components;
  running;
  pingNewContactTimeout;
  pingNewContactQueue;
  pingOldContactTimeout;
  pingOldContactQueue;
  populateFromDatastoreOnStart;
  populateFromDatastoreLimit;
  protocol;
  peerTagName;
  peerTagValue;
  metrics;
  shutdownController;
  constructor(components, init) {
    super();
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:routing-table`);
    this.kBucketSize = init.kBucketSize ?? KBUCKET_SIZE;
    this.running = false;
    this.protocol = init.protocol;
    this.network = init.network;
    this.peerTagName = init.peerTagName ?? KAD_PEER_TAG_NAME;
    this.peerTagValue = init.peerTagValue ?? KAD_PEER_TAG_VALUE;
    this.pingOldContacts = this.pingOldContacts.bind(this);
    this.verifyNewContact = this.verifyNewContact.bind(this);
    this.peerAdded = this.peerAdded.bind(this);
    this.peerRemoved = this.peerRemoved.bind(this);
    this.populateFromDatastoreOnStart = init.populateFromDatastoreOnStart ?? POPULATE_FROM_DATASTORE_ON_START;
    this.populateFromDatastoreLimit = init.populateFromDatastoreLimit ?? POPULATE_FROM_DATASTORE_LIMIT;
    this.shutdownController = new AbortController();
    this.pingOldContactQueue = new PeerQueue({
      concurrency: init.pingOldContactConcurrency ?? PING_OLD_CONTACT_CONCURRENCY,
      metricName: `${init.metricsPrefix}_ping_old_contact_queue`,
      metrics: this.components.metrics,
      maxSize: init.pingOldContactMaxQueueSize ?? PING_OLD_CONTACT_MAX_QUEUE_SIZE
    });
    this.pingOldContactTimeout = new AdaptiveTimeout({
      ...init.pingOldContactTimeout ?? {},
      metrics: this.components.metrics,
      metricName: `${init.metricsPrefix}_routing_table_ping_old_contact_time_milliseconds`
    });
    this.pingNewContactQueue = new PeerQueue({
      concurrency: init.pingNewContactConcurrency ?? PING_NEW_CONTACT_CONCURRENCY,
      metricName: `${init.metricsPrefix}_ping_new_contact_queue`,
      metrics: this.components.metrics,
      maxSize: init.pingNewContactMaxQueueSize ?? PING_NEW_CONTACT_MAX_QUEUE_SIZE
    });
    this.pingNewContactTimeout = new AdaptiveTimeout({
      ...init.pingNewContactTimeout ?? {},
      metrics: this.components.metrics,
      metricName: `${init.metricsPrefix}_routing_table_ping_new_contact_time_milliseconds`
    });
    this.kb = new KBucket(components, {
      kBucketSize: init.kBucketSize,
      prefixLength: init.prefixLength,
      splitThreshold: init.splitThreshold,
      numberOfOldContactsToPing: init.numberOfOldContactsToPing,
      lastPingThreshold: init.lastPingThreshold,
      ping: this.pingOldContacts,
      verify: this.verifyNewContact,
      onAdd: this.peerAdded,
      onRemove: this.peerRemoved,
      metricsPrefix: init.metricsPrefix
    });
    this.closestPeerTagger = new ClosestPeers(this.components, {
      logPrefix: init.logPrefix,
      routingTable: this,
      peerSetSize: init.closestPeerSetSize,
      refreshInterval: init.closestPeerSetRefreshInterval,
      closeTagName: init.closeTagName,
      closeTagValue: init.closeTagValue
    });
    if (this.components.metrics != null) {
      this.metrics = {
        routingTableSize: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_size`),
        routingTableKadBucketTotal: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_total`),
        routingTableKadBucketAverageOccupancy: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_average_occupancy`),
        routingTableKadBucketMinOccupancy: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_min_occupancy`),
        routingTableKadBucketMaxOccupancy: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_max_occupancy`),
        routingTableKadBucketMaxDepth: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_max_depth`),
        kadBucketEvents: this.components.metrics.registerCounterGroup(`${init.metricsPrefix}_kad_bucket_events_total`)
      };
    }
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this.shutdownController = new AbortController();
    await start(this.closestPeerTagger, this.kb);
  }
  async afterStart() {
    let peerStorePeers = 0;
    Promise.resolve().then(async () => {
      if (!this.populateFromDatastoreOnStart) {
        return;
      }
      const signal = anySignal([
        this.shutdownController.signal,
        AbortSignal.timeout(2e4)
      ]);
      setMaxListeners(Infinity, signal);
      try {
        for (const peer of await this.components.peerStore.all({
          filters: [(peer2) => {
            return peer2.protocols.includes(this.protocol) && peer2.tags.has(KAD_PEER_TAG_NAME);
          }],
          limit: this.populateFromDatastoreLimit,
          signal
        })) {
          if (!this.running) {
            return;
          }
          try {
            await this.add(peer.id, {
              signal
            });
            peerStorePeers++;
          } catch (err) {
            this.log("failed to add peer %p to routing table, removing kad-dht peer tags - %e");
            await this.components.peerStore.merge(peer.id, {
              tags: {
                [this.peerTagName]: void 0
              }
            });
          }
        }
      } finally {
        signal.clear();
      }
      this.log("added %d peer store peers to the routing table", peerStorePeers);
    }).catch((err) => {
      this.log.error("error adding %d, peer store peers to the routing table - %e", peerStorePeers, err);
    });
  }
  async stop() {
    this.running = false;
    await stop(this.closestPeerTagger, this.kb);
    this.pingOldContactQueue.abort();
    this.pingNewContactQueue.abort();
    this.shutdownController.abort();
  }
  async peerAdded(peer, bucket, options2) {
    if (!this.components.peerId.equals(peer.peerId)) {
      await this.components.peerStore.merge(peer.peerId, {
        tags: {
          [this.peerTagName]: {
            value: this.peerTagValue
          }
        }
      }, options2);
    }
    this.updateMetrics();
    this.metrics?.kadBucketEvents.increment({ peer_added: true });
    this.safeDispatchEvent("peer:add", { detail: peer.peerId });
  }
  async peerRemoved(peer, bucket, options2) {
    if (!this.components.peerId.equals(peer.peerId)) {
      await this.components.peerStore.merge(peer.peerId, {
        tags: {
          [this.peerTagName]: void 0
        }
      }, options2);
    }
    this.updateMetrics();
    this.metrics?.kadBucketEvents.increment({ peer_removed: true });
    this.safeDispatchEvent("peer:remove", { detail: peer.peerId });
  }
  /**
   * Called on the `ping` event from `k-bucket` when a bucket is full
   * and cannot split.
   *
   * `oldContacts.length` is defined by the `numberOfNodesToPing` param
   * passed to the `k-bucket` constructor.
   *
   * `oldContacts` will not be empty and is the list of contacts that
   * have not been contacted for the longest.
   */
  async *pingOldContacts(oldContacts, options2) {
    if (!this.running) {
      return;
    }
    const jobs = [];
    for (const oldContact of oldContacts) {
      if (this.kb.get(oldContact.kadId) == null) {
        this.log("asked to ping contact %p that was not in routing table", oldContact.peerId);
        continue;
      }
      this.metrics?.kadBucketEvents.increment({ ping_old_contact: true });
      jobs.push(async () => {
        const existingJob = this.pingOldContactQueue.find(oldContact.peerId);
        if (existingJob != null) {
          this.log("asked to ping contact %p was already being pinged", oldContact.peerId);
          const result2 = await existingJob.join(options2);
          if (!result2) {
            return oldContact;
          }
          return;
        }
        const result = await this.pingOldContactQueue.add(async (options3) => {
          const signal = this.pingOldContactTimeout.getTimeoutSignal();
          const signals = anySignal([
            signal,
            this.shutdownController.signal,
            options3?.signal
          ]);
          setMaxListeners(Infinity, signal, signals);
          try {
            return await this.pingContact(oldContact, options3);
          } catch {
            this.metrics?.kadBucketEvents.increment({ ping_old_contact_error: true });
            return true;
          } finally {
            this.pingOldContactTimeout.cleanUp(signal);
            signals.clear();
          }
        }, {
          peerId: oldContact.peerId,
          signal: options2?.signal
        });
        if (!result) {
          return oldContact;
        }
      });
    }
    for await (const peer of parallel(jobs)) {
      if (peer != null) {
        yield peer;
      }
    }
  }
  async verifyNewContact(contact, options2) {
    const signal = this.pingNewContactTimeout.getTimeoutSignal();
    const signals = anySignal([
      signal,
      this.shutdownController.signal,
      options2?.signal
    ]);
    setMaxListeners(Infinity, signal, signals);
    try {
      const job = this.pingNewContactQueue.find(contact.peerId);
      if (job != null) {
        this.log("joining existing ping to add new peer %p to routing table", contact.peerId);
        return await job.join({
          signal: signals
        });
      } else {
        return await this.pingNewContactQueue.add(async (options3) => {
          this.metrics?.kadBucketEvents.increment({ ping_new_contact: true });
          this.log("pinging new peer %p before adding to routing table", contact.peerId);
          return this.pingContact(contact, options3);
        }, {
          peerId: contact.peerId,
          signal: signals
        });
      }
    } catch (err) {
      this.log.trace("tried to add peer %p but they were not online", contact.peerId);
      this.metrics?.kadBucketEvents.increment({ ping_new_contact_error: true });
      return false;
    } finally {
      this.pingNewContactTimeout.cleanUp(signal);
      signals.clear();
    }
  }
  async pingContact(contact, options2) {
    let stream;
    try {
      this.log("pinging contact %p", contact.peerId);
      await this.components.ping.ping(contact.peerId, options2);
      this.log("contact %p ping ok", contact.peerId);
      this.safeDispatchEvent("peer:ping", {
        detail: contact.peerId
      });
      return true;
    } catch (err) {
      this.log("error pinging old contact %p - %e", contact.peerId, err);
      stream?.abort(err);
      return false;
    }
  }
  /**
   * Amount of currently stored peers
   */
  get size() {
    if (this.kb == null) {
      return 0;
    }
    return this.kb.count();
  }
  /**
   * Find a specific peer by id
   */
  async find(peer, options2) {
    const kadId = await convertPeerId(peer, options2);
    return this.kb.get(kadId)?.peerId;
  }
  /**
   * Retrieve the closest peers to the given kadId
   */
  closestPeer(kadId) {
    const res = this.closestPeers(kadId, {
      count: 1
    });
    if (res.length > 0) {
      return res[0];
    }
    return void 0;
  }
  /**
   * Retrieve the `count`-closest peers to the given kadId
   */
  closestPeers(kadId, options2) {
    if (this.kb == null) {
      return [];
    }
    return [...this.kb.closest(kadId, options2)];
  }
  /**
   * Add or update the routing table with the given peer
   */
  async add(peerId2, options2) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    await this.kb.add(peerId2, options2);
  }
  /**
   * Remove a given peer from the table
   */
  async remove(peer, options2) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const kadId = await convertPeerId(peer, options2);
    await this.kb.remove(kadId, options2);
  }
  updateMetrics() {
    if (this.metrics == null || this.kb == null) {
      return;
    }
    let size = 0;
    let buckets = 0;
    let maxDepth = 0;
    let minOccupancy = 20;
    let maxOccupancy = 0;
    function count(bucket) {
      if (isLeafBucket(bucket)) {
        if (bucket.depth > maxDepth) {
          maxDepth = bucket.depth;
        }
        buckets++;
        size += bucket.peers.length;
        if (bucket.peers.length < minOccupancy) {
          minOccupancy = bucket.peers.length;
        }
        if (bucket.peers.length > maxOccupancy) {
          maxOccupancy = bucket.peers.length;
        }
        return;
      }
      count(bucket.left);
      count(bucket.right);
    }
    count(this.kb.root);
    this.metrics.routingTableSize.update(size);
    this.metrics.routingTableKadBucketTotal.update(buckets);
    this.metrics.routingTableKadBucketAverageOccupancy.update(Math.round(size / buckets));
    this.metrics.routingTableKadBucketMinOccupancy.update(minOccupancy);
    this.metrics.routingTableKadBucketMaxOccupancy.update(maxOccupancy);
    this.metrics.routingTableKadBucketMaxDepth.update(maxDepth);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/generated-prefix-list-browser.js
var generated_prefix_list_browser_default = [
  77591,
  22417,
  43971,
  28421,
  740,
  29829,
  71467,
  228973,
  196661,
  78537,
  27689,
  36431,
  44415,
  14362,
  19456,
  106025,
  96308,
  2882,
  49509,
  21149,
  87173,
  131409,
  75844,
  23676,
  121838,
  30291,
  17492,
  2953,
  7564,
  110620,
  129477,
  127283,
  53113,
  72417,
  165166,
  109690,
  21200,
  102125,
  24049,
  71504,
  90342,
  25307,
  72039,
  26812,
  26715,
  32264,
  133800,
  71161,
  88956,
  171987,
  51779,
  24425,
  16671,
  30251,
  186294,
  247761,
  14202,
  2121,
  8465,
  35024,
  4876,
  85917,
  169730,
  3638,
  256836,
  96184,
  943,
  18678,
  6583,
  52907,
  35807,
  112254,
  214097,
  18796,
  11595,
  9243,
  23554,
  887,
  268203,
  382004,
  24590,
  111335,
  11625,
  16619,
  29039,
  102425,
  69006,
  97976,
  92362,
  32552,
  63717,
  41433,
  128974,
  137630,
  59943,
  10019,
  13986,
  35430,
  33665,
  108037,
  43799,
  43280,
  38195,
  29078,
  58629,
  18265,
  14425,
  46832,
  235538,
  40830,
  77881,
  110717,
  58937,
  3463,
  325358,
  51300,
  47623,
  117252,
  19007,
  10170,
  20540,
  91237,
  294813,
  4951,
  79841,
  56232,
  36270,
  128547,
  69209,
  66275,
  100156,
  32063,
  73531,
  34439,
  80937,
  28892,
  44466,
  88595,
  216307,
  32583,
  49620,
  16605,
  82127,
  45807,
  21630,
  78726,
  20235,
  40163,
  111007,
  96926,
  5567,
  72083,
  21665,
  58844,
  39419,
  179767,
  48328,
  42662,
  51550,
  5251,
  37811,
  49608,
  81056,
  50854,
  55513,
  20922,
  18891,
  197409,
  164656,
  32593,
  71449,
  220474,
  58919,
  85682,
  67854,
  13758,
  35066,
  3565,
  61905,
  214793,
  119572,
  141419,
  21504,
  10302,
  27354,
  67003,
  46131,
  32668,
  15165,
  64871,
  34450,
  17821,
  2757,
  11452,
  34189,
  5160,
  12257,
  85523,
  560,
  53385,
  65887,
  119549,
  135620,
  312353,
  115979,
  122356,
  10867,
  193231,
  124537,
  54783,
  90675,
  120791,
  4715,
  142253,
  50943,
  17271,
  43358,
  25331,
  4917,
  120566,
  34580,
  12878,
  33786,
  160528,
  32523,
  4869,
  301307,
  104817,
  81491,
  23276,
  8832,
  97911,
  31265,
  52065,
  7998,
  49622,
  9715,
  43998,
  34091,
  84587,
  20664,
  69041,
  29419,
  53205,
  10838,
  58288,
  116145,
  6185,
  5154,
  141795,
  35924,
  21307,
  144738,
  43730,
  12085,
  8279,
  10002,
  119,
  133779,
  199668,
  72938,
  31768,
  39176,
  67875,
  38453,
  9700,
  44144,
  4121,
  116048,
  41733,
  12868,
  82669,
  92308,
  128,
  34262,
  11332,
  7712,
  90764,
  36141,
  13553,
  71312,
  77470,
  117314,
  96549,
  49135,
  23602,
  54468,
  28605,
  6327,
  62308,
  17171,
  67531,
  21319,
  14105,
  894,
  107722,
  46157,
  8503,
  51069,
  100472,
  45138,
  15246,
  14577,
  35609,
  191464,
  1757,
  13364,
  161349,
  32067,
  91705,
  81144,
  52339,
  5408,
  91066,
  21983,
  14157,
  100545,
  4372,
  26630,
  129112,
  1423,
  29676,
  213626,
  4397,
  88436,
  99190,
  6877,
  49958,
  26122,
  114348,
  60661,
  29818,
  293118,
  50042,
  179738,
  16400,
  163423,
  89627,
  31040,
  43973,
  36638,
  45952,
  5153,
  1894,
  109322,
  1898,
  134021,
  12402,
  112077,
  68309,
  190269,
  69866,
  31938,
  107383,
  11522,
  105232,
  11248,
  14868,
  39852,
  71707,
  186525,
  16530,
  38162,
  106212,
  11700,
  5130,
  16608,
  26998,
  59586,
  108399,
  230033,
  43683,
  48135,
  82179,
  2073,
  5015,
  196684,
  189293,
  16378,
  23452,
  8301,
  35640,
  11632,
  214551,
  29240,
  57644,
  33137,
  91949,
  55157,
  52384,
  117313,
  5090,
  17717,
  89668,
  49363,
  82238,
  241035,
  66216,
  29066,
  184088,
  97206,
  62820,
  26595,
  4241,
  135635,
  173672,
  8202,
  459,
  71355,
  146294,
  29587,
  3008,
  135385,
  141203,
  14803,
  6634,
  45094,
  69362,
  50925,
  546,
  51884,
  62011,
  83296,
  234584,
  44515,
  56050,
  89476,
  87751,
  19373,
  12691,
  149923,
  19794,
  13833,
  35846,
  87557,
  58339,
  2884,
  19145,
  25647,
  12224,
  11024,
  77338,
  64608,
  122297,
  53025,
  7205,
  36189,
  36294,
  170779,
  21750,
  7739,
  173883,
  75192,
  35664,
  224240,
  113121,
  30181,
  26267,
  27036,
  117827,
  92015,
  106516,
  55628,
  203549,
  67949,
  60462,
  60844,
  35911,
  20457,
  1820,
  920,
  19773,
  8738,
  73173,
  181993,
  38521,
  98254,
  76257,
  46008,
  92796,
  5384,
  26868,
  151566,
  22124,
  2411,
  15919,
  186872,
  180021,
  28099,
  152961,
  78811,
  80237,
  62352,
  102653,
  74259,
  184890,
  16792,
  123702,
  224945,
  29940,
  19512,
  75283,
  14059,
  112691,
  92811,
  233329,
  20411,
  138569,
  53341,
  109802,
  50600,
  134528,
  66747,
  5529,
  166531,
  31578,
  64732,
  67189,
  1596,
  126357,
  967,
  167999,
  206598,
  109752,
  119431,
  207825,
  78791,
  91938,
  10301,
  27311,
  24233,
  252343,
  28831,
  32812,
  66002,
  112267,
  90895,
  8786,
  8095,
  16824,
  22866,
  21813,
  60507,
  174833,
  19549,
  130985,
  117051,
  52110,
  6938,
  81923,
  123864,
  38061,
  919,
  18680,
  53534,
  46739,
  112893,
  161529,
  85429,
  26761,
  11900,
  81121,
  91968,
  15390,
  217947,
  56524,
  1713,
  6654,
  37089,
  85630,
  138866,
  61850,
  16491,
  75577,
  16884,
  98296,
  73523,
  6140,
  44645,
  6062,
  36366,
  29844,
  57946,
  37932,
  42472,
  5266,
  20834,
  19309,
  33753,
  127182,
  134259,
  35810,
  41805,
  45878,
  312001,
  14881,
  47757,
  49251,
  120050,
  44252,
  3708,
  25856,
  107864,
  120347,
  1228,
  36550,
  41682,
  34496,
  47025,
  8393,
  173365,
  246526,
  12894,
  161607,
  35670,
  90785,
  126572,
  2095,
  124731,
  157033,
  58694,
  554,
  12786,
  9642,
  4817,
  16136,
  47864,
  174698,
  66992,
  4639,
  69284,
  10625,
  40710,
  27763,
  51738,
  30404,
  264105,
  137904,
  109882,
  52487,
  42824,
  57514,
  2740,
  10479,
  146799,
  107390,
  16586,
  88038,
  174951,
  9410,
  16185,
  44158,
  5568,
  40658,
  46108,
  12763,
  97385,
  26175,
  108859,
  664,
  230732,
  67470,
  46663,
  14395,
  50750,
  141320,
  93140,
  15361,
  47997,
  55784,
  6791,
  307840,
  118569,
  107326,
  18056,
  58281,
  260415,
  54691,
  8790,
  73332,
  45633,
  7511,
  45674,
  143373,
  14031,
  11799,
  94491,
  35646,
  96544,
  14560,
  26049,
  32983,
  25791,
  83814,
  42094,
  231370,
  63955,
  139212,
  2359,
  169908,
  3108,
  183486,
  105867,
  28197,
  32941,
  124968,
  26402,
  88267,
  149768,
  23053,
  3078,
  19091,
  52924,
  25383,
  19209,
  111548,
  97361,
  3959,
  24880,
  235061,
  9099,
  24921,
  161254,
  151405,
  20508,
  7159,
  34381,
  20133,
  11434,
  74036,
  19974,
  34769,
  36585,
  1076,
  22454,
  17354,
  38727,
  235160,
  111547,
  96454,
  117448,
  156940,
  91330,
  37299,
  7310,
  26915,
  117060,
  51369,
  22620,
  61861,
  322264,
  106850,
  111694,
  15091,
  2624,
  40345,
  300446,
  177064,
  1707,
  27389,
  54792,
  327783,
  132669,
  183543,
  59003,
  17744,
  20603,
  151134,
  106923,
  53084,
  71803,
  279424,
  319816,
  11579,
  21946,
  16728,
  38274,
  72711,
  5085,
  83391,
  88646,
  40159,
  25027,
  34680,
  10752,
  12988,
  54126,
  30365,
  18338,
  100445,
  230674,
  44874,
  84974,
  143877,
  123253,
  139372,
  28082,
  91477,
  144002,
  13096,
  219729,
  46016,
  50029,
  42377,
  14601,
  6660,
  58244,
  58978,
  23918,
  88206,
  113611,
  64452,
  17541,
  41032,
  10942,
  12021,
  49189,
  10978,
  40175,
  37156,
  10947,
  71709,
  106894,
  112538,
  57007,
  137486,
  150608,
  152719,
  40615,
  7746,
  279716,
  13101,
  19524,
  28708,
  40578,
  72320,
  1096,
  182051,
  94527,
  51275,
  22833,
  45164,
  81917,
  77519,
  48508,
  5421,
  140302,
  37845,
  149830,
  5587,
  27579,
  5357,
  428725,
  248187,
  6326,
  206760,
  39814,
  32585,
  89923,
  44341,
  288753,
  284443,
  96368,
  31201,
  94189,
  119504,
  20359,
  52073,
  103216,
  179,
  27934,
  32801,
  96035,
  34111,
  34309,
  101326,
  18198,
  20704,
  210266,
  37643,
  27880,
  141873,
  106e3,
  19414,
  56614,
  167714,
  66483,
  107885,
  86602,
  4379,
  20796,
  75467,
  4987,
  5017,
  118857,
  26003,
  34308,
  114428,
  29198,
  6686,
  29697,
  73632,
  3739,
  69795,
  16798,
  41504,
  7207,
  30722,
  21436,
  36735,
  28067,
  28545,
  3239,
  11221,
  36031,
  41889,
  100010,
  19247,
  317673,
  29495,
  174554,
  6424,
  129725,
  53845,
  94986,
  7955,
  59676,
  2604,
  191497,
  19735,
  102214,
  62954,
  23844,
  11872,
  179525,
  261436,
  34492,
  428,
  78404,
  142035,
  16747,
  17246,
  27578,
  37021,
  33672,
  57944,
  26056,
  135760,
  2369,
  61674,
  122066,
  31327,
  19374,
  157065,
  40553,
  130982,
  69619,
  71290,
  38855,
  72100,
  92903,
  95940,
  51422,
  165999,
  65713,
  57873,
  50726,
  7288,
  20272,
  2081,
  42326,
  22624,
  81120,
  57914,
  79352,
  19447,
  1684,
  72302,
  11774,
  302559,
  161481,
  96396,
  13692,
  414988,
  3721,
  79066,
  56627,
  46883,
  21150,
  11747,
  12184,
  5856,
  113458,
  176117,
  84416,
  52079,
  27933,
  3354,
  59765,
  141359,
  2212,
  216309,
  2555,
  23458,
  196722,
  142463,
  45701,
  44548,
  28798,
  19418,
  215,
  29916,
  9396,
  10574,
  114226,
  84475,
  13520,
  18694,
  34056,
  4524,
  90302,
  62930,
  13539,
  19407,
  77209,
  7728,
  38088,
  9535,
  2263,
  23875,
  183945,
  17750,
  26274,
  67172,
  10585,
  28042,
  22199,
  7478,
  51331,
  66030,
  26774,
  192929,
  31434,
  25850,
  50197,
  52926,
  178158,
  4679,
  181256,
  70184,
  229600,
  9959,
  105594,
  72158,
  73974,
  2726,
  35085,
  78087,
  23284,
  35568,
  51713,
  155676,
  5401,
  27254,
  11966,
  17569,
  223253,
  71993,
  103357,
  111477,
  55722,
  30504,
  26034,
  46774,
  35392,
  36285,
  214814,
  41143,
  163465,
  1051,
  16094,
  81044,
  6636,
  76489,
  179102,
  20712,
  39178,
  35683,
  125177,
  54219,
  30617,
  52994,
  25324,
  50123,
  2543,
  87529,
  58995,
  10688,
  125199,
  12388,
  60158,
  125481,
  131646,
  7642,
  133350,
  65874,
  3438,
  97277,
  101450,
  10075,
  56344,
  116821,
  50778,
  60547,
  98016,
  106135,
  13859,
  14255,
  16300,
  77373,
  173521,
  8285,
  45932,
  37426,
  4054,
  114295,
  55947,
  7703,
  39114,
  52,
  51119,
  128135,
  19714,
  60715,
  9554,
  50492,
  88180,
  2823,
  118271,
  52993,
  122625,
  97919,
  23859,
  37895,
  25040,
  33614,
  32102,
  20431,
  3577,
  9275,
  15686,
  43031,
  157741,
  110358,
  1884,
  40291,
  125391,
  13736,
  5008,
  64881,
  87336,
  77381,
  70711,
  43032,
  49155,
  118587,
  70494,
  4318,
  10168,
  30126,
  12580,
  10524,
  280104,
  104001,
  145413,
  2862,
  84140,
  6603,
  106005,
  13566,
  12780,
  11251,
  42830,
  571,
  179910,
  82443,
  13146,
  469,
  42714,
  32591,
  265217,
  424024,
  92553,
  54721,
  134100,
  6007,
  15242,
  114681,
  59030,
  16718,
  85465,
  200214,
  85982,
  55174,
  165013,
  23493,
  56964,
  82529,
  109150,
  32706,
  27568,
  82442,
  5350,
  14976,
  13165,
  44890,
  60021,
  21343,
  33978,
  17264,
  4655,
  22328,
  27819,
  75730,
  16567,
  55483,
  14510,
  17926,
  45827,
  150609,
  3704,
  7385,
  272531,
  161543,
  76904,
  122163,
  52405,
  2039,
  19165,
  41623,
  14423,
  228354,
  3369,
  176360,
  85491,
  7122,
  35789,
  303724,
  4465,
  13628,
  2233,
  55311,
  118771,
  20713,
  10006,
  221519,
  45115,
  71021,
  35650,
  29775,
  7337,
  10864,
  20665,
  21142,
  1746,
  15080,
  1624,
  32449,
  10905,
  105743,
  229797,
  7701,
  3940,
  22997,
  178467,
  57208,
  389057,
  39683,
  59403,
  63344,
  63125,
  54847,
  69691,
  18336,
  56448,
  3362,
  37202,
  18282,
  29648,
  138224,
  35867,
  10495,
  5911,
  28814,
  26653,
  31514,
  176702,
  26550,
  45621,
  11734,
  4525,
  40543,
  73944,
  121080,
  27858,
  155561,
  14887,
  44670,
  30742,
  8796,
  107455,
  113472,
  56369,
  75581,
  183777,
  240095,
  133699,
  153299,
  8768,
  160464,
  26058,
  49078,
  103971,
  21875,
  71486,
  44888,
  17156,
  9678,
  89541,
  123019,
  102337,
  3972,
  83930,
  21245,
  87852,
  109660,
  287918,
  183019,
  686,
  10100,
  39177,
  283941,
  11274,
  24736,
  26793,
  26214,
  25995,
  77011,
  141580,
  4070,
  23742,
  46285,
  46632,
  30700,
  26669,
  19056,
  35951,
  115575,
  174034,
  56097,
  35463,
  87425,
  24575,
  44245,
  38701,
  82317,
  85922,
  281616,
  100333,
  147697,
  61503,
  7730,
  84330,
  8530,
  59917,
  61597,
  17173,
  9092,
  32658,
  90288,
  193136,
  39023,
  20381,
  56654,
  31132,
  7779,
  1919,
  1375,
  117128,
  30819,
  11169,
  40938,
  23935,
  115201,
  101155,
  151034,
  4835,
  11231,
  74550,
  89388,
  59951,
  91704,
  107312,
  167882,
  115062,
  12732,
  72738,
  88703,
  464019,
  158267,
  57995,
  60496,
  737,
  14371,
  123867,
  4174,
  243339,
  159946,
  7568,
  16025,
  134556,
  110916,
  38103,
  191,
  80226,
  88794,
  29688,
  27230,
  10454,
  76308,
  57647,
  77409,
  113483,
  66864,
  14745,
  19808,
  12023,
  46583,
  84805,
  16015,
  17102,
  2231,
  20611,
  3547,
  95740,
  250131,
  34559,
  108894,
  8498,
  15853,
  159169,
  148920,
  20942,
  2813,
  93160,
  45188,
  210613,
  45531,
  52587,
  149062,
  39782,
  28194,
  57849,
  60965,
  84954,
  89766,
  84453,
  100927,
  16501,
  27658,
  165311,
  103841,
  54192,
  207341,
  19558,
  20084,
  319622,
  5672,
  205467,
  98462,
  61849,
  36279,
  13609,
  147177,
  24726,
  165015,
  209489,
  59591,
  31157,
  6551,
  117580,
  75060,
  141146,
  277310,
  21072,
  22023,
  106474,
  63041,
  137443,
  122965,
  68371,
  5383,
  42146,
  98961,
  113467,
  30863,
  23794,
  4843,
  99630,
  30392,
  82679,
  13699,
  241612,
  33601,
  93146,
  24319,
  18643,
  32155,
  95669,
  40440,
  15333,
  34089,
  67799,
  142144,
  58245,
  38633,
  114531,
  117400,
  77861,
  188726,
  5507,
  2568,
  8853,
  10987,
  107222,
  2663,
  2421,
  11530,
  13345,
  30075,
  41785,
  118661,
  104786,
  17459,
  12490,
  16281,
  71936,
  193555,
  17431,
  5944,
  71758,
  26485,
  77317,
  20803,
  367167,
  158,
  7362,
  93430,
  11735,
  172445,
  46002,
  11532,
  54482,
  930,
  62911,
  2235,
  23004,
  179236,
  4764,
  101859,
  208113,
  22477,
  55163,
  95579,
  14098,
  67320,
  162556,
  90709,
  156949,
  3826,
  57492,
  4025,
  34092,
  87442,
  104565,
  6718,
  186015,
  28214,
  14209,
  10039,
  107186,
  233912,
  58877,
  81637,
  55265,
  39828,
  6194,
  145813,
  50831,
  105849,
  4974,
  88319,
  122296,
  10272,
  197216,
  95714,
  51540,
  72418,
  23324,
  91555,
  8743,
  140452,
  250249,
  51666,
  34124,
  7229,
  38592,
  129641,
  78169,
  174242,
  22464,
  149964,
  51450,
  14034,
  10026,
  95376,
  26190,
  120062,
  14401,
  8700,
  265,
  31386,
  143573,
  7203,
  229889,
  61567,
  4227,
  140981,
  2466,
  72052,
  10787,
  10062,
  30958,
  6099,
  38471,
  30103,
  23202,
  208101,
  70847,
  467,
  58934,
  32271,
  32984,
  36637,
  24107,
  30771,
  17109,
  73353,
  13650,
  2098,
  157040,
  67366,
  66904,
  106018,
  265380,
  107238,
  18535,
  44025,
  32681,
  144983,
  62505,
  91295,
  56120,
  3082,
  77508,
  10322,
  63023,
  36700,
  81885,
  224127,
  16721,
  45023,
  239261,
  111272,
  13852,
  7866,
  149243,
  204199,
  32309,
  22084,
  42029,
  38316,
  126644,
  104973,
  14406,
  43454,
  67322,
  61310,
  15789,
  40285,
  24026,
  181047,
  6301,
  70927,
  23319,
  115823,
  27248,
  66693,
  115875,
  278566,
  63007,
  146844,
  56841,
  59007,
  87368,
  180001,
  22370,
  42114,
  80605,
  12022,
  10374,
  308,
  25079,
  14689,
  12618,
  63368,
  7936,
  264973,
  212291,
  136713,
  95999,
  105801,
  18965,
  32075,
  48700,
  52230,
  35119,
  96912,
  32992,
  8586,
  16606,
  101333,
  101812,
  14969,
  39930,
  759,
  193090,
  27387,
  42914,
  12937,
  5058,
  62646,
  64528,
  38624,
  25743,
  37502,
  3716,
  4435,
  30352,
  178687,
  26461,
  132611,
  42002,
  138442,
  35833,
  59582,
  16345,
  8048,
  60319,
  49349,
  309,
  47800,
  49739,
  90482,
  26405,
  34470,
  63786,
  32479,
  85028,
  39866,
  47846,
  11649,
  23934,
  29466,
  2816,
  42864,
  31828,
  7410,
  74885,
  49632,
  47629,
  111801,
  90749,
  19536,
  18767,
  105764,
  59606,
  21223,
  10746,
  76298,
  22220,
  39408,
  7190,
  79654,
  64856,
  11602,
  82156,
  272765,
  17079,
  70089,
  245473,
  51813,
  184407,
  384678,
  1576,
  122249,
  5064,
  27481,
  6188,
  25790,
  74361,
  27541,
  318284,
  45430,
  31488,
  620,
  93579,
  45723,
  192118,
  22670,
  51913,
  4162,
  70244,
  35966,
  26397,
  16199,
  50899,
  209613,
  121702,
  287507,
  2993,
  36101,
  132229,
  67345,
  33062,
  76295,
  118628,
  78705,
  52316,
  34375,
  107083,
  107454,
  44863,
  127561,
  33964,
  3073,
  154010,
  190914,
  55967,
  39074,
  6272,
  31047,
  5550,
  41123,
  26154,
  98638,
  47110,
  19998,
  148091,
  50229,
  31329,
  59900,
  195442,
  19106,
  61347,
  73497,
  70015,
  682,
  45850,
  25776,
  38022,
  148951,
  6288,
  37411,
  232526,
  109277,
  27286,
  32342,
  9262,
  5220,
  16651,
  23175,
  46740,
  129438,
  78614,
  121925,
  66914,
  88710,
  127952,
  5563,
  21500,
  34521,
  10739,
  14863,
  191006,
  62956,
  17359,
  16749,
  67027,
  56284,
  69134,
  43301,
  35039,
  58883,
  54466,
  60823,
  404451,
  75743,
  59856,
  86979,
  7923,
  34273,
  83785,
  32142,
  7693,
  268986,
  197428,
  282681,
  17049,
  22346,
  22990,
  92245,
  107180,
  3357,
  37104,
  96724,
  49153,
  7683,
  31197,
  43267,
  82231,
  164276,
  23696,
  20848,
  188364,
  22309,
  24821,
  158707,
  1018,
  22514,
  70922,
  27792,
  45589,
  59709,
  10765,
  736,
  35218,
  63479,
  51987,
  24275,
  63588,
  55361,
  92929,
  81964,
  4658,
  20122,
  12330,
  44058,
  13065,
  311456,
  72224,
  8337,
  211229,
  38979,
  22590,
  138478,
  52757,
  32595,
  133600,
  8838,
  31549,
  94412,
  43391,
  90056,
  1585,
  94802,
  127271,
  6223,
  31889,
  137038,
  132910,
  2165,
  57616,
  230152,
  6080,
  10748,
  36737,
  74579,
  134062,
  50525,
  180532,
  119270,
  34556,
  76155,
  82394,
  52595,
  29258,
  31435,
  87820,
  67996,
  26943,
  183878,
  38007,
  2410,
  13526,
  180297,
  69856,
  3503,
  187396,
  167700,
  7838,
  16701,
  9199,
  56267,
  3661,
  37407,
  65994,
  23767,
  5708,
  62508,
  221700,
  67088,
  86978,
  46776,
  84434,
  32088,
  5612,
  9149,
  88244,
  21685,
  95151,
  46750,
  189612,
  2979,
  506311,
  2594,
  3628,
  40074,
  105039,
  78243,
  28523,
  6651,
  38058,
  71999,
  30992,
  12764,
  68261,
  108991,
  6165,
  26450,
  61961,
  13400,
  22426,
  7490,
  60890,
  109623,
  2070,
  12958,
  50355,
  67979,
  257096,
  7213,
  42578,
  52121,
  35716,
  65461,
  7516,
  124758,
  39268,
  302,
  64712,
  14977,
  1467,
  219452,
  2840,
  34229,
  11121,
  21602,
  19270,
  63574,
  8024,
  1532,
  17331,
  79839,
  78885,
  52029,
  180767,
  57957,
  6069,
  91265,
  61380,
  55767,
  8927,
  32881,
  287603,
  22149,
  35029,
  68876,
  6428,
  199567,
  46926,
  13412,
  104132,
  21434,
  366616,
  45060,
  110046,
  81924,
  128910,
  45886,
  52821,
  130416,
  29416,
  77342,
  21762,
  67329,
  121432,
  79924,
  11724,
  38625,
  81006,
  102033,
  28338,
  13326,
  3250,
  82056,
  82526,
  38212,
  21112,
  12382,
  111495,
  3263,
  7414,
  86274,
  93490,
  40844,
  30224,
  45212,
  24019,
  48411,
  71367,
  24941,
  76729,
  57776,
  3769,
  38114,
  202019,
  197745,
  31953,
  237533,
  33270,
  201580,
  255648,
  100798,
  44741,
  32241,
  98468,
  106931,
  10085,
  15090,
  170358,
  33154,
  66787,
  18819,
  69760,
  25061,
  234005,
  82660,
  6295,
  131975,
  16874,
  9076,
  4094,
  25005,
  17740,
  40908,
  19533,
  220019,
  44330,
  99792,
  50040,
  19619,
  13950,
  55228,
  24423,
  31253,
  95308,
  103177,
  184795,
  28590,
  82285,
  5059,
  3210,
  75525,
  49894,
  70007,
  56178,
  10580,
  36051,
  139681,
  21617,
  98736,
  3555,
  106306,
  164189,
  37352,
  63915,
  47824,
  24883,
  145530,
  61904,
  28444,
  11483,
  19837,
  145446,
  30420,
  112972,
  85939,
  11835,
  191233,
  2262,
  20705,
  58630,
  1753,
  148334,
  1197,
  144714,
  6887,
  11223,
  107667,
  60879,
  77914,
  4151,
  57417,
  81594,
  96681,
  169430,
  1784,
  20444,
  95138,
  254041,
  27038,
  596,
  7117,
  72808,
  13759,
  3353,
  126776,
  21074,
  55322,
  27081,
  36942,
  39547,
  139830,
  179275,
  4453,
  713,
  8722,
  71399,
  19204,
  25785,
  22794,
  23923,
  104114,
  11291,
  25458,
  102309,
  88396,
  75288,
  230440,
  206396,
  104551,
  58447,
  130857,
  37247,
  94734,
  31548,
  176529,
  226077,
  65159,
  20104,
  10096,
  66881,
  94191,
  237909,
  27109,
  37404,
  1520,
  27421,
  25220,
  113003,
  23423,
  24884,
  50585,
  6286,
  231877,
  150800,
  11789,
  3226,
  90004,
  60642,
  5053,
  202400,
  61442,
  132531,
  175329,
  57138,
  30116,
  103847,
  9973,
  75367,
  16452,
  32360,
  59119,
  21246,
  10191,
  164804,
  23305,
  61051,
  37348,
  154530,
  13214,
  5468,
  50403,
  66754,
  130976,
  50559,
  80515,
  14436,
  155492,
  84017,
  5472,
  43107,
  41240,
  2890,
  90431,
  70188,
  382,
  76234,
  48040,
  50211,
  281038,
  237007,
  32115,
  142178,
  1536,
  22761,
  96429,
  1811,
  31243,
  1679,
  49143,
  55209,
  17402,
  235054,
  61494,
  7462,
  77030,
  34925,
  87609,
  78002,
  9499,
  9027,
  73289,
  201078,
  101379,
  63544,
  27666,
  5469,
  10642,
  30029,
  49816,
  132979,
  95620,
  58086,
  351930,
  116300,
  2110,
  2043,
  30845,
  6154,
  11279,
  16727,
  4122,
  2277,
  27281,
  4971,
  3650,
  39060,
  61970,
  65951,
  39674,
  75686,
  38151,
  11370,
  130809,
  177895,
  32665,
  63725,
  122267,
  7857,
  39618,
  118483,
  44792,
  157755,
  178624,
  136994,
  24260,
  41308,
  22471,
  12404,
  21707,
  12486,
  30473,
  52781,
  50246,
  20247,
  39065,
  909,
  56825,
  103158,
  128603,
  31542,
  1089,
  41935,
  32744,
  12428,
  37963,
  84420,
  33134,
  72921,
  208449,
  42622,
  168151,
  127335,
  147107,
  46699,
  38216,
  12591,
  94342,
  85814,
  31423,
  24944,
  2605,
  87542,
  67473,
  192551,
  4496,
  56321,
  91819,
  17630,
  6300,
  256183,
  114569,
  202090,
  33209,
  35289,
  34897,
  24967,
  40520,
  43470,
  5344,
  10199,
  34810,
  14283,
  10381,
  10017,
  62923,
  49924,
  23233,
  64539,
  13051,
  35686,
  19698,
  11570,
  135555,
  120868,
  44924,
  87065,
  52318,
  52335,
  47586,
  140906,
  245885,
  109834,
  78668,
  9065,
  46990,
  25258,
  72022,
  61243,
  40838,
  4545,
  146387,
  10537,
  11557,
  17470,
  36930,
  68104,
  46711,
  24264,
  79401,
  81043,
  18225,
  120488,
  24746,
  84338,
  81652,
  28266,
  13776,
  21878,
  46973,
  1047,
  230465,
  73357,
  95777,
  24973,
  210160,
  62210,
  58404,
  110633,
  169651,
  6937,
  41870,
  9909,
  26822,
  191062,
  76553,
  27519,
  96256,
  239070,
  2478,
  205678,
  67955,
  58532,
  20601,
  50120,
  19148,
  78501,
  195724,
  110740,
  8249,
  109665,
  27446,
  30568,
  57631,
  31425,
  49752,
  32820,
  65504,
  50079,
  3663,
  102256,
  219898,
  23849,
  211315,
  14645,
  4359,
  91767,
  9528,
  12449,
  49366,
  7941,
  49763,
  107848,
  8930,
  27086,
  50686,
  9744,
  10447,
  81935,
  39513,
  46514,
  1670,
  29229,
  6172,
  22312,
  137280,
  97759,
  9806,
  14445,
  22976,
  56458,
  73391,
  34983,
  93760,
  174219,
  52573,
  33149,
  59747,
  2429,
  136277,
  75123,
  165263,
  91040,
  7446,
  57632,
  48633,
  97140,
  246081,
  84766,
  151684,
  79918,
  93268,
  120346,
  54059,
  54875,
  77858,
  32996,
  103590,
  45276,
  11968,
  19600,
  25849,
  17159,
  132907,
  42828,
  16817,
  4913,
  99462,
  103303,
  27395,
  5737,
  74184,
  20749,
  21160,
  14377,
  77062,
  131403,
  158735,
  10999,
  27799,
  77785,
  9320,
  34366,
  51593,
  61070,
  33746,
  47048,
  29268,
  36675,
  30262,
  53297,
  9832,
  82e3,
  20188,
  122292,
  39917,
  7331,
  18160,
  68301,
  185935,
  134830,
  15031,
  4935,
  10004,
  165845,
  185534,
  46923,
  30109,
  44134,
  122631,
  18874,
  22903,
  112790,
  26561,
  18549,
  348902,
  82871,
  140345,
  255565,
  135390,
  63556,
  103747,
  145055,
  179600,
  145662,
  296111,
  61661,
  211987,
  23952,
  52342,
  126343,
  48450,
  32919,
  44277,
  82185,
  9591,
  62139,
  205363,
  376969,
  394874,
  108461,
  18040,
  120885,
  14798,
  39863,
  16571,
  16794,
  58271,
  81025,
  55206,
  14640,
  118656,
  6361,
  44092,
  85970,
  6262,
  153863,
  108244,
  180200,
  72264,
  79947,
  38044,
  10050,
  5735,
  61221,
  80712,
  5471,
  115689,
  11391,
  11661,
  184257,
  20010,
  60116,
  30320,
  19327,
  134598,
  45455,
  27542,
  18004,
  125092,
  452272,
  1549,
  91523,
  46567,
  180063,
  156026,
  2608,
  11174,
  58848,
  37788,
  65907,
  80194,
  30490,
  5786,
  40775,
  119519,
  106241,
  11323,
  156297,
  8425,
  61495,
  2617,
  29675,
  2425,
  59886,
  112582,
  49142,
  59618,
  4863,
  50597,
  86710,
  50650,
  168632,
  27693,
  85641,
  83643,
  18993,
  25768,
  84284,
  28090,
  93592,
  36627,
  312804,
  43381,
  9887,
  9402,
  100931,
  97165,
  3311,
  173330,
  66805,
  28935,
  4963,
  184460,
  3201,
  78102,
  19126,
  21607,
  37496,
  24938,
  22615,
  16153,
  32862,
  134792,
  153318,
  61120,
  6067,
  2812,
  12826,
  12792,
  23825,
  37559,
  64662,
  202250,
  102694,
  155488,
  85881,
  149193,
  46233,
  65383,
  15521,
  106982,
  11358,
  176786,
  25752,
  39717,
  34208,
  24510,
  32464,
  77742,
  39371,
  72028,
  138229,
  60688,
  71386,
  102834,
  132477,
  2208,
  11548,
  63670,
  271279,
  28351,
  30338,
  38620,
  32491,
  99845,
  143885,
  152266,
  13252,
  2825,
  178663,
  108097,
  1775,
  78201,
  14897,
  113573,
  163346,
  62292,
  171129,
  22183,
  96598,
  38733,
  64971,
  166776,
  117445,
  9968,
  146393,
  44677,
  74867,
  20908,
  97328,
  12761,
  25656,
  26785,
  9148,
  112344,
  26115,
  99176,
  110121,
  22437,
  49547,
  6180,
  79320,
  5835,
  31392,
  43328,
  33377,
  75870,
  119860,
  69497,
  80273,
  7325,
  155219,
  43167,
  111173,
  28347,
  20222,
  3763,
  71752,
  55041,
  47252,
  14618,
  28088,
  15012,
  97805,
  194698,
  54636,
  2036,
  41349,
  6173,
  96604,
  61530,
  51859,
  43782,
  13361,
  24334,
  22668,
  24792,
  7070,
  23441,
  16789,
  3209,
  36211,
  208475,
  26242,
  32880,
  122181,
  182407,
  21444,
  31060,
  88459,
  29929,
  77907,
  12716,
  10934,
  97005,
  20599,
  31690,
  8403,
  58445,
  30303,
  22700,
  10336,
  86731,
  103115,
  337709,
  72556,
  46788,
  112566,
  47684,
  67089,
  53548,
  36874,
  56487,
  41387,
  125985,
  26893,
  40071,
  106683,
  73712,
  18787,
  40105,
  72992,
  67246,
  137276,
  50802,
  36790,
  70328,
  138827,
  22466,
  39263,
  183295,
  29858,
  50975,
  9322,
  57397,
  10654,
  24364,
  30383,
  55799,
  41600,
  23584,
  127295,
  296610,
  129078,
  143558,
  244131,
  86397,
  36049,
  1085,
  80677,
  3820,
  108139,
  5476,
  34767,
  24683,
  7758,
  13060,
  7239,
  131671,
  250593,
  59556,
  103392,
  29810,
  4188,
  252323,
  39404,
  116877,
  7651,
  43600,
  40338,
  13554,
  157253,
  39196,
  25978,
  144387,
  61211,
  234,
  50104,
  6129,
  10449,
  93777,
  9240,
  356378,
  274148,
  4439,
  72970,
  3724,
  147770,
  78680,
  62570,
  115877,
  40027,
  40547,
  36817,
  224392,
  64609,
  34795,
  165027,
  67440,
  2477,
  37206,
  23431,
  50754,
  164797,
  46018,
  94995,
  170982,
  27051,
  7957,
  22767,
  3674,
  27900,
  56419,
  18930,
  60701,
  41302,
  2692,
  84749,
  339721,
  61996,
  111094,
  80221,
  50129,
  1045,
  8153,
  62945,
  19202,
  8250,
  37208,
  37418,
  32560,
  79477,
  41106,
  88569,
  33963,
  36693,
  5892,
  30570,
  1581,
  66471,
  49647,
  11922,
  160717,
  29442,
  5643,
  114865,
  82962,
  95982,
  132098,
  22633,
  22838,
  94726,
  54556,
  28566,
  205039,
  162340,
  33216,
  16849,
  35847,
  221339,
  94851,
  26533,
  71469,
  1805,
  3804,
  12935,
  45483,
  71020,
  36310,
  65381,
  192960,
  34240,
  35165,
  59773,
  1248,
  46954,
  155332,
  96864,
  4246,
  388800,
  16129,
  57133,
  74592,
  44807,
  442014,
  38203,
  42574,
  80818,
  91592,
  26377,
  36424,
  65760,
  977,
  77387,
  22628,
  147610,
  28018,
  30561,
  98454,
  6969,
  119628,
  63648,
  18170,
  36854,
  26601,
  64018,
  22027,
  37279,
  51395,
  152934,
  21153,
  9430,
  58760,
  194742,
  5330,
  55115,
  34158,
  28917,
  174111,
  13171,
  122326,
  1526,
  43896,
  66094,
  25325,
  4234,
  148354,
  11450,
  275,
  18999,
  112191,
  44365,
  22723,
  68409,
  8733,
  57746,
  96565,
  75007,
  14196,
  108844,
  29475,
  88599,
  177563,
  100792,
  106156,
  86323,
  93726,
  14248,
  135341,
  194131,
  40126,
  47099,
  14779,
  8272,
  39597,
  95983,
  171398,
  65882,
  28052,
  10393,
  47213,
  40689,
  22120,
  72212,
  106829,
  34964,
  109146,
  753,
  648,
  21660,
  30047,
  17527,
  181025,
  5619,
  145357,
  4085,
  216883,
  9359,
  186951,
  24779,
  53931,
  24545,
  36197,
  223296,
  62628,
  168101,
  4243,
  107313,
  30321,
  26642,
  13049,
  51059,
  31027,
  107912,
  807,
  73550,
  26551,
  84369,
  122422,
  165872,
  49754,
  74213,
  234264,
  33151,
  52014,
  33100,
  87183,
  22365,
  52500,
  40013,
  23302,
  5652,
  72723,
  21404,
  26107,
  48434,
  587,
  94049,
  168493,
  96418,
  32871,
  70860,
  31709,
  25128,
  443,
  71597,
  166253,
  15670,
  70994,
  26341,
  133675,
  28280,
  75491,
  54756,
  47955,
  56028,
  26182,
  11952,
  113272,
  472197,
  64640,
  110753,
  17919,
  337,
  50642,
  22576,
  142,
  87371,
  53391,
  93210,
  126694,
  15285,
  19642,
  85667,
  14148,
  1506,
  42092,
  52962,
  33243,
  11970,
  20734,
  135843,
  57044,
  58880,
  13002,
  219134,
  22876,
  64754,
  232519,
  4257,
  43120,
  321573,
  24799,
  64526,
  124728,
  52579,
  81472,
  70831,
  276848,
  17403,
  74359,
  23021,
  182101,
  74597,
  23744,
  148267,
  12055,
  7976,
  5349,
  11772,
  67540,
  167347,
  65318,
  18720,
  127832,
  108238,
  22828,
  90233,
  9987,
  259080,
  118185,
  73209,
  79270,
  13775,
  90100,
  137742,
  90799,
  70569,
  15699,
  19961,
  9087,
  67475,
  57872,
  39731,
  8810,
  134897,
  131868,
  146849,
  19898,
  3334,
  2281,
  167061,
  91073,
  60356,
  467742,
  74712,
  188,
  53179,
  137679,
  92769,
  29241,
  9537,
  132595,
  80119,
  1041,
  88962,
  5976,
  40171,
  44911,
  102859,
  139059,
  104558,
  98987,
  47761,
  19272,
  71472,
  113864,
  175377,
  73338,
  10857,
  23402,
  23758,
  1591,
  139864,
  5644,
  4076,
  118760,
  16427,
  134198,
  18853,
  20291,
  100849,
  37423,
  22038,
  36677,
  19071,
  195521,
  57445,
  11069,
  31869,
  55718,
  66882,
  148490,
  44,
  41296,
  75242,
  49704,
  166810,
  9906,
  20943,
  122258,
  49112,
  105667,
  15969,
  10344,
  6408,
  187694,
  21399,
  72742,
  58970,
  14867,
  14376,
  81889,
  41856,
  23225,
  15042,
  56993,
  16074,
  131389,
  74276,
  72407,
  53875,
  383108,
  53597,
  37363,
  68993,
  44854,
  122548,
  430927,
  198279,
  38430,
  80409,
  12245,
  2981,
  628,
  2818,
  17760,
  37437,
  238229,
  7968,
  46892,
  2200,
  3730,
  34190,
  65983,
  37959,
  112291,
  87850,
  70827,
  6522,
  20750,
  73913,
  111621,
  41652,
  19587,
  2780,
  58668,
  25916,
  85259,
  18200,
  168962,
  95781,
  42445,
  102050,
  7776,
  57662,
  103313,
  47742,
  96358,
  41964,
  66174,
  100396,
  29069,
  204735,
  19679,
  27978,
  7479,
  40264,
  22534,
  61183,
  36081,
  107436,
  58223,
  14680,
  23002,
  101311,
  24716,
  124108,
  12908,
  5646,
  31750,
  40380,
  14215,
  232799,
  102772,
  14122,
  96775,
  61398,
  50917,
  12096,
  149880,
  67833,
  598749,
  124194,
  155871,
  49216,
  790,
  14677,
  65319,
  56917,
  7440,
  145744,
  95701,
  12206,
  49405,
  129269,
  76199,
  45732,
  9767,
  11058,
  9047,
  210885,
  11051,
  7392,
  26307,
  2130,
  8132,
  147526,
  20802,
  232698,
  115660,
  50060,
  59789,
  57344,
  107623,
  80343,
  112676,
  23291,
  9866,
  160971,
  34032,
  118291,
  15719,
  59730,
  164911,
  28975,
  2659,
  58046,
  78480,
  21854,
  66209,
  53863,
  109085,
  116045,
  29021,
  46481,
  107552,
  22130,
  18764,
  70254,
  31272,
  11300,
  52460,
  43933,
  84738,
  20721,
  53869,
  190840,
  79673,
  105300,
  7561,
  321817,
  66924,
  13940,
  33281,
  101046,
  183181,
  32176,
  71878,
  5678,
  62924,
  79535,
  56646,
  40303,
  19559,
  27703,
  93042,
  73368,
  42187,
  3670,
  37376,
  46440,
  7023,
  36816,
  109628,
  20680,
  5940,
  276440,
  275233,
  170848,
  112093,
  136996,
  14984,
  20226,
  111441,
  77693,
  112960,
  48577,
  39370,
  55707,
  50314,
  123404,
  26570,
  54281,
  61372,
  123391,
  4857,
  35928,
  246740,
  132507,
  106646,
  44241,
  7196,
  92258,
  9825,
  37688,
  51197,
  303141,
  5590,
  15476,
  132986,
  10955,
  85782,
  34486,
  26696,
  7991,
  28813,
  18858,
  39546,
  11703,
  11365,
  38185,
  5716,
  93555,
  11925,
  40121,
  60002,
  6985,
  10976,
  171384,
  3887,
  43394,
  13337,
  56346,
  6381,
  252336,
  39573,
  75042,
  53711,
  1028,
  31781,
  44295,
  95925,
  131713,
  7214,
  68125,
  43571,
  70954,
  213234,
  1628,
  8760,
  13391,
  65485,
  17320,
  56038,
  1710,
  25248,
  60803,
  57399,
  19839,
  3870,
  326,
  281556,
  50945,
  72400,
  21460,
  316244,
  75619,
  56246,
  98775,
  481,
  13513,
  55765,
  50427,
  7388,
  123519,
  32929,
  57908,
  27124,
  61316,
  101097,
  57467,
  30228,
  48792,
  10788,
  20402,
  37318,
  50526,
  155730,
  34456,
  158065,
  145305,
  17832,
  43733,
  64052,
  4506,
  35072,
  205355,
  177028,
  184004,
  187081,
  68616,
  35938,
  83703,
  10367,
  36892,
  93186,
  260137,
  51934,
  89970,
  4985,
  23445,
  26755,
  21558,
  7948,
  78741,
  23376,
  124405,
  85594,
  68596,
  57536,
  49351,
  12619,
  56593,
  132668,
  99924,
  109728,
  71844,
  71935,
  196018,
  65464,
  17617,
  14987,
  89701,
  143773,
  33997,
  8687,
  22701,
  33258,
  2914,
  4436,
  72108,
  85610,
  9671,
  49067,
  2327,
  82988,
  1361,
  1672,
  44033,
  35777,
  30269,
  24057,
  10605,
  82236,
  616,
  15793,
  13919,
  47249,
  112086,
  116698,
  9484,
  80207,
  90574,
  33304,
  68624,
  93127,
  56101,
  42210,
  160929,
  4827,
  38995,
  38095,
  4701,
  125119,
  5027,
  33680,
  9236,
  231236,
  14135,
  87837,
  23318,
  70261,
  78893,
  30151,
  81482,
  14332,
  1084,
  74256,
  27532,
  46644,
  79185,
  3148,
  62615,
  6981,
  55672,
  31668,
  36825,
  1849,
  14536,
  37446,
  14738,
  23779,
  43058,
  162749,
  72199,
  1168,
  21346,
  5592,
  85932,
  85302,
  9668,
  18351,
  57135,
  150360,
  2080,
  228015,
  77953,
  34670,
  119302,
  151751,
  31009,
  106725,
  84265,
  45214,
  59289,
  74178,
  113071,
  263206,
  111009,
  4021,
  44449,
  188119,
  192629,
  123592,
  392506,
  292847,
  114487,
  12831,
  205858,
  9852,
  20780,
  79648,
  75767,
  357014,
  97721,
  18166,
  21005,
  67950,
  33226,
  204009,
  16536,
  2987,
  11335,
  66717,
  144910,
  47950,
  17262,
  55060,
  15063,
  2934,
  51038,
  26775,
  178497,
  66008,
  3427,
  49433,
  128592,
  20036,
  157553,
  63861,
  3089,
  23015,
  51210,
  28696,
  35933,
  49942,
  71135,
  231518,
  99620,
  17248,
  21835,
  176536,
  20676,
  16944,
  38700,
  165831,
  233253,
  295625,
  36723,
  13023,
  52745,
  10907,
  19423,
  67972,
  125868,
  95473,
  82875,
  1183,
  108455,
  52685,
  33417,
  64095,
  21433,
  52438,
  33191,
  127809,
  44505,
  211823,
  7810,
  2752,
  95548,
  162031,
  7185,
  91196,
  47563,
  61721,
  33359,
  17897,
  23682,
  42806,
  178101,
  22874,
  49707,
  199897,
  75419,
  82456,
  8618,
  11171,
  79712,
  116847,
  18783,
  44190,
  46564,
  5346,
  59046,
  95032,
  7893,
  14916,
  3214,
  26800,
  24172,
  121453,
  34362,
  10250,
  17408,
  18888,
  4840,
  68696,
  22831,
  13162,
  36005,
  32512,
  14800,
  62357,
  41723,
  45046,
  27247,
  37486,
  5372,
  2564,
  34261,
  298500,
  66509,
  133920,
  89138,
  31305,
  117697,
  19097,
  108304,
  81386,
  84106,
  23802,
  46411,
  63304,
  946,
  51417,
  41777,
  41041,
  19501,
  115864,
  60743,
  294354,
  37955,
  94165,
  18116,
  1156,
  17937,
  20645,
  57114,
  90804,
  58042,
  48643,
  92288,
  9861,
  2557,
  88546,
  61333,
  101008,
  12853,
  5148,
  87856,
  4152,
  144503,
  73841,
  18718,
  9789,
  147565,
  10846,
  42085,
  12789,
  30223,
  8993,
  56352,
  67203,
  2448,
  28215,
  6052,
  23540,
  126319,
  75933,
  36689,
  80235,
  23231,
  23561,
  21383,
  38800,
  77548,
  102798,
  21234,
  31468,
  158608,
  46188,
  63960,
  191679,
  8051,
  67014,
  11185,
  170078,
  42186,
  28827,
  34777,
  41930,
  212079,
  12421,
  34750,
  24111,
  110344,
  73918,
  45171,
  70826,
  141949,
  40063,
  23979,
  24254,
  37309,
  26724,
  27179,
  24718,
  83648,
  54938,
  14591,
  17425,
  29525,
  102675,
  48975,
  48654,
  12316,
  8929,
  60640,
  41709,
  50168,
  63264,
  89812,
  50716,
  48632,
  38755,
  138583,
  160123,
  55579,
  71829,
  24230,
  233277,
  46322,
  39650,
  166388,
  34718,
  24108,
  98252,
  7031,
  106695,
  62498,
  18258,
  35062,
  217827,
  78731,
  34824,
  33354,
  19520,
  60852,
  2432,
  60224,
  8587,
  2836,
  62955,
  702,
  20227,
  42285,
  40560,
  95592,
  62486,
  11094,
  53035,
  143291,
  18842,
  46177,
  77994,
  1770,
  9657,
  107422,
  172915,
  32655,
  128716,
  25886,
  25164,
  156740,
  119928,
  165875,
  85817,
  11007,
  89110,
  33956,
  12652,
  65156,
  180266,
  8494,
  36889,
  19958,
  20955,
  96,
  1264,
  118288,
  135769,
  44754,
  86671,
  5632,
  19026,
  168220,
  289120,
  33569,
  93821,
  66144,
  70635,
  7687,
  5642,
  2714,
  55445,
  56636,
  71545,
  184182,
  93133,
  7332,
  37389,
  12643,
  52315,
  22729,
  11014,
  158742,
  17050,
  152889,
  50178,
  34601,
  41945,
  52136,
  9948,
  26914,
  63548,
  95721,
  115951,
  40759,
  8960,
  158258,
  38938,
  49232,
  48325,
  42234,
  81523,
  253019,
  66128,
  40978,
  20048,
  238048,
  38760,
  62928,
  122560,
  118532,
  43687,
  137472,
  163689,
  26680,
  9878,
  17448,
  51035,
  16211,
  60834,
  36749,
  29178,
  14241,
  59868,
  150086,
  2305,
  26477,
  42422,
  34342,
  165341,
  83279,
  33894,
  14257,
  29928,
  12743,
  13957,
  125571,
  89134,
  66712,
  10952,
  16507,
  147839,
  30146,
  7249,
  16565,
  45399,
  39874,
  114565,
  215780,
  31990,
  230881,
  171477,
  102,
  196546,
  44538,
  10880,
  84948,
  281705,
  86651,
  10617,
  31395,
  2342,
  453658,
  43569,
  60561,
  132901,
  21845,
  17727,
  58556,
  258242,
  22262,
  58728,
  4008,
  77997,
  11806,
  37431,
  30599,
  81375,
  109137,
  185787,
  114085,
  217292,
  97453,
  169085,
  30593,
  60212,
  11544,
  102056,
  65580,
  2384,
  91655,
  4855,
  95725,
  7295,
  157994,
  16228,
  20669,
  53276,
  141590,
  105246,
  17334,
  25440,
  76067,
  17967,
  39321,
  38911,
  11362,
  28559,
  63807,
  21627,
  26468,
  85816,
  40120,
  1025,
  15234,
  58319,
  69516,
  66512,
  124548,
  75845,
  78873,
  22137,
  46681,
  51242,
  85683,
  32909,
  76747,
  35555,
  43396,
  101465,
  1765,
  73094,
  1077,
  2962,
  39028,
  66777,
  57831,
  42048,
  15828,
  13962,
  36041,
  63657,
  52412,
  5242,
  58846,
  2141,
  5506,
  219012,
  134451,
  3936,
  182230,
  17558,
  17153,
  152237,
  22621,
  49377,
  170216,
  35257,
  68233,
  65374,
  6510,
  11126,
  212151,
  7184,
  2480,
  22517,
  3437,
  33073,
  30156,
  16557,
  3768,
  55067,
  86829,
  91e3,
  12350,
  148650,
  66017,
  79424,
  70885,
  49066,
  28250,
  21369,
  51213,
  34533,
  11510,
  3258,
  18176,
  18465,
  84413,
  6315,
  36411,
  163765,
  4346,
  356,
  107618,
  598,
  13727,
  285026,
  162695,
  8749,
  14583,
  7132,
  63521,
  184253,
  32378,
  25991,
  5604,
  30961,
  53675,
  4874,
  84693,
  5086,
  34811,
  26978,
  56564,
  7904,
  33519,
  51221,
  113942,
  69253,
  6664,
  125563,
  22055,
  220680,
  102008,
  742,
  51930,
  19494,
  176108,
  44424,
  35123,
  13025,
  75685,
  11759,
  74335,
  22250,
  181453,
  131147,
  16984,
  132115,
  154311,
  11991,
  76452,
  52609,
  85351,
  196,
  30969,
  9198,
  74919,
  2529,
  56838,
  71779,
  29187,
  116304,
  3504,
  62330,
  41190,
  86153,
  28393,
  254926,
  104228,
  105189,
  13264,
  84359,
  3574,
  12415,
  8534,
  57147,
  10175,
  188174,
  59504,
  60932,
  66318,
  16407,
  107921,
  17638,
  99103,
  49278,
  28403,
  39786,
  145865,
  8462,
  3558,
  43406,
  142271,
  29139,
  21989,
  36552,
  93955,
  72365,
  7176,
  13556,
  106185,
  37957,
  321774,
  17782,
  129017,
  51154,
  27938,
  24952,
  1935,
  39366,
  2791,
  33489,
  41582,
  56078,
  24558,
  9311,
  5449,
  218786,
  27808,
  190429,
  68013,
  36020,
  86003,
  29735,
  3404,
  87348,
  119357,
  115714,
  2324,
  86796,
  81973,
  40992,
  43376,
  93621,
  28784,
  16808,
  36367,
  2517,
  2909,
  191926,
  24978,
  55303,
  53308,
  205724,
  60068,
  3098,
  21375,
  64784,
  23949,
  26579,
  63121,
  12319,
  80145,
  39967,
  97861,
  6757,
  70143,
  67642,
  37082,
  34698,
  69140,
  122883,
  46151,
  62187,
  80934,
  429,
  19437,
  135071,
  137885,
  222647,
  13331,
  154065,
  327,
  61778,
  74257,
  40116,
  37493,
  14855,
  85079,
  237641,
  42342,
  102164,
  199965,
  71204,
  4662,
  29368,
  5042,
  113914,
  122214,
  8955,
  13149,
  102503,
  43173,
  5659,
  163787,
  69003,
  307084,
  63392,
  171080,
  21390,
  81918,
  86666,
  36622,
  24126,
  28887,
  5736,
  28054,
  207170,
  163428,
  79891,
  346467,
  95363,
  38980,
  111806,
  80828,
  9200,
  19288,
  294896,
  114468,
  87405,
  111715,
  141705,
  7015,
  72754,
  68463,
  48738,
  243147,
  33397,
  101210,
  37051,
  98801,
  82847,
  20397,
  4940,
  185559,
  18716,
  54718,
  83491,
  11725,
  40803,
  1128,
  12128,
  23060,
  5174,
  7745,
  67007,
  46701,
  1571,
  27807,
  180186,
  256996,
  18975,
  16837,
  7877,
  212758,
  250379,
  15440,
  87954,
  57755,
  24719,
  124057,
  83461,
  258,
  50864,
  8874,
  29038,
  71289,
  31627,
  15429,
  9005,
  4061,
  113851,
  107716,
  82819,
  13651,
  79656,
  117851,
  17539,
  111446,
  12938,
  39724,
  190787,
  4352,
  15402,
  21070,
  62708,
  8539,
  23777,
  73853,
  13552,
  38810,
  86117,
  16285,
  56400,
  1718,
  75342,
  142863,
  29033,
  378,
  110113,
  180321,
  32586,
  23606,
  26393,
  160984,
  207987,
  23783,
  8406,
  16904,
  24596,
  47274,
  11693,
  46539,
  60524,
  78595,
  48423,
  31718,
  20170,
  9009,
  146268,
  15183,
  191060,
  172765,
  1349,
  138436,
  37365,
  10970,
  40509,
  225817,
  20021,
  70394,
  152138,
  21541,
  66559,
  66544,
  89352,
  2725,
  17258,
  91345,
  7313,
  3815,
  115868,
  8660,
  40362,
  4071,
  103524,
  39388,
  118275,
  21950,
  6549,
  38226,
  32754,
  209574,
  29201,
  43495,
  18028,
  20296,
  40597,
  18370,
  47520,
  202450,
  24134,
  2219,
  8195,
  69545,
  38041,
  136934,
  46374,
  19041,
  159811,
  84865,
  58620,
  846,
  98749,
  13569,
  30714,
  97246,
  32186,
  4479,
  27355,
  92973,
  35214,
  151491,
  75963,
  37631,
  1561,
  27200,
  238083,
  23182,
  60756,
  12291,
  25766,
  39355,
  102333,
  87362,
  65741,
  59906,
  19538,
  201575,
  48772,
  102938,
  24438,
  292580,
  39964,
  66366,
  9004,
  61379,
  50548,
  37622,
  38732,
  28379,
  68180,
  76622,
  17488,
  69849,
  5963,
  7219,
  48143,
  43413,
  55358,
  540,
  58691,
  29506,
  19245,
  52193,
  48621,
  5518,
  13048,
  118625,
  44755,
  191081,
  42061,
  89197,
  2259,
  60665,
  66994,
  71210,
  51232,
  3585,
  142096,
  55024,
  7892,
  8345,
  58653,
  463307,
  65658,
  64319,
  137941,
  136323,
  53499,
  12746,
  43492,
  6978,
  95163,
  29925,
  60175,
  5128,
  7352,
  41463,
  184756,
  121146,
  20473,
  18426,
  4598,
  5309,
  54580,
  14277,
  121151,
  10691,
  56711,
  43880,
  63409,
  76682,
  11830,
  172218,
  264898,
  32632,
  66536,
  81062,
  31649,
  25788,
  92774,
  60222,
  11100,
  63159,
  9432,
  224657,
  25240,
  53613,
  152,
  138620,
  163829,
  2397,
  85345,
  12501,
  37507,
  64932,
  38575,
  43522,
  65789,
  80198,
  78796,
  35226,
  3851,
  108891,
  73311,
  3060,
  28391,
  93671,
  39663,
  46142,
  30982,
  66041,
  37281,
  68157,
  26553,
  71872,
  81142,
  211527,
  39747,
  118119,
  22695,
  2859,
  11066,
  20232,
  168911,
  7933,
  197005,
  17066,
  111071,
  44434,
  133994,
  120798,
  12766,
  227798,
  45756,
  132852,
  29917,
  36076,
  55352,
  65281,
  129800,
  41958,
  18944,
  84678,
  18580,
  168093,
  132621,
  39997,
  54092,
  27740,
  32354,
  3770,
  114118,
  103242,
  43918,
  15899,
  18574,
  145944,
  3190,
  123469,
  219903,
  24169,
  100571,
  62403,
  16776,
  92779,
  14535,
  17168,
  16475,
  14304,
  37231,
  1712,
  28218,
  242754,
  61688,
  28980,
  1318,
  51359,
  222657,
  99200,
  67989,
  31772,
  23932,
  35351,
  201251,
  49041,
  27306,
  19128,
  40135,
  3986,
  77333,
  19649,
  120683,
  151927,
  21081,
  7076,
  78375,
  77501,
  101599,
  8011,
  89585,
  96715,
  58179,
  5378,
  102138,
  106793,
  26051,
  217276,
  4197,
  16297,
  27014,
  46721,
  13322,
  22806,
  5278,
  29629,
  70632,
  9647,
  71519,
  58818,
  40603,
  128530,
  8903,
  36770,
  56900,
  31483,
  26935,
  43845,
  34265,
  34920,
  87658,
  6114,
  84767,
  64250,
  47318,
  50720,
  19264,
  162514,
  33357,
  13117,
  6705,
  46696,
  75032,
  71054,
  87004,
  42035,
  69138,
  11903,
  99854,
  102328,
  19611,
  34525,
  69312,
  6431,
  49842,
  101600,
  133178,
  108751,
  41829,
  89939,
  225664,
  48916,
  99556,
  9195,
  130387,
  5960,
  36857,
  116724,
  53518,
  94002,
  39077,
  53996,
  6945,
  22261,
  64291,
  8314,
  152785,
  57588,
  16522,
  9091,
  5048,
  87671,
  35441,
  39509,
  1945,
  12423,
  158923,
  178413,
  37549,
  14095,
  1475,
  73188,
  62878,
  4819,
  24012,
  68534,
  42606,
  4010,
  120809,
  57497,
  59564,
  101758,
  103718,
  32701,
  80116,
  12345,
  95834,
  46918,
  21468,
  53213,
  15665,
  31200,
  3867,
  5140,
  96013,
  250744,
  21016,
  10069,
  13968,
  35449,
  180829,
  27683,
  39704,
  59956,
  22893,
  3115,
  26293,
  32785,
  75934,
  62445,
  141162,
  62720,
  2018,
  83638,
  19949,
  114012,
  95006,
  3330,
  99829,
  130935,
  309272,
  9565,
  55874,
  121727,
  37017,
  23586,
  319858,
  40970,
  27602,
  8625,
  112329,
  61060,
  100088,
  118525,
  25922,
  16232,
  1907,
  60671,
  51583,
  44553,
  80993,
  5262,
  94679,
  8676,
  940,
  20736,
  11823,
  3020,
  16476,
  12340,
  152600,
  97416,
  3703,
  25744,
  66826,
  16245,
  16876,
  46446,
  84798,
  74227,
  176020,
  45192,
  61955,
  75496,
  23946,
  23626,
  40372,
  26036,
  6149,
  11822,
  30582,
  16541,
  41914,
  82385,
  232823,
  40921,
  80773,
  14930,
  3631,
  7517,
  39619,
  4348,
  36180,
  126106,
  138939,
  62611,
  1477,
  113512,
  47321,
  25052,
  14546,
  118881,
  29060,
  23589,
  128322,
  36795,
  18401,
  137921,
  104699,
  267929,
  36194,
  172791,
  18113,
  4766,
  188215,
  30083,
  332586,
  94089,
  5805,
  77909,
  22194,
  68234,
  154976,
  43220,
  40660,
  70001,
  184893,
  138095,
  11128,
  103010,
  22663,
  5108,
  212615,
  8485,
  5565,
  49222,
  54614,
  26530,
  42639,
  16319,
  55062,
  152662,
  105595,
  21114,
  22216,
  10294,
  68158,
  10436,
  86950,
  7206,
  62115,
  3977,
  3657,
  59874,
  456,
  118617,
  18156,
  106663,
  112229,
  80992,
  17442,
  8217,
  55551,
  5133,
  34344,
  251927,
  51153,
  39364,
  201321,
  7816,
  66803,
  23057,
  156724,
  145664,
  14276,
  95705,
  979,
  2796,
  6875,
  13429,
  212525,
  50602,
  26276,
  28284,
  3424,
  19465,
  52397,
  46963,
  31420,
  51399,
  206476,
  92317,
  48851,
  637,
  100820,
  83349,
  10317,
  60227,
  21972,
  6908,
  282439,
  32857,
  224767,
  95629,
  83882,
  42106,
  87338,
  69757,
  29840,
  68709,
  37665,
  45244,
  114577,
  49188,
  175943,
  54009,
  186746,
  106158,
  70168,
  3358,
  234002,
  50555,
  9221,
  129338,
  9562,
  20118,
  32923,
  78479,
  118280,
  65752,
  4977,
  10474,
  102174,
  60947,
  129006,
  10570,
  83451,
  8598,
  8078,
  159367,
  123785,
  80438,
  16742,
  5905,
  5281,
  181513,
  42402,
  6977,
  163136,
  93179,
  42191,
  14968,
  50421,
  112401,
  105440,
  33456,
  57347,
  121611,
  4221,
  94954,
  36517,
  24046,
  27796,
  6255,
  33394,
  72990,
  135408,
  116627,
  1233,
  57874,
  25654,
  95419,
  68156,
  401399,
  313338,
  55208,
  45573,
  93124,
  119251,
  47200,
  38196,
  11909,
  130667,
  45391,
  73904,
  64964,
  167846,
  4137,
  115606,
  52036,
  62214,
  7969,
  160925,
  7187,
  1132,
  134835,
  40309,
  73195,
  64494,
  80472,
  444841,
  61111,
  26500,
  45323,
  40743,
  53625,
  52797,
  22659,
  15631,
  29739,
  36706,
  28841,
  39147,
  102836,
  26794,
  10536,
  14845,
  87305,
  45874,
  12241,
  127587,
  83833,
  57183,
  79722,
  30844,
  41304,
  84655,
  20825,
  92500,
  3722,
  25655,
  27811,
  10157,
  81634,
  31362,
  34088,
  92487,
  70123,
  22190,
  185100,
  72658,
  139035,
  192523,
  88241,
  2078,
  230490,
  44528,
  85638,
  100198,
  22088,
  29982,
  291233,
  241062,
  13865,
  4445,
  137791,
  37835,
  107218,
  31726,
  19718,
  38234,
  72528,
  23046,
  19177,
  66695,
  5109,
  17251,
  28077,
  5617,
  21554,
  47839,
  72425,
  133825,
  1486,
  73065,
  181275,
  141508,
  21768,
  62971,
  63082,
  2512,
  34200,
  9904,
  120309,
  6392,
  91243,
  68416,
  268253,
  41199,
  116757,
  138551,
  185526,
  41246,
  28986,
  4093,
  19057,
  17295,
  4148,
  245766,
  122360,
  35356,
  112075,
  20301,
  75441,
  10998,
  7977,
  19769,
  62922,
  937,
  63547,
  100196,
  26427,
  157820,
  20983,
  236696,
  22935,
  8140,
  90315,
  156004,
  47204,
  140973,
  7726,
  45097,
  52725,
  22636,
  23436,
  257282,
  105247,
  522,
  88389,
  216031,
  202204,
  46812,
  211666,
  19693,
  68828,
  81691,
  45925,
  11256,
  30292,
  372,
  5236,
  167826,
  88328,
  232776,
  151611,
  5360,
  82104,
  18841,
  80393,
  25465,
  18285,
  20320,
  72377,
  31730,
  33160,
  45803,
  38715,
  27705,
  37379,
  24163,
  18360,
  103586,
  4015,
  32305,
  269494,
  91252,
  20080,
  36567,
  54650,
  7797,
  57073,
  12650,
  31164,
  42209,
  6375,
  261663,
  105528,
  81661,
  106002,
  2800,
  5375,
  17247,
  43151,
  4442,
  15727,
  194619,
  100855,
  144898,
  62320,
  78465,
  39929,
  16454,
  1967,
  28311,
  61363,
  17219,
  9395,
  8745,
  121445,
  76939,
  80385,
  162380,
  22009,
  54191,
  44248,
  16299,
  122830,
  48151,
  74429,
  78291,
  64755,
  14238,
  44966,
  2511,
  17712,
  67954,
  93583,
  829,
  105899,
  49935,
  84750,
  11591,
  33185,
  85447,
  42717,
  27409,
  208542,
  28965,
  62052,
  52525,
  5597,
  25694,
  65594,
  16343,
  63224,
  276188,
  12475,
  9331,
  127507,
  38522,
  57287,
  24128,
  133161,
  79723,
  105548,
  133695,
  48917,
  27558,
  43278,
  46520,
  13778,
  141954,
  110785,
  83366,
  17715,
  46317,
  105763,
  66298,
  147013,
  41086,
  94180,
  16478,
  220447,
  44611,
  730,
  19722,
  78975,
  117889,
  125643,
  26254,
  16574,
  18480,
  65006,
  15806,
  38549,
  246418,
  46052,
  36056,
  8440,
  34984,
  30170,
  3163,
  59800,
  4458,
  115442,
  4283,
  41970,
  33507,
  104078,
  1653,
  22,
  121158,
  276486,
  3655,
  6338,
  24048,
  133421,
  23641,
  2161,
  24422,
  36006,
  8086,
  10675,
  181474,
  12307,
  29514,
  59143,
  14729,
  52509,
  87128,
  122470,
  19446,
  80852,
  33314,
  24573,
  119864,
  14237,
  9652,
  57779,
  6612,
  51851,
  15284,
  98871,
  90581,
  124466,
  156831,
  21190,
  22015,
  71380,
  161906,
  87247,
  69201,
  18392,
  17908,
  108470,
  72962,
  40719,
  14338,
  17911,
  95260,
  43339,
  20610,
  78916,
  20710,
  72451,
  11315,
  31448,
  17263,
  58853,
  178878,
  48111,
  116002,
  45497,
  80506,
  82605,
  85880,
  36300,
  121755,
  25215,
  36118,
  301929,
  88728,
  405223,
  276136,
  553,
  34704,
  212438,
  49970,
  78329,
  922,
  20711,
  25036,
  257130,
  38295,
  145369,
  18128,
  15385,
  30829,
  55656,
  48345,
  8012,
  3561,
  28004,
  122041,
  192900,
  58338,
  112508,
  41085,
  29976,
  87040,
  47117,
  23905,
  4336,
  92061,
  138880,
  97407,
  42083,
  172121,
  6256,
  25192,
  172671,
  5,
  93568,
  1420,
  12677,
  31605,
  56743,
  40620,
  6015,
  78415,
  231077,
  31298,
  80026,
  13902,
  19048,
  24924,
  170586,
  32955,
  176119,
  87859,
  36731,
  6773,
  27711,
  24658,
  26475,
  115216,
  133207,
  93250,
  95820,
  88522,
  8317,
  5714,
  124047,
  55219,
  86860,
  19677,
  23961,
  22928,
  162209,
  8904,
  225992,
  359835,
  56084,
  96201,
  29392,
  96558,
  86071,
  93643,
  55114,
  13347,
  8183,
  95129,
  82012,
  2017,
  123336,
  34219,
  115554,
  157159,
  47747,
  101684,
  41008,
  18735,
  193781,
  104151,
  226906,
  7552,
  179874,
  124113,
  31159,
  21162,
  44010,
  14771,
  51268,
  166128,
  31382,
  73124,
  77438,
  92830,
  205709,
  12113,
  1292,
  38937,
  13114,
  1334,
  2118,
  15597,
  69581,
  14449,
  21934,
  76618,
  48728,
  67038,
  14967,
  51495,
  24243,
  87736,
  147249,
  26720,
  11119,
  46063,
  43749,
  5843,
  44147,
  152629,
  133428,
  65703,
  14269,
  45604,
  57982,
  28672,
  55616,
  45957,
  8438,
  95433,
  37698,
  220862,
  132034,
  39456,
  61870,
  4161,
  26501,
  73560,
  56418,
  9845,
  4654,
  20916,
  10456,
  88920,
  119358,
  9015,
  65931,
  96507,
  48029,
  38534,
  21676,
  109081,
  43078,
  34943,
  25089,
  6131,
  28766,
  23665,
  5477,
  10255,
  16695,
  67,
  45778,
  42443,
  42770,
  29534,
  23733,
  100513,
  62617,
  42630,
  48746,
  14191,
  43753,
  50295,
  26007,
  8792,
  57243,
  43119,
  54725,
  164253,
  58250,
  112304,
  131796,
  25165,
  4651,
  3188,
  24831,
  47748,
  3705,
  19540,
  13211,
  102095,
  5593,
  18699,
  23666,
  32005,
  117571,
  33541,
  60584,
  74573,
  86311,
  99443,
  25172,
  27222,
  168938,
  7143,
  11853,
  53560,
  18834,
  19960,
  86522,
  28217,
  53266,
  117700,
  72989,
  34323,
  18721,
  66450,
  34346,
  74056,
  47217,
  202002,
  46269,
  9429,
  68582,
  75458,
  37823,
  82843,
  96652,
  32549,
  145144,
  27958,
  19820,
  158086,
  31955,
  201406,
  135379,
  31207,
  192545,
  12950,
  51704,
  9094,
  248263,
  76147,
  64028,
  110009,
  79407,
  89345,
  99284,
  223492,
  47966,
  26848,
  15359,
  201137,
  2861,
  110507,
  71231,
  72297,
  31851,
  118777,
  71039,
  151051,
  240855,
  16333,
  50766,
  14727,
  7939,
  4149,
  80908,
  418780,
  88378,
  59276,
  1327,
  7284,
  38576,
  79814,
  65820,
  42199,
  84860,
  49574,
  62596,
  12396,
  70598,
  40117,
  8648,
  7994,
  16836,
  7630,
  14047,
  359699,
  106878,
  525,
  29037,
  28064,
  13380,
  11675,
  50669,
  74216,
  103539,
  180314,
  27449,
  56299,
  172344,
  19274,
  7301,
  246099,
  32043,
  19422,
  36506,
  129317,
  6806,
  30140,
  4614,
  46639,
  66926,
  932,
  86600,
  6322,
  27847,
  233103,
  10541,
  39025,
  34887,
  3517,
  12972,
  26220,
  2031,
  66561,
  115015,
  48658,
  47596,
  12714,
  33845,
  3893,
  16165,
  35237,
  89983,
  14769,
  11962,
  147224,
  47018,
  29977,
  27979,
  5552,
  82338,
  86023,
  131368,
  1218,
  24853,
  237840,
  132193,
  15455,
  40873,
  3668,
  65351,
  53388,
  15229,
  59889,
  272245,
  47934,
  11858,
  34347,
  18038,
  90853,
  86981,
  300602,
  19343,
  114181,
  29362,
  84921,
  6095,
  106059,
  79472,
  38015,
  1206,
  48741,
  6208,
  8e4,
  21916,
  17423,
  6002,
  108083,
  24479,
  34931,
  56661,
  9511,
  26995,
  100694,
  163853,
  35997,
  81254,
  58321,
  18919,
  171890,
  86877,
  91341,
  74503,
  70477,
  53412,
  7027,
  59281,
  39892,
  131302,
  5864,
  15947,
  61301,
  67466,
  162369,
  47956,
  27874,
  35624,
  282324,
  21270,
  111847,
  102548,
  41482,
  30955,
  116737,
  28264,
  8592,
  55458,
  22301,
  75090,
  29821,
  30697,
  51709,
  3041,
  19208,
  8038,
  24634,
  30467,
  87509,
  126428,
  19389,
  18814,
  152686,
  20701,
  83474,
  45832,
  80891,
  105808,
  11378,
  153223,
  120770,
  98186,
  150633,
  49838,
  9141,
  12755,
  30962,
  5260,
  74490,
  21256,
  31678,
  65062,
  33326,
  289838,
  187831,
  20595,
  89768,
  2805,
  58535,
  10844,
  70085,
  12090,
  2451,
  138068,
  98544,
  24461,
  4511,
  6754,
  41684,
  28203,
  3383,
  65355,
  82833,
  30161,
  83924,
  234361,
  128424,
  28921,
  222594,
  33975,
  125491,
  34069,
  11508,
  67464,
  144226,
  41850,
  98703,
  34371,
  7901,
  21254,
  38398,
  65651,
  23549,
  53883,
  213340,
  123269,
  12028,
  71764,
  177701,
  28758,
  2623,
  68395,
  11549,
  15232,
  68603,
  9660,
  63116,
  36079,
  57093,
  31198,
  20475,
  48467,
  89984,
  35619,
  186847,
  107469,
  31389,
  43631,
  73867,
  41949,
  68841,
  114250,
  1605,
  30564,
  63403,
  17588,
  27680,
  99533,
  12641,
  70325,
  50428,
  73426,
  78379,
  11855,
  91651,
  72081,
  91720,
  60198,
  15743,
  12065,
  83398,
  140046,
  6761,
  46598,
  45900,
  5068,
  886,
  62448,
  148968,
  37347,
  19405,
  9680,
  15819,
  43496,
  63370,
  75667,
  163700,
  37639,
  3633,
  22774,
  34341,
  183131,
  134335,
  37200,
  23915,
  7054,
  14194,
  12970,
  26438,
  13350,
  285521,
  25594,
  8219,
  104410,
  91039,
  168804,
  138480,
  149734,
  15907,
  33818,
  61132,
  60082,
  4622,
  110187,
  56736,
  13551,
  73571,
  3945,
  73463,
  65498,
  17758,
  263266,
  17593,
  2710,
  27585,
  54469,
  38200,
  45367,
  63754,
  28881,
  3473,
  12791,
  98287,
  31895,
  65787,
  4463,
  94536,
  24951,
  36332,
  59901,
  28803,
  52130,
  86403,
  7668,
  181822,
  74831,
  18977,
  9850,
  177206,
  145485,
  109798,
  7292,
  31421,
  26280,
  77211,
  58511,
  12507,
  127004,
  11113,
  147,
  8729,
  56208,
  43066,
  79926,
  129937,
  31345,
  83947,
  39915,
  46146,
  98763,
  42566,
  1337,
  13192,
  18323,
  105163,
  80570,
  117753,
  16555,
  72883,
  11077,
  159438,
  40764,
  70933,
  83329,
  26066,
  12276,
  72059,
  21655,
  173836,
  126713,
  69454,
  153482,
  91585,
  70644,
  102558,
  110483,
  6764,
  127864,
  190133,
  3961,
  101798,
  20945,
  71138,
  82402,
  90884,
  69669,
  44753,
  923,
  16939,
  59700,
  164258,
  25969,
  27082,
  31399,
  43846,
  6306,
  246093,
  51342,
  6153,
  151581,
  202801,
  182731,
  56475,
  162188,
  89426,
  141356,
  14355,
  121815,
  27536,
  28023,
  65257,
  77523,
  106668,
  127314,
  24947,
  12790,
  38796,
  169698,
  23555,
  10725,
  44573,
  183083,
  42088,
  62716,
  43265,
  105958,
  32050,
  44067,
  50118,
  1668,
  3874,
  6243,
  318411,
  16599,
  1691,
  94999,
  52378,
  28671,
  216728,
  123258,
  2059,
  34969,
  69225,
  5913,
  136280,
  171443,
  141515,
  91662,
  22175,
  135282,
  80020,
  92270,
  1663,
  4808,
  4482,
  3495,
  34691,
  5226,
  109830,
  108512,
  17342,
  107488,
  11606,
  123190,
  100247,
  29666,
  146527,
  113014,
  15794,
  30894,
  13224,
  39585,
  243192,
  22351,
  9903,
  7836,
  47699,
  11078,
  25468,
  122291,
  48821,
  26780,
  122679,
  75521,
  81450,
  630,
  4895,
  92900,
  55074,
  74293,
  17441,
  3563,
  111657,
  103102,
  51613,
  12318,
  52370,
  36191,
  68245,
  34269,
  40445,
  41354,
  122901,
  168604,
  182500,
  62012,
  42557,
  11259,
  24428,
  115113,
  86345,
  12362,
  3909,
  78430,
  86852,
  134602,
  20459,
  47853,
  93879,
  22577,
  7659,
  3688,
  38555,
  13349,
  17381,
  56715,
  91639,
  12493,
  10895,
  92438,
  3142,
  37057,
  28928,
  2004,
  36427,
  32268,
  34222,
  209974,
  10432,
  67436,
  41989,
  173518,
  107930,
  27079,
  62729,
  30908,
  55558,
  5828,
  45031,
  14902,
  53546,
  8204,
  144263,
  60255,
  14520,
  88212,
  86582,
  109589,
  69356,
  8064,
  47449,
  8505,
  66558,
  16886,
  4844,
  52817,
  111260,
  215129,
  12941,
  91118,
  650,
  20770,
  6273,
  73089,
  40618,
  62790,
  2873,
  35002,
  14023,
  97208,
  19386,
  102646,
  36993,
  143736,
  135457,
  35385,
  113601,
  17893,
  32627,
  84439,
  100619,
  56016,
  6581,
  57264,
  172160,
  45452,
  111710,
  203627,
  70131,
  24100,
  322787,
  1996,
  35665,
  70078,
  22358,
  90922,
  83658,
  4097,
  63200,
  58499,
  14542,
  99153,
  52159,
  6615,
  12414,
  63415,
  31986,
  16823,
  1579,
  65405,
  137809,
  8841,
  16898,
  48082,
  259,
  33014,
  42375,
  12260,
  179850,
  73667,
  91389,
  98882,
  29532,
  17311,
  326251,
  41092,
  5928,
  20742,
  44964,
  48019,
  43505,
  9317,
  49265,
  6643,
  192712,
  48424,
  163487,
  19861,
  20113,
  70848,
  31928,
  105333,
  23685,
  78563,
  14638,
  54755,
  7158,
  24142,
  44018,
  20774,
  125255,
  20331,
  24280,
  10163,
  1285,
  2336,
  39851,
  4299,
  117269,
  46714,
  63816,
  87779,
  159624,
  11731,
  9971,
  990,
  137317,
  108831,
  50994,
  74554,
  162680,
  23640,
  131597,
  146962,
  170620,
  34829,
  91205,
  21184,
  1913,
  63616,
  18427,
  93136,
  156592,
  17519,
  67565,
  115882,
  138220,
  78622,
  88535,
  18115,
  2711,
  33554,
  109492,
  54298,
  971,
  24914,
  25863,
  36363,
  45715,
  27099,
  194995,
  14299,
  178181,
  111488,
  72395,
  322385,
  157719,
  130787,
  11897,
  81843,
  83999,
  11369,
  49280,
  118604,
  40922,
  61332,
  110343,
  53407,
  75639,
  40582,
  300440,
  54722,
  25637,
  13694,
  48248,
  48278,
  194521,
  56203,
  52779,
  48783,
  72627,
  10953,
  376,
  16733,
  280238,
  26351,
  230789,
  15132,
  25168,
  137270,
  3588,
  63704,
  73376,
  94031,
  74284,
  19443,
  159557,
  9697,
  39901,
  13351,
  119050,
  15406,
  146455,
  3460,
  29556,
  75195,
  37673,
  102524,
  92329,
  47289,
  98413,
  15311,
  100684,
  56345,
  7116,
  95480,
  11590,
  7200,
  167,
  23610,
  58426,
  17730,
  136656,
  27944,
  53151,
  2701,
  8824,
  103124,
  3017,
  90744,
  113588,
  53216,
  79736,
  65940,
  26931,
  498,
  29568,
  80540,
  143543,
  21292,
  1740,
  59268,
  16561,
  180816,
  42323,
  50174,
  40890,
  52866,
  10703,
  57169,
  4700,
  17191,
  4424,
  93511,
  49698,
  166650,
  26972,
  48631,
  165169,
  82879,
  69326,
  202970,
  4007,
  2376,
  231325,
  139592,
  22119,
  62851,
  37504,
  68816,
  58345,
  67398,
  186643,
  43331,
  277416,
  53749,
  15746,
  23102,
  17432,
  4793,
  151138,
  48822,
  54265,
  48203,
  198688,
  14305,
  54287,
  2291,
  18018,
  113378,
  123260,
  7180,
  97549,
  87027,
  120085,
  2920,
  76080,
  8190,
  102005,
  5641,
  64580,
  14955,
  59802,
  54028,
  58884,
  19367,
  81779,
  412567,
  85957,
  97053,
  103637,
  78871,
  29364,
  27637,
  141728,
  4767,
  30686,
  112738,
  130146,
  42745,
  12730,
  105040,
  14844,
  232,
  210944,
  36581,
  152317,
  135543,
  29744,
  3129,
  55647,
  58149,
  46319,
  27265,
  17499,
  28005,
  59948,
  7170,
  34138,
  5702,
  293047,
  110892,
  408,
  91760,
  218674,
  18469,
  46095,
  81403,
  14389,
  4610,
  35672,
  73060,
  11006,
  74848,
  104820,
  118143,
  190357,
  20043,
  105358,
  141735,
  5115,
  27093,
  45924,
  123073,
  52599,
  29433,
  9616,
  238350,
  78610,
  24851,
  58858,
  26769,
  31969,
  24613,
  18294,
  4982,
  32735,
  39639,
  143563,
  112073,
  202205,
  12567,
  4873,
  88601,
  44897,
  81503,
  101648,
  81362,
  34662,
  85277,
  17574,
  48173,
  21435,
  221188,
  40215,
  39576,
  80786,
  26544,
  64668,
  81841,
  10731,
  37733,
  247986,
  149188,
  127703,
  495,
  18382,
  54388,
  72446,
  43071,
  30974,
  198723,
  89608,
  41360,
  190,
  33045,
  8386,
  31658,
  19992,
  237838,
  119015,
  137622,
  50890,
  100913,
  6460,
  116233,
  267230,
  26621,
  104129,
  65114,
  14190,
  41542,
  14888,
  85962,
  23342,
  23041,
  26453,
  43725,
  71809,
  45186,
  4770,
  46452,
  53894,
  56616,
  221286,
  18973,
  9038,
  109299,
  55365,
  19366,
  26863,
  18808,
  60909,
  69353,
  41738,
  83463,
  12100,
  68561,
  72860,
  3980,
  13796,
  49340,
  12332,
  31311,
  27418,
  4255,
  53430,
  18976,
  45523,
  510,
  14224,
  30477,
  26581,
  4530,
  3651,
  101663,
  139840,
  22709,
  150861,
  31996,
  63923,
  120623,
  262522,
  3076,
  10528,
  2929,
  14672,
  130238,
  18087,
  9816,
  121894,
  100308,
  25085,
  55111,
  14565,
  18952,
  53293,
  2042,
  369988,
  23674,
  61789,
  133529,
  28783,
  108293,
  35477,
  47119,
  36448,
  71049,
  40015,
  33055,
  78598,
  198442,
  1833,
  159937,
  40654,
  77444,
  189245,
  113153,
  8621,
  18599,
  38553,
  35223,
  166072,
  2375,
  11659,
  21786,
  89523,
  6032,
  12116,
  63046,
  159398,
  18454,
  3678,
  32521,
  47626,
  11411,
  103527,
  38896,
  42946,
  15696,
  26370,
  10185,
  8413,
  37080,
  165583,
  4331,
  63555,
  14907,
  72220,
  50056,
  6623,
  62236,
  36565,
  49783,
  10049,
  17503,
  100581,
  55951,
  146244,
  24724,
  9626,
  17969,
  25524,
  109300,
  173965,
  99994,
  101056,
  46459,
  43647,
  53737,
  277968,
  8347,
  123521,
  74858,
  33829,
  44762,
  77574,
  877,
  81377,
  222525,
  123532,
  30602,
  43881,
  53145,
  2973,
  16284,
  81940,
  61281,
  127044,
  63620,
  9875,
  14756,
  114829,
  19032,
  9202,
  52759,
  119141,
  23928,
  120551,
  19607,
  3599,
  33401,
  76821,
  73233,
  117430,
  39968,
  36539,
  7071,
  5446,
  121735,
  194059,
  15206,
  45283,
  6706,
  15603,
  65615,
  1207,
  165723,
  92275,
  34773,
  104447,
  8396,
  32353,
  205240,
  164323,
  13600,
  60555,
  79205,
  25532,
  22907,
  33410,
  57480,
  107111,
  69630,
  32137,
  47832,
  70913,
  33161,
  20321,
  2371,
  117348,
  10714,
  86246,
  1625,
  11763,
  17900,
  268,
  78457,
  99175,
  97940,
  101092,
  86660,
  32221,
  14041,
  128504,
  125080,
  53744,
  124263,
  31017,
  13897,
  403,
  31859,
  21964,
  5633,
  111630,
  5547,
  77329,
  17961,
  18241,
  84995,
  25984,
  12983,
  67491,
  62168,
  47262,
  5241,
  297,
  51191,
  7351,
  8967,
  147212,
  82060,
  16821,
  782,
  11033,
  82431,
  62957,
  5026,
  43459,
  77963,
  203477,
  53528,
  6247,
  191852,
  87774,
  74164,
  215654,
  13467,
  1522,
  219964,
  28589,
  244104,
  16242,
  117821,
  67725,
  72570,
  156792,
  17186,
  15979,
  26990,
  44128,
  193014,
  35276,
  57125,
  16212,
  166451,
  68017,
  6905,
  77608,
  16364,
  53777,
  75921,
  76426,
  37975,
  26203,
  269296,
  64099,
  84122,
  12077,
  38533,
  830,
  4407,
  20139,
  963,
  43028,
  38902,
  42911,
  37503,
  83343,
  85045,
  16979,
  1165,
  60835,
  137387,
  58380,
  86990,
  110066,
  134540,
  56331,
  193845,
  81238,
  17922,
  163093,
  38744,
  110641,
  12502,
  56404,
  34862,
  26865,
  125964,
  12965,
  111648,
  25547,
  7771,
  27196,
  136980,
  9555,
  29551,
  107158,
  57885,
  18831,
  37705,
  35505,
  101742,
  13970,
  102109,
  62548,
  124657,
  23328,
  11124,
  89592,
  146376,
  248050,
  6241,
  22033,
  18337,
  80685,
  29898,
  11908,
  216623,
  67721,
  106162,
  146610,
  21377,
  15085,
  91552,
  42041,
  62560,
  122532,
  125336,
  102365,
  121537,
  142559,
  29693,
  223919,
  11515,
  110495,
  18776,
  22494,
  5895,
  185059,
  103592,
  229351,
  51220,
  100102,
  37027,
  257855,
  29359,
  54123,
  36066,
  106493,
  12244,
  79258,
  32002,
  432,
  56205,
  94836,
  90182,
  6726,
  14762,
  29391,
  48938,
  26864,
  38083,
  60364,
  3310,
  60192,
  14766,
  205567,
  57504,
  110760,
  22649,
  24666,
  46333,
  21517,
  3430,
  13135,
  28873,
  27052,
  158809,
  11597,
  20529,
  6695,
  23138,
  22960,
  37137,
  45574,
  6545,
  305877,
  43423,
  26153,
  24769,
  59844,
  14501,
  10430,
  134352,
  56169,
  13213,
  103432,
  49523,
  35181,
  13435,
  12408,
  129475,
  64620,
  230854,
  77390,
  51990,
  15653,
  83248,
  33466,
  44571,
  117828,
  51481,
  2187,
  10559,
  68019,
  18021,
  54895,
  48247,
  18354,
  33737,
  4554,
  108595,
  37288,
  39767,
  116707,
  9175,
  3726,
  108877,
  21616,
  83684,
  49862,
  1938,
  8543,
  276466,
  20134,
  108498,
  48770,
  102254,
  31914,
  131520,
  185291,
  100559,
  51890,
  209,
  19526,
  76471,
  50544,
  71814,
  99351,
  8172,
  198526,
  28816,
  20419,
  9109,
  98389,
  136777,
  76479,
  75596,
  30635,
  165417,
  48216,
  120220,
  25955,
  211071,
  39314,
  24308,
  32164,
  2559,
  146280,
  43403,
  9233,
  17947,
  90585,
  1786,
  86920,
  125662,
  2457,
  64741,
  32152,
  32918,
  122882,
  78538,
  44001,
  31723,
  56426,
  23375,
  103172,
  88177,
  145697,
  52506,
  49319,
  68016,
  31664,
  41488,
  18486,
  110400,
  7030,
  28241,
  986,
  109199,
  19900,
  42147,
  56864,
  65287,
  49183,
  7858,
  24e3,
  30453,
  840,
  16673,
  25907,
  68916,
  89927,
  6309,
  158335,
  36407,
  199737,
  130464,
  13137,
  59603,
  201778,
  195292,
  21015,
  42466,
  179062,
  172561,
  89492,
  11075,
  180407,
  31868,
  72493,
  20998,
  60217,
  9865,
  19530,
  39274,
  130266,
  54539,
  21623,
  12535,
  13505,
  40641,
  73375,
  4087,
  85633,
  2153,
  3117,
  70680,
  55788,
  92096,
  47509,
  98493,
  37490,
  271936,
  151475,
  3032,
  16171,
  96642,
  34106,
  78425,
  125761,
  19591,
  3366,
  19316,
  54508,
  24183,
  50786,
  194248,
  91528,
  33253,
  34622,
  108355,
  41741,
  705,
  3814,
  3883,
  108929,
  13203,
  67831,
  10142,
  59754,
  68208,
  29128,
  84820,
  56880,
  38794,
  24972,
  48571,
  40821,
  40476,
  18137,
  164254,
  24064,
  236309,
  79181,
  11282,
  395,
  39169,
  2013,
  51587,
  28551,
  9645,
  701,
  109513,
  115899,
  113566,
  12762,
  62045,
  58322,
  103726,
  41343,
  40866,
  244102,
  143816,
  2490,
  70346,
  40973,
  52618,
  15412,
  30720,
  104315,
  38917,
  42027,
  93676,
  17513,
  107418,
  20706,
  123890,
  13399,
  97727,
  24044,
  87962,
  65606,
  44250,
  98044,
  65276,
  74790,
  101473,
  19350,
  91570,
  1326,
  87790,
  172042,
  7577,
  100813,
  86896,
  85891,
  41512,
  108130,
  27794,
  14875,
  71431,
  12835,
  156250,
  58135,
  3759,
  22476,
  42176,
  115873,
  34686,
  56523,
  73643,
  108505,
  51491,
  20838,
  12721,
  32863,
  45700,
  29496,
  13700,
  34294,
  55360,
  29206,
  155942,
  123812,
  7706,
  163234,
  203,
  132720,
  49358,
  144431,
  8130,
  175788,
  35818,
  3270,
  76832,
  25710,
  54095,
  97274,
  28779,
  94621,
  74396,
  19092,
  128242,
  58067,
  20885,
  14670,
  93255,
  15107,
  63291,
  23654,
  126900,
  129421,
  59294,
  262659,
  9798,
  3251,
  67344,
  28600,
  44629,
  50672,
  29072,
  26999,
  31526,
  23183,
  49175,
  165843,
  175455,
  17282,
  175411,
  32022,
  45989,
  30298,
  90690,
  78118,
  83156,
  23749,
  35636,
  31317,
  7069,
  80381,
  94561,
  133756,
  14960,
  97404,
  6138,
  41065,
  78041,
  32843,
  16601,
  34123,
  9559,
  146529,
  123377,
  96395,
  54441,
  42012,
  84257,
  123541,
  10745,
  22139,
  106459,
  11720,
  150883,
  172651,
  154996,
  110538,
  4728,
  53447,
  25704,
  2009,
  71152,
  119354,
  21166,
  66604,
  1429,
  216162,
  8637,
  122250,
  63520,
  27180,
  29172,
  36124,
  276428,
  107787,
  77184,
  4680,
  14952,
  104903,
  24418,
  14793,
  51561,
  52931,
  8371,
  26342,
  48526,
  7118,
  92066,
  67280,
  40653,
  8847,
  34597,
  105438,
  14198,
  50163,
  61188,
  146286,
  50315,
  41205,
  170829,
  161496,
  585,
  197359,
  95056,
  1687,
  365794,
  91349,
  48507,
  5804,
  49263,
  5146,
  104902,
  96365,
  117343,
  132222,
  46084,
  96919,
  16875,
  8073,
  262381,
  79982,
  52663,
  13928,
  16056,
  153908,
  15145,
  109256,
  132308,
  18763,
  24904,
  167644,
  13618,
  40750,
  18686,
  147124,
  114709,
  150038,
  52849,
  2938,
  12568,
  48617,
  8778,
  5459,
  44202,
  44591,
  74914,
  17183,
  248689,
  13878,
  7822,
  80060,
  23116,
  194037,
  18487,
  2067,
  7798,
  43077,
  33678,
  244028,
  31320,
  74273,
  2794,
  19466,
  8218,
  36280,
  183997,
  48124,
  19416,
  29656,
  19280,
  98734,
  7715,
  18311,
  30701,
  133602,
  150307,
  126956,
  7378,
  2933,
  79903,
  13178,
  12593,
  86571,
  26604,
  92446,
  13574,
  44205,
  65699,
  427599,
  21118,
  8245,
  14407,
  27877,
  47936,
  33542,
  7916,
  26460,
  117762,
  21596,
  37818,
  2249,
  127359,
  209394,
  60044,
  47677,
  308089,
  36791,
  154971,
  31417,
  6998,
  150042,
  174360,
  12255,
  43009,
  29335,
  48739,
  3912,
  101398,
  53340,
  2580,
  146939,
  151295,
  45360,
  125275,
  15273,
  45383,
  27456,
  48761,
  23314,
  8750,
  60801,
  85823,
  104759,
  27894,
  123685,
  66968,
  39480,
  26917,
  55290,
  83305,
  2696,
  98390,
  57569,
  145853,
  340733,
  4919,
  20024,
  52268,
  30884,
  7413,
  203685,
  70989,
  112855,
  4129,
  50536,
  349518,
  68205,
  332641,
  159581,
  135361,
  236026,
  37563,
  176404,
  64899,
  6578,
  122033,
  63871,
  1850,
  85234,
  82089,
  66124,
  74145,
  121098,
  107351,
  12687,
  36881,
  117334,
  13136,
  14698,
  85933,
  93866,
  18047,
  32620,
  310,
  15094,
  46e3,
  88451,
  23632,
  36645,
  27940,
  87618,
  80520,
  58892,
  20976,
  27702,
  140090,
  96075,
  67841,
  103292,
  238964,
  87778,
  107338,
  17019,
  83427,
  67522,
  7302,
  8261,
  47570,
  116787,
  8730,
  80484,
  61772,
  174422,
  56005,
  131193,
  52875,
  14588,
  28471,
  59817,
  9586,
  15720,
  158155,
  51307,
  109734,
  15196,
  11025,
  59331,
  3884,
  52626,
  102602,
  84797,
  25158,
  27314,
  4437,
  20488,
  76214,
  189248,
  35023,
  114952,
  157376,
  2827,
  62439,
  102878,
  129749,
  36405,
  10329,
  109339,
  108633,
  36662,
  1254,
  13267,
  5470,
  87105,
  58004,
  15397,
  10434,
  159667,
  21864,
  52022,
  179464,
  3013,
  32147,
  31496,
  116832,
  18494,
  105502,
  129227,
  107267,
  50033,
  13481,
  9954,
  24267,
  22141,
  16257,
  116154,
  36185,
  950,
  115685,
  11305,
  176708,
  2048,
  178671,
  112573,
  287867,
  162328,
  497663,
  95170,
  50979,
  193861,
  50987,
  30368,
  136257,
  31830,
  46549,
  15119,
  169876,
  23788,
  17462,
  249887,
  57377,
  1949,
  35448,
  14791,
  43769,
  210091,
  3783,
  34612,
  282103,
  88380,
  245190,
  5457,
  20491,
  98908,
  11402,
  86899,
  117916,
  16028,
  162584,
  60644,
  320177,
  156096,
  31065,
  55876,
  22e3,
  77655,
  9992,
  23397,
  13757,
  317623,
  63978,
  215255,
  2443,
  17648,
  93231,
  27388,
  104529,
  93807,
  55505,
  140477,
  12046,
  112040,
  70887,
  40152,
  94365,
  112353,
  25063,
  114679,
  266061,
  71248,
  119555,
  15589,
  2244,
  617,
  14129,
  211431,
  70110,
  100652,
  7777,
  4383,
  85911,
  89221,
  21010,
  120615,
  58357,
  86405,
  37554,
  41647,
  18,
  15143,
  69662,
  60491,
  14714,
  186134,
  148344,
  42347,
  5410,
  168175,
  44535,
  42449,
  343894,
  129417,
  99682,
  20659,
  27272,
  140483,
  63455,
  222159,
  17536,
  13722,
  42637,
  62324,
  11976,
  114691,
  148109,
  2283,
  32057,
  182393,
  4295,
  147364,
  33705,
  2075,
  44303,
  30274,
  28331,
  63740,
  69740,
  29148,
  10346,
  44862,
  33716,
  73937,
  153333,
  12930,
  38784,
  247159,
  2515,
  41053,
  20256,
  83368,
  256189,
  54639,
  115240,
  5096,
  24661,
  175419,
  153552,
  26516,
  141,
  138176,
  63885,
  34115,
  47222,
  55709,
  2765,
  28479,
  38875,
  236608,
  12229,
  22921,
  77291,
  54426,
  45388,
  2860,
  57787,
  114579,
  295139,
  105782,
  17826,
  71066,
  19119,
  54364,
  69385,
  16568,
  12323,
  28057,
  33346,
  34919,
  124763,
  155533,
  101386,
  31644,
  8627,
  49001,
  303600,
  29868,
  63213,
  9103,
  77280,
  71333,
  9696,
  138789,
  37059,
  24823,
  5057,
  21352,
  32368,
  114208,
  56803,
  19424,
  10445,
  58514,
  8661,
  209508,
  26187,
  171838,
  10460,
  63454,
  14016,
  122504,
  41328,
  21329,
  46618,
  32493,
  38225,
  7855,
  31763,
  7945,
  29876,
  8734,
  6438,
  24205,
  97490,
  139977,
  130740,
  47323,
  33195,
  85390,
  57194,
  13813,
  60600,
  21313,
  96251,
  7699,
  27584,
  170521,
  139271,
  1363,
  4402,
  336738,
  129223,
  84983,
  69150,
  13147,
  3590,
  163929,
  207225,
  155260,
  55916,
  20288,
  4503,
  8398,
  98490,
  11773,
  27512,
  37113,
  84976,
  86558,
  28365,
  11756,
  116005,
  182148,
  13733,
  115313,
  47644,
  67208,
  85069,
  9347,
  14995,
  226141,
  14704,
  101835,
  41159,
  35314,
  13113,
  63526,
  214039,
  29978,
  50446,
  83339,
  17440,
  129441,
  72522,
  118641,
  97816,
  24907,
  73844,
  15717,
  118884,
  167255,
  96509,
  162793,
  30847,
  36849,
  51297,
  78974,
  77793,
  10427,
  1873,
  2972,
  9999,
  35074,
  28190,
  64297,
  146836,
  46298,
  60038,
  163007,
  108919,
  61219,
  2403,
  75022,
  127339,
  4233,
  110389,
  69022,
  9833,
  128097,
  88016,
  79390,
  222936,
  22570,
  94657,
  28462,
  56956,
  38803,
  81536,
  30474,
  152794,
  19566,
  16481,
  147408,
  74574,
  81895,
  20731,
  1918,
  1366,
  76367,
  187321,
  54494,
  24366,
  21690,
  61696,
  33283,
  107477,
  77499,
  31112,
  414383,
  74362,
  18463,
  218441,
  120929,
  59848,
  258629,
  201924,
  69269,
  454,
  19989,
  13054,
  59894,
  3623,
  58908,
  20681,
  35723,
  78523,
  102680,
  38988,
  184112,
  108087,
  50944,
  132704,
  52966,
  21699,
  18860,
  96349,
  201411,
  82697,
  85395,
  95658,
  5093,
  6427,
  177894,
  44191,
  32755,
  26961,
  155739,
  6249,
  31310,
  81030,
  26574,
  84311,
  120155,
  86730,
  113535,
  7424,
  48888,
  13516,
  45747,
  98098,
  20077,
  183995,
  81945,
  43210,
  26704,
  40420,
  75831,
  45648,
  11180,
  6855,
  57927,
  65528,
  124096,
  34851,
  2598,
  156633,
  107572,
  127352,
  38169,
  123845,
  60142,
  62722,
  105584,
  232364,
  23211,
  68120,
  1601,
  22169,
  89299,
  747,
  258039,
  80572,
  7258,
  152249,
  11862,
  101204,
  8834,
  121434,
  33761,
  19175,
  133142,
  46343,
  40178,
  48723,
  3589,
  41977,
  30210,
  38868,
  62257,
  10087,
  82658,
  87827,
  90646,
  16415,
  47552,
  351723,
  28298,
  72225,
  91146,
  272760,
  1701,
  11295,
  1652,
  109651,
  300747,
  51863,
  198800,
  29446,
  11794,
  32345,
  37538,
  22356,
  33102,
  37590,
  113544,
  37970,
  11478,
  179743,
  25454,
  103417,
  59905,
  221970,
  105196,
  145604,
  7817,
  164809,
  102360,
  16974,
  75840,
  255333,
  56902,
  6659,
  1954,
  645,
  59400,
  67769,
  7689,
  18675,
  5215,
  13793,
  20536,
  27852,
  3387,
  29523,
  259718,
  16860,
  94625,
  43143,
  29245,
  15848,
  233581,
  22685,
  63631,
  78557,
  22836,
  133302,
  84513,
  1348,
  51826,
  47129,
  98836,
  58284,
  1830,
  1749,
  94642,
  10933,
  6145,
  12506,
  10975,
  13879,
  103781,
  144434,
  10268,
  28409,
  32346,
  52968,
  121567,
  107374,
  77268,
  23686,
  35097,
  10501,
  155275,
  15303,
  47136,
  21102,
  168741,
  55332,
  90385,
  15996,
  84817,
  681,
  137803,
  25054,
  142275,
  6163,
  38175,
  8056,
  124296,
  240642,
  65621,
  4934,
  178205,
  16101,
  62803,
  60964,
  18230,
  100622,
  76465,
  44689,
  14545,
  9543,
  47514,
  16852,
  93380,
  28048,
  12047,
  107106,
  37575,
  101485,
  77047,
  57326,
  34819,
  96137,
  76916,
  6469,
  46264,
  115983,
  75768,
  87668,
  69942,
  13027,
  165,
  8373,
  114231,
  26434,
  52844,
  42799,
  182044,
  23580,
  146254,
  38081,
  43236,
  33883,
  146220,
  382894,
  14606,
  46035,
  36481,
  166621,
  35417,
  95382,
  2957,
  59384,
  60428,
  36358,
  66343,
  75378,
  22267,
  22950,
  83528,
  17577,
  56474,
  25285,
  4619,
  179691,
  75355,
  95836,
  53295,
  34588,
  171410,
  4487,
  14679,
  84208,
  44015,
  18562,
  109133,
  54101,
  11531,
  86052,
  174479,
  303157,
  28095,
  9953,
  35642,
  14564,
  39802,
  16145,
  77606,
  117406,
  53038,
  121117,
  53624,
  22062,
  1212,
  7632,
  127157,
  237292,
  189087,
  10478,
  127345,
  102515,
  181997,
  86752,
  87623,
  10966,
  121602,
  68783,
  68681,
  83042,
  114380,
  138349,
  191305,
  67176,
  50085,
  39016,
  1427,
  42384,
  1412,
  67118,
  122616,
  72389,
  25260,
  2237,
  13576,
  137346,
  19938,
  20304,
  2191,
  68759,
  5373,
  61364,
  238507,
  75814,
  23931,
  69565,
  38993,
  131741,
  38364,
  12528,
  87762,
  5679,
  129853,
  5310,
  186831,
  32653,
  90338,
  260176,
  389531,
  108118,
  26843,
  43985,
  50175,
  30563,
  25106,
  56965,
  18130,
  140428,
  4542,
  165503,
  117991,
  24219,
  229605,
  1819,
  129663,
  1240,
  3797,
  76093,
  18398,
  71339,
  51919,
  93043,
  27175,
  47060,
  216257,
  6483,
  35051,
  1217,
  16512,
  80798,
  129064,
  13225,
  69339,
  8548,
  237079,
  72298,
  2575,
  34280,
  51379,
  117910,
  55671,
  53345,
  247552,
  29486,
  39328,
  140821,
  34681,
  57045,
  60177,
  5004,
  90269,
  78522,
  2479,
  322607,
  48474,
  61296,
  13057,
  31558,
  4678,
  59271,
  6699,
  27044,
  31988,
  35944,
  12503,
  83480,
  4389,
  136508,
  3781,
  114121,
  70279,
  4488,
  155829,
  42214,
  2898,
  68191,
  75695,
  305850,
  45041,
  74344,
  106509,
  30087,
  17429,
  93292,
  12477,
  290,
  23080,
  114802,
  35714,
  18751,
  26554,
  105424,
  17775,
  2144,
  2412,
  100610,
  65192,
  113975,
  52975,
  180272,
  135050,
  129815,
  76238,
  106483,
  21440,
  63186,
  4260,
  46189,
  9711,
  28249,
  4169,
  23429,
  23390,
  8324,
  141585,
  63809,
  67668,
  38457,
  38063,
  39226,
  59972,
  1189,
  203916,
  62368,
  14403,
  16949,
  61767,
  85801,
  1739,
  40147,
  35049,
  76757,
  33124,
  62102,
  15780,
  103593,
  103009,
  53484,
  22952,
  67973,
  114645,
  6566,
  5245,
  50462,
  7601,
  8288,
  3513,
  194571,
  80276,
  1908,
  54592,
  5124,
  58571,
  2513,
  6800,
  273997,
  193904,
  1119,
  17991,
  117245,
  2508,
  129156,
  82366,
  26278,
  71465,
  63341,
  56943,
  39662,
  106116,
  94966,
  156875,
  9736,
  2204,
  122308,
  94418,
  27134,
  1280,
  24539,
  49022,
  45314,
  3764,
  50904,
  46424,
  30699,
  28087,
  293839,
  9400,
  33646,
  40165,
  822,
  147499,
  50263,
  116179,
  29085,
  11863,
  31314,
  5578,
  17797,
  5104,
  12454,
  1604,
  15342,
  219206,
  10232,
  67800,
  94261,
  25872,
  13565,
  90339,
  78971,
  75377,
  26649,
  41184,
  47695,
  11514,
  35369,
  20767,
  14227,
  41953,
  309396,
  148270,
  147938,
  33074,
  14453,
  27499,
  109019,
  39018,
  25738,
  240196,
  158931,
  52820,
  8612,
  95853,
  21524,
  137010,
  84901,
  70869,
  70021,
  116794,
  48404,
  38771,
  6732,
  1070,
  70990,
  187297,
  49140,
  5238,
  576,
  3564,
  253975,
  16027,
  16483,
  2811,
  37775,
  19034,
  25259,
  4053,
  2e3,
  70083,
  95774,
  19713,
  33431,
  92703,
  91314,
  42381,
  288770,
  48194,
  95985,
  3991,
  77418,
  13406,
  241328,
  245086,
  56533,
  35275,
  62725,
  9246,
  51924,
  70181,
  95331,
  16163,
  31410,
  79016,
  39312,
  120878,
  119371,
  275987,
  80124,
  27712,
  9186,
  220,
  23598,
  146167,
  85209,
  68238,
  282190,
  57048,
  31273,
  30555,
  80913,
  17594,
  75779,
  59160,
  135002,
  101219,
  189377,
  29225,
  96735,
  60126,
  62522,
  104e3,
  27620,
  86814,
  17240,
  147533,
  11001,
  5425,
  43682,
  410,
  49460,
  87270,
  69480,
  46315,
  59448,
  1816,
  76201,
  9431,
  11788,
  87960,
  29063,
  65539,
  47347,
  11678,
  33846,
  7008,
  196704,
  9895,
  6753,
  8633,
  120892,
  59970,
  572824,
  115934,
  6646,
  202559,
  892,
  48351,
  37611,
  251282,
  57823,
  67263,
  57750,
  26527,
  34485,
  90747,
  7685,
  88370,
  6144,
  64182,
  1709,
  41969,
  21458,
  62327,
  181657,
  49247,
  225330,
  122600,
  114574,
  107124,
  85361,
  111833,
  63243,
  71420,
  15655,
  191178,
  72430,
  18063,
  51425,
  54002,
  12364,
  53225,
  86557,
  18193,
  97580,
  41232,
  138398,
  67821,
  128724,
  8944,
  233212,
  101353,
  52099,
  42127,
  14006,
  120107,
  32789,
  32132,
  3498,
  18123,
  33758,
  56058,
  5779,
  128760,
  59888,
  98869,
  18445,
  84702,
  51911,
  13234,
  218379,
  20093,
  39031,
  8074,
  70195,
  20708,
  23462,
  24355,
  131384,
  60189,
  26390,
  10403,
  41060,
  7140,
  10781,
  49410,
  42261,
  87202,
  82566,
  41663,
  43105,
  60276,
  2768,
  5733,
  74176,
  28329,
  2297,
  145430,
  131632,
  83615,
  122915,
  105441,
  655,
  224102,
  5284,
  136426,
  67763,
  16294,
  188511,
  32538,
  61049,
  27893,
  3394,
  13951,
  159099,
  28542,
  17930,
  145360,
  9492,
  190122,
  32285,
  78855,
  26440,
  13570,
  58648,
  73908,
  4239,
  124561,
  2444,
  74172,
  53131,
  11468,
  10794,
  73566,
  11623,
  35343,
  64710,
  30481,
  4163,
  10328,
  38309,
  29901,
  10538,
  154377,
  76132,
  92405,
  24839,
  11679,
  3465,
  13449,
  11637,
  7824,
  2337,
  57754,
  1260,
  14458,
  41118,
  19878,
  38661,
  13416,
  159180,
  37074,
  163164,
  54137,
  28627,
  52134,
  184900,
  8520,
  40385,
  29546,
  30502,
  22386,
  66527,
  107458,
  6850,
  24022,
  47983,
  30603,
  35083,
  8934,
  304066,
  39500,
  9,
  28261,
  33026,
  77251,
  9374,
  44833,
  116312,
  34990,
  29236,
  63563,
  125639,
  135405,
  165398,
  159055,
  55690,
  88141,
  69643,
  236964,
  31983,
  25572,
  20436,
  36746,
  60896,
  31850,
  16179,
  11828,
  5888,
  3043,
  66368,
  9750,
  31167,
  7915,
  53111,
  36430,
  1333,
  64344,
  93659,
  20061,
  60596,
  180191,
  51630,
  6792,
  30244,
  43509,
  101058,
  22409,
  420,
  44210,
  109783,
  43223,
  27030,
  72477,
  72831,
  32679,
  29235,
  7675,
  47556,
  12258,
  39907,
  149412,
  84926,
  118247,
  24692,
  71717,
  105038,
  86009,
  45941,
  41189,
  89453,
  29856,
  52543,
  30627,
  226798,
  67303,
  59230,
  67415,
  34408,
  1367,
  99685,
  16867,
  128419,
  52147,
  4111,
  125381,
  117881,
  16173,
  44093,
  102224,
  31575,
  23234,
  24870,
  83790,
  127407,
  239098,
  3200,
  994,
  1255,
  100903,
  242275,
  117266,
  55116,
  38205,
  16140,
  29662,
  11307,
  40414,
  208793,
  123355,
  56470,
  4862,
  75600,
  30119,
  58218,
  70828,
  24075,
  26974,
  7802,
  192353,
  4851,
  5475,
  78720,
  66596,
  3409,
  28573,
  64396,
  30381,
  30690,
  59859,
  88256,
  5406,
  99945,
  103064,
  34463,
  37727,
  24238,
  86643,
  60088,
  4057,
  23741,
  5967,
  162904,
  38240,
  28356,
  93858,
  25510,
  122879,
  6897,
  3278,
  7057,
  11971,
  4400,
  35461,
  211413,
  21395,
  59615,
  39471,
  87233,
  55795,
  128426,
  3051,
  22470,
  41950,
  14705,
  3974,
  180108,
  80476,
  78442,
  204996,
  91987,
  15634,
  67610,
  139015,
  142373,
  35611,
  51134,
  10387,
  4353,
  153456,
  57749,
  181039,
  14183,
  68447,
  151532,
  21107,
  36452,
  20551,
  3186,
  46247,
  46383,
  129666,
  88736,
  140662,
  146243,
  2066,
  8360,
  7978,
  64818,
  106963,
  17896,
  47801,
  10723,
  114821,
  223295,
  74192,
  3293,
  3393,
  16987,
  74064,
  11277,
  91622,
  4270,
  29828,
  27951,
  387869,
  103235,
  1374,
  61988,
  120083,
  477,
  145892,
  128378,
  11779,
  211263,
  61354,
  18221,
  17869,
  46530,
  83061,
  108538,
  157981,
  90608,
  67199,
  95080,
  49064,
  195814,
  12302,
  66307,
  10348,
  231346,
  160732,
  112859,
  63633,
  146558,
  21271,
  31037,
  198802,
  47622,
  12862,
  95710,
  3910,
  77850,
  73961,
  85585,
  34752,
  61e3,
  4082,
  24595,
  103679,
  71107,
  8208,
  79568,
  150019,
  16615,
  24961,
  139857,
  32664,
  197366,
  4559,
  54735,
  32696,
  4126,
  162019,
  75698,
  13916,
  70108,
  159638,
  19834,
  9349,
  24675,
  175560,
  49643,
  18206,
  52459,
  27992,
  10809,
  88865,
  401975,
  133172,
  29e3,
  34558,
  30915,
  3658,
  25834,
  42430,
  36562,
  125265,
  18182,
  10155,
  40149,
  97082,
  208980,
  19575,
  60853,
  90529,
  66545,
  9600,
  789,
  46420,
  2317,
  88593,
  55595,
  98980,
  115302,
  5742,
  169155,
  1073,
  177901,
  3472,
  11189,
  63711,
  78643,
  65472,
  50459,
  127979,
  93,
  42202,
  67053,
  21720,
  157650,
  11145,
  141378,
  42033,
  22824,
  85705,
  79114,
  35584,
  15974,
  1510,
  54172,
  28562,
  12451,
  104226,
  19190,
  97151,
  73024,
  20948,
  5151,
  81741,
  21499,
  29006,
  84183,
  198074,
  54003,
  45120,
  170125,
  26240,
  35177,
  28389,
  64863,
  79974,
  60778,
  176915,
  232183,
  45342,
  2038,
  80253,
  41564,
  40703,
  32689,
  5430,
  100689,
  5366,
  23007,
  134279,
  14266,
  26712,
  73993,
  24934,
  64242,
  52113,
  102887,
  61801,
  46415,
  201049,
  54251,
  62133,
  122757,
  164883,
  30815,
  139966,
  2319,
  30842,
  766,
  13362,
  10287,
  134518,
  86111,
  81665,
  82440,
  28333,
  43019,
  18963,
  8804,
  161944,
  23439,
  102144,
  101145,
  80029,
  39052,
  248708,
  30350,
  117340,
  11878,
  128467,
  974,
  138625,
  63961,
  5237,
  74778,
  61834,
  67040,
  43814,
  13690,
  65947,
  33809,
  232476,
  115258,
  181745,
  28824,
  94013,
  9510,
  10246,
  93722,
  81976,
  7217,
  114383,
  3493,
  16014,
  69045,
  72692,
  12145,
  80981,
  9507,
  6692,
  1620,
  60820,
  330444,
  35474,
  33962,
  4797,
  7053,
  295463,
  46445,
  27026,
  12491,
  77988,
  49524,
  35675,
  90947,
  29114,
  166705,
  101385,
  133782,
  32704,
  6186,
  84595,
  176031,
  185623,
  45966,
  151302,
  63069,
  1699,
  107491,
  947,
  15458,
  74452,
  196212,
  6046,
  10498,
  12163,
  10239,
  35191,
  243951,
  9277,
  9090,
  29539,
  54460,
  22820,
  26514,
  112549,
  60372,
  51753,
  48756,
  21812,
  70861,
  260326,
  41,
  44222,
  10441,
  16961,
  48148,
  138771,
  216194,
  5914,
  52153,
  53400,
  212036,
  56519,
  26245,
  10117,
  45888,
  15294,
  138019,
  90913,
  26368,
  43842,
  42111,
  23348,
  6082,
  194845,
  161089,
  156206,
  51546,
  11647,
  30759,
  302912,
  262094,
  8635,
  78876,
  26535,
  35283,
  54183,
  31183,
  85484,
  147873,
  12989,
  5197,
  6356,
  72894,
  65347,
  20150,
  27370,
  73787,
  1493,
  45918,
  12366,
  190217,
  20724,
  13858,
  10981,
  67449,
  81213,
  7553,
  14115,
  72242,
  271517,
  11842,
  48310,
  88743,
  143726,
  22177,
  3290,
  243231,
  58452,
  62937,
  12592,
  1654,
  40066,
  33477,
  13751,
  9921,
  128442,
  15868,
  7106,
  75236,
  83773,
  10775,
  36938,
  10482,
  170465,
  17368,
  17469,
  161508,
  32752,
  98340,
  800,
  19824,
  264456,
  3901,
  87319,
  2867,
  26782,
  9630,
  113102,
  185815,
  24197,
  44584,
  86366,
  40224,
  3636,
  140916,
  31731,
  267731,
  9567,
  53678,
  72984,
  29389,
  27963,
  17106,
  50282,
  284911,
  60170,
  8322,
  12608,
  23374,
  89652,
  5268,
  39044,
  229766,
  8869,
  151350,
  31436,
  177342,
  12269,
  183212,
  120418,
  116270,
  2843,
  78888,
  69192,
  7865,
  184099,
  1086,
  129897,
  18383,
  70508,
  20242,
  18508,
  229924,
  124569,
  35749,
  50589,
  55626,
  9884,
  83115,
  40971,
  30671,
  18135,
  14452,
  38861,
  17844,
  201826,
  5549,
  26413,
  17189,
  13561,
  38539,
  10679,
  143331,
  3314,
  36785,
  171194,
  49685,
  187713,
  67506,
  4618,
  104039,
  17060,
  195080,
  50648,
  33159,
  19238,
  67559,
  134840,
  28599,
  157523,
  17130,
  38064,
  117398,
  94355,
  31918,
  13575,
  34538,
  40326,
  13997,
  3494,
  348283,
  62481,
  26862,
  3603,
  104426,
  244363,
  153709,
  112487,
  304612,
  199674,
  41239,
  35545,
  54869,
  293005,
  28223,
  26277,
  26899,
  4533,
  18518,
  15492,
  38587,
  80488,
  70485,
  160395,
  263,
  60162,
  11382,
  222152,
  4696,
  250751,
  51921,
  182609,
  10707,
  48463,
  46243,
  1227,
  49111,
  111564,
  46502,
  33342,
  56846,
  68541,
  63559,
  858,
  139927,
  16654,
  229375,
  76759,
  26478,
  33205,
  95828,
  23399,
  92945,
  2637,
  35630,
  28470,
  143992,
  50214,
  14174,
  21456,
  166191,
  65665,
  1711,
  21594,
  78019,
  97599,
  111701,
  36,
  147151,
  110246,
  189022,
  43021,
  30397,
  40757,
  131935,
  42065,
  73335,
  48039,
  26596,
  28984,
  15102,
  2361,
  7421,
  202167,
  69744,
  43766,
  52826,
  3642,
  83304,
  33873,
  75140,
  63169,
  192389,
  36551,
  92748,
  13039,
  123959,
  233220,
  21738,
  84447,
  77230,
  20228,
  187852,
  19095,
  25799,
  92136,
  108774,
  29237,
  53947,
  2299,
  118106,
  2687,
  8830,
  42331,
  202924,
  33667,
  2023,
  73763,
  30704,
  19363,
  19779,
  16737,
  35629,
  48081,
  24068,
  101013,
  162338,
  291912,
  13749,
  24745,
  328289,
  167679,
  70086,
  48299,
  23306,
  16732,
  17801,
  43322,
  54589,
  3586,
  63653,
  43624,
  53474,
  925,
  109177,
  251316,
  43805,
  13082,
  19511,
  86565,
  142182,
  92461,
  17117,
  101033,
  103319,
  64589,
  4022,
  4351,
  235897,
  5352,
  82705,
  107142,
  46391,
  156084,
  5860,
  61365,
  10558,
  13045,
  7717,
  18357,
  33922,
  12590,
  33065,
  6928,
  46993,
  783,
  46937,
  67846,
  8952,
  26295,
  6107,
  119656,
  18799,
  17458,
  50747,
  4229,
  179559,
  112727,
  118080,
  20683,
  41464,
  125468,
  51560,
  49749,
  44231,
  7359,
  35339,
  62988,
  136487,
  67015,
  5208,
  29150,
  24956,
  105186,
  48858,
  6143,
  18097,
  6972,
  16404,
  73489,
  58742,
  97196,
  36357,
  164616,
  5834,
  32267,
  13746,
  147733,
  15113,
  132091,
  34127,
  106298,
  39729,
  106426,
  22294,
  9780,
  15602,
  36213,
  71502,
  42808,
  66802,
  599,
  60755,
  5851,
  39120,
  67363,
  108623,
  126368,
  72770,
  91263,
  32486,
  30596,
  151717,
  7951,
  52002,
  43103,
  11768,
  68942,
  40901,
  39344,
  24037,
  127500,
  116890,
  48403,
  16926,
  86750,
  17745,
  48648,
  159545,
  34460,
  58419,
  5634,
  114317,
  67865,
  31462,
  23352,
  24010,
  98185,
  125708,
  69686,
  68337,
  13610,
  26271,
  70691,
  2980,
  4768,
  27225,
  102402,
  75453,
  28106,
  8104,
  6931,
  1176,
  6274,
  6475,
  112635,
  22498,
  6176,
  238686,
  26832,
  28893,
  90319,
  14441,
  15682,
  15087,
  39517,
  45270,
  109134,
  104440,
  45965,
  47645,
  81772,
  7876,
  52683,
  87720,
  12898,
  4505,
  185665,
  2769,
  113401,
  15664,
  57592,
  105229,
  137381,
  97059,
  119268,
  6876,
  43309,
  33886,
  128363,
  35476,
  144249,
  67013,
  143587,
  83367,
  25703,
  91436,
  59347,
  53236,
  2289,
  16519,
  19844,
  46309,
  58558,
  99834,
  23313,
  218816,
  231303,
  36388,
  51333,
  183535,
  109792,
  139277,
  54306,
  90139,
  18235,
  8275,
  32710,
  37677,
  82464,
  86025,
  92204,
  88842,
  117723,
  37570,
  128723,
  234242,
  76350,
  73795,
  34896,
  148247,
  58424,
  11105,
  11744,
  45746,
  63372,
  17118,
  49772,
  199520,
  81902,
  38004,
  22911,
  33752,
  3125,
  1995,
  53792,
  4689,
  26909,
  108150,
  146062,
  69674,
  41811,
  161444,
  84855,
  8999,
  28561,
  16731,
  93937,
  3189,
  21967,
  24890,
  22943,
  1356,
  145300,
  51569,
  28802,
  517,
  118679,
  31703,
  40607,
  48098,
  108854,
  25003,
  10233,
  73969,
  177495,
  5248,
  24516,
  215347,
  146192,
  48712,
  60626,
  69188,
  40735,
  5866,
  586,
  101541,
  6509,
  47590,
  52129,
  5969,
  222045,
  110933,
  25733,
  24223,
  65339,
  62812,
  2414,
  155418,
  35819,
  16022,
  78423,
  43138,
  20995,
  128255,
  240673,
  46745,
  236093,
  72176,
  57085,
  97841,
  61248,
  107,
  36068,
  193177,
  105427,
  55726,
  215229,
  20446,
  47228,
  100420,
  87091,
  14429,
  121708,
  23605,
  21157,
  187721,
  21880,
  2997,
  203976,
  99166,
  95068,
  25877,
  7724,
  98925,
  83401,
  4829,
  13182,
  18229,
  13718,
  239662,
  38653,
  116505,
  153497,
  30589,
  89029,
  38962,
  181302,
  43853,
  78872,
  180301,
  4786,
  248240,
  7401,
  106136,
  112590,
  77745,
  19731,
  60880,
  77789,
  125748,
  135487,
  5975,
  48627,
  34084,
  12419,
  215770,
  47557,
  254582,
  10364,
  106495,
  21856,
  67539,
  88981,
  38805,
  21428,
  48732,
  42316,
  12149,
  16078,
  52808,
  25327,
  51322,
  33850,
  51147,
  12253,
  122354,
  46077,
  56483,
  254553,
  115417,
  81834,
  150991,
  94662,
  86668,
  7381,
  12841,
  100650,
  18218,
  15741,
  22372,
  68294,
  50705,
  15535,
  84660,
  61887,
  22553,
  72299,
  31361,
  24824,
  17743,
  46820,
  64288,
  31582,
  77006,
  111674,
  116384,
  30760,
  80920,
  86149,
  77192,
  51979,
  79691,
  60342,
  122805,
  103800,
  240873,
  160744,
  233114,
  78962,
  54920,
  8608,
  3484,
  316104,
  72548,
  24337,
  5088,
  230040,
  21926,
  10172,
  36838,
  26,
  86221,
  83458,
  102176,
  12062,
  17571,
  41929,
  41170,
  28428,
  68239,
  41750,
  103930,
  2634,
  18313,
  53019,
  34825,
  97837,
  63115,
  24606,
  73157,
  152474,
  14715,
  91439,
  37033,
  109806,
  140259,
  30668,
  174760,
  380,
  135597,
  95673,
  136073,
  65073,
  134249,
  13829,
  17279,
  122305,
  4420,
  46444,
  10237,
  64848,
  203623,
  70728,
  10349,
  182885,
  65075,
  24519,
  25783,
  40318,
  34139,
  22222,
  63394,
  55266,
  102764,
  41422,
  20126,
  65100,
  90408,
  53640,
  35128,
  48932,
  11192,
  38935,
  96839,
  34782,
  39492,
  19396,
  41332,
  6250,
  5511,
  19492,
  51304,
  25936,
  104466,
  54099,
  73771,
  86115,
  5080,
  7669,
  30891,
  111700,
  13931,
  25276,
  72289,
  135447,
  14820,
  258641,
  25265,
  31005,
  281179,
  75286,
  393,
  95359,
  14623,
  13584,
  6680,
  101227,
  80173,
  44933,
  76666,
  54542,
  13244,
  39348,
  458,
  25379,
  109451,
  134348,
  81143,
  6959,
  65554,
  12027,
  51311,
  8716,
  57589,
  140731,
  28467,
  23316,
  17272,
  30458,
  25980,
  55229,
  77197,
  83798,
  28302,
  114784,
  7428,
  34548,
  26241,
  14712,
  39336,
  103304,
  18928,
  54080,
  12870,
  334,
  87722,
  15208,
  16895,
  142098,
  114262,
  39820,
  83913,
  57817,
  28682,
  7721,
  14900,
  108672,
  11250,
  62246,
  42849,
  415188,
  1724,
  26555,
  24549,
  25505,
  26443,
  107450,
  145899,
  61035,
  43528,
  6901,
  60726,
  65906,
  267741,
  21338,
  147590,
  42079,
  18924,
  73017,
  135236,
  15393,
  5206,
  4026,
  84185,
  1531,
  5988,
  113890,
  82647,
  303391,
  7386,
  69844,
  71611,
  189865,
  76523,
  31877,
  13315,
  19314,
  198575,
  32821,
  1928,
  67641,
  25913,
  104475,
  103489,
  3297,
  70391,
  18406,
  15446,
  113347,
  19295,
  93790,
  27856,
  1792,
  167471,
  116449,
  8541,
  4408,
  41757,
  63233,
  25765,
  86680,
  64501,
  27034,
  24816,
  34975,
  6079,
  4486,
  49693,
  36229,
  16917,
  21581,
  62426,
  27862,
  11612,
  54284,
  35702,
  194034,
  355,
  24277,
  48262,
  87411,
  70504,
  310164,
  118018,
  12516,
  47559,
  43502,
  57433,
  107139,
  9290,
  66533,
  80863,
  14634,
  34312,
  91725,
  28606,
  21342,
  67241,
  72355,
  43244,
  375789,
  37402,
  174015,
  105070,
  8342,
  44167,
  67494,
  1890,
  16365,
  11723,
  271002,
  1865,
  47918,
  8350,
  45564,
  27742,
  25110,
  125803,
  8553,
  49504,
  81925,
  62211,
  4534,
  15491,
  19011,
  80373,
  206920,
  667,
  102405,
  128623,
  245524,
  5553,
  113309,
  192739,
  65766,
  19567,
  22832,
  261958,
  29679,
  21293,
  71134,
  20962,
  105123,
  24721,
  860,
  21752,
  33448,
  18372,
  157167,
  94822,
  35770,
  173224,
  232737,
  75729,
  28937,
  46828,
  28062,
  25453,
  5207,
  140366,
  36665,
  30652,
  6169,
  67920,
  150458,
  92040,
  23186,
  184604,
  92330,
  20891,
  176492,
  49427,
  27828,
  38305,
  42495,
  143982,
  49560,
  25503,
  90043,
  29747,
  65328,
  47830,
  12932,
  11068,
  77721,
  9003,
  25213,
  94205,
  140426,
  46090,
  89945,
  138173,
  192691,
  33329,
  112232,
  129905,
  35709,
  27514,
  1841,
  19957,
  31411,
  127476,
  53572,
  17497,
  173549,
  55063,
  175135,
  19841,
  69314,
  5192,
  237921,
  117660,
  150697,
  4060,
  273045,
  50414,
  98940,
  65348,
  153665,
  164423,
  58804,
  156695,
  48994,
  213928,
  86036,
  28608,
  8355,
  39574,
  34540,
  16927,
  135680,
  18374,
  151587,
  10830,
  53805,
  16878,
  16623,
  4282,
  48030,
  8537,
  14986,
  46102,
  13062,
  72897,
  72,
  33050,
  108227,
  39451,
  45935,
  651,
  113320,
  40535,
  95176,
  57450,
  48843,
  5003,
  19019,
  10407,
  211163,
  3848,
  1068,
  4988,
  32091,
  30095,
  41692,
  15099,
  43602,
  107434,
  50744,
  7627,
  171349,
  16313,
  150832,
  352665,
  207750,
  33937,
  38256,
  51091,
  156e3,
  87889,
  90663,
  84175,
  24908,
  114900,
  50365,
  31494,
  83829,
  5398,
  169342,
  47521,
  54818,
  18935,
  8356,
  43094,
  41212,
  174536,
  10082,
  92550,
  6678,
  60614,
  23355,
  69721,
  14796,
  34149,
  128830,
  58187,
  3179,
  208,
  40325,
  28399,
  225029,
  401412,
  51150,
  31580,
  207268,
  6657,
  10993,
  69818,
  64282,
  289845,
  23308,
  12961,
  38447,
  6681,
  52944,
  31855,
  2572,
  47646,
  120728,
  179148,
  37240,
  45196,
  218274,
  4816,
  3695,
  21961,
  50084,
  35209,
  18073,
  51452,
  27004,
  6100,
  33941,
  1377,
  84831,
  171214,
  85,
  141510,
  9078,
  99227,
  32610,
  6417,
  11718,
  49868,
  65579,
  87902,
  73018,
  49062,
  46280,
  61742,
  21512,
  40862,
  107733,
  15941,
  29168,
  157765,
  144919,
  14487,
  5767,
  158014,
  140070,
  7241,
  573,
  71584,
  16921,
  223566,
  40331,
  179473,
  35081,
  47926,
  140885,
  41508,
  52104,
  59180,
  42310,
  32811,
  29048,
  123517,
  102413,
  80208,
  10104,
  14746,
  12649,
  153641,
  126022,
  37965,
  113017,
  4171,
  83,
  142592,
  2809,
  6362,
  50416,
  71323,
  116894,
  260776,
  16204,
  1524,
  5760,
  30351,
  12658,
  20703,
  54403,
  36083,
  45408,
  74772,
  4946,
  14485,
  50759,
  111222,
  10890,
  2195,
  167147,
  92962,
  130534,
  16283,
  177256,
  35016,
  15472,
  210156,
  151187,
  73922,
  117691,
  43250,
  52051,
  37392,
  24811,
  24358,
  30830,
  5775,
  818,
  21969,
  1476,
  127322,
  151783,
  58392,
  31021,
  106913,
  65215,
  89407,
  90802,
  28531,
  11690,
  20234,
  95249,
  44602,
  37256,
  18707,
  11928,
  5161,
  4410,
  26571,
  51903,
  49768,
  22008,
  25252,
  65780,
  209499,
  68769,
  203726,
  13249,
  137363,
  48845,
  86823,
  6658,
  5674,
  31881,
  1083,
  1823,
  108676,
  34518,
  166752,
  13791,
  14287,
  91576,
  91429,
  8665,
  11529,
  26401,
  16191,
  91972,
  30964,
  5254,
  28486,
  54697,
  79613,
  66520,
  18447,
  22870,
  45203,
  194466,
  22822,
  51703,
  12278,
  76716,
  44595,
  73455,
  33546,
  12235,
  144843,
  36154,
  51247,
  11116,
  33040,
  3180,
  225753,
  60864,
  1972,
  28469,
  12891,
  28879,
  10338,
  144157,
  56294,
  353058,
  38302,
  41447,
  87532,
  110616,
  27065,
  168438,
  6557,
  1213,
  50804,
  144643,
  24817,
  2390,
  136531,
  38174,
  247513,
  16190,
  4059,
  122791,
  131994,
  137430,
  39506,
  57650,
  16305,
  5188,
  54309,
  106128,
  20628,
  88071,
  67394,
  395446,
  250285,
  66176,
  91254,
  1399,
  114196,
  43915,
  60230,
  44853,
  27206,
  106353,
  43013,
  18733,
  345105,
  226453,
  51202,
  16607,
  57106,
  117175,
  35492,
  10476,
  89598,
  127439,
  15187,
  39624,
  13688,
  61570,
  10615,
  31111,
  59370,
  6238,
  175252,
  32143,
  224492,
  41388,
  95408,
  34384,
  148238,
  78307,
  38959,
  9340,
  160091,
  61443,
  15737,
  11216,
  41244,
  170,
  38299,
  102443,
  113097,
  26382,
  14027,
  33707,
  3957,
  76300,
  66160,
  19431,
  18900,
  6952,
  1717,
  108656,
  82206,
  188021,
  257335,
  27295,
  43999,
  41210,
  31777,
  46956,
  57457,
  12657,
  11489,
  15697,
  48060,
  204748,
  53583,
  82422,
  284790,
  30503,
  137341,
  8120,
  19615,
  220311,
  15991,
  10217,
  63424,
  9808,
  67431,
  70976,
  98221,
  4491,
  15177,
  28535,
  144789,
  751,
  13230,
  2394,
  1504,
  33977,
  132104,
  30316,
  22230,
  931,
  97193,
  185240,
  24826,
  22687,
  174322,
  15307,
  22988,
  1390,
  188745,
  180325,
  29580,
  59068,
  74903,
  18994,
  29195,
  79,
  15436,
  7622,
  38462,
  11566,
  138710,
  44828,
  45774,
  37768,
  99236,
  68137,
  84083,
  19282,
  22698,
  17134,
  74807,
  126662,
  173497,
  46248,
  16938,
  119735,
  3212,
  28292,
  213652,
  49013,
  9975,
  32180,
  45660,
  86250,
  4801,
  68788,
  95490,
  77482,
  113751,
  11994,
  44624,
  94452,
  46839,
  128497,
  100316,
  5798,
  58588,
  73184,
  202987,
  65417,
  37790,
  88524,
  1606,
  43156,
  97964,
  105717,
  34947,
  11203,
  100060,
  37742,
  130074,
  93653,
  107799,
  94311,
  196106,
  41347,
  8035,
  10780,
  16390,
  27883,
  118236,
  167395,
  1979,
  25006,
  19375,
  31628,
  18916,
  144723,
  78502,
  114047,
  103107,
  86492,
  107686,
  5844,
  20934,
  206963,
  23556,
  22591,
  16562,
  146333,
  20167,
  10471,
  117434,
  33085,
  2863,
  9740,
  36669,
  41849,
  37271,
  22790,
  18209,
  28979,
  8231,
  12952,
  54408,
  21731,
  25130,
  45208,
  55748,
  138120,
  75826,
  414,
  29593,
  9925,
  292865,
  25999,
  683,
  123149,
  7036,
  92159,
  86055,
  61827,
  103680,
  23176,
  54918,
  58466,
  57578,
  13305,
  5709,
  86479,
  16697,
  31064,
  17660,
  200919,
  10770,
  49793,
  33423,
  32370,
  52047,
  16488,
  62555,
  6459,
  8426,
  83493,
  7763,
  59725,
  82812,
  18628,
  67760,
  79405,
  68557,
  9612,
  7673,
  28102,
  56517,
  69620,
  171797,
  32458,
  29541,
  15870,
  81109,
  32080,
  207644,
  71495,
  21202,
  11039,
  91036,
  61230,
  2810,
  130800,
  32260,
  4613,
  60590,
  37112,
  75214,
  33979,
  126402,
  155062,
  30642,
  63875,
  12810,
  194463,
  82799,
  47664,
  16725,
  36685,
  43367,
  61099,
  449,
  172150,
  102867,
  21691,
  301838,
  36745,
  7130,
  18671,
  57316,
  34852,
  38034,
  54182,
  35578,
  65900,
  99486,
  19771,
  3456,
  2658,
  16914,
  99866,
  28390,
  28109,
  8262,
  21147,
  34353,
  20006,
  4228,
  137085,
  1675,
  203023,
  283196,
  198286,
  214375,
  163329,
  290603,
  152574,
  40471,
  83506,
  30068,
  14730,
  23177,
  131539,
  34759,
  27668,
  32178,
  71896,
  104799,
  116305,
  85430,
  119262,
  42860,
  25160,
  8911,
  23428,
  49437,
  105322,
  6519,
  16203,
  6349,
  74711,
  1230,
  38045,
  8540,
  75165,
  44736,
  25909,
  51026,
  317034,
  4984,
  32281,
  91312,
  27060,
  44431,
  17817,
  45363,
  155937,
  239085,
  35697,
  59784,
  91993,
  29531,
  126740,
  213757,
  76560,
  167776,
  285273,
  24262,
  8237,
  65030,
  41160,
  74437,
  48804,
  118916,
  13159,
  37842,
  1031,
  75349,
  1478,
  11655,
  108777,
  23435,
  277425,
  101734,
  67469,
  70231,
  124711,
  43532,
  28514,
  65526,
  54956,
  1e3,
  21882,
  17728,
  25302,
  40952,
  52214,
  149632,
  1999,
  2111,
  3259,
  63362,
  89961,
  220561,
  39777,
  26335,
  9063,
  10572,
  12416,
  34551,
  34623,
  38604,
  24723,
  5947,
  15588,
  69927,
  66252,
  119177,
  69173,
  46629,
  28714,
  70715,
  212408,
  20521,
  406913,
  74380,
  11716,
  50659,
  50862,
  37009,
  88460,
  130101,
  7210,
  53853,
  538,
  65120,
  151950,
  55806,
  163748,
  52837,
  13153,
  21100,
  16674,
  64536,
  6091,
  138201,
  44837,
  58547,
  3723,
  163,
  2177,
  32288,
  85454,
  34033,
  8497,
  14282,
  25742,
  10535,
  10741,
  79559,
  117493,
  243787,
  49337,
  100718,
  79495,
  40139,
  42956,
  7551,
  55433,
  15421,
  31509,
  23034,
  45081,
  547,
  61176,
  53434,
  328001,
  8470,
  36263,
  30145,
  4519,
  74173,
  53935,
  11845,
  73774,
  60211,
  78025,
  3,
  4102,
  73782,
  109293,
  315332,
  48412,
  26683,
  13714,
  6865,
  20128,
  18490,
  104141,
  325,
  39470,
  171970,
  115860,
  15707,
  7268,
  73301,
  74336,
  31370,
  2368,
  111827,
  107757,
  136231,
  142844,
  97138,
  96638,
  84053,
  38691,
  23801,
  1588,
  10573,
  122098,
  77039,
  240,
  186135,
  146101,
  11996,
  18143,
  112963,
  46171,
  155836,
  348769,
  47795,
  121213,
  116266,
  132515,
  3344,
  144804,
  31286,
  99187,
  255838,
  129694,
  35894,
  48779,
  55235,
  148582,
  71967,
  65282,
  15174,
  13920,
  47080,
  6147,
  108242,
  157593,
  125025,
  7136,
  1286,
  28957,
  127956,
  28402,
  98813,
  20805,
  7532,
  109417,
  40610,
  5041,
  32958,
  15142,
  18408,
  108596,
  33543,
  50517,
  27748,
  80114,
  233434,
  91447,
  487,
  37094,
  100048,
  30541,
  43477,
  10639,
  89862,
  155868,
  37667,
  8726,
  60684,
  237903,
  73408,
  99589,
  12190,
  38739,
  97348,
  3914,
  13594,
  2680,
  149016,
  13907,
  30171,
  28343,
  23530,
  115225,
  61104,
  35821,
  147679,
  14337,
  4297,
  244282,
  24085,
  326976,
  56428,
  7851,
  21303,
  131620,
  71446,
  83253,
  68692,
  111870,
  5224,
  15813,
  38197,
  49026,
  45057,
  13660,
  3306,
  76345,
  40671,
  27905,
  91072,
  996,
  68527,
  62085,
  91351,
  122634,
  55109,
  168209,
  2024,
  27560,
  112707,
  17352,
  8306,
  167115,
  169921,
  166958,
  5031,
  46020,
  11844,
  67284,
  19130,
  76185,
  6920,
  32849,
  5450,
  14610,
  22451,
  21002,
  17392,
  31872,
  66682,
  84796,
  13709,
  40210,
  59898,
  12029,
  8719,
  53564,
  21462,
  91884,
  21647,
  88379,
  194428,
  12754,
  37797,
  132826,
  160016,
  22567,
  54383,
  53186,
  77611,
  31107,
  8339,
  4694,
  19185,
  90355,
  23597,
  17222,
  140675,
  28442,
  23668,
  55977,
  9128,
  61555,
  28774,
  155229,
  17658,
  9390,
  24379,
  69357,
  15752,
  127381,
  239631,
  62460,
  93181,
  55913,
  45133,
  140155,
  18676,
  25249,
  33164,
  29581,
  82837,
  67223,
  22362,
  29975,
  7317,
  52813,
  1943,
  29613,
  20012,
  207130,
  49617,
  49651,
  5636,
  15334,
  36313,
  29226,
  28084,
  95247,
  72072,
  19e3,
  224932,
  15811,
  114,
  32127,
  38097,
  37508,
  88507,
  37225,
  27359,
  91626,
  12193,
  69279,
  20608,
  11055,
  88156,
  92808,
  2152,
  57259,
  55275,
  72789,
  24475,
  104414,
  1708,
  9882,
  3818,
  48661,
  66897,
  1631,
  34806,
  227930,
  85815,
  87753,
  18321,
  250664,
  72733,
  25107,
  206797,
  50891,
  8082,
  196411,
  92596,
  96764,
  152823,
  65514,
  22819,
  387277,
  62176,
  51225,
  40329,
  15563,
  189,
  3659,
  73670,
  64357,
  51793,
  275136,
  33482,
  86653,
  74615,
  67058,
  11318,
  125720,
  15388,
  22388,
  8267,
  1730,
  102663,
  170910,
  40784,
  7144,
  85373,
  13040,
  7088,
  94309,
  583,
  44224,
  140424,
  77439,
  18496,
  164026,
  36578,
  4722,
  9151,
  5824,
  63365,
  26510,
  35199,
  40500,
  79277,
  32495,
  44614,
  35233,
  9566,
  203293,
  152144,
  7097,
  2330,
  183480,
  98629,
  13423,
  330887,
  44130,
  68600,
  30939,
  97829,
  31012,
  345465,
  56747,
  94879,
  4939,
  160027,
  149761,
  99423,
  46099,
  32251,
  15332,
  8761,
  96094,
  128555,
  5763,
  235318,
  222223,
  55729,
  30241,
  55420,
  201746,
  3987,
  81382,
  8259,
  49325,
  23287,
  7719,
  24633,
  251100,
  92311,
  18591,
  110533,
  64759,
  170260,
  393860,
  7175,
  21144,
  132887,
  3593,
  75346,
  101277,
  91109,
  16387,
  259187,
  11627,
  57459,
  173829,
  44694,
  55780,
  49797,
  89192,
  120443,
  62622,
  3904,
  14814,
  23887,
  1027,
  112258,
  64955,
  99800,
  11132,
  66353,
  36202,
  48624,
  18158,
  88481,
  96882,
  43059,
  11040,
  2455,
  7077,
  21651,
  181159,
  99126,
  100434,
  61388,
  68186,
  19161,
  110468,
  120052,
  8819,
  55324,
  41494,
  7014,
  37689,
  3618,
  87729,
  92615,
  207943,
  9823,
  128657,
  12587,
  15857,
  6379,
  67628,
  51216,
  71775,
  157617,
  63244,
  1503,
  3864,
  218754,
  110864,
  5769,
  21492,
  7243,
  1192,
  87921,
  85529,
  31512,
  18537,
  42698,
  35350,
  73510,
  84474,
  34301,
  8991,
  21013,
  35034,
  566,
  38832,
  19838,
  35586,
  37216,
  39413,
  55006,
  12178,
  59742,
  856,
  84563,
  6900,
  25632,
  17437,
  49786,
  30723,
  13847,
  70845,
  4044,
  7843,
  23944,
  235976,
  55530,
  48942,
  6518,
  20939,
  73769,
  192653,
  52936,
  95207,
  23895,
  132542,
  142982,
  22632,
  87452,
  48042,
  54018,
  178468,
  10728,
  26230,
  23559,
  363,
  81269,
  142012,
  5718,
  346258,
  31456,
  84333,
  246476,
  51018,
  66692,
  101804,
  120570,
  39962,
  30373,
  70593,
  2864,
  60541,
  19425,
  54209,
  104092,
  7201,
  31545,
  48018,
  25865,
  15442,
  46257,
  40443,
  8328,
  6451,
  111782,
  47527,
  97754,
  33046,
  470,
  245116,
  31095,
  39,
  91934,
  87208,
  73470,
  36708,
  36521,
  12801,
  70624,
  36272,
  8892,
  79768,
  12427,
  55454,
  103756,
  5908,
  52390,
  62962,
  22720,
  141138,
  94634,
  41689,
  128402,
  126390,
  6628,
  106394,
  35527,
  134394,
  82727,
  254651,
  194502,
  148064,
  89549,
  3202,
  28359,
  957,
  21954,
  27906,
  49840,
  142747,
  8307,
  24206,
  48978,
  1186,
  71728,
  133038,
  71474,
  91306,
  6333,
  110959,
  74600,
  70387,
  18983,
  62609,
  56057,
  22970,
  1147,
  135850,
  1321,
  28834,
  3578,
  59715,
  102227,
  32827,
  81415,
  99952,
  55636,
  257598,
  390,
  22702,
  35701,
  85872,
  402916,
  39216,
  189795,
  14929,
  19467,
  10112,
  144422,
  61514,
  5279,
  63421,
  134686,
  41436,
  8424,
  51925,
  10598,
  132295,
  124416,
  4604,
  194739,
  210929,
  57866,
  31829,
  51626,
  50007,
  9976,
  91878,
  61906,
  56168,
  81906,
  60918,
  61859,
  40017,
  23059,
  16887,
  40927,
  62064,
  12785,
  32893,
  32913,
  21782,
  93965,
  20169,
  44387,
  79084,
  38463,
  11457,
  93950,
  27127,
  157050,
  2697,
  337088,
  5116,
  54128,
  48255,
  33279,
  8821,
  27352,
  25515,
  124022,
  65710,
  28906,
  38557,
  33390,
  1722,
  104435,
  72215,
  38551,
  12094,
  30978,
  25113,
  6671,
  37355,
  175109,
  42862,
  98024,
  65406,
  221276,
  59624,
  118012,
  64637,
  78760,
  86697,
  21426,
  1639,
  40350,
  12584,
  67193,
  84144,
  31396,
  7863,
  143011,
  69629,
  63112,
  9454,
  28666,
  65798,
  46372,
  134721,
  6314,
  51402,
  30837,
  151922,
  2847,
  38676,
  38008,
  92823,
  136245,
  17540,
  5504,
  109295,
  205242,
  37606,
  5211,
  214892,
  1586,
  20670,
  208711,
  137743,
  19328,
  40652,
  16995,
  20023,
  14657,
  154919,
  34422,
  12996,
  13918,
  38221,
  47690,
  16398,
  2959,
  37680,
  89122,
  6721,
  198469,
  91876,
  172043,
  83898,
  101992,
  26084,
  94570,
  3635,
  76958,
  22853,
  76497,
  38266,
  176590,
  168403,
  44464,
  142840,
  79180,
  184594,
  1984,
  41806,
  83147,
  11985,
  6546,
  366068,
  59732,
  24533,
  271505,
  8736,
  39084,
  222992,
  93429,
  28962,
  58985,
  86665,
  8432,
  30028,
  14548,
  32439,
  54424,
  165029,
  55175,
  27458,
  69046,
  121277,
  46168,
  33732,
  20661,
  24581,
  135574,
  123110,
  37556,
  79260,
  72611,
  16957,
  12939,
  46162,
  58238,
  44907,
  72936,
  253758,
  41324,
  32518,
  96480,
  11949,
  124438,
  65280,
  43256,
  34107,
  53533,
  43531,
  37037,
  28366,
  45970,
  32741,
  173438,
  6121,
  194202,
  62969,
  26355,
  30314,
  58370,
  28455,
  1848,
  50519,
  82830,
  90393,
  21761,
  295490,
  10936,
  256940,
  133568,
  44050,
  20269,
  4089,
  27457,
  21610,
  219460,
  36743,
  14821,
  101388,
  52005,
  13124,
  30979,
  140816,
  167362,
  26054,
  18458,
  60789,
  34917,
  40447,
  26606,
  33422,
  9066,
  3452,
  83614,
  5761,
  20263,
  137238,
  25038,
  91310,
  101,
  52322,
  74548,
  42572,
  38084,
  214054,
  186568,
  31802,
  17665,
  30620,
  141936,
  37730,
  14420,
  4265,
  187218,
  49640,
  188208,
  51441,
  55388,
  96452,
  66659,
  40869,
  42039,
  60967,
  221027,
  19234,
  178581,
  29105,
  96050,
  9165,
  196118,
  157335,
  3738,
  40354,
  117436,
  2965,
  34136,
  59659,
  15570,
  50843,
  230035,
  31444,
  71260,
  43886,
  18316,
  5387,
  38500,
  168508,
  17406,
  32174,
  8828,
  103373,
  143806,
  90367,
  3560,
  18719,
  122310,
  16508,
  26719,
  2541,
  105429,
  6645,
  37998,
  73190,
  10591,
  235916,
  49737,
  87112,
  233941,
  53188,
  32193,
  79154,
  4544,
  52905,
  126477,
  7580,
  63501,
  57314,
  3216,
  31337,
  6541,
  103083,
  60846,
  49,
  9756,
  15481,
  1355,
  43840,
  14319,
  13743,
  27486,
  10222,
  73114,
  230718,
  418644,
  16706,
  6674,
  279748,
  23058,
  45273,
  295831,
  86306,
  2743,
  5535,
  88773,
  21829,
  35253,
  120938,
  31153,
  3169,
  16839,
  42847,
  8751,
  80974,
  33942,
  36867,
  35514,
  16485,
  26474,
  77775,
  56877,
  5391,
  48346,
  3882,
  108713,
  31403,
  27804,
  55248,
  26235,
  43821,
  136104,
  40118,
  175507,
  28034,
  203908,
  18732,
  1788,
  34030,
  106427,
  36958,
  54359,
  7251,
  44936,
  15356,
  69139,
  455,
  157915,
  22173,
  140291,
  50348,
  43275,
  82066,
  49621,
  54952,
  15216,
  36226,
  96695,
  66855,
  6936,
  1987,
  8227,
  196087,
  4631,
  68827,
  99004,
  47541,
  110265,
  17953,
  147605,
  110242,
  58520,
  31312,
  38724,
  329975,
  642,
  3155,
  34497,
  75937,
  6207,
  73843,
  6120,
  17249,
  51429,
  117746,
  3218,
  910,
  68961,
  319671,
  14938,
  29555,
  34700,
  1649,
  66673,
  72268,
  9655,
  76800,
  153087,
  6941,
  210168,
  27130,
  35398,
  1780,
  73242,
  3135,
  56689,
  19556,
  165307,
  8765,
  35967,
  121458,
  13333,
  70453,
  17350,
  117253,
  22265,
  13340,
  44265,
  39869,
  441,
  3742,
  135025,
  23581,
  33309,
  16543,
  17731,
  13291,
  157637,
  283005,
  21408,
  101360,
  63887,
  52312,
  83873,
  5338,
  233779,
  23759,
  186949,
  34531,
  177320,
  38069,
  156465,
  91004,
  19353,
  59852,
  68160,
  14891,
  1338,
  1072,
  29823,
  1950,
  28901,
  81407,
  313445,
  73038,
  84807,
  162348,
  240257,
  37162,
  138934,
  16111,
  58013,
  41253,
  102951,
  16457,
  96056,
  19541,
  56402,
  67217,
  41638,
  94381,
  89674,
  29481,
  37456,
  80815,
  151579,
  13937,
  13683,
  132537,
  19699,
  134545,
  67020,
  29816,
  222341,
  141235,
  427578,
  48868,
  129557,
  233342,
  23077,
  87871,
  16213,
  18728,
  16184,
  9469,
  37913,
  19680,
  2798,
  171356,
  178328,
  13216,
  50049,
  72690,
  71904,
  124644,
  55455,
  7504,
  29052,
  41036,
  266546,
  19899,
  30391,
  188755,
  8659,
  59469,
  16,
  104298,
  112943,
  53865,
  76203,
  138226,
  68857,
  139953,
  14125,
  107625,
  119795,
  173133,
  4398,
  50273,
  48808,
  54390,
  16466,
  122086,
  31835,
  67035,
  50971,
  48859,
  7508,
  46427,
  66477,
  73021,
  84615,
  39985,
  83076,
  46779,
  201569,
  53336,
  36443,
  60865,
  168164,
  143810,
  51393,
  25548,
  169307,
  32896,
  24485,
  38424,
  21837,
  29087,
  275813,
  51674,
  6714,
  64883,
  46169,
  187369,
  55186,
  76192,
  12852,
  12018,
  62134,
  31067,
  118303,
  16542,
  12125,
  10579,
  4928,
  26291,
  43854,
  7091,
  10946,
  253716,
  109062,
  39283,
  17261,
  113012,
  258512,
  47764,
  125126,
  32646,
  55892,
  80279,
  201623,
  149872,
  3192,
  385,
  1208,
  48750,
  5376,
  58738,
  22335,
  5427,
  82416,
  47811,
  32435,
  143086,
  38930,
  94128,
  59975,
  156037,
  37977,
  38224,
  62485,
  7698,
  50405,
  71027,
  16462,
  21559,
  136153,
  34131,
  107506,
  162069,
  63703,
  3101,
  215029,
  40407,
  4178,
  3774,
  9187,
  80019,
  17880,
  97926,
  67579,
  2600,
  18405,
  8351,
  47924,
  86638,
  70820,
  92206,
  86453,
  29610,
  42241,
  119200,
  3198,
  15466,
  67813,
  57863,
  35454,
  4779,
  99518,
  4649,
  104641,
  144269,
  33730,
  38073,
  65864,
  6838,
  109456,
  193298,
  154007,
  5623,
  45741,
  30846,
  182578,
  25573,
  157224,
  1543,
  58575,
  138703,
  146140,
  44971,
  49356,
  18275,
  59064,
  20300,
  13122,
  11848,
  24453,
  11973,
  9797,
  86843,
  2919,
  25530,
  49210,
  1130,
  161220,
  76788,
  75373,
  85604,
  34926,
  36014,
  17777,
  17255,
  51533,
  11676,
  92226,
  51845,
  119859,
  21525,
  5936,
  18507,
  28050,
  1140,
  31418,
  14857,
  34207,
  47859,
  10750,
  36382,
  32079,
  106909,
  59426,
  87757,
  38393,
  110042,
  15965,
  97104,
  33757,
  35344,
  97993,
  53979,
  33651,
  45407,
  41884,
  82515,
  173089,
  7177,
  58371,
  35365,
  47543,
  51927,
  35587,
  10670,
  23544,
  29306,
  84233,
  39976,
  76076,
  62097,
  9007,
  8668,
  28119,
  78281,
  120790,
  19835,
  143020,
  54968,
  18670,
  64959,
  20649,
  34469,
  42570,
  33001,
  136570,
  87796,
  120044,
  1106,
  58700,
  63951,
  127623,
  12805,
  83057,
  40212,
  31773,
  49850,
  7361,
  54336,
  347524,
  101314,
  23751,
  19569,
  48791,
  29174,
  49369,
  20467,
  7465,
  75842,
  38281,
  623,
  112457,
  60210,
  28849,
  51003,
  94720,
  6426,
  90047,
  85560,
  43761,
  3579,
  85105,
  34607,
  90410,
  118528,
  7224,
  42907,
  111163,
  18168,
  6960,
  161135,
  191298,
  5247,
  100584,
  127552,
  171568,
  20121,
  91173,
  12636,
  54615,
  20199,
  63730,
  98105,
  2396,
  40387,
  14438,
  125012,
  4765,
  33235,
  12865,
  45299,
  37728,
  82098,
  77872,
  114037,
  59253,
  19675,
  24838,
  398016,
  102561,
  11446,
  17069,
  57508,
  178277,
  65836,
  99941,
  26114,
  2585,
  271882,
  136866,
  50126,
  11027,
  155648,
  118367,
  14585,
  8910,
  123015,
  335383,
  40434,
  41016,
  53021,
  14439,
  87098,
  176860,
  201543,
  121888,
  2358,
  9286,
  5739,
  22666,
  54270,
  37884,
  169381,
  33984,
  93859,
  16124,
  89364,
  72207,
  51639,
  76366,
  99029,
  65812,
  2198,
  12147,
  174891,
  194289,
  6986,
  30252,
  88822,
  21284,
  11445,
  288337,
  160821,
  33034,
  100869,
  43852,
  25761,
  52882,
  1144,
  103809,
  1924,
  84458,
  86079,
  43411,
  13542,
  139276,
  18141,
  34978,
  41298,
  7276,
  26481,
  173800,
  33210,
  17951,
  142652,
  33616,
  33677,
  2210,
  19941,
  98568,
  2486,
  192414,
  80136,
  12058,
  235883,
  50963,
  249638,
  29572,
  27221,
  47034,
  6124,
  72107,
  63346,
  97620,
  158513,
  299699,
  40388,
  23235,
  37176,
  224244,
  198386,
  121323,
  67992,
  23827,
  63170,
  17838,
  106622,
  158590,
  26807,
  5345,
  23489,
  91891,
  55474,
  74834,
  37981,
  13058,
  5977,
  72552,
  34706,
  26828,
  145172,
  19904,
  21367,
  34043,
  960,
  77092,
  91381,
  4733,
  47446,
  7680,
  41697,
  5170,
  16960,
  14741,
  46101,
  13656,
  473,
  51842,
  37433,
  11103,
  11551,
  121951,
  13191,
  97536,
  165932,
  50397,
  51628,
  129028,
  9069,
  44885,
  6590,
  59195,
  47045,
  32940,
  225472,
  90345,
  21833,
  13303,
  29407,
  96615,
  141951,
  5198,
  6028,
  18395,
  7181,
  3861,
  14966,
  156358,
  167182,
  36529,
  55253,
  25942,
  173153,
  30959,
  27261,
  50691,
  150176,
  162201,
  38467,
  48462,
  80602,
  42163,
  118482,
  168,
  108756,
  26011,
  17166,
  54149,
  456538,
  22512,
  91374,
  13816,
  90358,
  131615,
  18132,
  226707,
  1824,
  28139,
  26860,
  42253,
  93877,
  77351,
  65575,
  8980,
  80574,
  22020,
  27948,
  40422,
  91324,
  76376,
  13528,
  39281,
  91685,
  82215,
  122541,
  144066,
  1983,
  193851,
  17283,
  26320,
  2739,
  194978,
  4790,
  26845,
  42627,
  61300,
  65815,
  174612,
  55133,
  4200,
  191130,
  79771,
  158321,
  52280,
  166796,
  221620,
  62461,
  11278,
  4067,
  88152,
  83409,
  31717,
  121367,
  13522,
  47325,
  37945,
  10406,
  174348,
  249321,
  154101,
  64912,
  29938,
  51775,
  17220,
  15776,
  166138,
  78890,
  84425,
  54121,
  42861,
  16368,
  24572,
  291647,
  10197,
  32073,
  22651,
  11677,
  97509,
  26952,
  35787,
  18424,
  41910,
  71614,
  94977,
  72318,
  41594,
  70024,
  275419,
  37702,
  60199,
  7335,
  39107,
  61315,
  18271,
  18394,
  33768,
  87884,
  104277,
  123724,
  7277,
  56288,
  71981,
  189803,
  49320,
  3352,
  6798,
  14240,
  8954,
  69220,
  94433,
  57372,
  28620,
  68863,
  193727,
  85575,
  42309,
  41667,
  67689,
  42081,
  22543,
  44824,
  12719,
  28540,
  114236,
  101553,
  27638,
  27296,
  4300,
  5353,
  4663,
  19379,
  94098,
  3758,
  95888,
  95144,
  80344,
  87320,
  28447,
  259518,
  12718,
  71391,
  152731,
  37063,
  24132,
  31911,
  104896,
  15672,
  103782,
  1521,
  4945,
  72541,
  23717,
  122632,
  15619,
  87175,
  206120,
  29428,
  189780,
  61416,
  28350,
  44457,
  972,
  1175,
  47233,
  198738,
  95789,
  41907,
  21953,
  97034,
  59341,
  22864,
  53713,
  16873,
  32971,
  20693,
  20954,
  31336,
  21477,
  16169,
  38370,
  16412,
  9019,
  3841,
  24599,
  21938,
  17085,
  6484,
  81198,
  76413,
  5849,
  72514,
  12320,
  65247,
  276175,
  37234,
  59796,
  52642,
  16312,
  57349,
  198507,
  94148,
  46134,
  18958,
  125552,
  1747,
  18725,
  151873,
  14901,
  5490,
  68287,
  29470,
  3689,
  64794,
  40814,
  26018,
  25692,
  54450,
  2703,
  88278,
  124886,
  173087,
  174e3,
  24159,
  179477,
  24276,
  46004,
  201876,
  209202,
  445,
  52876,
  31948,
  30206,
  157610,
  39180,
  18439,
  44124,
  50469,
  5774,
  96278,
  222758,
  200216,
  50290,
  45486,
  20435,
  46986,
  46276,
  140133,
  142326,
  15569,
  13363,
  47522,
  92583,
  2182,
  7135,
  16853,
  22998,
  30272,
  4952,
  63263,
  35623,
  39096,
  53789,
  44864,
  20053,
  110392,
  124213,
  4630,
  16087,
  28221,
  127787,
  25839,
  77481,
  44693,
  13464,
  113146,
  6983,
  27069,
  55717,
  50102,
  4760,
  7107,
  26186,
  66507,
  59145,
  36032,
  104182,
  71328,
  29425,
  64317,
  50781,
  47465,
  94298,
  69706,
  74899,
  22754,
  120756,
  25108,
  93077,
  56834,
  73286,
  39928,
  16218,
  41699,
  176763,
  7555,
  70819,
  50083,
  26895,
  23315,
  26014,
  16773,
  123079,
  41712,
  5719,
  31516,
  90427,
  158540,
  85051,
  183128,
  40864,
  27505,
  55392,
  9058,
  45224,
  96857,
  30901,
  136622,
  96557,
  56304,
  120061,
  11501,
  151448,
  5773,
  89743,
  7769,
  86069,
  2935,
  18471,
  41628,
  10114,
  33660,
  110170,
  49479,
  26745,
  92846,
  33221,
  26731,
  18795,
  87076,
  8550,
  2100,
  29972,
  120289,
  3077,
  72490,
  33784,
  2630,
  208722,
  50861,
  63483,
  79029,
  6419,
  39467,
  14302,
  45286,
  64207,
  9686,
  67513,
  44170,
  1050,
  77246,
  59266,
  17055,
  53801,
  7150,
  11111,
  42432,
  4278,
  94579,
  362117,
  36175,
  42902,
  41933,
  39002,
  98489,
  22913,
  74161,
  84773,
  57036,
  17556,
  162288,
  74485,
  178760,
  93867,
  73635,
  128860,
  50362,
  261,
  67455,
  80001,
  46080,
  35662,
  4368,
  25247,
  19230,
  74393,
  22588,
  1822,
  27682,
  235324,
  13798,
  85998,
  13194,
  235067,
  23514,
  71669,
  147632,
  23191,
  134748,
  214683,
  105101,
  1518,
  25489,
  247114,
  7380,
  54842,
  26922,
  3971,
  26361,
  20844,
  68642,
  170517,
  77339,
  123255,
  8963,
  77818,
  150998,
  48466,
  36806,
  2732,
  23261,
  11741,
  236162,
  18243,
  126216,
  28690,
  50546,
  16385,
  92760,
  197383,
  246558,
  201295,
  88255,
  67588,
  71687,
  176076,
  172653,
  169058,
  33906,
  63747,
  24835,
  157621,
  43338,
  30050,
  46152,
  132741,
  2770,
  51371,
  94835,
  6614,
  15112,
  11749,
  56936,
  1250,
  19027,
  399017,
  58036,
  100215,
  23388,
  55815,
  308768,
  124152,
  94803,
  9521,
  64186,
  8971,
  28,
  30427,
  62163,
  7616,
  103838,
  35079,
  29203,
  131235,
  7743,
  17389,
  10882,
  37420,
  61460,
  228512,
  85363,
  41581,
  131077,
  62822,
  119647,
  10130,
  54445,
  26925,
  19968,
  29016,
  24446,
  74028,
  24176,
  61448,
  67185,
  9254,
  8563,
  119129,
  9771,
  99184,
  37716,
  39514,
  10532,
  221512,
  258753,
  218630,
  55980,
  23394,
  32141,
  61924,
  66749,
  32411,
  3741,
  36475,
  26678,
  77010,
  44946,
  91203,
  128749,
  116953,
  20476,
  49625,
  53116,
  13735,
  102335,
  29376,
  51946,
  83407,
  67892,
  59212,
  34685,
  21083,
  1546,
  112982,
  32972,
  74397,
  1078,
  190545,
  16082,
  86140,
  58591,
  89611,
  101531,
  10061,
  105104,
  76319,
  20035,
  17551,
  52611,
  169061,
  190842,
  100780,
  23907,
  90413,
  115619,
  9675,
  34710,
  193435,
  49443,
  129734,
  11183,
  258877,
  16318,
  136182,
  126808,
  44635,
  27304,
  192375,
  2599,
  125648,
  47051,
  12091,
  23814,
  721,
  58800,
  40137,
  66726,
  97930,
  60877,
  74487,
  7942,
  54326,
  9841,
  41428,
  13762,
  8211,
  85383,
  6950,
  99177,
  79806,
  201786,
  296464,
  124087,
  13144,
  29741,
  41721,
  47634,
  55088,
  254286,
  106408,
  17041,
  99064,
  12942,
  64086,
  45233,
  14005,
  2612,
  55827,
  255,
  7984,
  13980,
  38574,
  12776,
  46654,
  73499,
  249951,
  2101,
  26676,
  25996,
  132326,
  116415,
  119062,
  50449,
  31033,
  23038,
  11589,
  179252,
  20007,
  14860,
  129270,
  21143,
  17796,
  144715,
  60106,
  70758,
  69842,
  34674,
  282133,
  44014,
  16774,
  57268,
  38528,
  24053,
  46373,
  201667,
  28327,
  471023,
  51889,
  102667,
  21193,
  114909,
  84132,
  69317,
  96723,
  67969,
  16134,
  68145,
  15058,
  28765,
  32035,
  2524,
  101089,
  98664,
  25045,
  76571,
  14957,
  86040,
  118506,
  262428,
  154764,
  81573,
  39681,
  283900,
  73287,
  127825,
  544,
  80448,
  52347,
  38512,
  175971,
  15180,
  45467,
  33086,
  46552,
  48894,
  81107,
  43213,
  36672,
  54025,
  76703,
  8053,
  7608,
  13299,
  56619,
  20752,
  238099,
  54164,
  105133,
  1444,
  32942,
  953,
  37564,
  8e3,
  66316,
  119463,
  106817,
  404,
  13667,
  149108,
  128597,
  31267,
  10269,
  49836,
  106150,
  1484,
  52330,
  76965,
  160486,
  171648,
  38456,
  31263,
  22424,
  37738,
  66245,
  67467,
  143369,
  60471,
  75610,
  20895,
  115528,
  86070,
  60854,
  40796,
  49347,
  18989,
  15030,
  11371,
  37578,
  15779,
  79867,
  10187,
  86462,
  46402,
  155626,
  93200,
  40229,
  7090,
  57547,
  108053,
  99598,
  11088,
  47505,
  41218,
  206017,
  2173,
  20988,
  30219,
  22919,
  80563,
  57566,
  42369,
  93141,
  41675,
  2407,
  182519,
  120495,
  27154,
  16702,
  29456,
  14349,
  7958,
  16688,
  117177,
  140375,
  42467,
  261919,
  74916,
  153569,
  10836,
  34742,
  49526,
  7621,
  105997,
  12212,
  2270,
  392377,
  7755,
  17959,
  25086,
  232152,
  138791,
  33847,
  13860,
  35316,
  5811,
  1344,
  71259,
  50452,
  207539,
  92635,
  50359,
  5821,
  33674,
  30255,
  2086,
  2587,
  96264,
  17543,
  42,
  6029,
  9580,
  43007,
  139248,
  82831,
  12917,
  29607,
  25786,
  51467,
  42137,
  85161,
  100698,
  31561,
  88989,
  121990,
  278500,
  3602,
  109344,
  37982,
  15279,
  116442,
  28936,
  30880,
  87894,
  58079,
  128661,
  126731,
  67392,
  28051,
  146885,
  4861,
  16216,
  97344,
  42827,
  147561,
  153948,
  22684,
  21335,
  47685,
  1853,
  43349,
  15185,
  59642,
  10229,
  25520,
  187921,
  108972,
  5579,
  98037,
  24945,
  6697,
  19193,
  63734,
  137934,
  75056,
  89740,
  19767,
  224268,
  56138,
  63643,
  151661,
  39313,
  70618,
  84031,
  89723,
  84074,
  13703,
  85626,
  35460,
  8867,
  64845,
  3439,
  57906,
  99776,
  63968,
  49270,
  81130,
  34356,
  16210,
  23547,
  36446,
  34090,
  140028,
  72439,
  2221,
  22163,
  57058,
  363492,
  113754,
  18913,
  95451,
  48663,
  54464,
  54037,
  176097,
  68425,
  3023,
  34906,
  29482,
  117389,
  341780,
  80431,
  58330,
  16753,
  92616,
  60907,
  94846,
  147486,
  4498,
  48646,
  7773,
  46801,
  7778,
  18946,
  464978,
  47558,
  33223,
  177444,
  7328,
  15626,
  63337,
  94700,
  11743,
  9351,
  255024,
  39098,
  16447,
  42647,
  96230,
  39769,
  58840,
  10068,
  63439,
  35800,
  65843,
  58823,
  413844,
  9156,
  51258,
  7434,
  61791,
  85018,
  6872,
  3692,
  28096,
  7121,
  33024,
  6009,
  75532,
  31997,
  192535,
  9661,
  3304,
  9547,
  14753,
  31987,
  25314,
  55689,
  15896,
  20430,
  39472,
  31340,
  99744,
  25398,
  115569,
  54883,
  28719,
  205423,
  23071,
  57855,
  64638,
  149867,
  25671,
  82403,
  37616,
  20668,
  39989,
  77996,
  74948,
  140555,
  175248,
  64810,
  36515,
  46595,
  4958,
  248773,
  24045,
  28728,
  136673,
  168704,
  20804,
  114833,
  100325,
  27135,
  21205,
  96151,
  153134,
  45992,
  7093,
  13992,
  76047,
  1980,
  19432,
  145001,
  75159,
  87462,
  17710,
  1013,
  45556,
  34297,
  144882,
  20648,
  26061,
  11319,
  129567,
  108555,
  18872,
  464580,
  33386,
  22717,
  65948,
  167189,
  5603,
  135042,
  79542,
  8801,
  202632,
  18114,
  91882,
  5973,
  5239,
  67315,
  4431,
  60916,
  47819,
  71693,
  32597,
  32606,
  18183,
  45072,
  80329,
  76385,
  24749,
  51305,
  40314,
  156514,
  14693,
  130345,
  13168,
  66214,
  18029,
  12858,
  34801,
  27628,
  14544,
  10823,
  40522,
  40185,
  33739,
  148694,
  23548,
  9923,
  61012,
  28859,
  17933,
  19442,
  34364,
  99849,
  164107,
  141167,
  30629,
  21054,
  6744,
  36491,
  8096,
  42474,
  41706,
  155060,
  30650,
  10600,
  163442,
  1143,
  96655,
  61390,
  52359,
  7559,
  51568,
  64256,
  203854,
  4467,
  22453,
  14504,
  436398,
  7878,
  6980,
  8293,
  63610,
  293747,
  16167,
  35763,
  19627,
  147603,
  15419,
  18032,
  110744,
  51346,
  33681,
  54571,
  40472,
  48615,
  39073,
  21604,
  13754,
  173027,
  92560,
  11083,
  47299,
  63062,
  11813,
  52007,
  29883,
  9734,
  139722,
  15953,
  1550,
  20651,
  13616,
  49306,
  16113,
  90089,
  92326,
  7584,
  30712,
  72424,
  164858,
  6831,
  152871,
  55746,
  197721,
  34167,
  196442,
  6022,
  112107,
  55215,
  7538,
  123381,
  4920,
  43539,
  77165,
  8939,
  50392,
  34192,
  20225,
  79762,
  22505,
  58667,
  40770,
  29788,
  97180,
  82835,
  4568,
  8579,
  13273,
  363569,
  35898,
  49983,
  436,
  36598,
  3237,
  131691,
  62418,
  35591,
  8101,
  4073,
  379438,
  65218,
  76072,
  33887,
  2968,
  27573,
  212619,
  288680,
  68278,
  72851,
  150504,
  217896,
  6913,
  121339,
  22017,
  35340,
  51072,
  43616,
  75043,
  31437,
  10833,
  81487,
  4364,
  22968,
  41454,
  106687,
  85446,
  19863,
  109625,
  149241,
  524,
  141850,
  214404,
  54376,
  657,
  237023,
  9401,
  108137,
  53800,
  32474,
  49712,
  53334,
  126876,
  27337,
  45552,
  177696,
  8269,
  15036,
  12097,
  42240,
  2328,
  125374,
  119295,
  99715,
  2500,
  19624,
  39441,
  27220,
  102691,
  60957,
  94543,
  39101,
  18566,
  67362,
  13975,
  78230,
  25017,
  34017,
  239007,
  90027,
  39351,
  41681,
  35354,
  43822,
  1043,
  916,
  58587,
  141983,
  94818,
  38799,
  75459,
  41114,
  67432,
  16195,
  36606,
  59568,
  22272,
  126769,
  31424,
  68659,
  12287,
  134302,
  257977,
  5756,
  207285,
  95637,
  47248,
  117689,
  19583,
  77451,
  22373,
  12200,
  54993,
  117118,
  34244,
  29386,
  34562,
  53819,
  71267,
  64172,
  77665,
  49368,
  7716,
  59301,
  25749,
  45426,
  194789,
  17297,
  2650,
  1766,
  32501,
  45198,
  20403,
  20984,
  6600,
  14171,
  94604,
  19037,
  5402,
  29896,
  9938,
  59935,
  109708,
  88081,
  145182,
  44844,
  39167,
  352626,
  164173,
  35374,
  45982,
  6122,
  154,
  73419,
  220487,
  53834,
  53601,
  17992,
  8609,
  229321,
  5610,
  68098,
  66815,
  71012,
  95069,
  140968,
  27396,
  8957,
  134489,
  24656,
  86659,
  56598,
  134852,
  17316,
  123838,
  255436,
  6613,
  41610,
  138033,
  81452,
  32023,
  32396,
  123687,
  63398,
  8693,
  29712,
  30407,
  19296,
  121188,
  3551,
  36099,
  20032,
  111948,
  56624,
  16547,
  27453,
  35916,
  15378,
  52039,
  56849,
  13489,
  22214,
  73177,
  53097,
  277349,
  2157,
  14029,
  187886,
  10260,
  141743,
  246460,
  91880,
  50869,
  3788,
  49486,
  133566,
  54950,
  33120,
  129337,
  53768,
  18333,
  9525,
  26902,
  312251,
  10297,
  9020,
  70759,
  16647,
  112432,
  59260,
  84609,
  9818,
  82766,
  73569,
  468,
  46001,
  75780,
  55028,
  52106,
  11498,
  43645,
  108069,
  17150,
  17753,
  29417,
  16705,
  31799,
  9606,
  289,
  122254,
  115975,
  8620,
  6133,
  255357,
  56908,
  14456,
  133464,
  43554,
  79224,
  11247,
  29630,
  160,
  12756,
  25464,
  65960,
  350428,
  62521,
  321796,
  100359,
  67358,
  35169,
  46172,
  113128,
  48988,
  88868,
  31094,
  33266,
  6847,
  60887,
  98188,
  49659,
  69117,
  92977,
  220228,
  13947,
  80181,
  35103,
  62170,
  97351,
  13475,
  2440,
  199768,
  19498,
  36597,
  46971,
  25234,
  67806,
  62881,
  84717,
  73648,
  181966,
  10488,
  94149,
  21550,
  26655,
  63436,
  48375,
  14405,
  165650,
  9621,
  24439,
  28043,
  42735,
  4490,
  29963,
  56674,
  45373,
  1934,
  262446,
  50855,
  67098,
  26898,
  5261,
  52696,
  40644,
  33900,
  9440,
  180286,
  87162,
  22940,
  19704,
  26936,
  69769,
  10254,
  101759,
  27406,
  12243,
  48e3,
  73926,
  113215,
  54935,
  5726,
  192787,
  4312,
  106216,
  9366,
  11550,
  52949,
  23457,
  212271,
  277152,
  133895,
  108374,
  6191,
  96477,
  29980,
  218916,
  58024,
  54696,
  40853,
  91124,
  65894,
  91170,
  65908,
  252552,
  6793,
  29212,
  15389,
  44516,
  122515,
  52617,
  35058,
  9017,
  103536,
  39510,
  49136,
  19242,
  130652,
  662077,
  74699,
  47024,
  31422,
  8517,
  73351,
  24399,
  13867,
  128360,
  4810,
  4434,
  61779,
  111983,
  61036,
  17798,
  110240,
  59722,
  102960,
  39688,
  10001,
  23803,
  23039,
  176498,
  56659,
  44814,
  134295,
  17188,
  77577,
  74466,
  226175,
  102472,
  154333,
  63900,
  111747,
  18062,
  41171,
  79669,
  32773,
  408933,
  42562,
  28931,
  30907,
  107388,
  43487,
  2946,
  240310,
  23938,
  24354,
  319,
  184983,
  7927,
  6488,
  1422,
  10790,
  68809,
  68209,
  64775,
  4361,
  202,
  17123,
  59634,
  51200,
  44391,
  18188,
  17843,
  2619,
  74278,
  3230,
  9540,
  47187,
  21702,
  36274,
  56894,
  43907,
  16310,
  34790,
  16866,
  6150,
  5561,
  13587,
  107545,
  108873,
  126867,
  86986,
  28640,
  33427,
  19017,
  5762,
  80637,
  17430,
  46903,
  2047,
  131055,
  25958,
  13558,
  5444,
  47152,
  13900,
  44563,
  122857,
  45348,
  70863,
  39593,
  54332,
  38068,
  33637,
  318,
  40310,
  143467,
  18502,
  24520,
  11377,
  62013,
  28942,
  27246,
  28269,
  83545,
  17999,
  59015,
  90707,
  30065,
  15161,
  34720,
  1263,
  37008,
  2012,
  6060,
  98575,
  92933,
  5721,
  299,
  199555,
  24578,
  29223,
  2985,
  743,
  115825,
  109523,
  136657,
  47454,
  26378,
  53586,
  3733,
  174945,
  93340,
  244456,
  5693,
  37386,
  28782,
  89767,
  27545,
  23573,
  18798,
  136425,
  34320,
  84778,
  20041,
  48453,
  38215,
  7477,
  71958,
  40621,
  8773,
  5874,
  187927,
  105965,
  51100,
  43533,
  18083,
  8443,
  10180,
  43597,
  2003,
  183999,
  69689,
  12216,
  129696,
  146188,
  62389,
  34044,
  68410,
  12765,
  43273,
  26949,
  266807,
  3345,
  34477,
  79197,
  5688,
  47539,
  213110,
  21634,
  22257,
  50092,
  32222,
  42346,
  39530,
  63668,
  98,
  134978,
  74022,
  5152,
  59088,
  174145,
  37220,
  9934,
  9545,
  118937,
  5724,
  87240,
  19875,
  15784,
  40143,
  23263,
  87513,
  181654,
  285152,
  37881,
  263241,
  4966,
  43934,
  10433,
  186657,
  6470,
  74416,
  225854,
  25908,
  142677,
  246262,
  32280,
  6192,
  75890,
  45546,
  143264,
  135305,
  29742,
  47013,
  77787,
  11732,
  126658,
  8763,
  37950,
  21806,
  57557,
  113464,
  89465,
  108995,
  164574,
  23894,
  22996,
  23169,
  15369,
  23117,
  17642,
  130607,
  40503,
  36239,
  280990,
  44666,
  9981,
  40427,
  147487,
  26869,
  168452,
  32886,
  32991,
  46798,
  240839,
  15111,
  70502,
  65697,
  88548,
  44145,
  28701,
  48767,
  31139,
  206777,
  35659,
  181164,
  166262,
  14554,
  171445,
  31786,
  66523,
  76607,
  17956,
  6507,
  31279,
  90476,
  116611,
  167918,
  6560,
  1243,
  115324,
  80128,
  41867,
  55897,
  187323,
  37069,
  32596,
  189444,
  145931,
  13390,
  105530,
  65709,
  26805,
  6999,
  55714,
  41300,
  22915,
  68951,
  22138,
  21120,
  22264,
  10058,
  19945,
  33635,
  56123,
  99085,
  10032,
  5818,
  6016,
  46649,
  57476,
  35264,
  94413,
  112522,
  262288,
  93686,
  83038,
  14341,
  23204,
  28807,
  66084,
  77987,
  6101,
  126673,
  7133,
  38126,
  5923,
  122091,
  170240,
  97772,
  46874,
  215746,
  43948,
  41622,
  3272,
  55596,
  8332,
  146411,
  251315,
  13533,
  8561,
  81521,
  115449,
  48616,
  175175,
  2063,
  186556,
  3036,
  134537,
  75772,
  29728,
  82360,
  22973,
  186559,
  86348,
  89100,
  38388,
  82297,
  45610,
  2613,
  87082,
  9986,
  177812,
  57884,
  23591,
  47485,
  42543,
  33582,
  44713,
  74439,
  257444,
  252451,
  31825,
  35631,
  38540,
  33066,
  5147,
  13973,
  4343,
  51830,
  70378,
  22827,
  26448,
  95560,
  36896,
  241741,
  48067,
  203953,
  298860,
  61620,
  20450,
  3220,
  67272,
  6586,
  107662,
  100160,
  108684,
  6929,
  57226,
  4762,
  7457,
  1320,
  40404,
  77204,
  99309,
  62750,
  208653,
  59977,
  44e3,
  74315,
  34332,
  5819,
  172217,
  64904,
  114077,
  18147,
  84012,
  1791,
  98456,
  90930,
  21446,
  116669,
  103938,
  7422,
  85140,
  59713,
  5768,
  326211,
  16239,
  75411,
  13229,
  29398,
  10758,
  236107,
  1539,
  112472,
  95979,
  152154,
  151294,
  306,
  21196,
  38146,
  10700,
  6891,
  84282,
  109646,
  56492,
  40539,
  6589,
  119491,
  51354,
  30685,
  140209,
  136906,
  29622,
  73617,
  49553,
  70525,
  51671,
  166869,
  139616,
  74395,
  37439,
  49595,
  45678,
  11959,
  33211,
  86560,
  52434,
  9282,
  62690,
  112155,
  130810,
  5243,
  108261,
  99970,
  265613,
  72551,
  80049,
  6391,
  33365,
  90721,
  66737,
  69872,
  87011,
  1860,
  9032,
  112544,
  60905,
  37371,
  89015,
  140351,
  19076,
  850,
  373531,
  2802,
  36725,
  218795,
  72062,
  28990,
  16550,
  24614,
  7815,
  6187,
  26336,
  33373,
  32162,
  42791,
  73555,
  32062,
  23386,
  10244,
  56392,
  49442,
  27076,
  136262,
  12412,
  14883,
  1134,
  33675,
  97153,
  199281,
  15608,
  100152,
  74072,
  47942,
  254301,
  36451,
  16026,
  10687,
  65067,
  56708,
  254030,
  30290,
  50490,
  13864,
  57941,
  259331,
  35588,
  23485,
  43486,
  24869,
  21620,
  92971,
  22072,
  88645,
  1048,
  182050,
  13343,
  32452,
  14825,
  19509,
  3325,
  216938,
  45740,
  99716,
  189082,
  53740,
  78245,
  25609,
  24311,
  176777,
  47340,
  308354,
  40669,
  66085,
  14102,
  125339,
  9225,
  128709,
  97207,
  1271,
  200933,
  78439,
  113451,
  88975,
  18324,
  46521,
  11819,
  18570,
  141756,
  72512,
  170020,
  52754,
  63550,
  118515,
  103073,
  93330,
  32736,
  50499,
  14722,
  31600,
  68452,
  398867,
  29316,
  172786,
  18417,
  104924,
  2606,
  5670,
  84818,
  16288,
  67106,
  59580,
  82929,
  607401,
  291,
  85829,
  359,
  15897,
  35830,
  50696,
  65630,
  52672,
  22115,
  356968,
  29895,
  40837,
  231192,
  34024,
  38957,
  26722,
  406,
  23335,
  124952,
  72068,
  68804,
  13268,
  147101,
  164740,
  276569,
  162596,
  66943,
  11569,
  26654,
  66358,
  4777,
  23229,
  102127,
  5848,
  978,
  2921,
  59666,
  5371,
  28212,
  90108,
  42938,
  39320,
  2499,
  4271,
  108792,
  33510,
  125072,
  71653,
  65239,
  38250,
  66357,
  38577,
  13964,
  86251,
  35708,
  50755,
  36010,
  29448,
  12209,
  3844,
  38222,
  206337,
  100876,
  67827,
  137088,
  14167,
  252225,
  84163,
  195270,
  1306,
  5703,
  54198,
  779,
  46802,
  22028,
  51124,
  86759,
  70560,
  113164,
  35685,
  162145,
  45471,
  34561,
  422,
  2611,
  6464,
  47486,
  19223,
  38246,
  9191,
  18331,
  89942,
  243642,
  212364,
  15893,
  17518,
  22617,
  6409,
  30046,
  126182,
  59716,
  36560,
  104428,
  18846,
  26592,
  19458,
  50793,
  147333,
  30826,
  1388,
  27647,
  10922,
  14495,
  33545,
  19269,
  135828,
  39727,
  41601,
  46931,
  233379,
  49169,
  131130,
  182112,
  16276,
  82381,
  118209,
  142445,
  128310,
  19672,
  28740,
  82907,
  33436,
  3118,
  102206,
  28723,
  24819,
  41937,
  38854,
  5157,
  3881,
  111491,
  1142,
  9776,
  421673,
  152241,
  29309,
  14961,
  87854,
  6054,
  15424,
  3796,
  82656,
  54996,
  2108,
  55367,
  239450,
  154525,
  9643,
  118103,
  106041,
  64601,
  68549,
  48707,
  30266,
  25772,
  18740,
  9462,
  229669,
  91798,
  112152,
  191327,
  14493,
  72828,
  8175,
  66636,
  236474,
  25817,
  87351,
  129027,
  76653,
  20422,
  22983,
  71240,
  27846,
  44661,
  12399,
  46158,
  77704,
  53101,
  35032,
  11072,
  17300,
  109294,
  33638,
  24408,
  1895,
  11241,
  760,
  17584,
  82479,
  125877,
  63150,
  141075,
  34259,
  23274,
  81698,
  15732,
  43577,
  48340,
  91584,
  14688,
  16379,
  24481,
  150280,
  96420,
  262050,
  48635,
  43727,
  61819,
  56268,
  72003,
  88178,
  17281,
  79912,
  13218,
  122519,
  125295,
  166396,
  11811,
  2171,
  118930,
  67746,
  17636,
  178278,
  174656,
  95661,
  173039,
  83845,
  79689,
  17473,
  98555,
  127696,
  203415,
  54730,
  22925,
  232239,
  9309,
  12136,
  175026,
  20740,
  180188,
  10747,
  39816,
  314017,
  266131,
  10040,
  175732,
  112550,
  220651,
  31974,
  37393,
  888,
  23008,
  86799,
  4303,
  64905,
  148467,
  75337,
  251,
  3284,
  370102,
  50264,
  9835,
  5438,
  23655,
  4481,
  29851,
  329,
  12855,
  7162,
  64931,
  78141,
  12804,
  42372,
  296771,
  83547,
  18624,
  34874,
  86271,
  3360,
  48665,
  77735,
  88767,
  11463,
  63527,
  28889,
  22258,
  29140,
  194315,
  113924,
  25499,
  6406,
  31334,
  1845,
  4802,
  49184,
  43455,
  35469,
  127594,
  92970,
  61038,
  115005,
  38840,
  87761,
  106838,
  8811,
  20572,
  55637,
  11162,
  96721,
  132425,
  108925,
  2948,
  125457,
  36356,
  3502,
  75270,
  27622,
  127192,
  2561,
  123095,
  49394,
  61155,
  16897,
  110064,
  9699,
  89448,
  53356,
  19628,
  220310,
  21622,
  83036,
  9885,
  112214,
  6087,
  26713,
  17901,
  161912,
  91492,
  3440,
  68594,
  9266,
  92238,
  8087,
  6866,
  150194,
  72175,
  80701,
  13459,
  31836,
  43243,
  239700,
  95846,
  44749,
  50647,
  21945,
  230538,
  120612,
  132371,
  244604,
  5193,
  105637,
  34661,
  41341,
  68775,
  85393,
  1874,
  8771,
  33718,
  49672,
  77403,
  595452,
  99507,
  6490,
  58895,
  128742,
  7704,
  39239,
  73217,
  43816,
  62824,
  37804,
  199976,
  22361,
  80005,
  87514,
  94832,
  14089,
  4574,
  139975,
  59142,
  75523,
  100268,
  43906,
  53442,
  15152,
  2547,
  186002,
  17011,
  19513,
  204282,
  3343,
  60568,
  128318,
  119250,
  4298,
  51871,
  41336,
  71759,
  21921,
  45074,
  98169,
  145889,
  99427,
  11350,
  1237,
  5520,
  28799,
  7803,
  53702,
  21026,
  136352,
  38293,
  128690,
  12158,
  90132,
  44600,
  10184,
  26957,
  39459,
  126025,
  78904,
  82999,
  59373,
  39301,
  150198,
  120529,
  153042,
  20177,
  50089,
  14764,
  271571,
  30530,
  123161,
  38975,
  101562,
  22941,
  5648,
  124654,
  109243,
  69817,
  71675,
  49162,
  106884,
  21241,
  107795,
  30258,
  16572,
  188262,
  141456,
  7688,
  60718,
  8271,
  11044,
  32440,
  104608,
  103419,
  236109,
  93156,
  43293,
  128929,
  42107,
  67180,
  25201,
  115254,
  185488,
  130954,
  72813,
  167547,
  20537,
  39969,
  38432,
  22582,
  184022,
  1139,
  27199,
  5655,
  17767,
  97412,
  122606,
  209377,
  27070,
  35871,
  326617,
  188954,
  42680,
  73512,
  80911,
  22629,
  3011,
  95021,
  315242,
  157737,
  383,
  41821,
  41808,
  19335,
  27950,
  15674,
  25677,
  110950,
  35375,
  76835,
  59108,
  57370,
  35262,
  16569,
  160415,
  37706,
  78086,
  32041,
  49691,
  137143,
  9782,
  172080,
  50148,
  77917,
  6323,
  10110,
  69172,
  17711,
  21795,
  59511,
  76184,
  135114,
  31046,
  132319,
  59105,
  157578,
  20549,
  80778,
  57649,
  158421,
  65143,
  4575,
  72235,
  21899,
  10797,
  92745,
  34035,
  106079,
  80159,
  4508,
  78304,
  25350,
  75457,
  46458,
  32937,
  25623,
  47,
  8531,
  104751,
  84953,
  8138,
  36508,
  187199,
  66310,
  115274,
  13253,
  32461,
  38536,
  1916,
  42007,
  187160,
  35055,
  26325,
  84394,
  35963,
  94216,
  45590,
  97782
];

// node_modules/@libp2p/kad-dht/dist/src/routing-table/refresh.js
var MAX_COMMON_PREFIX_LENGTH = 15;
var RoutingTableRefresh = class {
  log;
  peerRouting;
  routingTable;
  refreshInterval;
  refreshQueryTimeout;
  commonPrefixLengthRefreshedAt;
  refreshTimeoutId;
  constructor(components, init) {
    const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, logPrefix } = init;
    this.log = components.logger.forComponent(`${logPrefix}:routing-table:refresh`);
    this.peerRouting = peerRouting;
    this.routingTable = routingTable;
    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;
    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;
    this.commonPrefixLengthRefreshedAt = [];
    this.refreshTable = this.refreshTable.bind(this);
  }
  async afterStart() {
    this.log(`refreshing routing table every ${this.refreshInterval}ms`);
    this.refreshTable(true);
  }
  async stop() {
    if (this.refreshTimeoutId != null) {
      clearTimeout(this.refreshTimeoutId);
    }
  }
  /**
   * To speed lookups, we seed the table with random PeerIds. This means
   * when we are asked to locate a peer on the network, we can find a KadId
   * that is close to the requested peer ID and query that, then network
   * peers will tell us who they know who is close to the fake ID
   */
  refreshTable(force = false, options2) {
    this.log("refreshing routing table");
    const prefixLength = this._maxCommonPrefix();
    const refreshCommonPrefixLengths = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
    this.log(`max common prefix length ${prefixLength}`);
    this.log(`tracked CPLs [ ${refreshCommonPrefixLengths.map((date) => date.toISOString()).join(", ")} ]`);
    Promise.all(refreshCommonPrefixLengths.map(async (lastRefresh, index) => {
      try {
        await this._refreshCommonPrefixLength(index, lastRefresh, force, options2);
        if (this._numPeersForCpl(prefixLength) === 0) {
          const lastCpl = Math.min(2 * (index + 1), refreshCommonPrefixLengths.length - 1);
          for (let n = index + 1; n < lastCpl + 1; n++) {
            try {
              await this._refreshCommonPrefixLength(n, lastRefresh, force, options2);
            } catch (err) {
              this.log.error(err);
            }
          }
        }
      } catch (err) {
        this.log.error(err);
      }
    })).catch((err) => {
      this.log.error(err);
    }).then(() => {
      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);
      if (this.refreshTimeoutId.unref != null) {
        this.refreshTimeoutId.unref();
      }
    }).catch((err) => {
      this.log.error(err);
    });
  }
  async _refreshCommonPrefixLength(cpl, lastRefresh, force, options2) {
    if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {
      this.log("not running refresh for cpl %s as time since last refresh not above interval", cpl);
      return;
    }
    const peerId2 = this._generateRandomPeerId(cpl);
    this.log("starting refreshing cpl %s with key %p (routing table size was %s)", cpl, peerId2, this.routingTable.size);
    const signal = anySignal([options2?.signal, AbortSignal.timeout(this.refreshQueryTimeout)]);
    setMaxListeners(Infinity, signal);
    try {
      const peers = await src_default10(this.peerRouting.getClosestPeers(peerId2.toMultihash().bytes, {
        signal
      }));
      this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId2);
      this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", cpl, peerId2, this.routingTable.size);
    } finally {
      signal.clear();
    }
  }
  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
    }
    const dates = [];
    for (let i = 0; i <= maxCommonPrefix; i++) {
      dates[i] = this.commonPrefixLengthRefreshedAt[i] ?? /* @__PURE__ */ new Date();
    }
    return dates;
  }
  _generateRandomPeerId(targetCommonPrefixLength) {
    if (this.routingTable.kb == null) {
      throw new Error("Routing table not started");
    }
    if (this.routingTable.kb.localPeer == null) {
      throw new Error("Local peer not set");
    }
    const randomData = randomBytes(2);
    const randomUint16 = (randomData[1] << 8) + randomData[0];
    const key = this._makePeerId(this.routingTable.kb.localPeer.kadId, randomUint16, targetCommonPrefixLength);
    const multihash = decode55(key);
    return peerIdFromMultihash(multihash);
  }
  _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
    }
    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
    const localPrefix = view.getUint16(0, false);
    const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
    const keyPrefix2 = generated_prefix_list_browser_default[targetPrefix];
    const keyBuffer = new ArrayBuffer(34);
    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
    keyView.setUint8(0, sha2567.code);
    keyView.setUint8(1, 32);
    keyView.setUint32(2, keyPrefix2, false);
    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
  }
  /**
   * returns the maximum common prefix length between any peer in the table
   * and the current peer
   */
  _maxCommonPrefix() {
    let prefixLength = 0;
    for (const length16 of this._prefixLengths()) {
      if (length16 > prefixLength) {
        prefixLength = length16;
      }
    }
    return prefixLength;
  }
  /**
   * Returns the number of peers in the table with a given prefix length
   */
  _numPeersForCpl(prefixLength) {
    let count = 0;
    for (const length16 of this._prefixLengths()) {
      if (length16 === prefixLength) {
        count++;
      }
    }
    return count;
  }
  /**
   * Yields the common prefix length of every peer in the table
   */
  *_prefixLengths() {
    if (this.routingTable.kb?.localPeer == null) {
      return;
    }
    for (const { kadId } of this.routingTable.kb.toIterable()) {
      const distance = xor(this.routingTable.kb.localPeer.kadId, kadId);
      let leadingZeros = 0;
      for (const byte of distance) {
        if (byte === 0) {
          leadingZeros++;
        } else {
          break;
        }
      }
      yield leadingZeros;
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/add-provider.js
var AddProviderHandler = class {
  peerId;
  providers;
  peerStore;
  log;
  constructor(components, init) {
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:add-provider`);
    this.peerId = components.peerId;
    this.providers = init.providers;
    this.peerStore = components.peerStore;
  }
  async handle(peerId2, msg) {
    if (msg.key == null || msg.key.length === 0) {
      throw new InvalidMessageError("Missing key");
    }
    let cid;
    try {
      cid = CID9.decode(msg.key);
    } catch (err) {
      throw new InvalidMessageError("Invalid CID");
    }
    if (msg.providers == null || msg.providers.length === 0) {
      this.log.error("no providers found in message");
    }
    this.log("%p asked us, %p to store provider record for for %c", peerId2, this.peerId, cid);
    await Promise.all(msg.providers.map(async (pi) => {
      const digest5 = decode55(pi.id);
      const providerId = peerIdFromMultihash(digest5);
      const providerMultiaddrs = pi.multiaddrs.map((buf) => multiaddr(buf));
      if (!peerId2.equals(providerId)) {
        this.log("invalid provider peer %p from %p", pi.id, peerId2);
        return;
      }
      if (pi.multiaddrs.length < 1) {
        this.log("no valid addresses for provider %p. Ignore", peerId2);
        return;
      }
      this.log.trace("received provider %p for %s (addrs %s)", peerId2, cid, providerMultiaddrs);
      await this.providers.addProvider(cid, providerId);
      await this.peerStore.merge(providerId, {
        multiaddrs: providerMultiaddrs
      });
    }));
    return void 0;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/find-node.js
var FindNodeHandler = class {
  peerRouting;
  peerInfoMapper;
  peerId;
  addressManager;
  log;
  constructor(components, init) {
    const { peerRouting, logPrefix } = init;
    this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:find-node`);
    this.peerId = components.peerId;
    this.addressManager = components.addressManager;
    this.peerRouting = peerRouting;
    this.peerInfoMapper = init.peerInfoMapper;
  }
  /**
   * Process `FindNode` DHT messages
   */
  async handle(peerId2, msg) {
    this.log("incoming request from %p for peers close to %b", peerId2, msg.key);
    try {
      if (msg.key == null) {
        throw new InvalidMessageError("Invalid FIND_NODE message received - key was missing");
      }
      const closer = await this.peerRouting.getClosestPeersOffline(msg.key, {
        exclude: [
          // never tell a peer about itself
          peerId2,
          // do not include the server in the results
          this.peerId
        ]
      });
      if (equals(this.peerId.toMultihash().bytes, msg.key)) {
        closer.push({
          id: this.peerId,
          multiaddrs: this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(protocols("p2p").code))
        });
      }
      const response = {
        type: MessageType.FIND_NODE,
        clusterLevel: msg.clusterLevel,
        closer: closer.map(this.peerInfoMapper).filter(({ multiaddrs }) => multiaddrs.length).map((peerInfo) => ({
          id: peerInfo.id.toMultihash().bytes,
          multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
        })),
        providers: []
      };
      if (response.closer.length === 0) {
        this.log("could not find any peers closer to %b for %p", msg.key, peerId2);
      } else {
        this.log("found %d peers close to %b for %p", response.closer.length, msg.key, peerId2);
      }
      return response;
    } catch (err) {
      this.log("error during finding peers closer to %b for %p - %e", msg.key, peerId2, err);
      throw err;
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-providers.js
var GetProvidersHandler = class {
  peerId;
  peerRouting;
  providers;
  peerStore;
  peerInfoMapper;
  log;
  constructor(components, init) {
    const { peerRouting, providers, logPrefix } = init;
    this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:get-providers`);
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.peerRouting = peerRouting;
    this.providers = providers;
    this.peerInfoMapper = init.peerInfoMapper;
  }
  async handle(peerId2, msg) {
    if (msg.key == null) {
      throw new InvalidMessageError("Invalid GET_PROVIDERS message received - key was missing");
    }
    let cid;
    try {
      cid = CID9.decode(msg.key);
    } catch (err) {
      throw new InvalidMessageError("Invalid CID");
    }
    this.log("%p asking for providers for %s", peerId2, cid);
    const [providerPeers, closerPeers] = await Promise.all([
      src_default8(src_default5(await this.providers.getProviders(cid), async (peerId3) => {
        const peer = await this.peerStore.get(peerId3);
        const info = {
          id: peer.id,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
        };
        return info;
      })),
      this.peerRouting.getClosestPeersOffline(msg.key)
    ]);
    const response = {
      type: MessageType.GET_PROVIDERS,
      key: msg.key,
      clusterLevel: msg.clusterLevel,
      closer: closerPeers.map(this.peerInfoMapper).filter(({ id, multiaddrs }) => multiaddrs.length > 0).map((peerInfo) => ({
        id: peerInfo.id.toMultihash().bytes,
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      })),
      providers: providerPeers.map(this.peerInfoMapper).filter(({ id, multiaddrs }) => multiaddrs.length > 0).map((peerInfo) => ({
        id: peerInfo.id.toMultihash().bytes,
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      }))
    };
    this.log("got %s providers %s closerPeers", response.providers.length, response.closer.length);
    return response;
  }
  async _getAddresses(peerId2) {
    return [];
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-value.js
var GetValueHandler = class {
  peerStore;
  datastore;
  peerRouting;
  log;
  datastorePrefix;
  constructor(components, init) {
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:get-value`);
    this.datastorePrefix = `${init.datastorePrefix}/record`;
    this.peerStore = components.peerStore;
    this.datastore = components.datastore;
    this.peerRouting = init.peerRouting;
  }
  async handle(peerId2, msg) {
    const key = msg.key;
    this.log("%p asked for key %b", peerId2, key);
    if (key == null || key.length === 0) {
      throw new InvalidMessageError("Invalid key");
    }
    const response = {
      type: MessageType.GET_VALUE,
      key,
      clusterLevel: msg.clusterLevel,
      closer: [],
      providers: []
    };
    if (isPublicKeyKey(key)) {
      this.log("is public key");
      const idFromKey = fromPublicKeyKey(key);
      let pubKey;
      try {
        const peer = await this.peerStore.get(idFromKey);
        if (peer.id.publicKey == null) {
          throw new NotFoundError("No public key found in key book");
        }
        pubKey = publicKeyToProtobuf(peer.id.publicKey);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      if (pubKey != null) {
        this.log("returning found public key");
        response.record = new Libp2pRecord(key, pubKey, /* @__PURE__ */ new Date()).serialize();
        return response;
      }
    }
    const [record, closer] = await Promise.all([
      this._checkLocalDatastore(key),
      this.peerRouting.getClosestPeersOffline(key)
    ]);
    if (record != null) {
      this.log("had record for %b in local datastore", key);
      response.record = record.serialize();
    }
    if (closer.length > 0) {
      this.log("had %s closer peers in routing table", closer.length);
      response.closer = closer.map((peerInfo) => ({
        id: peerInfo.id.toMultihash().bytes,
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      }));
    }
    return response;
  }
  /**
   * Try to fetch a given record by from the local datastore.
   * Returns the record if it is still valid, meaning
   * - it was either authored by this node, or
   * - it was received less than `MAX_RECORD_AGE` ago.
   */
  async _checkLocalDatastore(key) {
    this.log("checkLocalDatastore looking for %b", key);
    const dsKey = bufferToRecordKey(this.datastorePrefix, key);
    let rawRecord;
    try {
      rawRecord = await this.datastore.get(dsKey);
    } catch (err) {
      if (err.name === "NotFoundError") {
        return void 0;
      }
      throw err;
    }
    const record = Libp2pRecord.deserialize(rawRecord);
    if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {
      await this.datastore.delete(dsKey);
      return void 0;
    }
    return record;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/ping.js
var PingHandler = class {
  log;
  constructor(components, init) {
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:ping`);
  }
  async handle(peerId2, msg) {
    this.log("ping from %p", peerId2);
    return msg;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/put-value.js
var PutValueHandler = class {
  components;
  validators;
  log;
  datastorePrefix;
  constructor(components, init) {
    const { validators: validators2 } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:put-value`);
    this.datastorePrefix = `${init.datastorePrefix}/record`;
    this.validators = validators2;
  }
  async handle(peerId2, msg) {
    const key = msg.key;
    this.log("%p asked us to store value for key %b", peerId2, key);
    if (msg.record == null) {
      const errMsg = `Empty record from: ${peerId2.toString()}`;
      this.log.error(errMsg);
      throw new InvalidMessageError(errMsg);
    }
    try {
      const deserializedRecord = Libp2pRecord.deserialize(msg.record);
      await verifyRecord(this.validators, deserializedRecord);
      deserializedRecord.timeReceived = /* @__PURE__ */ new Date();
      const recordKey = bufferToRecordKey(this.datastorePrefix, deserializedRecord.key);
      await this.components.datastore.put(recordKey, deserializedRecord.serialize().subarray());
      this.log("put record for %b into datastore under key %k", key, recordKey);
    } catch (err) {
      this.log("did not put record for key %b into datastore %o", key, err);
    }
    return msg;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/index.js
var RPC = class {
  handlers;
  log;
  metrics;
  incomingMessageTimeout;
  constructor(components, init) {
    this.metrics = {
      operations: components.metrics?.registerCounterGroup(`${init.metricsPrefix}_inbound_rpc_requests_total`),
      errors: components.metrics?.registerCounterGroup(`${init.metricsPrefix}_inbound_rpc_errors_total`),
      rpcTime: components.metrics?.registerMetricGroup(`${init.metricsPrefix}_inbound_rpc_time_seconds`, { label: "operation" })
    };
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc`);
    this.incomingMessageTimeout = init.incomingMessageTimeout ?? 1e4;
    this.handlers = {
      [MessageType.GET_VALUE.toString()]: new GetValueHandler(components, init),
      [MessageType.PUT_VALUE.toString()]: new PutValueHandler(components, init),
      [MessageType.FIND_NODE.toString()]: new FindNodeHandler(components, init),
      [MessageType.ADD_PROVIDER.toString()]: new AddProviderHandler(components, init),
      [MessageType.GET_PROVIDERS.toString()]: new GetProvidersHandler(components, init),
      [MessageType.PING.toString()]: new PingHandler(components, init)
    };
  }
  /**
   * Process incoming DHT messages
   */
  async handleMessage(peerId2, msg) {
    const handler = this.handlers[msg.type];
    if (handler == null) {
      this.log.error(`no handler found for message type: ${msg.type}`);
      return;
    }
    try {
      this.metrics.operations?.increment({
        [msg.type]: true
      });
      return await handler.handle(peerId2, msg);
    } catch {
      this.metrics.errors?.increment({
        [msg.type]: true
      });
    }
  }
  /**
   * Handle incoming streams on the dht protocol
   */
  onIncomingStream(data) {
    const message2 = "unknown";
    Promise.resolve().then(async () => {
      const { stream, connection } = data;
      const abortListener = () => {
        stream.abort(new TimeoutError());
      };
      let signal = AbortSignal.timeout(this.incomingMessageTimeout);
      signal.addEventListener("abort", abortListener);
      const messages2 = pbStream(stream).pb(Message2);
      try {
        while (true) {
          const message3 = await messages2.read({
            signal
          });
          const stopSuccessTimer = this.metrics?.rpcTime?.timer(message3.type.toString());
          const stopErrorTimer = this.metrics?.rpcTime?.timer(message3.type.toString());
          let errored = false;
          try {
            this.log("incoming %s from %p", message3.type, connection.remotePeer);
            const res = await this.handleMessage(connection.remotePeer, message3);
            if (res != null) {
              await messages2.write(res, {
                signal
              });
            }
          } catch (err) {
            errored = true;
            stopErrorTimer?.();
            throw err;
          } finally {
            if (!errored) {
              stopSuccessTimer?.();
            }
          }
          signal.removeEventListener("abort", abortListener);
          signal = AbortSignal.timeout(this.incomingMessageTimeout);
          signal.addEventListener("abort", abortListener);
        }
      } catch (err) {
        stream.abort(err);
      }
    }).catch((err) => {
      this.log.error("error handling %s RPC message from %p - %e", message2, data.connection.remotePeer, err);
    });
  }
};

// node_modules/@libp2p/kad-dht/dist/src/topology-listener.js
var TopologyListener = class extends TypedEventEmitter {
  log;
  components;
  protocol;
  running;
  registrarId;
  constructor(components, init) {
    super();
    const { protocol, logPrefix } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${logPrefix}:topology-listener`);
    this.running = false;
    this.protocol = protocol;
  }
  isStarted() {
    return this.running;
  }
  /**
   * Start the network
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this.registrarId = await this.components.registrar.register(this.protocol, {
      onConnect: (peerId2) => {
        this.log("observed peer %p with protocol %s", peerId2, this.protocol);
        this.dispatchEvent(new CustomEvent("peer", {
          detail: peerId2
        }));
      }
    });
  }
  /**
   * Stop all network activity
   */
  async stop() {
    this.running = false;
    if (this.registrarId != null) {
      this.components.registrar.unregister(this.registrarId);
      this.registrarId = void 0;
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/kad-dht.js
var DHTContentRouting = class {
  dht;
  constructor(dht) {
    this.dht = dht;
  }
  async provide(cid, options2 = {}) {
    await src_default(this.dht.provide(cid, options2));
  }
  async cancelReprovide(key) {
    await this.dht.cancelReprovide(key);
  }
  async *findProviders(cid, options2 = {}) {
    for await (const event of this.dht.findProviders(cid, options2)) {
      if (event.name === "PROVIDER") {
        yield* event.providers;
      }
    }
  }
  async put(key, value7, options2) {
    await src_default(this.dht.put(key, value7, options2));
  }
  async get(key, options2) {
    for await (const event of this.dht.get(key, options2)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw new NotFoundError("Could not find value for key");
  }
};
var DHTPeerRouting = class {
  dht;
  constructor(dht) {
    this.dht = dht;
  }
  async findPeer(peerId2, options2 = {}) {
    for await (const event of this.dht.findPeer(peerId2, options2)) {
      if (event.name === "FINAL_PEER") {
        return event.peer;
      }
    }
    throw new NotFoundError("Peer not found");
  }
  async *getClosestPeers(key, options2 = {}) {
    for await (const event of this.dht.getClosestPeers(key, options2)) {
      if (event.name === "FINAL_PEER") {
        yield event.peer;
      }
    }
  }
};
var DEFAULT_MAX_INBOUND_STREAMS3 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS3 = 64;
var KadDHT = class extends TypedEventEmitter {
  k;
  a;
  d;
  protocol;
  routingTable;
  providers;
  network;
  peerRouting;
  components;
  log;
  running;
  clientMode;
  validators;
  selectors;
  queryManager;
  contentFetching;
  contentRouting;
  routingTableRefresh;
  rpc;
  topologyListener;
  querySelf;
  maxInboundStreams;
  maxOutboundStreams;
  dhtContentRouting;
  dhtPeerRouting;
  peerInfoMapper;
  reprovider;
  onPeerConnectTimeout;
  /**
   * Create a new KadDHT
   */
  constructor(components, init = {}) {
    super();
    const logPrefix = init.logPrefix ?? "libp2p:kad-dht";
    const datastorePrefix = init.datastorePrefix ?? "/dht";
    const metricsPrefix = init.metricsPrefix ?? "libp2p_kad_dht";
    const operationMetrics = {
      queries: components.metrics?.registerMetricGroup(`${metricsPrefix}_operations_total`, { label: "operation" }),
      errors: components.metrics?.registerCounterGroup(`${metricsPrefix}_operation_errors_total`, { label: "operation" }),
      queryTime: components.metrics?.registerMetricGroup(`${metricsPrefix}_operation_time_seconds`, { label: "operation" }),
      errorTime: components.metrics?.registerMetricGroup(`${metricsPrefix}_operation_error_time_seconds`, { label: "operation" })
    };
    this.running = false;
    this.components = components;
    this.log = components.logger.forComponent(logPrefix);
    this.k = init.kBucketSize ?? KBUCKET_SIZE;
    this.a = init.alpha ?? ALPHA;
    this.d = init.disjointPaths ?? this.a;
    this.protocol = init.protocol ?? PROTOCOL;
    this.clientMode = init.clientMode ?? true;
    this.maxInboundStreams = init.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS3;
    this.maxOutboundStreams = init.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS3;
    this.peerInfoMapper = init.peerInfoMapper ?? removePrivateAddressesMapper;
    this.onPeerConnectTimeout = init.onPeerConnectTimeout ?? ON_PEER_CONNECT_TIMEOUT;
    this.providers = new Providers(components, {
      ...init.providers,
      logPrefix,
      datastorePrefix
    });
    this.validators = {
      ...validators,
      ...init.validators
    };
    this.selectors = {
      ...selectors,
      ...init.selectors
    };
    this.network = new Network2(components, {
      protocol: this.protocol,
      logPrefix,
      metricsPrefix
    });
    this.routingTable = new RoutingTable(components, {
      kBucketSize: this.k,
      pingOldContactTimeout: init.pingOldContactTimeout,
      pingOldContactConcurrency: init.pingOldContactConcurrency,
      pingOldContactMaxQueueSize: init.pingOldContactMaxQueueSize,
      pingNewContactTimeout: init.pingNewContactTimeout,
      pingNewContactConcurrency: init.pingNewContactConcurrency,
      pingNewContactMaxQueueSize: init.pingNewContactMaxQueueSize,
      protocol: this.protocol,
      logPrefix,
      metricsPrefix,
      prefixLength: init.prefixLength,
      splitThreshold: init.kBucketSplitThreshold,
      network: this.network
    });
    const initialQuerySelfHasRun = pDefer();
    if (init.allowQueryWithZeroPeers === true) {
      initialQuerySelfHasRun.resolve();
    }
    this.queryManager = new QueryManager(components, {
      disjointPaths: this.d,
      alpha: this.a,
      logPrefix,
      metricsPrefix,
      initialQuerySelfHasRun,
      routingTable: this.routingTable,
      allowQueryWithZeroPeers: init.allowQueryWithZeroPeers
    });
    this.peerRouting = new PeerRouting(components, {
      routingTable: this.routingTable,
      network: this.network,
      validators: this.validators,
      queryManager: this.queryManager,
      logPrefix
    });
    this.contentFetching = new ContentFetching(components, {
      validators: this.validators,
      selectors: this.selectors,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      network: this.network,
      logPrefix,
      datastorePrefix
    });
    this.contentRouting = new ContentRouting(components, {
      network: this.network,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      providers: this.providers,
      logPrefix
    });
    this.routingTableRefresh = new RoutingTableRefresh(components, {
      peerRouting: this.peerRouting,
      routingTable: this.routingTable,
      logPrefix
    });
    this.rpc = new RPC(components, {
      routingTable: this.routingTable,
      providers: this.providers,
      peerRouting: this.peerRouting,
      validators: this.validators,
      logPrefix,
      metricsPrefix,
      datastorePrefix,
      peerInfoMapper: this.peerInfoMapper
    });
    this.topologyListener = new TopologyListener(components, {
      protocol: this.protocol,
      logPrefix
    });
    this.querySelf = new QuerySelf(components, {
      peerRouting: this.peerRouting,
      interval: init.querySelfInterval,
      initialInterval: init.initialQuerySelfInterval,
      logPrefix,
      initialQuerySelfHasRun,
      operationMetrics
    });
    this.reprovider = new Reprovider(components, {
      ...init.reprovide,
      logPrefix,
      metricsPrefix,
      datastorePrefix,
      contentRouting: this.contentRouting,
      operationMetrics
    });
    this.network.addEventListener("peer", (evt) => {
      const peerData = evt.detail;
      this.onPeerConnect(peerData).catch((err) => {
        this.log.error("could not add %p to routing table", peerData.id, err);
      });
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    this.topologyListener.addEventListener("peer", (evt) => {
      const peerId2 = evt.detail;
      Promise.resolve().then(async () => {
        const peer = await this.components.peerStore.get(peerId2);
        const peerData = {
          id: peerId2,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
          protocols: peer.protocols
        };
        await this.onPeerConnect(peerData);
      }).catch((err) => {
        this.log.error("could not add %p to routing table - %e - %e", peerId2, err);
      });
    });
    this.dhtPeerRouting = new DHTPeerRouting(this);
    this.dhtContentRouting = new DHTContentRouting(this);
    if (init.clientMode == null) {
      components.events.addEventListener("self:peer:update", (evt) => {
        this.log("received update of self-peer info");
        void Promise.resolve().then(async () => {
          const hasPublicAddress = evt.detail.peer.addresses.some(({ multiaddr: multiaddr2 }) => multiaddrIsPublic(multiaddr2));
          const mode = this.getMode();
          if (hasPublicAddress && mode === "client") {
            await this.setMode("server");
          } else if (mode === "server" && !hasPublicAddress) {
            await this.setMode("client");
          }
        }).catch((err) => {
          this.log.error("error setting dht server mode", err);
        });
      });
    }
    this.get = timeOperationGenerator(this.get.bind(this), operationMetrics, "GET_VALUE");
    this.findProviders = timeOperationGenerator(this.findProviders.bind(this), operationMetrics, "FIND_PROVIDERS");
    this.findPeer = timeOperationGenerator(this.findPeer.bind(this), operationMetrics, "FIND_PEER");
    this.getClosestPeers = timeOperationGenerator(this.getClosestPeers.bind(this), operationMetrics, "GET_CLOSEST_PEERS");
    this.provide = timeOperationGenerator(this.provide.bind(this), operationMetrics, "PROVIDE");
    this.put = timeOperationGenerator(this.put.bind(this), operationMetrics, "PUT_VALUE");
  }
  [Symbol.toStringTag] = "@libp2p/kad-dht";
  [serviceCapabilities] = [
    "@libp2p/content-routing",
    "@libp2p/peer-routing",
    "@libp2p/peer-discovery",
    "@libp2p/kad-dht"
  ];
  [serviceDependencies] = [
    "@libp2p/identify",
    "@libp2p/ping"
  ];
  get [contentRoutingSymbol]() {
    return this.dhtContentRouting;
  }
  get [peerRoutingSymbol]() {
    return this.dhtPeerRouting;
  }
  get [peerDiscoverySymbol]() {
    return this;
  }
  async onPeerConnect(peerData) {
    this.log.trace("peer %p connected", peerData.id);
    peerData = this.peerInfoMapper(peerData);
    if (peerData.multiaddrs.length === 0) {
      this.log.trace("ignoring %p as there were no valid addresses in %s after filtering", peerData.id, peerData.multiaddrs.map((addr) => addr.toString()));
      return;
    }
    const signal = AbortSignal.timeout(this.onPeerConnectTimeout);
    setMaxListeners(Infinity, signal);
    try {
      await this.routingTable.add(peerData.id, {
        signal
      });
    } catch (err) {
      this.log.error("could not add %p to routing table", peerData.id, err);
    }
  }
  /**
   * Is this DHT running.
   */
  isStarted() {
    return this.running;
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  getMode() {
    return this.clientMode ? "client" : "server";
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  async setMode(mode, options2) {
    if (mode === this.getMode() && options2?.force !== true) {
      this.log("already in %s mode", mode);
      return;
    }
    await this.components.registrar.unhandle(this.protocol, options2);
    if (mode === this.getMode() && options2?.force !== true) {
      this.log("already in %s mode", mode);
      return;
    }
    if (mode === "client") {
      this.log("enabling client mode while in %s mode", this.getMode());
      this.clientMode = true;
    } else {
      this.log("enabling server mode while in %s mode", this.getMode());
      this.clientMode = false;
      await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {
        signal: options2?.signal,
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams
      });
    }
  }
  /**
   * Start listening to incoming connections.
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    await this.setMode(this.clientMode ? "client" : "server", {
      force: true
    });
    await start(this.routingTable, this.queryManager, this.network, this.topologyListener, this.routingTableRefresh, this.reprovider);
    await start(this.querySelf);
  }
  /**
   * Stop accepting incoming connections and sending outgoing
   * messages.
   */
  async stop() {
    this.running = false;
    await stop(this.querySelf, this.queryManager, this.network, this.routingTable, this.routingTableRefresh, this.topologyListener, this.reprovider);
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value7, options2 = {}) {
    yield* this.contentFetching.put(key, value7, options2);
  }
  /**
   * Get the value that corresponds to the passed key
   */
  async *get(key, options2 = {}) {
    yield* this.contentFetching.get(key, options2);
  }
  // ----------- Content Routing
  /**
   * Announce to the network that we can provide given key's value
   */
  async *provide(key, options2 = {}) {
    yield* this.contentRouting.provide(key, this.components.addressManager.getAddresses(), options2);
  }
  /**
   * Provider records must be re-published every 24 hours - pass a previously
   * provided CID here to not re-publish a record for it any more
   */
  async cancelReprovide(key, options2) {
    await this.providers.removeProvider(key, this.components.peerId, options2);
  }
  /**
   * Search the dht for providers of the given CID
   */
  async *findProviders(key, options2 = {}) {
    yield* this.contentRouting.findProviders(key, options2);
  }
  // ----------- Peer Routing -----------
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options2 = {}) {
    yield* this.peerRouting.findPeer(id, options2);
  }
  /**
   * Kademlia 'node lookup' operation
   */
  async *getClosestPeers(key, options2 = {}) {
    yield* this.peerRouting.getClosestPeers(key, options2);
  }
  async refreshRoutingTable(options2) {
    this.routingTableRefresh.refreshTable(true, options2);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/index.js
var EventTypes;
(function(EventTypes2) {
  EventTypes2[EventTypes2["SEND_QUERY"] = 0] = "SEND_QUERY";
  EventTypes2[EventTypes2["PEER_RESPONSE"] = 1] = "PEER_RESPONSE";
  EventTypes2[EventTypes2["FINAL_PEER"] = 2] = "FINAL_PEER";
  EventTypes2[EventTypes2["QUERY_ERROR"] = 3] = "QUERY_ERROR";
  EventTypes2[EventTypes2["PROVIDER"] = 4] = "PROVIDER";
  EventTypes2[EventTypes2["VALUE"] = 5] = "VALUE";
  EventTypes2[EventTypes2["ADD_PEER"] = 6] = "ADD_PEER";
  EventTypes2[EventTypes2["DIAL_PEER"] = 7] = "DIAL_PEER";
  EventTypes2[EventTypes2["PATH_ENDED"] = 8] = "PATH_ENDED";
})(EventTypes || (EventTypes = {}));
function kadDHT(init = {}) {
  return (components) => new KadDHT(components, init);
}

// node_modules/@libp2p/mplex/dist/src/message-types.js
var MessageTypes;
(function(MessageTypes2) {
  MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
  MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
  MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
  MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
  MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
  MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
  MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
})(MessageTypes || (MessageTypes = {}));
var MessageTypeNames = Object.freeze({
  0: "NEW_STREAM",
  1: "MESSAGE_RECEIVER",
  2: "MESSAGE_INITIATOR",
  3: "CLOSE_RECEIVER",
  4: "CLOSE_INITIATOR",
  5: "RESET_RECEIVER",
  6: "RESET_INITIATOR"
});
var InitiatorMessageTypes = Object.freeze({
  NEW_STREAM: MessageTypes.NEW_STREAM,
  MESSAGE: MessageTypes.MESSAGE_INITIATOR,
  CLOSE: MessageTypes.CLOSE_INITIATOR,
  RESET: MessageTypes.RESET_INITIATOR
});
var ReceiverMessageTypes = Object.freeze({
  MESSAGE: MessageTypes.MESSAGE_RECEIVER,
  CLOSE: MessageTypes.CLOSE_RECEIVER,
  RESET: MessageTypes.RESET_RECEIVER
});

// node_modules/@libp2p/mplex/dist/src/decode.js
var MAX_MSG_SIZE = 1 << 20;
var MAX_MSG_QUEUE_SIZE = 4 << 20;
var Decoder15 = class {
  _buffer;
  _headerInfo;
  _maxMessageSize;
  _maxUnprocessedMessageQueueSize;
  constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {
    this._buffer = new Uint8ArrayList();
    this._headerInfo = null;
    this._maxMessageSize = maxMessageSize;
    this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;
  }
  write(chunk) {
    if (chunk == null || chunk.length === 0) {
      return [];
    }
    this._buffer.append(chunk);
    if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {
      throw new InvalidMessageError("Unprocessed message queue size too large!");
    }
    const msgs = [];
    while (this._buffer.length !== 0) {
      if (this._headerInfo == null) {
        try {
          this._headerInfo = this._decodeHeader(this._buffer);
        } catch (err) {
          if (err.name === "InvalidMessageError") {
            throw err;
          }
          break;
        }
      }
      const { id, type, length: length16, offset } = this._headerInfo;
      const bufferedDataLength = this._buffer.length - offset;
      if (bufferedDataLength < length16) {
        break;
      }
      const msg = {
        id,
        type
      };
      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
        msg.data = this._buffer.sublist(offset, offset + length16);
      }
      msgs.push(msg);
      this._buffer.consume(offset + length16);
      this._headerInfo = null;
    }
    return msgs;
  }
  /**
   * Attempts to decode the message header from the buffer
   */
  _decodeHeader(data) {
    const { value: h, offset } = readVarInt(data);
    const { value: length16, offset: end } = readVarInt(data, offset);
    const type = h & 7;
    if (MessageTypeNames[type] == null) {
      throw new Error(`Invalid type received: ${type}`);
    }
    if (length16 > this._maxMessageSize) {
      throw new InvalidMessageError("Message size too large");
    }
    return { id: h >> 3, type, offset: offset + end, length: length16 };
  }
};
var MSB14 = 128;
var REST14 = 127;
function readVarInt(buf, offset = 0) {
  let res = 0;
  let shift = 0;
  let counter = offset;
  let b;
  const l = buf.length;
  do {
    if (counter >= l || shift > 49) {
      offset = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf.get(counter++);
    res += shift < 28 ? (b & REST14) << shift : (b & REST14) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB14);
  offset = counter - offset;
  return {
    value: res,
    offset
  };
}

// node_modules/@libp2p/mplex/dist/src/encode.js
var POOL_SIZE = 10 * 1024;
var Encoder14 = class {
  _pool;
  _poolOffset;
  constructor() {
    this._pool = allocUnsafe(POOL_SIZE);
    this._poolOffset = 0;
  }
  /**
   * Encodes the given message and adds it to the passed list
   */
  write(msg, list) {
    const pool = this._pool;
    let offset = this._poolOffset;
    encode(msg.id << 3 | msg.type, pool, offset);
    offset += encodingLength(msg.id << 3 | msg.type);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      encode(msg.data.length, pool, offset);
      offset += encodingLength(msg.data.length);
    } else {
      encode(0, pool, offset);
      offset += encodingLength(0);
    }
    const header = pool.subarray(this._poolOffset, offset);
    if (POOL_SIZE - offset < 100) {
      this._pool = allocUnsafe(POOL_SIZE);
      this._poolOffset = 0;
    } else {
      this._poolOffset = offset;
    }
    list.append(header);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      list.append(msg.data);
    }
  }
};
var encoder = new Encoder14();
async function* encode34(source) {
  for await (const message2 of source) {
    const list = new Uint8ArrayList();
    encoder.write(message2, list);
    yield list;
  }
}

// node_modules/@libp2p/mplex/dist/src/errors.js
var StreamInputBufferError = class extends Error {
  constructor(message2 = "Stream input buffer error") {
    super(message2);
    this.name = "StreamInputBufferError";
  }
};

// node_modules/@libp2p/mplex/dist/src/stream.js
var MplexStream = class extends AbstractStream {
  name;
  streamId;
  send;
  types;
  maxDataSize;
  constructor(init) {
    super(init);
    this.types = init.direction === "outbound" ? InitiatorMessageTypes : ReceiverMessageTypes;
    this.send = init.send;
    this.name = init.name;
    this.streamId = init.streamId;
    this.maxDataSize = init.maxDataSize;
  }
  async sendNewStream() {
    await this.send({ id: this.streamId, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString(this.name)) });
  }
  async sendData(data) {
    data = data.sublist();
    while (data.byteLength > 0) {
      const toSend = Math.min(data.byteLength, this.maxDataSize);
      await this.send({
        id: this.streamId,
        type: this.types.MESSAGE,
        data: data.sublist(0, toSend)
      });
      data.consume(toSend);
    }
  }
  async sendReset() {
    await this.send({ id: this.streamId, type: this.types.RESET });
  }
  async sendCloseWrite() {
    await this.send({ id: this.streamId, type: this.types.CLOSE });
  }
  async sendCloseRead() {
  }
};
function createStream(options2) {
  const { id, name: name9, send, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options2;
  return new MplexStream({
    id: type === "initiator" ? `i${id}` : `r${id}`,
    streamId: id,
    name: `${name9 ?? id}`,
    direction: type === "initiator" ? "outbound" : "inbound",
    maxDataSize: maxMsgSize,
    onEnd,
    send,
    log: options2.logger.forComponent(`libp2p:mplex:stream:${type}:${id}`)
  });
}

// node_modules/@libp2p/mplex/dist/src/mplex.js
var MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
var DISCONNECT_THRESHOLD = 5;
var CLOSE_TIMEOUT3 = 500;
function printMessage(msg) {
  const output = {
    ...msg,
    type: `${MessageTypeNames[msg.type]} (${msg.type})`
  };
  if (msg.type === MessageTypes.NEW_STREAM) {
    output.data = toString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
  }
  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
    output.data = toString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
  }
  return output;
}
var MplexStreamMuxer = class {
  protocol = "/mplex/6.7.0";
  sink;
  source;
  log;
  _streamId;
  _streams;
  _init;
  _source;
  closeController;
  rateLimiter;
  closeTimeout;
  logger;
  constructor(components, init) {
    init = init ?? {};
    this.log = components.logger.forComponent("libp2p:mplex");
    this.logger = components.logger;
    this._streamId = 0;
    this._streams = {
      /**
       * Stream to ids map
       */
      initiators: /* @__PURE__ */ new Map(),
      /**
       * Stream to ids map
       */
      receivers: /* @__PURE__ */ new Map()
    };
    this._init = init;
    this.closeTimeout = init.closeTimeout ?? CLOSE_TIMEOUT3;
    this.sink = this._createSink();
    this._source = pushable({
      objectMode: true,
      onEnd: () => {
        for (const stream of this._streams.initiators.values()) {
          stream.destroy();
        }
        for (const stream of this._streams.receivers.values()) {
          stream.destroy();
        }
      }
    });
    this.source = pipe(this._source, (source) => encode34(source));
    this.closeController = new AbortController();
    this.rateLimiter = new RateLimiter({
      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,
      duration: 1
    });
  }
  /**
   * Returns a Map of streams and their ids
   */
  get streams() {
    const streams = [];
    for (const stream of this._streams.initiators.values()) {
      streams.push(stream);
    }
    for (const stream of this._streams.receivers.values()) {
      streams.push(stream);
    }
    return streams;
  }
  /**
   * Initiate a new stream with the given name. If no name is
   * provided, the id of the stream will be used.
   */
  newStream(name9) {
    if (this.closeController.signal.aborted) {
      throw new MuxerClosedError("Muxer already closed");
    }
    const id = this._streamId++;
    name9 = name9 == null ? id.toString() : name9.toString();
    const registry = this._streams.initiators;
    return this._newStream({ id, name: name9, type: "initiator", registry });
  }
  /**
   * Close or abort all tracked streams and stop the muxer
   */
  async close(options2) {
    if (this.closeController.signal.aborted) {
      return;
    }
    const signal = options2?.signal ?? AbortSignal.timeout(this.closeTimeout);
    try {
      await Promise.all(this.streams.map(async (s) => s.close({
        signal
      })));
      this._source.end();
      await this._source.onEmpty({
        signal
      });
      this.closeController.abort();
    } catch (err) {
      this.abort(err);
    }
  }
  abort(err) {
    if (this.closeController.signal.aborted) {
      return;
    }
    this.streams.forEach((s) => {
      s.abort(err);
    });
    this.closeController.abort(err);
  }
  /**
   * Called whenever an inbound stream is created
   */
  _newReceiverStream(options2) {
    const { id, name: name9 } = options2;
    const registry = this._streams.receivers;
    return this._newStream({ id, name: name9, type: "receiver", registry });
  }
  _newStream(options2) {
    const { id, name: name9, type, registry } = options2;
    this.log("new %s stream %s", type, id);
    if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
      throw new TooManyOutboundProtocolStreamsError("Too many outbound streams open");
    }
    if (registry.has(id)) {
      throw new Error(`${type} stream ${id} already exists!`);
    }
    const send = async (msg) => {
      if (this.log.enabled) {
        this.log.trace("%s stream %s send", type, id, printMessage(msg));
      }
      this._source.push(msg);
    };
    const onEnd = () => {
      this.log("%s stream with id %s and protocol %s ended", type, id, stream.protocol);
      registry.delete(id);
      if (this._init.onStreamEnd != null) {
        this._init.onStreamEnd(stream);
      }
    };
    const stream = createStream({ id, name: name9, send, type, onEnd, maxMsgSize: this._init.maxMsgSize, logger: this.logger });
    registry.set(id, stream);
    return stream;
  }
  /**
   * Creates a sink with an abortable source. Incoming messages will
   * also have their size restricted. All messages will be varint decoded.
   */
  _createSink() {
    const sink = async (source) => {
      const abortListener = () => {
        closeSource(source, this.log);
      };
      this.closeController.signal.addEventListener("abort", abortListener);
      try {
        const decoder = new Decoder15(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);
        for await (const chunk of source) {
          for (const msg of decoder.write(chunk)) {
            await this._handleIncoming(msg);
          }
        }
        this._source.end();
      } catch (err) {
        this.log("error in sink", err);
        this._source.end(err);
      } finally {
        this.closeController.signal.removeEventListener("abort", abortListener);
      }
    };
    return sink;
  }
  async _handleIncoming(message2) {
    const { id, type } = message2;
    if (this.log.enabled) {
      this.log.trace("incoming message", printMessage(message2));
    }
    if (message2.type === MessageTypes.NEW_STREAM) {
      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
        this.log("too many inbound streams open");
        this._source.push({
          id,
          type: MessageTypes.RESET_RECEIVER
        });
        try {
          await this.rateLimiter.consume("new-stream", 1);
        } catch {
          this.log("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
          this.abort(new Error("Too many open streams"));
          return;
        }
        return;
      }
      const stream2 = this._newReceiverStream({ id, name: toString(message2.data instanceof Uint8Array ? message2.data : message2.data.subarray()) });
      if (this._init.onIncomingStream != null) {
        this._init.onIncomingStream(stream2);
      }
      return;
    }
    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
    const stream = list.get(id);
    if (stream == null) {
      this.log("missing stream %s for message type %s", id, MessageTypeNames[type]);
      try {
        await this.rateLimiter.consume("missing-stream", 1);
      } catch {
        this.log("rate limit hit when receiving messages for streams that do not exist - closing remote connection");
        this.abort(new Error("Too many messages for missing streams"));
        return;
      }
      return;
    }
    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
    try {
      switch (type) {
        case MessageTypes.MESSAGE_INITIATOR:
        case MessageTypes.MESSAGE_RECEIVER:
          if (stream.sourceReadableLength() > maxBufferSize) {
            this._source.push({
              id: message2.id,
              type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
            });
            throw new StreamInputBufferError("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers");
          }
          stream.sourcePush(message2.data);
          break;
        case MessageTypes.CLOSE_INITIATOR:
        case MessageTypes.CLOSE_RECEIVER:
          stream.remoteCloseWrite();
          break;
        case MessageTypes.RESET_INITIATOR:
        case MessageTypes.RESET_RECEIVER:
          stream.reset();
          break;
        default:
          this.log("unknown message type %s", type);
      }
    } catch (err) {
      this.log.error("error while processing message", err);
      stream.abort(err);
    }
  }
};

// node_modules/@libp2p/mplex/dist/src/index.js
var Mplex = class {
  protocol = "/mplex/6.7.0";
  _init;
  components;
  constructor(components, init = {}) {
    this.components = components;
    this._init = init;
  }
  [Symbol.toStringTag] = "@libp2p/mplex";
  [serviceCapabilities] = [
    "@libp2p/stream-multiplexing"
  ];
  createStreamMuxer(init = {}) {
    return new MplexStreamMuxer(this.components, {
      ...init,
      ...this._init
    });
  }
};
function mplex(init = {}) {
  return (components) => new Mplex(components, init);
}

// node_modules/@libp2p/ping/dist/src/constants.js
var PING_LENGTH2 = 32;
var PROTOCOL_VERSION3 = "1.0.0";
var PROTOCOL_NAME3 = "ping";
var PROTOCOL_PREFIX3 = "ipfs";
var TIMEOUT2 = 1e4;
var MAX_INBOUND_STREAMS2 = 2;
var MAX_OUTBOUND_STREAMS2 = 1;

// node_modules/@libp2p/ping/dist/src/ping.js
var Ping = class {
  protocol;
  components;
  started;
  timeout;
  maxInboundStreams;
  maxOutboundStreams;
  runOnLimitedConnection;
  log;
  constructor(components, init = {}) {
    this.components = components;
    this.log = components.logger.forComponent("libp2p:ping");
    this.started = false;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX3}/${PROTOCOL_NAME3}/${PROTOCOL_VERSION3}`;
    this.timeout = init.timeout ?? TIMEOUT2;
    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS2;
    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS2;
    this.runOnLimitedConnection = init.runOnLimitedConnection ?? true;
    this.handleMessage = this.handleMessage.bind(this);
  }
  [Symbol.toStringTag] = "@libp2p/ping";
  [serviceCapabilities] = [
    "@libp2p/ping"
  ];
  async start() {
    await this.components.registrar.handle(this.protocol, this.handleMessage, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * A handler to register with Libp2p to process ping messages
   */
  handleMessage(data) {
    this.log("incoming ping from %p", data.connection.remotePeer);
    const { stream } = data;
    const start2 = Date.now();
    const bytes = byteStream(stream);
    let pinged = false;
    Promise.resolve().then(async () => {
      while (true) {
        const signal = AbortSignal.timeout(this.timeout);
        setMaxListeners(Infinity, signal);
        signal.addEventListener("abort", () => {
          stream?.abort(new TimeoutError("ping timeout"));
        });
        const buf = await bytes.read({
          bytes: PING_LENGTH2,
          signal
        });
        await bytes.write(buf, {
          signal
        });
        pinged = true;
      }
    }).catch((err) => {
      if (pinged && err.name === "UnexpectedEOFError" && stream.readStatus !== "ready") {
        return;
      }
      this.log.error("incoming ping from %p failed with error - %e", data.connection.remotePeer, err);
      stream?.abort(err);
    }).finally(() => {
      const ms = Date.now() - start2;
      this.log("incoming ping from %p complete in %dms", data.connection.remotePeer, ms);
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      stream.close({
        signal
      }).catch((err) => {
        this.log.error("error closing ping stream from %p - %e", data.connection.remotePeer, err);
        stream?.abort(err);
      });
    });
  }
  /**
   * Ping a given peer and wait for its response, getting the operation latency.
   */
  async ping(peer, options2 = {}) {
    this.log("pinging %p", peer);
    const start2 = Date.now();
    const data = randomBytes(PING_LENGTH2);
    const connection = await this.components.connectionManager.openConnection(peer, options2);
    let stream;
    if (options2.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      options2 = {
        ...options2,
        signal
      };
    }
    try {
      stream = await connection.newStream(this.protocol, {
        ...options2,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      const bytes = byteStream(stream);
      const [, result] = await Promise.all([
        bytes.write(data, options2),
        bytes.read({
          ...options2,
          bytes: PING_LENGTH2
        })
      ]);
      const ms = Date.now() - start2;
      if (!equals(data, result.subarray())) {
        throw new ProtocolError(`Received wrong ping ack after ${ms}ms`);
      }
      this.log("ping %p complete in %dms", connection.remotePeer, ms);
      return ms;
    } catch (err) {
      this.log.error("error while pinging %p", connection.remotePeer, err);
      stream?.abort(err);
      throw err;
    } finally {
      if (stream != null) {
        await stream.close(options2);
      }
    }
  }
};

// node_modules/@libp2p/ping/dist/src/index.js
function ping(init = {}) {
  return (components) => new Ping(components, init);
}

// node_modules/@libp2p/webrtc/node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
var code14 = (code17) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component == null) {
        return false;
      }
      if (component.code !== code17) {
        return false;
      }
      if (component.value != null) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var value5 = (code17, value7) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component?.code !== code17) {
        return false;
      }
      if (component.value == null) {
        return false;
      }
      if (value7 != null && component.value !== value7) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var optional6 = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    }
  };
};
var or19 = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    }
  };
};
var and6 = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    }
  };
};
function fmt6(...matchers) {
  function match(ma) {
    if (ma == null) {
      return false;
    }
    let parts = ma.getComponents();
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matchers,
    matches,
    exactMatch
  };
}

// node_modules/@libp2p/webrtc/node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var _PEER_ID6 = value5(CODE_P2P);
var PEER_ID6 = fmt6(_PEER_ID6);
var _DNS46 = value5(CODE_DNS4);
var _DNS66 = value5(CODE_DNS6);
var _DNSADDR6 = value5(CODE_DNSADDR);
var _DNS8 = value5(CODE_DNS);
var DNS46 = fmt6(_DNS46, optional6(value5(CODE_P2P)));
var DNS66 = fmt6(_DNS66, optional6(value5(CODE_P2P)));
var DNSADDR6 = fmt6(_DNSADDR6, optional6(value5(CODE_P2P)));
var DNS9 = fmt6(or19(_DNS8, _DNSADDR6, _DNS46, _DNS66), optional6(value5(CODE_P2P)));
var _IP46 = and6(value5(CODE_IP4), optional6(value5(CODE_IPCIDR)));
var _IP66 = and6(optional6(value5(CODE_IP6ZONE)), value5(CODE_IP6), optional6(value5(CODE_IPCIDR)));
var _IP8 = or19(_IP46, _IP66);
var _IP_OR_DOMAIN6 = or19(_IP8, _DNS8, _DNS46, _DNS66, _DNSADDR6);
var IP_OR_DOMAIN6 = fmt6(or19(_IP8, and6(or19(_DNS8, _DNSADDR6, _DNS46, _DNS66), optional6(value5(CODE_P2P)))));
var IP46 = fmt6(_IP46);
var IP66 = fmt6(_IP66);
var IP8 = fmt6(_IP8);
var _TCP6 = and6(_IP_OR_DOMAIN6, value5(CODE_TCP));
var _UDP6 = and6(_IP_OR_DOMAIN6, value5(CODE_UDP));
var TCP6 = fmt6(and6(_TCP6, optional6(value5(CODE_P2P))));
var UDP6 = fmt6(_UDP6);
var _QUIC6 = and6(_UDP6, code14(CODE_QUIC), optional6(value5(CODE_P2P)));
var _QUIC_V15 = and6(_UDP6, code14(CODE_QUIC_V1), optional6(value5(CODE_P2P)));
var QUIC_V0_OR_V16 = or19(_QUIC6, _QUIC_V15);
var QUIC6 = fmt6(_QUIC6);
var QUIC_V15 = fmt6(_QUIC_V15);
var _WEB6 = or19(_IP_OR_DOMAIN6, _TCP6, _UDP6, _QUIC6, _QUIC_V15);
var _WebSockets6 = or19(and6(_WEB6, code14(CODE_WS), optional6(value5(CODE_P2P))));
var WebSockets6 = fmt6(_WebSockets6);
var _WebSocketsSecure6 = or19(and6(_WEB6, code14(CODE_WSS), optional6(value5(CODE_P2P))), and6(_WEB6, code14(CODE_TLS), optional6(value5(CODE_SNI)), code14(CODE_WS), optional6(value5(CODE_P2P))));
var WebSocketsSecure6 = fmt6(_WebSocketsSecure6);
var _WebRTCDirect6 = and6(_UDP6, code14(CODE_WEBRTC_DIRECT), optional6(value5(CODE_CERTHASH)), optional6(value5(CODE_CERTHASH)), optional6(value5(CODE_P2P)));
var WebRTCDirect6 = fmt6(_WebRTCDirect6);
var _WebTransport6 = and6(_QUIC_V15, code14(CODE_WEBTRANSPORT), optional6(value5(CODE_CERTHASH)), optional6(value5(CODE_CERTHASH)), optional6(value5(CODE_P2P)));
var WebTransport6 = fmt6(_WebTransport6);
var _P2P6 = or19(_WebSockets6, _WebSocketsSecure6, and6(_TCP6, optional6(value5(CODE_P2P))), and6(QUIC_V0_OR_V16, optional6(value5(CODE_P2P))), and6(_IP_OR_DOMAIN6, optional6(value5(CODE_P2P))), _WebRTCDirect6, _WebTransport6, value5(CODE_P2P));
var P2P7 = fmt6(_P2P6);
var _Circuit6 = and6(_P2P6, code14(CODE_P2P_CIRCUIT), value5(CODE_P2P));
var Circuit6 = fmt6(_Circuit6);
var _WebRTC6 = or19(and6(_P2P6, code14(CODE_P2P_CIRCUIT), code14(CODE_WEBRTC), optional6(value5(CODE_P2P))), and6(_P2P6, code14(CODE_WEBRTC), optional6(value5(CODE_P2P))), and6(code14(CODE_WEBRTC), optional6(value5(CODE_P2P))));
var WebRTC6 = fmt6(_WebRTC6);
var _HTTP6 = or19(and6(_IP_OR_DOMAIN6, value5(CODE_TCP), code14(CODE_HTTP), optional6(value5(CODE_P2P))), and6(_IP_OR_DOMAIN6, code14(CODE_HTTP), optional6(value5(CODE_P2P))));
var HTTP6 = fmt6(_HTTP6);
var _HTTPS6 = and6(_IP_OR_DOMAIN6, or19(and6(value5(CODE_TCP, "443"), code14(CODE_HTTP)), and6(value5(CODE_TCP), code14(CODE_HTTPS)), and6(value5(CODE_TCP), code14(CODE_TLS), code14(CODE_HTTP)), and6(code14(CODE_TLS), code14(CODE_HTTP)), code14(CODE_TLS), code14(CODE_HTTPS)), optional6(value5(CODE_P2P)));
var HTTPS6 = fmt6(_HTTPS6);
var _Memory6 = or19(and6(value5(CODE_MEMORY), optional6(value5(CODE_P2P))));
var Memory6 = fmt6(_Memory6);
var _Unix6 = or19(and6(value5(CODE_UNIX), optional6(value5(CODE_P2P))));
var Unix6 = fmt6(_Unix6);

// node_modules/@libp2p/webrtc/dist/src/private-to-public/pb/message.js
var Message3;
(function(Message5) {
  let Flag2;
  (function(Flag3) {
    Flag3["FIN"] = "FIN";
    Flag3["STOP_SENDING"] = "STOP_SENDING";
    Flag3["RESET"] = "RESET";
    Flag3["FIN_ACK"] = "FIN_ACK";
  })(Flag2 = Message5.Flag || (Message5.Flag = {}));
  let __FlagValues;
  (function(__FlagValues2) {
    __FlagValues2[__FlagValues2["FIN"] = 0] = "FIN";
    __FlagValues2[__FlagValues2["STOP_SENDING"] = 1] = "STOP_SENDING";
    __FlagValues2[__FlagValues2["RESET"] = 2] = "RESET";
    __FlagValues2[__FlagValues2["FIN_ACK"] = 3] = "FIN_ACK";
  })(__FlagValues || (__FlagValues = {}));
  (function(Flag3) {
    Flag3.codec = () => {
      return enumeration(__FlagValues);
    };
  })(Flag2 = Message5.Flag || (Message5.Flag = {}));
  let _codec;
  Message5.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.flag != null) {
          w.uint32(8);
          Message5.Flag.codec().encode(obj.flag, w);
        }
        if (obj.message != null) {
          w.uint32(18);
          w.bytes(obj.message);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {};
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.flag = Message5.Flag.codec().decode(reader);
              break;
            }
            case 2: {
              obj.message = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message5.encode = (obj) => {
    return encodeMessage(obj, Message5.codec());
  };
  Message5.decode = (buf, opts) => {
    return decodeMessage(buf, Message5.codec(), opts);
  };
})(Message3 || (Message3 = {}));

// node_modules/@libp2p/webrtc/dist/src/constants.js
var DEFAULT_ICE_SERVERS = [
  "stun:stun.l.google.com:19302",
  "stun:global.stun.twilio.com:3478",
  "stun:stun.cloudflare.com:3478",
  "stun:stun.services.mozilla.com:3478"
];
var UFRAG_ALPHABET = Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");
var UFRAG_PREFIX = "libp2p+webrtc+v1/";
var CODEC_CERTHASH = 466;
var MAX_BUFFERED_AMOUNT = 2 * 1024 * 1024;
var BUFFERED_AMOUNT_LOW_TIMEOUT = 30 * 1e3;
var MAX_MESSAGE_SIZE2 = 16 * 1024;
function calculateProtobufOverhead(maxMessageSize = MAX_MESSAGE_SIZE2) {
  const messageLength = encodingLength(maxMessageSize - encodingLength(maxMessageSize));
  const flagField = 1 + encodingLength(Object.keys(Message3.Flag).length - 1);
  const messageFieldIdType = 1;
  const available = maxMessageSize - messageLength - flagField - messageFieldIdType;
  const messageFieldLengthLength = encodingLength(available);
  return messageLength + flagField + messageFieldIdType + messageFieldLengthLength;
}
var PROTOBUF_OVERHEAD = calculateProtobufOverhead();
var FIN_ACK_TIMEOUT = 5e3;
var OPEN_TIMEOUT = 5e3;
var DATA_CHANNEL_DRAIN_TIMEOUT = 3e4;
var MUXER_PROTOCOL = "/webrtc";
var SIGNALING_PROTOCOL = "/webrtc-signaling/0.0.1";
var DEFAULT_CERTIFICATE_DATASTORE_KEY = "/libp2p/webrtc-direct/certificate";
var DEFAULT_CERTIFICATE_PRIVATE_KEY_NAME = "webrtc-direct-certificate-private-key";
var DEFAULT_CERTIFICATE_LIFESPAN = 12096e5;
var DEFAULT_CERTIFICATE_RENEWAL_THRESHOLD = 864e5;

// node_modules/@libp2p/webrtc/dist/src/util.js
var browser = detect();
var isFirefox = browser != null && browser.name === "firefox";
var nopSource = async function* nop() {
};
var nopSink = async (_) => {
};
function drainAndClose(channel, direction, drainTimeout = DATA_CHANNEL_DRAIN_TIMEOUT, options2) {
  if (channel.readyState !== "open") {
    return;
  }
  void Promise.resolve().then(async () => {
    if (channel.bufferedAmount > 0) {
      options2.log("%s drain channel with %d buffered bytes", direction, channel.bufferedAmount);
      const deferred = pDefer();
      let drained = false;
      channel.bufferedAmountLowThreshold = 0;
      const closeListener = () => {
        if (!drained) {
          options2.log("%s drain channel closed before drain", direction);
          deferred.resolve();
        }
      };
      channel.addEventListener("close", closeListener, {
        once: true
      });
      channel.addEventListener("bufferedamountlow", () => {
        drained = true;
        channel.removeEventListener("close", closeListener);
        deferred.resolve();
      });
      await pTimeout(deferred.promise, {
        milliseconds: drainTimeout
      });
    }
  }).then(async () => {
    if (channel.readyState === "open") {
      channel.close();
    }
  }).catch((err) => {
    options2.log.error("error closing outbound stream", err);
  });
}
async function getRtcConfiguration(config) {
  config = config ?? {};
  if (typeof config === "function") {
    config = await config();
  }
  config.iceServers = config.iceServers ?? DEFAULT_ICE_SERVERS.map((url) => ({
    urls: [
      url
    ]
  }));
  return config;
}
var genUfrag = (len = 32) => {
  return UFRAG_PREFIX + [...Array(len)].map(() => UFRAG_ALPHABET.at(Math.floor(Math.random() * UFRAG_ALPHABET.length))).join("");
};

// node_modules/@libp2p/webrtc/dist/src/maconn.js
var WebRTCMultiaddrConnection = class {
  log;
  /**
   * WebRTC Peer Connection
   */
  peerConnection;
  /**
   * The multiaddr address used to communicate with the remote peer
   */
  remoteAddr;
  /**
   * Holds the life cycle times of the connection
   */
  timeline;
  /**
   * Optional metrics counter group for this connection
   */
  metrics;
  /**
   * The stream source, a no-op as the transport natively supports multiplexing
   */
  source = nopSource();
  /**
   * The stream destination, a no-op as the transport natively supports multiplexing
   */
  sink = nopSink;
  constructor(components, init) {
    this.log = components.logger.forComponent("libp2p:webrtc:maconn");
    this.remoteAddr = init.remoteAddr;
    this.timeline = init.timeline;
    this.peerConnection = init.peerConnection;
    const peerConnection = this.peerConnection;
    const initialState = peerConnection.connectionState;
    this.peerConnection.onconnectionstatechange = () => {
      this.log.trace("peer connection state change", peerConnection.connectionState, "initial state", initialState);
      if (peerConnection.connectionState === "disconnected" || peerConnection.connectionState === "failed" || peerConnection.connectionState === "closed") {
        this.timeline.close = Date.now();
      }
    };
  }
  async close(options2) {
    this.log.trace("closing connection");
    this.peerConnection.close();
    this.timeline.close = Date.now();
    this.metrics?.increment({ close: true });
  }
  abort(err) {
    this.log.error("closing connection due to error", err);
    this.peerConnection.close();
    this.timeline.close = Date.now();
    this.metrics?.increment({ abort: true });
  }
};

// node_modules/@libp2p/webrtc/dist/src/stream.js
var WebRTCStream = class extends AbstractStream {
  /**
   * The data channel used to send and receive data
   */
  channel;
  /**
   * push data from the underlying datachannel to the length prefix decoder
   * and then the protobuf decoder.
   */
  incomingData;
  maxBufferedAmount;
  bufferedAmountLowEventTimeout;
  /**
   * The maximum size of a message in bytes
   */
  maxMessageSize;
  /**
   * When this promise is resolved, the remote has sent us a FIN flag
   */
  receiveFinAck;
  finAckTimeout;
  openTimeout;
  closeController;
  constructor(init) {
    const originalOnEnd = init.onEnd;
    init.onEnd = (err) => {
      this.log.trace('readable and writeable ends closed with status "%s"', this.status);
      void Promise.resolve(async () => {
        if (this.timeline.abort != null || this.timeline.reset !== null) {
          return;
        }
        try {
          await pTimeout(this.receiveFinAck.promise, {
            milliseconds: this.finAckTimeout
          });
        } catch (err2) {
          this.log.error("error receiving FIN_ACK", err2);
        }
      }).then(() => {
        this.incomingData.end();
        originalOnEnd?.(err);
      }).catch((err2) => {
        this.log.error("error ending stream", err2);
      }).finally(() => {
        this.channel.close();
      });
    };
    super(init);
    this.channel = init.channel;
    this.channel.binaryType = "arraybuffer";
    this.incomingData = pushable();
    this.bufferedAmountLowEventTimeout = init.bufferedAmountLowEventTimeout ?? BUFFERED_AMOUNT_LOW_TIMEOUT;
    this.maxBufferedAmount = init.maxBufferedAmount ?? MAX_BUFFERED_AMOUNT;
    this.maxMessageSize = (init.maxMessageSize ?? MAX_MESSAGE_SIZE2) - PROTOBUF_OVERHEAD;
    this.receiveFinAck = pDefer();
    this.finAckTimeout = init.closeTimeout ?? FIN_ACK_TIMEOUT;
    this.openTimeout = init.openTimeout ?? OPEN_TIMEOUT;
    this.closeController = new AbortController();
    switch (this.channel.readyState) {
      case "open":
        this.timeline.open = (/* @__PURE__ */ new Date()).getTime();
        break;
      case "closed":
      case "closing":
        if (this.timeline.close === void 0 || this.timeline.close === 0) {
          this.timeline.close = Date.now();
        }
        break;
      case "connecting":
        break;
      default:
        this.log.error("unknown datachannel state %s", this.channel.readyState);
        throw new StreamStateError("Unknown datachannel state");
    }
    this.channel.onopen = (_evt) => {
      this.timeline.open = (/* @__PURE__ */ new Date()).getTime();
    };
    this.channel.onclose = (_evt) => {
      this.log.trace("received onclose event");
      this.closeController.abort();
      this.receiveFinAck.resolve();
      void this.close().catch((err) => {
        this.log.error("error closing stream after channel closed", err);
      });
    };
    this.channel.onerror = (evt) => {
      this.log.trace("received onerror event");
      this.closeController.abort();
      const err = evt.error;
      this.abort(err);
    };
    this.channel.onmessage = async (event) => {
      const { data } = event;
      if (data === null || data.byteLength === 0) {
        return;
      }
      this.incomingData.push(new Uint8Array(data, 0, data.byteLength));
    };
    const self2 = this;
    Promise.resolve().then(async () => {
      for await (const buf of decode9(this.incomingData)) {
        const message2 = self2.processIncomingProtobuf(buf);
        if (message2 != null) {
          self2.sourcePush(new Uint8ArrayList(message2));
        }
      }
    }).catch((err) => {
      this.log.error("error processing incoming data channel messages", err);
    });
  }
  sendNewStream() {
  }
  async _sendMessage(data, checkBuffer = true) {
    if (this.channel.readyState === "closed" || this.channel.readyState === "closing") {
      throw new StreamStateError(`Invalid datachannel state - ${this.channel.readyState}`);
    }
    if (this.channel.readyState !== "open") {
      const timeout = AbortSignal.timeout(this.openTimeout);
      const signal = anySignal([
        this.closeController.signal,
        timeout
      ]);
      try {
        this.log('channel state is "%s" and not "open", waiting for "open" event before sending data', this.channel.readyState);
        await raceEvent(this.channel, "open", signal);
      } finally {
        signal.clear();
      }
      this.log('channel state is now "%s", sending data', this.channel.readyState);
    }
    if (checkBuffer && this.channel.bufferedAmount > this.maxBufferedAmount) {
      const timeout = AbortSignal.timeout(this.bufferedAmountLowEventTimeout);
      const signal = anySignal([
        this.closeController.signal,
        timeout
      ]);
      try {
        this.log('channel buffer is %d, wait for "bufferedamountlow" event', this.channel.bufferedAmount);
        await raceEvent(this.channel, "bufferedamountlow", signal);
      } catch (err) {
        if (timeout.aborted) {
          throw new TimeoutError(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`);
        }
        throw err;
      } finally {
        signal.clear();
      }
    }
    try {
      this.log.trace('sending message, channel state "%s"', this.channel.readyState);
      this.channel.send(data.subarray());
    } catch (err) {
      this.log.error("error while sending message", err);
    }
  }
  async sendData(data) {
    const bytesTotal = data.byteLength;
    data = data.sublist();
    while (data.byteLength > 0) {
      const toSend = Math.min(data.byteLength, this.maxMessageSize);
      const buf = data.subarray(0, toSend);
      const messageBuf = Message3.encode({ message: buf });
      const sendBuf = encode8.single(messageBuf);
      this.log.trace("sending %d/%d bytes on channel", buf.byteLength, bytesTotal);
      await this._sendMessage(sendBuf);
      data.consume(toSend);
    }
    this.log.trace('finished sending data, channel state "%s"', this.channel.readyState);
  }
  async sendReset() {
    try {
      await this._sendFlag(Message3.Flag.RESET);
    } catch (err) {
      this.log.error("failed to send reset - %e", err);
    } finally {
      this.channel.close();
    }
  }
  async sendCloseWrite(options2) {
    if (this.channel.readyState !== "open") {
      this.receiveFinAck.resolve();
      return;
    }
    const sent = await this._sendFlag(Message3.Flag.FIN);
    if (sent) {
      this.log.trace("awaiting FIN_ACK");
      try {
        await raceSignal(this.receiveFinAck.promise, options2?.signal, {
          errorMessage: "sending close-write was aborted before FIN_ACK was received",
          errorName: "FinAckNotReceivedError"
        });
      } catch (err) {
        this.log.error("failed to await FIN_ACK", err);
      }
    } else {
      this.log.trace("sending FIN failed, not awaiting FIN_ACK");
    }
    this.receiveFinAck.resolve();
  }
  async sendCloseRead() {
    if (this.channel.readyState !== "open") {
      return;
    }
    await this._sendFlag(Message3.Flag.STOP_SENDING);
  }
  /**
   * Handle incoming
   */
  processIncomingProtobuf(buffer) {
    const message2 = Message3.decode(buffer);
    if (message2.flag !== void 0) {
      this.log.trace('incoming flag %s, write status "%s", read status "%s"', message2.flag, this.writeStatus, this.readStatus);
      if (message2.flag === Message3.Flag.FIN) {
        this.remoteCloseWrite();
        this.log.trace("sending FIN_ACK");
        void this._sendFlag(Message3.Flag.FIN_ACK).catch((err) => {
          this.log.error("error sending FIN_ACK immediately", err);
        });
      }
      if (message2.flag === Message3.Flag.RESET) {
        this.reset();
      }
      if (message2.flag === Message3.Flag.STOP_SENDING) {
        this.remoteCloseRead();
      }
      if (message2.flag === Message3.Flag.FIN_ACK) {
        this.log.trace("received FIN_ACK");
        this.receiveFinAck.resolve();
      }
    }
    if (this.readStatus === "ready") {
      return message2.message;
    }
  }
  async _sendFlag(flag) {
    if (this.channel.readyState !== "open") {
      this.log.trace('not sending flag %s because channel is "%s" and not "open"', flag.toString(), this.channel.readyState);
      return false;
    }
    this.log.trace("sending flag %s", flag.toString());
    const messageBuf = Message3.encode({ flag });
    const prefixedBuf = encode8.single(messageBuf);
    try {
      await this._sendMessage(prefixedBuf, false);
      return true;
    } catch (err) {
      this.log.error("could not send flag %s - %e", flag.toString(), err);
    }
    return false;
  }
};
function createStream2(options2) {
  const { channel, direction, handshake } = options2;
  return new WebRTCStream({
    id: `${channel.id}`,
    log: options2.logger.forComponent(`libp2p:webrtc:stream:${handshake === true ? "handshake" : direction}:${channel.id}`),
    ...options2
  });
}

// node_modules/@libp2p/webrtc/dist/src/muxer.js
var DataChannelMuxerFactory = class {
  protocol;
  /**
   * WebRTC Peer Connection
   */
  peerConnection;
  bufferedStreams = [];
  metrics;
  dataChannelOptions;
  components;
  log;
  constructor(components, init) {
    this.components = components;
    this.peerConnection = init.peerConnection;
    this.metrics = init.metrics;
    this.protocol = init.protocol ?? MUXER_PROTOCOL;
    this.dataChannelOptions = init.dataChannelOptions ?? {};
    this.log = components.logger.forComponent("libp2p:webrtc:muxerfactory");
    this.peerConnection.ondatachannel = ({ channel }) => {
      this.log.trace('incoming early datachannel with channel id %d and label "%s"', channel.id);
      if (channel.label === "init") {
        this.log.trace("closing early init channel");
        channel.close();
        return;
      }
      const bufferedStream = {};
      const stream = createStream2({
        channel,
        direction: "inbound",
        onEnd: (err) => {
          bufferedStream.onEnd(err);
        },
        logger: components.logger,
        ...this.dataChannelOptions
      });
      bufferedStream.stream = stream;
      bufferedStream.channel = channel;
      bufferedStream.onEnd = () => {
        this.bufferedStreams = this.bufferedStreams.filter((s) => s.stream.id !== stream.id);
      };
      this.bufferedStreams.push(bufferedStream);
    };
  }
  createStreamMuxer(init) {
    return new DataChannelMuxer(this.components, {
      ...init,
      peerConnection: this.peerConnection,
      dataChannelOptions: this.dataChannelOptions,
      metrics: this.metrics,
      streams: this.bufferedStreams,
      protocol: this.protocol
    });
  }
};
var DataChannelMuxer = class {
  init;
  /**
   * Array of streams in the data channel
   */
  streams;
  protocol;
  log;
  peerConnection;
  dataChannelOptions;
  metrics;
  logger;
  constructor(components, init) {
    this.init = init;
    this.log = components.logger.forComponent("libp2p:webrtc:muxer");
    this.logger = components.logger;
    this.streams = init.streams.map((s) => s.stream);
    this.peerConnection = init.peerConnection;
    this.protocol = init.protocol ?? MUXER_PROTOCOL;
    this.metrics = init.metrics;
    this.dataChannelOptions = init.dataChannelOptions ?? {};
    this.peerConnection.ondatachannel = ({ channel }) => {
      this.log.trace("incoming datachannel with channel id %d", channel.id);
      if (channel.label === "init") {
        this.log.trace("closing init channel");
        channel.close();
        return;
      }
      const id = channel.id;
      const stream = createStream2({
        channel,
        direction: "inbound",
        onEnd: () => {
          this.#onStreamEnd(stream, channel);
          this.log("incoming channel %s ended", id);
        },
        logger: this.logger,
        ...this.dataChannelOptions
      });
      this.streams.push(stream);
      this.metrics?.increment({ incoming_stream: true });
      init?.onIncomingStream?.(stream);
    };
    if (this.init.streams.length > 0) {
      queueMicrotask(() => {
        this.init.streams.forEach((bufferedStream) => {
          bufferedStream.onEnd = () => {
            this.log("incoming early channel %s ended with state %s", bufferedStream.channel.id, bufferedStream.channel.readyState);
            this.#onStreamEnd(bufferedStream.stream, bufferedStream.channel);
          };
          this.metrics?.increment({ incoming_stream: true });
          this.init?.onIncomingStream?.(bufferedStream.stream);
        });
      });
    }
  }
  #onStreamEnd(stream, channel) {
    this.log.trace("stream %s %s %s onEnd", stream.direction, stream.id, stream.protocol);
    drainAndClose(channel, `${stream.direction} ${stream.id} ${stream.protocol}`, this.dataChannelOptions.drainTimeout, {
      log: this.log
    });
    this.streams = this.streams.filter((s) => s.id !== stream.id);
    this.metrics?.increment({ stream_end: true });
    this.init?.onStreamEnd?.(stream);
  }
  /**
   * Gracefully close all tracked streams and stop the muxer
   */
  async close(options2) {
    try {
      await Promise.all(this.streams.map(async (stream) => stream.close(options2)));
    } catch (err) {
      this.abort(err);
    }
  }
  /**
   * Abort all tracked streams and stop the muxer
   */
  abort(err) {
    for (const stream of this.streams) {
      stream.abort(err);
    }
  }
  /**
   * The stream source, a no-op as the transport natively supports multiplexing
   */
  source = nopSource();
  /**
   * The stream destination, a no-op as the transport natively supports multiplexing
   */
  sink = nopSink;
  newStream() {
    const channel = this.peerConnection.createDataChannel("");
    const id = channel.id;
    this.log.trace("opened outgoing datachannel with channel id %s", id);
    const stream = createStream2({
      channel,
      direction: "outbound",
      onEnd: () => {
        this.#onStreamEnd(stream, channel);
        this.log("outgoing channel %s ended", id);
      },
      logger: this.logger,
      ...this.dataChannelOptions
    });
    this.streams.push(stream);
    this.metrics?.increment({ outgoing_stream: true });
    return stream;
  }
};

// node_modules/@libp2p/webrtc/dist/src/webrtc/index.browser.js
var RTCPeerConnection2 = globalThis.RTCPeerConnection;
var RTCSessionDescription = globalThis.RTCSessionDescription;
var RTCIceCandidate = globalThis.RTCIceCandidate;

// node_modules/@libp2p/webrtc/dist/src/error.js
var WebRTCTransportError = class extends Error {
  constructor(msg) {
    super(`WebRTC transport error: ${msg}`);
    this.name = "WebRTCTransportError";
  }
};
var SDPHandshakeFailedError = class extends WebRTCTransportError {
  constructor(message2 = "SDP handshake failed") {
    super(message2);
    this.name = "SDPHandshakeFailedError";
  }
};
var InvalidFingerprintError = class extends WebRTCTransportError {
  constructor(fingerprint, source) {
    super(`Invalid fingerprint "${fingerprint}" within ${source}`);
    this.name = "WebRTC/InvalidFingerprintError";
  }
};
var UnimplementedError = class extends WebRTCTransportError {
  constructor(methodName) {
    super(`A method (${methodName}) was called though it has been intentionally left unimplemented.`);
    this.name = "WebRTC/UnimplementedError";
  }
};
var UnsupportedHashAlgorithmError = class extends WebRTCTransportError {
  constructor(algo) {
    super(`unsupported hash algorithm code: ${algo} please see the codes at https://github.com/multiformats/multicodec/blob/master/table.csv `);
    this.name = "WebRTC/UnsupportedHashAlgorithmError";
  }
};

// node_modules/@libp2p/webrtc/dist/src/private-to-private/pb/message.js
var Message4;
(function(Message5) {
  let Type;
  (function(Type2) {
    Type2["SDP_OFFER"] = "SDP_OFFER";
    Type2["SDP_ANSWER"] = "SDP_ANSWER";
    Type2["ICE_CANDIDATE"] = "ICE_CANDIDATE";
  })(Type = Message5.Type || (Message5.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["SDP_OFFER"] = 0] = "SDP_OFFER";
    __TypeValues2[__TypeValues2["SDP_ANSWER"] = 1] = "SDP_ANSWER";
    __TypeValues2[__TypeValues2["ICE_CANDIDATE"] = 2] = "ICE_CANDIDATE";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = Message5.Type || (Message5.Type = {}));
  let _codec;
  Message5.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          Message5.Type.codec().encode(obj.type, w);
        }
        if (obj.data != null) {
          w.uint32(18);
          w.string(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length16, opts = {}) => {
        const obj = {};
        const end = length16 == null ? reader.len : reader.pos + length16;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = Message5.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.data = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message5.encode = (obj) => {
    return encodeMessage(obj, Message5.codec());
  };
  Message5.decode = (buf, opts) => {
    return decodeMessage(buf, Message5.codec(), opts);
  };
})(Message4 || (Message4 = {}));

// node_modules/@libp2p/webrtc/dist/src/private-to-private/util.js
var readCandidatesUntilConnected = async (pc, stream, options2) => {
  try {
    const connectedPromise = pDefer();
    resolveOnConnected(pc, connectedPromise);
    while (true) {
      const message2 = await Promise.race([
        connectedPromise.promise,
        stream.read({
          signal: options2.signal
        }).catch(() => {
        })
      ]);
      if (message2 == null) {
        options2.signal?.throwIfAborted();
        break;
      }
      if (message2.type !== Message4.Type.ICE_CANDIDATE) {
        throw new InvalidMessageError("ICE candidate message expected");
      }
      const candidateInit = JSON.parse(message2.data ?? "null");
      if (candidateInit === "" || candidateInit === null) {
        options2.onProgress?.(new CustomProgressEvent("webrtc:end-of-ice-candidates"));
        options2.log.trace("end-of-candidates received");
        continue;
      }
      const candidate = new RTCIceCandidate(candidateInit);
      options2.log.trace("%s received new ICE candidate %o", options2.direction, candidateInit);
      try {
        options2.onProgress?.(new CustomProgressEvent("webrtc:add-ice-candidate", candidate.candidate));
        await pc.addIceCandidate(candidate);
      } catch (err) {
        options2.log.error("%s bad candidate received", options2.direction, candidateInit, err);
      }
    }
  } catch (err) {
    options2.log.error("%s error parsing ICE candidate", options2.direction, err);
    if (options2.signal?.aborted === true && getConnectionState(pc) !== "connected") {
      throw err;
    }
  }
};
function getConnectionState(pc) {
  return isFirefox ? pc.iceConnectionState : pc.connectionState;
}
function resolveOnConnected(pc, promise) {
  pc[isFirefox ? "oniceconnectionstatechange" : "onconnectionstatechange"] = (_) => {
    switch (getConnectionState(pc)) {
      case "connected":
        promise.resolve();
        break;
      case "failed":
      case "disconnected":
      case "closed":
        promise.reject(new ConnectionFailedError("RTCPeerConnection was closed"));
        break;
      default:
        break;
    }
  };
}

// node_modules/@libp2p/webrtc/dist/src/private-to-private/initiate-connection.js
async function initiateConnection({ rtcConfiguration, dataChannel, signal, metrics, multiaddr: ma, connectionManager, transportManager, log: log5, logger: logger2, onProgress }) {
  const { circuitAddress, targetPeer } = splitAddr(ma);
  metrics?.dialerEvents.increment({ open: true });
  log5.trace("dialing circuit address: %a", circuitAddress);
  const connections = connectionManager.getConnections(targetPeer);
  let connection;
  if (connections.length === 0) {
    onProgress?.(new CustomProgressEvent("webrtc:dial-relay"));
    connection = await transportManager.dial(circuitAddress, {
      signal,
      onProgress
    });
  } else {
    onProgress?.(new CustomProgressEvent("webrtc:reuse-relay-connection"));
    connection = connections[0];
  }
  onProgress?.(new CustomProgressEvent("webrtc:open-signaling-stream"));
  const stream = await connection.newStream(SIGNALING_PROTOCOL, {
    signal,
    runOnLimitedConnection: true
  });
  const messageStream = pbStream(stream).pb(Message4);
  const peerConnection = new RTCPeerConnection2(rtcConfiguration);
  const muxerFactory = new DataChannelMuxerFactory({
    logger: logger2
  }, {
    peerConnection,
    dataChannelOptions: dataChannel
  });
  try {
    const channel = peerConnection.createDataChannel("init");
    peerConnection.onicecandidate = ({ candidate }) => {
      const data = JSON.stringify(candidate?.toJSON() ?? null);
      log5.trace("initiator sending ICE candidate %o", candidate);
      void messageStream.write({
        type: Message4.Type.ICE_CANDIDATE,
        data
      }, {
        signal
      }).catch((err) => {
        log5.error("error sending ICE candidate", err);
      });
    };
    peerConnection.onicecandidateerror = (event) => {
      log5.error("initiator ICE candidate error", event);
    };
    const offerSdp = await peerConnection.createOffer().catch((err) => {
      log5.error("could not execute createOffer", err);
      throw new SDPHandshakeFailedError("Failed to set createOffer");
    });
    log5.trace("initiator send SDP offer %s", offerSdp.sdp);
    onProgress?.(new CustomProgressEvent("webrtc:send-sdp-offer"));
    await messageStream.write({ type: Message4.Type.SDP_OFFER, data: offerSdp.sdp }, {
      signal
    });
    await peerConnection.setLocalDescription(offerSdp).catch((err) => {
      log5.error("could not execute setLocalDescription", err);
      throw new SDPHandshakeFailedError("Failed to set localDescription");
    });
    onProgress?.(new CustomProgressEvent("webrtc:read-sdp-answer"));
    log5.trace("initiator read SDP answer");
    const answerMessage = await messageStream.read({
      signal
    });
    if (answerMessage.type !== Message4.Type.SDP_ANSWER) {
      throw new SDPHandshakeFailedError("Remote should send an SDP answer");
    }
    log5.trace("initiator received SDP answer %s", answerMessage.data);
    const answerSdp = new RTCSessionDescription({ type: "answer", sdp: answerMessage.data });
    await peerConnection.setRemoteDescription(answerSdp).catch((err) => {
      log5.error("could not execute setRemoteDescription", err);
      throw new SDPHandshakeFailedError("Failed to set remoteDescription");
    });
    log5.trace("initiator read candidates until connected");
    onProgress?.(new CustomProgressEvent("webrtc:read-ice-candidates"));
    await readCandidatesUntilConnected(peerConnection, messageStream, {
      direction: "initiator",
      signal,
      log: log5,
      onProgress
    });
    log5.trace("initiator connected, closing init channel");
    channel.close();
    onProgress?.(new CustomProgressEvent("webrtc:close-signaling-stream"));
    log5.trace("closing signaling channel");
    await stream.close({
      signal
    });
    log5.trace("initiator connected to remote address %s", ma);
    return {
      remoteAddress: ma,
      peerConnection,
      muxerFactory
    };
  } catch (err) {
    log5.error("outgoing signaling error", err);
    peerConnection.close();
    stream.abort(err);
    throw err;
  } finally {
    peerConnection.onicecandidate = null;
    peerConnection.onicecandidateerror = null;
  }
}

// node_modules/@libp2p/webrtc/dist/src/private-to-private/listener.js
var Circuit7 = fmt6(P2P7.matchers[0], code14(CODE_P2P_CIRCUIT));
var WebRTCPeerListener = class _WebRTCPeerListener extends TypedEventEmitter {
  transportManager;
  shutdownController;
  events;
  constructor(components, init) {
    super();
    this.transportManager = components.transportManager;
    this.events = components.events;
    this.shutdownController = init.shutdownController;
    this.onTransportListening = this.onTransportListening.bind(this);
  }
  async listen() {
    this.events.addEventListener("transport:listening", this.onTransportListening);
  }
  onTransportListening(event) {
    const circuitAddresses = event.detail.getAddrs().filter((ma) => Circuit7.exactMatch(ma)).map((ma) => {
      return ma.encapsulate("/webrtc");
    });
    if (circuitAddresses.length > 0) {
      this.safeDispatchEvent("listening");
    }
  }
  getAddrs() {
    return this.transportManager.getListeners().filter((l) => !(l instanceof _WebRTCPeerListener)).map((l) => l.getAddrs().filter((ma) => Circuit7.exactMatch(ma)).map((ma) => {
      return ma.encapsulate("/webrtc");
    })).flat();
  }
  updateAnnounceAddrs() {
  }
  async close() {
    this.events.removeEventListener("transport:listening", this.onTransportListening);
    this.shutdownController.abort();
    queueMicrotask(() => {
      this.safeDispatchEvent("close");
    });
  }
};

// node_modules/@libp2p/webrtc/dist/src/private-to-private/signaling-stream-handler.js
async function handleIncomingStream({ peerConnection, stream, signal, connection, log: log5 }) {
  log5.trace("new inbound signaling stream");
  const messageStream = pbStream(stream).pb(Message4);
  try {
    peerConnection.onicecandidate = ({ candidate }) => {
      const data = JSON.stringify(candidate?.toJSON() ?? null);
      log5.trace("recipient sending ICE candidate %s", data);
      messageStream.write({
        type: Message4.Type.ICE_CANDIDATE,
        data
      }, {
        signal
      }).catch((err) => {
        log5.error("error sending ICE candidate", err);
      });
    };
    log5.trace("recipient read SDP offer");
    const pbOffer = await messageStream.read({
      signal
    });
    if (pbOffer.type !== Message4.Type.SDP_OFFER) {
      throw new SDPHandshakeFailedError(`expected message type SDP_OFFER, received: ${pbOffer.type ?? "undefined"} `);
    }
    log5.trace("recipient received SDP offer %s", pbOffer.data);
    const offer = new RTCSessionDescription({
      type: "offer",
      sdp: pbOffer.data
    });
    await peerConnection.setRemoteDescription(offer).catch((err) => {
      log5.error("could not execute setRemoteDescription", err);
      throw new SDPHandshakeFailedError("Failed to set remoteDescription");
    });
    const answer = await peerConnection.createAnswer().catch((err) => {
      log5.error("could not execute createAnswer", err);
      throw new SDPHandshakeFailedError("Failed to create answer");
    });
    log5.trace("recipient send SDP answer %s", answer.sdp);
    await messageStream.write({ type: Message4.Type.SDP_ANSWER, data: answer.sdp }, {
      signal
    });
    await peerConnection.setLocalDescription(answer).catch((err) => {
      log5.error("could not execute setLocalDescription", err);
      throw new SDPHandshakeFailedError("Failed to set localDescription");
    });
    log5.trace("recipient read candidates until connected");
    await readCandidatesUntilConnected(peerConnection, messageStream, {
      direction: "recipient",
      signal,
      log: log5
    });
  } catch (err) {
    if (getConnectionState(peerConnection) !== "connected") {
      log5.error("error while handling signaling stream from peer %a", connection.remoteAddr, err);
      peerConnection.close();
      throw err;
    } else {
      log5("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected", connection.remoteAddr, err);
    }
  }
  const remoteAddress = multiaddr(`/webrtc/p2p/${connection.remoteAddr.getPeerId()}`);
  log5.trace("recipient connected to remote address %s", remoteAddress);
  return { remoteAddress };
}

// node_modules/@libp2p/webrtc/dist/src/private-to-private/transport.js
var WebRTCTransport = class {
  components;
  init;
  log;
  _started = false;
  metrics;
  shutdownController;
  constructor(components, init = {}) {
    this.components = components;
    this.init = init;
    this.log = components.logger.forComponent("libp2p:webrtc");
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total", {
          label: "event",
          help: "Total count of WebRTC dialer events by type"
        }),
        listenerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total", {
          label: "event",
          help: "Total count of WebRTC listener events by type"
        })
      };
    }
  }
  [transportSymbol] = true;
  [Symbol.toStringTag] = "@libp2p/webrtc";
  [serviceCapabilities] = [
    "@libp2p/transport"
  ];
  [serviceDependencies] = [
    "@libp2p/identify",
    "@libp2p/circuit-relay-v2-transport"
  ];
  isStarted() {
    return this._started;
  }
  async start() {
    await this.components.registrar.handle(SIGNALING_PROTOCOL, (data) => {
      const signal = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);
      this._onProtocol(data, signal).catch((err) => {
        this.log.error("failed to handle incoming connect from %p", data.connection.remotePeer, err);
      }).finally(() => {
        signal.clear();
      });
    }, {
      runOnLimitedConnection: true
    });
    this._started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(SIGNALING_PROTOCOL);
    this._started = false;
  }
  createListener(options2) {
    return new WebRTCPeerListener(this.components, {
      shutdownController: this.shutdownController
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    return multiaddrs.filter(WebRTC6.exactMatch);
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
  /*
   * dial connects to a remote via the circuit relay or any other protocol
   * and proceeds to upgrade to a webrtc connection.
   * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>
   * For a circuit relay, this will be of the form
   * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>
  */
  async dial(ma, options2) {
    this.log.trace("dialing address: %a", ma);
    const { remoteAddress, peerConnection, muxerFactory } = await initiateConnection({
      rtcConfiguration: await getRtcConfiguration(this.init.rtcConfiguration),
      dataChannel: this.init.dataChannel,
      multiaddr: ma,
      dataChannelOptions: this.init.dataChannel,
      signal: options2.signal,
      connectionManager: this.components.connectionManager,
      transportManager: this.components.transportManager,
      log: this.log,
      logger: this.components.logger,
      onProgress: options2.onProgress
    });
    const webRTCConn = new WebRTCMultiaddrConnection(this.components, {
      peerConnection,
      timeline: { open: Date.now() },
      remoteAddr: remoteAddress,
      metrics: this.metrics?.dialerEvents
    });
    const connection = await options2.upgrader.upgradeOutbound(webRTCConn, {
      skipProtection: true,
      skipEncryption: true,
      muxerFactory,
      onProgress: options2.onProgress,
      signal: options2.signal
    });
    this._closeOnShutdown(peerConnection, webRTCConn);
    return connection;
  }
  async _onProtocol({ connection, stream }, signal) {
    const peerConnection = new RTCPeerConnection2(await getRtcConfiguration(this.init.rtcConfiguration));
    const muxerFactory = new DataChannelMuxerFactory(this.components, {
      peerConnection,
      dataChannelOptions: this.init.dataChannel
    });
    try {
      const { remoteAddress } = await handleIncomingStream({
        peerConnection,
        connection,
        stream,
        signal,
        log: this.log
      });
      await stream.close({
        signal
      });
      const webRTCConn = new WebRTCMultiaddrConnection(this.components, {
        peerConnection,
        timeline: { open: (/* @__PURE__ */ new Date()).getTime() },
        remoteAddr: remoteAddress,
        metrics: this.metrics?.listenerEvents
      });
      await this.components.upgrader.upgradeInbound(webRTCConn, {
        skipEncryption: true,
        skipProtection: true,
        muxerFactory,
        signal
      });
      this._closeOnShutdown(peerConnection, webRTCConn);
    } catch (err) {
      this.log.error("incoming signaling error", err);
      peerConnection.close();
      stream.abort(err);
      throw err;
    }
  }
  _closeOnShutdown(pc, webRTCConn) {
    const shutDownListener = () => {
      webRTCConn.close().catch((err) => {
        this.log.error("could not close WebRTCMultiaddrConnection", err);
      });
    };
    this.shutdownController.signal.addEventListener("abort", shutDownListener);
    pc.addEventListener("close", () => {
      this.shutdownController.signal.removeEventListener("abort", shutDownListener);
    });
  }
};
function splitAddr(ma) {
  const target = ma.getComponents().filter(({ name: name9 }) => name9 === "p2p").map(({ value: value7 }) => value7).pop();
  if (target == null) {
    throw new InvalidParametersError("Destination peer id was missing");
  }
  const circuitAddress = multiaddr(ma.getComponents().filter(({ name: name9 }) => name9 !== "webrtc"));
  return { circuitAddress, targetPeer: peerIdFromString(target) };
}

// node_modules/reflect-metadata/Reflect.js
var Reflect2;
(function(Reflect3) {
  (function(factory) {
    var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
    var exporter2 = makeExporter(Reflect3);
    if (typeof root.Reflect !== "undefined") {
      exporter2 = makeExporter(root.Reflect, exporter2);
    }
    factory(exporter2, root);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect3;
    }
    function makeExporter(target, previous) {
      return function(key, value7) {
        Object.defineProperty(target, key, { configurable: true, writable: true, value: value7 });
        if (previous)
          previous(key, value7);
      };
    }
    function functionThis() {
      try {
        return Function("return this;")();
      } catch (_) {
      }
    }
    function indirectEvalThis() {
      try {
        return (void 0, eval)("(function() { return this; })()");
      } catch (_) {
      }
    }
    function sloppyModeThis() {
      return functionThis() || indirectEvalThis();
    }
  })(function(exporter2, root) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map2, key) {
        return hasOwn.call(map2, key);
      } : function(map2, key) {
        return key in map2;
      },
      get: downLevel ? function(map2, key) {
        return hasOwn.call(map2, key) ? map2[key] : void 0;
      } : function(map2, key) {
        return map2[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
    var metadataRegistry = GetOrCreateMetadataRegistry();
    var metadataProvider = CreateMetadataProvider(metadataRegistry);
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter2("decorate", decorate);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter2("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter2("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter2("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter2("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter2("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter2("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter2("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter2("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var provider = GetMetadataProvider(
        target,
        propertyKey,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
    }
    exporter2("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn2)
        return true;
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      var provider = GetMetadataProvider(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn2)
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      var provider = GetMetadataProvider(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return;
      return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      var provider = GetMetadataProvider(
        O,
        P,
        /*Create*/
        true
      );
      provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
    }
    function OrdinaryMetadataKeys(O, P) {
      var ownKeys = OrdinaryOwnMetadataKeys(O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (parent === null)
        return ownKeys;
      var parentKeys = OrdinaryMetadataKeys(parent, P);
      if (parentKeys.length <= 0)
        return ownKeys;
      if (ownKeys.length <= 0)
        return parentKeys;
      var set = new _Set();
      var keys = [];
      for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a3 = 0, parentKeys_1 = parentKeys; _a3 < parentKeys_1.length; _a3++) {
        var key = parentKeys_1[_a3];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O, P) {
      var provider = GetMetadataProvider(
        O,
        P,
        /*create*/
        false
      );
      if (!provider) {
        return [];
      }
      return provider.OrdinaryOwnMetadataKeys(O, P);
    }
    function Type(x) {
      if (x === null)
        return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return x === void 0;
    }
    function IsNull(x) {
      return x === null;
    }
    function IsSymbol(x) {
      return typeof x === "symbol";
    }
    function IsObject(x) {
      return typeof x === "object" ? x !== null : typeof x === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if (hint === "string") {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(
        argument,
        3
        /* String */
      );
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function SameValueZero(x, y) {
      return x === y || x !== x && y !== y;
    }
    function GetMethod(V, P) {
      var func2 = V[P];
      if (func2 === void 0 || func2 === null)
        return void 0;
      if (!IsCallable(func2))
        throw new TypeError();
      return func2;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator = method.call(obj);
      if (!IsObject(iterator))
        throw new TypeError();
      return iterator;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator) {
      var f = iterator["return"];
      if (f)
        f.call(iterator);
    }
    function OrdinaryGetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype = O.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O)
        return proto;
      return constructor;
    }
    function CreateMetadataRegistry() {
      var fallback;
      if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
        fallback = CreateFallbackProvider(root.Reflect);
      }
      var first;
      var second3;
      var rest;
      var targetProviderMap = new _WeakMap();
      var registry = {
        registerProvider,
        getProvider,
        setProvider
      };
      return registry;
      function registerProvider(provider) {
        if (!Object.isExtensible(registry)) {
          throw new Error("Cannot add provider to a frozen registry.");
        }
        switch (true) {
          case fallback === provider:
            break;
          case IsUndefined(first):
            first = provider;
            break;
          case first === provider:
            break;
          case IsUndefined(second3):
            second3 = provider;
            break;
          case second3 === provider:
            break;
          default:
            if (rest === void 0)
              rest = new _Set();
            rest.add(provider);
            break;
        }
      }
      function getProviderNoCache(O, P) {
        if (!IsUndefined(first)) {
          if (first.isProviderFor(O, P))
            return first;
          if (!IsUndefined(second3)) {
            if (second3.isProviderFor(O, P))
              return first;
            if (!IsUndefined(rest)) {
              var iterator = GetIterator(rest);
              while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                  return void 0;
                }
                var provider = IteratorValue(next);
                if (provider.isProviderFor(O, P)) {
                  IteratorClose(iterator);
                  return provider;
                }
              }
            }
          }
        }
        if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
          return fallback;
        }
        return void 0;
      }
      function getProvider(O, P) {
        var providerMap = targetProviderMap.get(O);
        var provider;
        if (!IsUndefined(providerMap)) {
          provider = providerMap.get(P);
        }
        if (!IsUndefined(provider)) {
          return provider;
        }
        provider = getProviderNoCache(O, P);
        if (!IsUndefined(provider)) {
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O, providerMap);
          }
          providerMap.set(P, provider);
        }
        return provider;
      }
      function hasProvider(provider) {
        if (IsUndefined(provider))
          throw new TypeError();
        return first === provider || second3 === provider || !IsUndefined(rest) && rest.has(provider);
      }
      function setProvider(O, P, provider) {
        if (!hasProvider(provider)) {
          throw new Error("Metadata provider not registered.");
        }
        var existingProvider = getProvider(O, P);
        if (existingProvider !== provider) {
          if (!IsUndefined(existingProvider)) {
            return false;
          }
          var providerMap = targetProviderMap.get(O);
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O, providerMap);
          }
          providerMap.set(P, provider);
        }
        return true;
      }
    }
    function GetOrCreateMetadataRegistry() {
      var metadataRegistry2;
      if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
        metadataRegistry2 = root.Reflect[registrySymbol];
      }
      if (IsUndefined(metadataRegistry2)) {
        metadataRegistry2 = CreateMetadataRegistry();
      }
      if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
        Object.defineProperty(root.Reflect, registrySymbol, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: metadataRegistry2
        });
      }
      return metadataRegistry2;
    }
    function CreateMetadataProvider(registry) {
      var metadata2 = new _WeakMap();
      var provider = {
        isProviderFor: function(O, P) {
          var targetMetadata = metadata2.get(O);
          if (IsUndefined(targetMetadata))
            return false;
          return targetMetadata.has(P);
        },
        OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
        OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
        OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
        OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
        OrdinaryDeleteMetadata
      };
      metadataRegistry.registerProvider(provider);
      return provider;
      function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = metadata2.get(O);
        var createdTargetMetadata = false;
        if (IsUndefined(targetMetadata)) {
          if (!Create)
            return void 0;
          targetMetadata = new _Map();
          metadata2.set(O, targetMetadata);
          createdTargetMetadata = true;
        }
        var metadataMap = targetMetadata.get(P);
        if (IsUndefined(metadataMap)) {
          if (!Create)
            return void 0;
          metadataMap = new _Map();
          targetMetadata.set(P, metadataMap);
          if (!registry.setProvider(O, P, provider)) {
            targetMetadata.delete(P);
            if (createdTargetMetadata) {
              metadata2.delete(O);
            }
            throw new Error("Wrong provider for target.");
          }
        }
        return metadataMap;
      }
      function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        return ToBoolean(metadataMap.has(MetadataKey));
      }
      function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return void 0;
        return metadataMap.get(MetadataKey);
      }
      function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          true
        );
        metadataMap.set(MetadataKey, MetadataValue);
      }
      function OrdinaryOwnMetadataKeys2(O, P) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k = 0;
        while (true) {
          var next = IteratorStep(iterator);
          if (!next) {
            keys.length = k;
            return keys;
          }
          var nextValue = IteratorValue(next);
          try {
            keys[k] = nextValue;
          } catch (e) {
            try {
              IteratorClose(iterator);
            } finally {
              throw e;
            }
          }
          k++;
        }
      }
      function OrdinaryDeleteMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        if (!metadataMap.delete(MetadataKey))
          return false;
        if (metadataMap.size === 0) {
          var targetMetadata = metadata2.get(O);
          if (!IsUndefined(targetMetadata)) {
            targetMetadata.delete(P);
            if (targetMetadata.size === 0) {
              metadata2.delete(targetMetadata);
            }
          }
        }
        return true;
      }
    }
    function CreateFallbackProvider(reflect) {
      var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
      var metadataOwner = new _WeakMap();
      var provider = {
        isProviderFor: function(O, P) {
          var metadataPropertySet = metadataOwner.get(O);
          if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
            return true;
          }
          if (getOwnMetadataKeys2(O, P).length) {
            if (IsUndefined(metadataPropertySet)) {
              metadataPropertySet = new _Set();
              metadataOwner.set(O, metadataPropertySet);
            }
            metadataPropertySet.add(P);
            return true;
          }
          return false;
        },
        OrdinaryDefineOwnMetadata: defineMetadata2,
        OrdinaryHasOwnMetadata: hasOwnMetadata2,
        OrdinaryGetOwnMetadata: getOwnMetadata2,
        OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
        OrdinaryDeleteMetadata: deleteMetadata2
      };
      return provider;
    }
    function GetMetadataProvider(O, P, Create) {
      var registeredProvider = metadataRegistry.getProvider(O, P);
      if (!IsUndefined(registeredProvider)) {
        return registeredProvider;
      }
      if (Create) {
        if (metadataRegistry.setProvider(O, P, metadataProvider)) {
          return metadataProvider;
        }
        throw new Error("Illegal state.");
      }
      return void 0;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = (
        /** @class */
        function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: void 0, done: true };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value7) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value: value7, done: true };
          };
          return MapIterator2;
        }()
      );
      var Map2 = (
        /** @class */
        function() {
          function Map3() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map3.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map3.prototype.has = function(key) {
            return this._find(
              key,
              /*insert*/
              false
            ) >= 0;
          };
          Map3.prototype.get = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            return index >= 0 ? this._values[index] : void 0;
          };
          Map3.prototype.set = function(key, value7) {
            var index = this._find(
              key,
              /*insert*/
              true
            );
            this._values[index] = value7;
            return this;
          };
          Map3.prototype.delete = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            if (index >= 0) {
              var size = this._keys.length;
              for (var i = index + 1; i < size; i++) {
                this._keys[i - 1] = this._keys[i];
                this._values[i - 1] = this._values[i];
              }
              this._keys.length--;
              this._values.length--;
              if (SameValueZero(key, this._cacheKey)) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map3.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map3.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map3.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map3.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map3.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map3.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map3.prototype._find = function(key, insert) {
            if (!SameValueZero(this._cacheKey, key)) {
              this._cacheIndex = -1;
              for (var i = 0; i < this._keys.length; i++) {
                if (SameValueZero(this._keys[i], key)) {
                  this._cacheIndex = i;
                  break;
                }
              }
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(void 0);
            }
            return this._cacheIndex;
          };
          return Map3;
        }()
      );
      return Map2;
      function getKey(key, _) {
        return key;
      }
      function getValue(_, value7) {
        return value7;
      }
      function getEntry(key, value7) {
        return [key, value7];
      }
    }
    function CreateSetPolyfill() {
      var Set3 = (
        /** @class */
        function() {
          function Set4() {
            this._map = new _Map();
          }
          Object.defineProperty(Set4.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set4.prototype.has = function(value7) {
            return this._map.has(value7);
          };
          Set4.prototype.add = function(value7) {
            return this._map.set(value7, value7), this;
          };
          Set4.prototype.delete = function(value7) {
            return this._map.delete(value7);
          };
          Set4.prototype.clear = function() {
            this._map.clear();
          };
          Set4.prototype.keys = function() {
            return this._map.keys();
          };
          Set4.prototype.values = function() {
            return this._map.keys();
          };
          Set4.prototype.entries = function() {
            return this._map.entries();
          };
          Set4.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set4.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set4;
        }()
      );
      return Set3;
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return (
        /** @class */
        function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.get(table, this._key) : void 0;
          };
          WeakMap2.prototype.set = function(target, value7) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            );
            table[this._key] = value7;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }()
      );
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create15) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create15)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer, size) {
        for (var i = 0; i < size; ++i)
          buffer[i] = Math.random() * 255 | 0;
        return buffer;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          var array = new Uint8Array(size);
          if (typeof crypto !== "undefined") {
            crypto.getRandomValues(array);
          } else if (typeof msCrypto !== "undefined") {
            msCrypto.getRandomValues(array);
          } else {
            FillRandomBytes(array, size);
          }
          return array;
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect2 || (Reflect2 = {}));

// node_modules/@peculiar/asn1-schema/build/es2015/enums.js
var AsnTypeTypes;
(function(AsnTypeTypes2) {
  AsnTypeTypes2[AsnTypeTypes2["Sequence"] = 0] = "Sequence";
  AsnTypeTypes2[AsnTypeTypes2["Set"] = 1] = "Set";
  AsnTypeTypes2[AsnTypeTypes2["Choice"] = 2] = "Choice";
})(AsnTypeTypes || (AsnTypeTypes = {}));
var AsnPropTypes;
(function(AsnPropTypes2) {
  AsnPropTypes2[AsnPropTypes2["Any"] = 1] = "Any";
  AsnPropTypes2[AsnPropTypes2["Boolean"] = 2] = "Boolean";
  AsnPropTypes2[AsnPropTypes2["OctetString"] = 3] = "OctetString";
  AsnPropTypes2[AsnPropTypes2["BitString"] = 4] = "BitString";
  AsnPropTypes2[AsnPropTypes2["Integer"] = 5] = "Integer";
  AsnPropTypes2[AsnPropTypes2["Enumerated"] = 6] = "Enumerated";
  AsnPropTypes2[AsnPropTypes2["ObjectIdentifier"] = 7] = "ObjectIdentifier";
  AsnPropTypes2[AsnPropTypes2["Utf8String"] = 8] = "Utf8String";
  AsnPropTypes2[AsnPropTypes2["BmpString"] = 9] = "BmpString";
  AsnPropTypes2[AsnPropTypes2["UniversalString"] = 10] = "UniversalString";
  AsnPropTypes2[AsnPropTypes2["NumericString"] = 11] = "NumericString";
  AsnPropTypes2[AsnPropTypes2["PrintableString"] = 12] = "PrintableString";
  AsnPropTypes2[AsnPropTypes2["TeletexString"] = 13] = "TeletexString";
  AsnPropTypes2[AsnPropTypes2["VideotexString"] = 14] = "VideotexString";
  AsnPropTypes2[AsnPropTypes2["IA5String"] = 15] = "IA5String";
  AsnPropTypes2[AsnPropTypes2["GraphicString"] = 16] = "GraphicString";
  AsnPropTypes2[AsnPropTypes2["VisibleString"] = 17] = "VisibleString";
  AsnPropTypes2[AsnPropTypes2["GeneralString"] = 18] = "GeneralString";
  AsnPropTypes2[AsnPropTypes2["CharacterString"] = 19] = "CharacterString";
  AsnPropTypes2[AsnPropTypes2["UTCTime"] = 20] = "UTCTime";
  AsnPropTypes2[AsnPropTypes2["GeneralizedTime"] = 21] = "GeneralizedTime";
  AsnPropTypes2[AsnPropTypes2["DATE"] = 22] = "DATE";
  AsnPropTypes2[AsnPropTypes2["TimeOfDay"] = 23] = "TimeOfDay";
  AsnPropTypes2[AsnPropTypes2["DateTime"] = 24] = "DateTime";
  AsnPropTypes2[AsnPropTypes2["Duration"] = 25] = "Duration";
  AsnPropTypes2[AsnPropTypes2["TIME"] = 26] = "TIME";
  AsnPropTypes2[AsnPropTypes2["Null"] = 27] = "Null";
})(AsnPropTypes || (AsnPropTypes = {}));

// node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
var BitString2 = class {
  constructor(params, unusedBits = 0) {
    this.unusedBits = 0;
    this.value = new ArrayBuffer(0);
    if (params) {
      if (typeof params === "number") {
        this.fromNumber(params);
      } else if (BufferSourceConverter.isBufferSource(params)) {
        this.unusedBits = unusedBits;
        this.value = BufferSourceConverter.toArrayBuffer(params);
      } else {
        throw TypeError("Unsupported type of 'params' argument for BitString");
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof BitString)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
    }
    this.unusedBits = asn.valueBlock.unusedBits;
    this.value = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new BitString({ unusedBits: this.unusedBits, valueHex: this.value });
  }
  toSchema(name9) {
    return new BitString({ name: name9 });
  }
  toNumber() {
    let res = "";
    const uintArray = new Uint8Array(this.value);
    for (const octet of uintArray) {
      res += octet.toString(2).padStart(8, "0");
    }
    res = res.split("").reverse().join("");
    if (this.unusedBits) {
      res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
    }
    return parseInt(res, 2);
  }
  fromNumber(value7) {
    let bits = value7.toString(2);
    const octetSize = bits.length + 7 >> 3;
    this.unusedBits = (octetSize << 3) - bits.length;
    const octets = new Uint8Array(octetSize);
    bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
    let index = 0;
    while (index < octetSize) {
      octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
      index++;
    }
    this.value = octets.buffer;
  }
};

// node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
var OctetString2 = class {
  get byteLength() {
    return this.buffer.byteLength;
  }
  get byteOffset() {
    return 0;
  }
  constructor(param) {
    if (typeof param === "number") {
      this.buffer = new ArrayBuffer(param);
    } else {
      if (BufferSourceConverter.isBufferSource(param)) {
        this.buffer = BufferSourceConverter.toArrayBuffer(param);
      } else if (Array.isArray(param)) {
        this.buffer = new Uint8Array(param);
      } else {
        this.buffer = new ArrayBuffer(0);
      }
    }
  }
  fromASN(asn) {
    if (!(asn instanceof OctetString)) {
      throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
    }
    this.buffer = asn.valueBlock.valueHex;
    return this;
  }
  toASN() {
    return new OctetString({ valueHex: this.buffer });
  }
  toSchema(name9) {
    return new OctetString({ name: name9 });
  }
};

// node_modules/@peculiar/asn1-schema/build/es2015/converters.js
var AsnAnyConverter = {
  fromASN: (value7) => value7 instanceof Null ? null : value7.valueBeforeDecodeView,
  toASN: (value7) => {
    if (value7 === null) {
      return new Null();
    }
    const schema = fromBER(value7);
    if (schema.result.error) {
      throw new Error(schema.result.error);
    }
    return schema.result;
  }
};
var AsnIntegerConverter = {
  fromASN: (value7) => value7.valueBlock.valueHexView.byteLength >= 4 ? value7.valueBlock.toString() : value7.valueBlock.valueDec,
  toASN: (value7) => new Integer({ value: +value7 })
};
var AsnEnumeratedConverter = {
  fromASN: (value7) => value7.valueBlock.valueDec,
  toASN: (value7) => new Enumerated({ value: value7 })
};
var AsnIntegerArrayBufferConverter = {
  fromASN: (value7) => value7.valueBlock.valueHexView,
  toASN: (value7) => new Integer({ valueHex: value7 })
};
var AsnBitStringConverter = {
  fromASN: (value7) => value7.valueBlock.valueHexView,
  toASN: (value7) => new BitString({ valueHex: value7 })
};
var AsnObjectIdentifierConverter = {
  fromASN: (value7) => value7.valueBlock.toString(),
  toASN: (value7) => new ObjectIdentifier({ value: value7 })
};
var AsnBooleanConverter = {
  fromASN: (value7) => value7.valueBlock.value,
  toASN: (value7) => new Boolean2({ value: value7 })
};
var AsnOctetStringConverter = {
  fromASN: (value7) => value7.valueBlock.valueHexView,
  toASN: (value7) => new OctetString({ valueHex: value7 })
};
var AsnConstructedOctetStringConverter = {
  fromASN: (value7) => new OctetString2(value7.getValue()),
  toASN: (value7) => value7.toASN()
};
function createStringConverter(Asn1Type) {
  return {
    fromASN: (value7) => value7.valueBlock.value,
    toASN: (value7) => new Asn1Type({ value: value7 })
  };
}
var AsnUtf8StringConverter = createStringConverter(Utf8String);
var AsnBmpStringConverter = createStringConverter(BmpString);
var AsnUniversalStringConverter = createStringConverter(UniversalString);
var AsnNumericStringConverter = createStringConverter(NumericString);
var AsnPrintableStringConverter = createStringConverter(PrintableString);
var AsnTeletexStringConverter = createStringConverter(TeletexString);
var AsnVideotexStringConverter = createStringConverter(VideotexString);
var AsnIA5StringConverter = createStringConverter(IA5String);
var AsnGraphicStringConverter = createStringConverter(GraphicString);
var AsnVisibleStringConverter = createStringConverter(VisibleString);
var AsnGeneralStringConverter = createStringConverter(GeneralString);
var AsnCharacterStringConverter = createStringConverter(CharacterString);
var AsnUTCTimeConverter = {
  fromASN: (value7) => value7.toDate(),
  toASN: (value7) => new UTCTime({ valueDate: value7 })
};
var AsnGeneralizedTimeConverter = {
  fromASN: (value7) => value7.toDate(),
  toASN: (value7) => new GeneralizedTime({ valueDate: value7 })
};
var AsnNullConverter = {
  fromASN: () => null,
  toASN: () => {
    return new Null();
  }
};
function defaultConverter(type) {
  switch (type) {
    case AsnPropTypes.Any:
      return AsnAnyConverter;
    case AsnPropTypes.BitString:
      return AsnBitStringConverter;
    case AsnPropTypes.BmpString:
      return AsnBmpStringConverter;
    case AsnPropTypes.Boolean:
      return AsnBooleanConverter;
    case AsnPropTypes.CharacterString:
      return AsnCharacterStringConverter;
    case AsnPropTypes.Enumerated:
      return AsnEnumeratedConverter;
    case AsnPropTypes.GeneralString:
      return AsnGeneralStringConverter;
    case AsnPropTypes.GeneralizedTime:
      return AsnGeneralizedTimeConverter;
    case AsnPropTypes.GraphicString:
      return AsnGraphicStringConverter;
    case AsnPropTypes.IA5String:
      return AsnIA5StringConverter;
    case AsnPropTypes.Integer:
      return AsnIntegerConverter;
    case AsnPropTypes.Null:
      return AsnNullConverter;
    case AsnPropTypes.NumericString:
      return AsnNumericStringConverter;
    case AsnPropTypes.ObjectIdentifier:
      return AsnObjectIdentifierConverter;
    case AsnPropTypes.OctetString:
      return AsnOctetStringConverter;
    case AsnPropTypes.PrintableString:
      return AsnPrintableStringConverter;
    case AsnPropTypes.TeletexString:
      return AsnTeletexStringConverter;
    case AsnPropTypes.UTCTime:
      return AsnUTCTimeConverter;
    case AsnPropTypes.UniversalString:
      return AsnUniversalStringConverter;
    case AsnPropTypes.Utf8String:
      return AsnUtf8StringConverter;
    case AsnPropTypes.VideotexString:
      return AsnVideotexStringConverter;
    case AsnPropTypes.VisibleString:
      return AsnVisibleStringConverter;
    default:
      return null;
  }
}

// node_modules/@peculiar/asn1-schema/build/es2015/helper.js
function isConvertible(target) {
  if (typeof target === "function" && target.prototype) {
    if (target.prototype.toASN && target.prototype.fromASN) {
      return true;
    } else {
      return isConvertible(target.prototype);
    }
  } else {
    return !!(target && typeof target === "object" && "toASN" in target && "fromASN" in target);
  }
}
function isTypeOfArray(target) {
  var _a3;
  if (target) {
    const proto = Object.getPrototypeOf(target);
    if (((_a3 = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a3 === void 0 ? void 0 : _a3.constructor) === Array) {
      return true;
    }
    return isTypeOfArray(proto);
  }
  return false;
}
function isArrayEqual(bytes1, bytes2) {
  if (!(bytes1 && bytes2)) {
    return false;
  }
  if (bytes1.byteLength !== bytes2.byteLength) {
    return false;
  }
  const b1 = new Uint8Array(bytes1);
  const b2 = new Uint8Array(bytes2);
  for (let i = 0; i < bytes1.byteLength; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@peculiar/asn1-schema/build/es2015/schema.js
var AsnSchemaStorage = class {
  constructor() {
    this.items = /* @__PURE__ */ new WeakMap();
  }
  has(target) {
    return this.items.has(target);
  }
  get(target, checkSchema = false) {
    const schema = this.items.get(target);
    if (!schema) {
      throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);
    }
    if (checkSchema && !schema.schema) {
      throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
    }
    return schema;
  }
  cache(target) {
    const schema = this.get(target);
    if (!schema.schema) {
      schema.schema = this.create(target, true);
    }
  }
  createDefault(target) {
    const schema = {
      type: AsnTypeTypes.Sequence,
      items: {}
    };
    const parentSchema = this.findParentSchema(target);
    if (parentSchema) {
      Object.assign(schema, parentSchema);
      schema.items = Object.assign({}, schema.items, parentSchema.items);
    }
    return schema;
  }
  create(target, useNames) {
    const schema = this.items.get(target) || this.createDefault(target);
    const asn1Value = [];
    for (const key in schema.items) {
      const item = schema.items[key];
      const name9 = useNames ? key : "";
      let asn1Item;
      if (typeof item.type === "number") {
        const Asn1TypeName = AsnPropTypes[item.type];
        const Asn1Type = index_es_exports[Asn1TypeName];
        if (!Asn1Type) {
          throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
        }
        asn1Item = new Asn1Type({ name: name9 });
      } else if (isConvertible(item.type)) {
        const instance2 = new item.type();
        asn1Item = instance2.toSchema(name9);
      } else if (item.optional) {
        const itemSchema = this.get(item.type);
        if (itemSchema.type === AsnTypeTypes.Choice) {
          asn1Item = new Any({ name: name9 });
        } else {
          asn1Item = this.create(item.type, false);
          asn1Item.name = name9;
        }
      } else {
        asn1Item = new Any({ name: name9 });
      }
      const optional8 = !!item.optional || item.defaultValue !== void 0;
      if (item.repeated) {
        asn1Item.name = "";
        const Container = item.repeated === "set" ? Set2 : Sequence;
        asn1Item = new Container({
          name: "",
          value: [
            new Repeated({
              name: name9,
              value: asn1Item
            })
          ]
        });
      }
      if (item.context !== null && item.context !== void 0) {
        if (item.implicit) {
          if (typeof item.type === "number" || isConvertible(item.type)) {
            const Container = item.repeated ? Constructed : Primitive;
            asn1Value.push(new Container({
              name: name9,
              optional: optional8,
              idBlock: {
                tagClass: 3,
                tagNumber: item.context
              }
            }));
          } else {
            this.cache(item.type);
            const isRepeated = !!item.repeated;
            let value7 = !isRepeated ? this.get(item.type, true).schema : asn1Item;
            value7 = "valueBlock" in value7 ? value7.valueBlock.value : value7.value;
            asn1Value.push(new Constructed({
              name: !isRepeated ? name9 : "",
              optional: optional8,
              idBlock: {
                tagClass: 3,
                tagNumber: item.context
              },
              value: value7
            }));
          }
        } else {
          asn1Value.push(new Constructed({
            optional: optional8,
            idBlock: {
              tagClass: 3,
              tagNumber: item.context
            },
            value: [asn1Item]
          }));
        }
      } else {
        asn1Item.optional = optional8;
        asn1Value.push(asn1Item);
      }
    }
    switch (schema.type) {
      case AsnTypeTypes.Sequence:
        return new Sequence({ value: asn1Value, name: "" });
      case AsnTypeTypes.Set:
        return new Set2({ value: asn1Value, name: "" });
      case AsnTypeTypes.Choice:
        return new Choice({ value: asn1Value, name: "" });
      default:
        throw new Error(`Unsupported ASN1 type in use`);
    }
  }
  set(target, schema) {
    this.items.set(target, schema);
    return this;
  }
  findParentSchema(target) {
    const parent = Object.getPrototypeOf(target);
    if (parent) {
      const schema = this.items.get(parent);
      return schema || this.findParentSchema(parent);
    }
    return null;
  }
};

// node_modules/@peculiar/asn1-schema/build/es2015/storage.js
var schemaStorage = new AsnSchemaStorage();

// node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
var AsnType = (options2) => (target) => {
  let schema;
  if (!schemaStorage.has(target)) {
    schema = schemaStorage.createDefault(target);
    schemaStorage.set(target, schema);
  } else {
    schema = schemaStorage.get(target);
  }
  Object.assign(schema, options2);
};
var AsnProp = (options2) => (target, propertyKey) => {
  let schema;
  if (!schemaStorage.has(target.constructor)) {
    schema = schemaStorage.createDefault(target.constructor);
    schemaStorage.set(target.constructor, schema);
  } else {
    schema = schemaStorage.get(target.constructor);
  }
  const copyOptions = Object.assign({}, options2);
  if (typeof copyOptions.type === "number" && !copyOptions.converter) {
    const defaultConverter2 = defaultConverter(options2.type);
    if (!defaultConverter2) {
      throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);
    }
    copyOptions.converter = defaultConverter2;
  }
  schema.items[propertyKey] = copyOptions;
};

// node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js
var AsnSchemaValidationError = class extends Error {
  constructor() {
    super(...arguments);
    this.schemas = [];
  }
};

// node_modules/@peculiar/asn1-schema/build/es2015/parser.js
var AsnParser = class {
  static parse(data, target) {
    const asn1Parsed = fromBER(data);
    if (asn1Parsed.result.error) {
      throw new Error(asn1Parsed.result.error);
    }
    const res = this.fromASN(asn1Parsed.result, target);
    return res;
  }
  static fromASN(asn1Schema, target) {
    var _a3;
    try {
      if (isConvertible(target)) {
        const value7 = new target();
        return value7.fromASN(asn1Schema);
      }
      const schema = schemaStorage.get(target);
      schemaStorage.cache(target);
      let targetSchema = schema.schema;
      if (asn1Schema.constructor === Constructed && schema.type !== AsnTypeTypes.Choice) {
        targetSchema = new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: asn1Schema.idBlock.tagNumber
          },
          value: schema.schema.valueBlock.value
        });
        for (const key in schema.items) {
          delete asn1Schema[key];
        }
      }
      const asn1ComparedSchema = compareSchema({}, asn1Schema, targetSchema);
      if (!asn1ComparedSchema.verified) {
        throw new AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);
      }
      const res = new target();
      if (isTypeOfArray(target)) {
        if (!("value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {
          throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);
        }
        const itemType = schema.itemType;
        if (typeof itemType === "number") {
          const converter = defaultConverter(itemType);
          if (!converter) {
            throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
          }
          return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));
        } else {
          return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));
        }
      }
      for (const key in schema.items) {
        const asn1SchemaValue = asn1ComparedSchema.result[key];
        if (!asn1SchemaValue) {
          continue;
        }
        const schemaItem = schema.items[key];
        const schemaItemType = schemaItem.type;
        if (typeof schemaItemType === "number" || isConvertible(schemaItemType)) {
          const converter = (_a3 = schemaItem.converter) !== null && _a3 !== void 0 ? _a3 : isConvertible(schemaItemType) ? new schemaItemType() : null;
          if (!converter) {
            throw new Error("Converter is empty");
          }
          if (schemaItem.repeated) {
            if (schemaItem.implicit) {
              const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
              const newItem = new Container();
              newItem.valueBlock = asn1SchemaValue.valueBlock;
              const newItemAsn = fromBER(newItem.toBER(false));
              if (newItemAsn.offset === -1) {
                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);
              }
              if (!("value" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {
                throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");
              }
              const value7 = newItemAsn.result.valueBlock.value;
              res[key] = Array.from(value7, (element) => converter.fromASN(element));
            } else {
              res[key] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));
            }
          } else {
            let value7 = asn1SchemaValue;
            if (schemaItem.implicit) {
              let newItem;
              if (isConvertible(schemaItemType)) {
                newItem = new schemaItemType().toSchema("");
              } else {
                const Asn1TypeName = AsnPropTypes[schemaItemType];
                const Asn1Type = index_es_exports[Asn1TypeName];
                if (!Asn1Type) {
                  throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
                }
                newItem = new Asn1Type();
              }
              newItem.valueBlock = value7.valueBlock;
              value7 = fromBER(newItem.toBER(false)).result;
            }
            res[key] = converter.fromASN(value7);
          }
        } else {
          if (schemaItem.repeated) {
            if (!Array.isArray(asn1SchemaValue)) {
              throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");
            }
            res[key] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));
          } else {
            res[key] = this.fromASN(asn1SchemaValue, schemaItemType);
          }
        }
      }
      return res;
    } catch (error) {
      if (error instanceof AsnSchemaValidationError) {
        error.schemas.push(target.name);
      }
      throw error;
    }
  }
};

// node_modules/@peculiar/asn1-schema/build/es2015/serializer.js
var AsnSerializer = class _AsnSerializer {
  static serialize(obj) {
    if (obj instanceof BaseBlock) {
      return obj.toBER(false);
    }
    return this.toASN(obj).toBER(false);
  }
  static toASN(obj) {
    if (obj && typeof obj === "object" && isConvertible(obj)) {
      return obj.toASN();
    }
    if (!(obj && typeof obj === "object")) {
      throw new TypeError("Parameter 1 should be type of Object.");
    }
    const target = obj.constructor;
    const schema = schemaStorage.get(target);
    schemaStorage.cache(target);
    let asn1Value = [];
    if (schema.itemType) {
      if (!Array.isArray(obj)) {
        throw new TypeError("Parameter 1 should be type of Array.");
      }
      if (typeof schema.itemType === "number") {
        const converter = defaultConverter(schema.itemType);
        if (!converter) {
          throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
        }
        asn1Value = obj.map((o) => converter.toASN(o));
      } else {
        asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, "[]", target, o));
      }
    } else {
      for (const key in schema.items) {
        const schemaItem = schema.items[key];
        const objProp = obj[key];
        if (objProp === void 0 || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === "object" && typeof objProp === "object" && isArrayEqual(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {
          continue;
        }
        const asn1Item = _AsnSerializer.toAsnItem(schemaItem, key, target, objProp);
        if (typeof schemaItem.context === "number") {
          if (schemaItem.implicit) {
            if (!schemaItem.repeated && (typeof schemaItem.type === "number" || isConvertible(schemaItem.type))) {
              const value7 = {};
              value7.valueHex = asn1Item instanceof Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();
              asn1Value.push(new Primitive({
                optional: schemaItem.optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: schemaItem.context
                },
                ...value7
              }));
            } else {
              asn1Value.push(new Constructed({
                optional: schemaItem.optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: schemaItem.context
                },
                value: asn1Item.valueBlock.value
              }));
            }
          } else {
            asn1Value.push(new Constructed({
              optional: schemaItem.optional,
              idBlock: {
                tagClass: 3,
                tagNumber: schemaItem.context
              },
              value: [asn1Item]
            }));
          }
        } else if (schemaItem.repeated) {
          asn1Value = asn1Value.concat(asn1Item);
        } else {
          asn1Value.push(asn1Item);
        }
      }
    }
    let asnSchema;
    switch (schema.type) {
      case AsnTypeTypes.Sequence:
        asnSchema = new Sequence({ value: asn1Value });
        break;
      case AsnTypeTypes.Set:
        asnSchema = new Set2({ value: asn1Value });
        break;
      case AsnTypeTypes.Choice:
        if (!asn1Value[0]) {
          throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);
        }
        asnSchema = asn1Value[0];
        break;
    }
    return asnSchema;
  }
  static toAsnItem(schemaItem, key, target, objProp) {
    let asn1Item;
    if (typeof schemaItem.type === "number") {
      const converter = schemaItem.converter;
      if (!converter) {
        throw new Error(`Property '${key}' doesn't have converter for type ${AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);
      }
      if (schemaItem.repeated) {
        if (!Array.isArray(objProp)) {
          throw new TypeError("Parameter 'objProp' should be type of Array.");
        }
        const items = Array.from(objProp, (element) => converter.toASN(element));
        const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
        asn1Item = new Container({
          value: items
        });
      } else {
        asn1Item = converter.toASN(objProp);
      }
    } else {
      if (schemaItem.repeated) {
        if (!Array.isArray(objProp)) {
          throw new TypeError("Parameter 'objProp' should be type of Array.");
        }
        const items = Array.from(objProp, (element) => this.toASN(element));
        const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
        asn1Item = new Container({
          value: items
        });
      } else {
        asn1Item = this.toASN(objProp);
      }
    }
    return asn1Item;
  }
};

// node_modules/@peculiar/asn1-schema/build/es2015/objects.js
var AsnArray = class extends Array {
  constructor(items = []) {
    if (typeof items === "number") {
      super(items);
    } else {
      super();
      for (const item of items) {
        this.push(item);
      }
    }
  }
};

// node_modules/@peculiar/asn1-schema/build/es2015/convert.js
var AsnConvert = class _AsnConvert {
  static serialize(obj) {
    return AsnSerializer.serialize(obj);
  }
  static parse(data, target) {
    return AsnParser.parse(data, target);
  }
  static toString(data) {
    const buf = BufferSourceConverter.isBufferSource(data) ? BufferSourceConverter.toArrayBuffer(data) : _AsnConvert.serialize(data);
    const asn = fromBER(buf);
    if (asn.offset === -1) {
      throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);
    }
    return asn.result.toString();
  }
};

// node_modules/@peculiar/asn1-x509/node_modules/tslib/tslib.es6.mjs
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js
var IpConverter = class {
  static isIPv4(ip) {
    return /^(\d{1,3}\.){3}\d{1,3}$/.test(ip);
  }
  static parseIPv4(ip) {
    const parts = ip.split(".");
    if (parts.length !== 4) {
      throw new Error("Invalid IPv4 address");
    }
    return parts.map((part) => {
      const num = parseInt(part, 10);
      if (isNaN(num) || num < 0 || num > 255) {
        throw new Error("Invalid IPv4 address part");
      }
      return num;
    });
  }
  static parseIPv6(ip) {
    const expandedIP = this.expandIPv6(ip);
    const parts = expandedIP.split(":");
    if (parts.length !== 8) {
      throw new Error("Invalid IPv6 address");
    }
    return parts.reduce((bytes, part) => {
      const num = parseInt(part, 16);
      if (isNaN(num) || num < 0 || num > 65535) {
        throw new Error("Invalid IPv6 address part");
      }
      bytes.push(num >> 8 & 255);
      bytes.push(num & 255);
      return bytes;
    }, []);
  }
  static expandIPv6(ip) {
    if (!ip.includes("::")) {
      return ip;
    }
    const parts = ip.split("::");
    if (parts.length > 2) {
      throw new Error("Invalid IPv6 address");
    }
    const left = parts[0] ? parts[0].split(":") : [];
    const right = parts[1] ? parts[1].split(":") : [];
    const missing = 8 - (left.length + right.length);
    if (missing < 0) {
      throw new Error("Invalid IPv6 address");
    }
    return [...left, ...Array(missing).fill("0"), ...right].join(":");
  }
  static formatIPv6(bytes) {
    const parts = [];
    for (let i = 0; i < 16; i += 2) {
      parts.push((bytes[i] << 8 | bytes[i + 1]).toString(16));
    }
    return this.compressIPv6(parts.join(":"));
  }
  static compressIPv6(ip) {
    const parts = ip.split(":");
    let longestZeroStart = -1;
    let longestZeroLength = 0;
    let currentZeroStart = -1;
    let currentZeroLength = 0;
    for (let i = 0; i < parts.length; i++) {
      if (parts[i] === "0") {
        if (currentZeroStart === -1) {
          currentZeroStart = i;
        }
        currentZeroLength++;
      } else {
        if (currentZeroLength > longestZeroLength) {
          longestZeroStart = currentZeroStart;
          longestZeroLength = currentZeroLength;
        }
        currentZeroStart = -1;
        currentZeroLength = 0;
      }
    }
    if (currentZeroLength > longestZeroLength) {
      longestZeroStart = currentZeroStart;
      longestZeroLength = currentZeroLength;
    }
    if (longestZeroLength > 1) {
      const before = parts.slice(0, longestZeroStart).join(":");
      const after = parts.slice(longestZeroStart + longestZeroLength).join(":");
      return `${before}::${after}`;
    }
    return ip;
  }
  static parseCIDR(text) {
    const [addr, prefixStr] = text.split("/");
    const prefix = parseInt(prefixStr, 10);
    if (this.isIPv4(addr)) {
      if (prefix < 0 || prefix > 32) {
        throw new Error("Invalid IPv4 prefix length");
      }
      return [this.parseIPv4(addr), prefix];
    } else {
      if (prefix < 0 || prefix > 128) {
        throw new Error("Invalid IPv6 prefix length");
      }
      return [this.parseIPv6(addr), prefix];
    }
  }
  static decodeIP(value7) {
    if (value7.length === 64 && parseInt(value7, 16) === 0) {
      return "::/0";
    }
    if (value7.length !== 16) {
      return value7;
    }
    const mask = parseInt(value7.slice(8), 16).toString(2).split("").reduce((a, k) => a + +k, 0);
    let ip = value7.slice(0, 8).replace(/(.{2})/g, (match) => `${parseInt(match, 16)}.`);
    ip = ip.slice(0, -1);
    return `${ip}/${mask}`;
  }
  static toString(buf) {
    const uint8 = new Uint8Array(buf);
    if (uint8.length === 4) {
      return Array.from(uint8).join(".");
    }
    if (uint8.length === 16) {
      return this.formatIPv6(uint8);
    }
    if (uint8.length === 8 || uint8.length === 32) {
      const half = uint8.length / 2;
      const addrBytes = uint8.slice(0, half);
      const maskBytes = uint8.slice(half);
      const isAllZeros = uint8.every((byte) => byte === 0);
      if (isAllZeros) {
        return uint8.length === 8 ? "0.0.0.0/0" : "::/0";
      }
      const prefixLen = maskBytes.reduce((a, b) => a + (b.toString(2).match(/1/g) || []).length, 0);
      if (uint8.length === 8) {
        const addrStr = Array.from(addrBytes).join(".");
        return `${addrStr}/${prefixLen}`;
      } else {
        const addrStr = this.formatIPv6(addrBytes);
        return `${addrStr}/${prefixLen}`;
      }
    }
    return this.decodeIP(Convert.ToHex(buf));
  }
  static fromString(text) {
    if (text.includes("/")) {
      const [addr, prefix] = this.parseCIDR(text);
      const maskBytes = new Uint8Array(addr.length);
      let bitsLeft = prefix;
      for (let i = 0; i < maskBytes.length; i++) {
        if (bitsLeft >= 8) {
          maskBytes[i] = 255;
          bitsLeft -= 8;
        } else if (bitsLeft > 0) {
          maskBytes[i] = 255 << 8 - bitsLeft;
          bitsLeft = 0;
        }
      }
      const out = new Uint8Array(addr.length * 2);
      out.set(addr, 0);
      out.set(maskBytes, addr.length);
      return out.buffer;
    }
    const bytes = this.isIPv4(text) ? this.parseIPv4(text) : this.parseIPv6(text);
    return new Uint8Array(bytes).buffer;
  }
};

// node_modules/@peculiar/asn1-x509/build/es2015/name.js
var RelativeDistinguishedName_1;
var RDNSequence_1;
var Name_1;
var DirectoryString = class DirectoryString2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.TeletexString })
], DirectoryString.prototype, "teletexString", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.PrintableString })
], DirectoryString.prototype, "printableString", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.UniversalString })
], DirectoryString.prototype, "universalString", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.Utf8String })
], DirectoryString.prototype, "utf8String", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.BmpString })
], DirectoryString.prototype, "bmpString", void 0);
DirectoryString = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], DirectoryString);
var AttributeValue = class AttributeValue2 extends DirectoryString {
  constructor(params = {}) {
    super(params);
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || (this.anyValue ? Convert.ToHex(this.anyValue) : super.toString());
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String })
], AttributeValue.prototype, "ia5String", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.Any })
], AttributeValue.prototype, "anyValue", void 0);
AttributeValue = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], AttributeValue);
var AttributeTypeAndValue = class {
  constructor(params = {}) {
    this.type = "";
    this.value = new AttributeValue();
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], AttributeTypeAndValue.prototype, "type", void 0);
__decorate([
  AsnProp({ type: AttributeValue })
], AttributeTypeAndValue.prototype, "value", void 0);
var RelativeDistinguishedName = RelativeDistinguishedName_1 = class RelativeDistinguishedName2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RelativeDistinguishedName_1.prototype);
  }
};
RelativeDistinguishedName = RelativeDistinguishedName_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Set, itemType: AttributeTypeAndValue })
], RelativeDistinguishedName);
var RDNSequence = RDNSequence_1 = class RDNSequence2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RDNSequence_1.prototype);
  }
};
RDNSequence = RDNSequence_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: RelativeDistinguishedName })
], RDNSequence);
var Name = Name_1 = class Name2 extends RDNSequence {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Name_1.prototype);
  }
};
Name = Name_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], Name);

// node_modules/@peculiar/asn1-x509/build/es2015/general_name.js
var AsnIpConverter = {
  fromASN: (value7) => IpConverter.toString(AsnOctetStringConverter.fromASN(value7)),
  toASN: (value7) => AsnOctetStringConverter.toASN(IpConverter.fromString(value7))
};
var OtherName = class {
  constructor(params = {}) {
    this.typeId = "";
    this.value = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], OtherName.prototype, "typeId", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.Any, context: 0 })
], OtherName.prototype, "value", void 0);
var EDIPartyName = class {
  constructor(params = {}) {
    this.partyName = new DirectoryString();
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: DirectoryString, optional: true, context: 0, implicit: true })
], EDIPartyName.prototype, "nameAssigner", void 0);
__decorate([
  AsnProp({ type: DirectoryString, context: 1, implicit: true })
], EDIPartyName.prototype, "partyName", void 0);
var GeneralName = class GeneralName2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: OtherName, context: 0, implicit: true })
], GeneralName.prototype, "otherName", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String, context: 1, implicit: true })
], GeneralName.prototype, "rfc822Name", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String, context: 2, implicit: true })
], GeneralName.prototype, "dNSName", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.Any, context: 3, implicit: true })
], GeneralName.prototype, "x400Address", void 0);
__decorate([
  AsnProp({ type: Name, context: 4, implicit: false })
], GeneralName.prototype, "directoryName", void 0);
__decorate([
  AsnProp({ type: EDIPartyName, context: 5 })
], GeneralName.prototype, "ediPartyName", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String, context: 6, implicit: true })
], GeneralName.prototype, "uniformResourceIdentifier", void 0);
__decorate([
  AsnProp({
    type: AsnPropTypes.OctetString,
    context: 7,
    implicit: true,
    converter: AsnIpConverter
  })
], GeneralName.prototype, "iPAddress", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier, context: 8, implicit: true })
], GeneralName.prototype, "registeredID", void 0);
GeneralName = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], GeneralName);

// node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js
var id_pkix = "1.3.6.1.5.5.7";
var id_pe = `${id_pkix}.1`;
var id_qt = `${id_pkix}.2`;
var id_kp = `${id_pkix}.3`;
var id_ad = `${id_pkix}.48`;
var id_qt_csp = `${id_qt}.1`;
var id_qt_unotice = `${id_qt}.2`;
var id_ad_ocsp = `${id_ad}.1`;
var id_ad_caIssuers = `${id_ad}.2`;
var id_ad_timeStamping = `${id_ad}.3`;
var id_ad_caRepository = `${id_ad}.5`;
var id_ce = "2.5.29";

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js
var AuthorityInfoAccessSyntax_1;
var id_pe_authorityInfoAccess = `${id_pe}.1`;
var AccessDescription = class {
  constructor(params = {}) {
    this.accessMethod = "";
    this.accessLocation = new GeneralName();
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], AccessDescription.prototype, "accessMethod", void 0);
__decorate([
  AsnProp({ type: GeneralName })
], AccessDescription.prototype, "accessLocation", void 0);
var AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = class AuthorityInfoAccessSyntax2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_1.prototype);
  }
};
AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: AccessDescription })
], AuthorityInfoAccessSyntax);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js
var id_ce_authorityKeyIdentifier = `${id_ce}.35`;
var KeyIdentifier = class extends OctetString2 {
};
var AuthorityKeyIdentifier = class {
  constructor(params = {}) {
    if (params) {
      Object.assign(this, params);
    }
  }
};
__decorate([
  AsnProp({ type: KeyIdentifier, context: 0, optional: true, implicit: true })
], AuthorityKeyIdentifier.prototype, "keyIdentifier", void 0);
__decorate([
  AsnProp({ type: GeneralName, context: 1, optional: true, implicit: true, repeated: "sequence" })
], AuthorityKeyIdentifier.prototype, "authorityCertIssuer", void 0);
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    context: 2,
    optional: true,
    implicit: true,
    converter: AsnIntegerArrayBufferConverter
  })
], AuthorityKeyIdentifier.prototype, "authorityCertSerialNumber", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js
var id_ce_basicConstraints = `${id_ce}.19`;
var BasicConstraints = class {
  constructor(params = {}) {
    this.cA = false;
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Boolean, defaultValue: false })
], BasicConstraints.prototype, "cA", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, optional: true })
], BasicConstraints.prototype, "pathLenConstraint", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/general_names.js
var GeneralNames_1;
var GeneralNames = GeneralNames_1 = class GeneralNames2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralNames_1.prototype);
  }
};
GeneralNames = GeneralNames_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: GeneralName })
], GeneralNames);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js
var CertificateIssuer_1;
var id_ce_certificateIssuer = `${id_ce}.29`;
var CertificateIssuer = CertificateIssuer_1 = class CertificateIssuer2 extends GeneralNames {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificateIssuer_1.prototype);
  }
};
CertificateIssuer = CertificateIssuer_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], CertificateIssuer);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js
var CertificatePolicies_1;
var id_ce_certificatePolicies = `${id_ce}.32`;
var id_ce_certificatePolicies_anyPolicy = `${id_ce_certificatePolicies}.0`;
var DisplayText = class DisplayText2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
  toString() {
    return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String })
], DisplayText.prototype, "ia5String", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.VisibleString })
], DisplayText.prototype, "visibleString", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.BmpString })
], DisplayText.prototype, "bmpString", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.Utf8String })
], DisplayText.prototype, "utf8String", void 0);
DisplayText = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], DisplayText);
var NoticeReference = class {
  constructor(params = {}) {
    this.organization = new DisplayText();
    this.noticeNumbers = [];
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: DisplayText })
], NoticeReference.prototype, "organization", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, repeated: "sequence" })
], NoticeReference.prototype, "noticeNumbers", void 0);
var UserNotice = class {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: NoticeReference, optional: true })
], UserNotice.prototype, "noticeRef", void 0);
__decorate([
  AsnProp({ type: DisplayText, optional: true })
], UserNotice.prototype, "explicitText", void 0);
var Qualifier = class Qualifier2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.IA5String })
], Qualifier.prototype, "cPSuri", void 0);
__decorate([
  AsnProp({ type: UserNotice })
], Qualifier.prototype, "userNotice", void 0);
Qualifier = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], Qualifier);
var PolicyQualifierInfo = class {
  constructor(params = {}) {
    this.policyQualifierId = "";
    this.qualifier = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PolicyQualifierInfo.prototype, "policyQualifierId", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.Any })
], PolicyQualifierInfo.prototype, "qualifier", void 0);
var PolicyInformation = class {
  constructor(params = {}) {
    this.policyIdentifier = "";
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PolicyInformation.prototype, "policyIdentifier", void 0);
__decorate([
  AsnProp({ type: PolicyQualifierInfo, repeated: "sequence", optional: true })
], PolicyInformation.prototype, "policyQualifiers", void 0);
var CertificatePolicies = CertificatePolicies_1 = class CertificatePolicies2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificatePolicies_1.prototype);
  }
};
CertificatePolicies = CertificatePolicies_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: PolicyInformation })
], CertificatePolicies);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js
var id_ce_cRLNumber = `${id_ce}.20`;
var CRLNumber = class CRLNumber2 {
  constructor(value7 = 0) {
    this.value = value7;
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Integer })
], CRLNumber.prototype, "value", void 0);
CRLNumber = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], CRLNumber);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js
var id_ce_deltaCRLIndicator = `${id_ce}.27`;
var BaseCRLNumber = class BaseCRLNumber2 extends CRLNumber {
};
BaseCRLNumber = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], BaseCRLNumber);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js
var CRLDistributionPoints_1;
var id_ce_cRLDistributionPoints = `${id_ce}.31`;
var ReasonFlags;
(function(ReasonFlags2) {
  ReasonFlags2[ReasonFlags2["unused"] = 1] = "unused";
  ReasonFlags2[ReasonFlags2["keyCompromise"] = 2] = "keyCompromise";
  ReasonFlags2[ReasonFlags2["cACompromise"] = 4] = "cACompromise";
  ReasonFlags2[ReasonFlags2["affiliationChanged"] = 8] = "affiliationChanged";
  ReasonFlags2[ReasonFlags2["superseded"] = 16] = "superseded";
  ReasonFlags2[ReasonFlags2["cessationOfOperation"] = 32] = "cessationOfOperation";
  ReasonFlags2[ReasonFlags2["certificateHold"] = 64] = "certificateHold";
  ReasonFlags2[ReasonFlags2["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
  ReasonFlags2[ReasonFlags2["aACompromise"] = 256] = "aACompromise";
})(ReasonFlags || (ReasonFlags = {}));
var Reason = class extends BitString2 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & ReasonFlags.aACompromise) {
      res.push("aACompromise");
    }
    if (flags & ReasonFlags.affiliationChanged) {
      res.push("affiliationChanged");
    }
    if (flags & ReasonFlags.cACompromise) {
      res.push("cACompromise");
    }
    if (flags & ReasonFlags.certificateHold) {
      res.push("certificateHold");
    }
    if (flags & ReasonFlags.cessationOfOperation) {
      res.push("cessationOfOperation");
    }
    if (flags & ReasonFlags.keyCompromise) {
      res.push("keyCompromise");
    }
    if (flags & ReasonFlags.privilegeWithdrawn) {
      res.push("privilegeWithdrawn");
    }
    if (flags & ReasonFlags.superseded) {
      res.push("superseded");
    }
    if (flags & ReasonFlags.unused) {
      res.push("unused");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
};
var DistributionPointName = class DistributionPointName2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: GeneralName, context: 0, repeated: "sequence", implicit: true })
], DistributionPointName.prototype, "fullName", void 0);
__decorate([
  AsnProp({ type: RelativeDistinguishedName, context: 1, implicit: true })
], DistributionPointName.prototype, "nameRelativeToCRLIssuer", void 0);
DistributionPointName = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], DistributionPointName);
var DistributionPoint = class {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: DistributionPointName, context: 0, optional: true })
], DistributionPoint.prototype, "distributionPoint", void 0);
__decorate([
  AsnProp({ type: Reason, context: 1, optional: true, implicit: true })
], DistributionPoint.prototype, "reasons", void 0);
__decorate([
  AsnProp({ type: GeneralName, context: 2, optional: true, repeated: "sequence", implicit: true })
], DistributionPoint.prototype, "cRLIssuer", void 0);
var CRLDistributionPoints = CRLDistributionPoints_1 = class CRLDistributionPoints2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CRLDistributionPoints_1.prototype);
  }
};
CRLDistributionPoints = CRLDistributionPoints_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: DistributionPoint })
], CRLDistributionPoints);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js
var FreshestCRL_1;
var id_ce_freshestCRL = `${id_ce}.46`;
var FreshestCRL = FreshestCRL_1 = class FreshestCRL2 extends CRLDistributionPoints {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, FreshestCRL_1.prototype);
  }
};
FreshestCRL = FreshestCRL_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: DistributionPoint })
], FreshestCRL);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js
var id_ce_issuingDistributionPoint = `${id_ce}.28`;
var IssuingDistributionPoint = class _IssuingDistributionPoint {
  constructor(params = {}) {
    this.onlyContainsUserCerts = _IssuingDistributionPoint.ONLY;
    this.onlyContainsCACerts = _IssuingDistributionPoint.ONLY;
    this.indirectCRL = _IssuingDistributionPoint.ONLY;
    this.onlyContainsAttributeCerts = _IssuingDistributionPoint.ONLY;
    Object.assign(this, params);
  }
};
IssuingDistributionPoint.ONLY = false;
__decorate([
  AsnProp({ type: DistributionPointName, context: 0, optional: true })
], IssuingDistributionPoint.prototype, "distributionPoint", void 0);
__decorate([
  AsnProp({
    type: AsnPropTypes.Boolean,
    context: 1,
    defaultValue: IssuingDistributionPoint.ONLY,
    implicit: true
  })
], IssuingDistributionPoint.prototype, "onlyContainsUserCerts", void 0);
__decorate([
  AsnProp({
    type: AsnPropTypes.Boolean,
    context: 2,
    defaultValue: IssuingDistributionPoint.ONLY,
    implicit: true
  })
], IssuingDistributionPoint.prototype, "onlyContainsCACerts", void 0);
__decorate([
  AsnProp({ type: Reason, context: 3, optional: true, implicit: true })
], IssuingDistributionPoint.prototype, "onlySomeReasons", void 0);
__decorate([
  AsnProp({
    type: AsnPropTypes.Boolean,
    context: 4,
    defaultValue: IssuingDistributionPoint.ONLY,
    implicit: true
  })
], IssuingDistributionPoint.prototype, "indirectCRL", void 0);
__decorate([
  AsnProp({
    type: AsnPropTypes.Boolean,
    context: 5,
    defaultValue: IssuingDistributionPoint.ONLY,
    implicit: true
  })
], IssuingDistributionPoint.prototype, "onlyContainsAttributeCerts", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js
var id_ce_cRLReasons = `${id_ce}.21`;
var CRLReasons;
(function(CRLReasons2) {
  CRLReasons2[CRLReasons2["unspecified"] = 0] = "unspecified";
  CRLReasons2[CRLReasons2["keyCompromise"] = 1] = "keyCompromise";
  CRLReasons2[CRLReasons2["cACompromise"] = 2] = "cACompromise";
  CRLReasons2[CRLReasons2["affiliationChanged"] = 3] = "affiliationChanged";
  CRLReasons2[CRLReasons2["superseded"] = 4] = "superseded";
  CRLReasons2[CRLReasons2["cessationOfOperation"] = 5] = "cessationOfOperation";
  CRLReasons2[CRLReasons2["certificateHold"] = 6] = "certificateHold";
  CRLReasons2[CRLReasons2["removeFromCRL"] = 8] = "removeFromCRL";
  CRLReasons2[CRLReasons2["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
  CRLReasons2[CRLReasons2["aACompromise"] = 10] = "aACompromise";
})(CRLReasons || (CRLReasons = {}));
var CRLReason = class CRLReason2 {
  constructor(reason = CRLReasons.unspecified) {
    this.reason = CRLReasons.unspecified;
    this.reason = reason;
  }
  toJSON() {
    return CRLReasons[this.reason];
  }
  toString() {
    return this.toJSON();
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Enumerated })
], CRLReason.prototype, "reason", void 0);
CRLReason = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], CRLReason);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js
var ExtendedKeyUsage_1;
var id_ce_extKeyUsage = `${id_ce}.37`;
var ExtendedKeyUsage = ExtendedKeyUsage_1 = class ExtendedKeyUsage2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtendedKeyUsage_1.prototype);
  }
};
ExtendedKeyUsage = ExtendedKeyUsage_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: AsnPropTypes.ObjectIdentifier })
], ExtendedKeyUsage);
var anyExtendedKeyUsage = `${id_ce_extKeyUsage}.0`;
var id_kp_serverAuth = `${id_kp}.1`;
var id_kp_clientAuth = `${id_kp}.2`;
var id_kp_codeSigning = `${id_kp}.3`;
var id_kp_emailProtection = `${id_kp}.4`;
var id_kp_timeStamping = `${id_kp}.8`;
var id_kp_OCSPSigning = `${id_kp}.9`;

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js
var id_ce_inhibitAnyPolicy = `${id_ce}.54`;
var InhibitAnyPolicy = class InhibitAnyPolicy2 {
  constructor(value7 = new ArrayBuffer(0)) {
    this.value = value7;
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], InhibitAnyPolicy.prototype, "value", void 0);
InhibitAnyPolicy = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], InhibitAnyPolicy);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js
var id_ce_invalidityDate = `${id_ce}.24`;
var InvalidityDate = class InvalidityDate2 {
  constructor(value7) {
    this.value = /* @__PURE__ */ new Date();
    if (value7) {
      this.value = value7;
    }
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.GeneralizedTime })
], InvalidityDate.prototype, "value", void 0);
InvalidityDate = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], InvalidityDate);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js
var IssueAlternativeName_1;
var id_ce_issuerAltName = `${id_ce}.18`;
var IssueAlternativeName = IssueAlternativeName_1 = class IssueAlternativeName2 extends GeneralNames {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, IssueAlternativeName_1.prototype);
  }
};
IssueAlternativeName = IssueAlternativeName_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], IssueAlternativeName);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js
var id_ce_keyUsage = `${id_ce}.15`;
var KeyUsageFlags;
(function(KeyUsageFlags3) {
  KeyUsageFlags3[KeyUsageFlags3["digitalSignature"] = 1] = "digitalSignature";
  KeyUsageFlags3[KeyUsageFlags3["nonRepudiation"] = 2] = "nonRepudiation";
  KeyUsageFlags3[KeyUsageFlags3["keyEncipherment"] = 4] = "keyEncipherment";
  KeyUsageFlags3[KeyUsageFlags3["dataEncipherment"] = 8] = "dataEncipherment";
  KeyUsageFlags3[KeyUsageFlags3["keyAgreement"] = 16] = "keyAgreement";
  KeyUsageFlags3[KeyUsageFlags3["keyCertSign"] = 32] = "keyCertSign";
  KeyUsageFlags3[KeyUsageFlags3["cRLSign"] = 64] = "cRLSign";
  KeyUsageFlags3[KeyUsageFlags3["encipherOnly"] = 128] = "encipherOnly";
  KeyUsageFlags3[KeyUsageFlags3["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags || (KeyUsageFlags = {}));
var KeyUsage = class extends BitString2 {
  toJSON() {
    const flag = this.toNumber();
    const res = [];
    if (flag & KeyUsageFlags.cRLSign) {
      res.push("crlSign");
    }
    if (flag & KeyUsageFlags.dataEncipherment) {
      res.push("dataEncipherment");
    }
    if (flag & KeyUsageFlags.decipherOnly) {
      res.push("decipherOnly");
    }
    if (flag & KeyUsageFlags.digitalSignature) {
      res.push("digitalSignature");
    }
    if (flag & KeyUsageFlags.encipherOnly) {
      res.push("encipherOnly");
    }
    if (flag & KeyUsageFlags.keyAgreement) {
      res.push("keyAgreement");
    }
    if (flag & KeyUsageFlags.keyCertSign) {
      res.push("keyCertSign");
    }
    if (flag & KeyUsageFlags.keyEncipherment) {
      res.push("keyEncipherment");
    }
    if (flag & KeyUsageFlags.nonRepudiation) {
      res.push("nonRepudiation");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
};

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js
var GeneralSubtrees_1;
var id_ce_nameConstraints = `${id_ce}.30`;
var GeneralSubtree = class {
  constructor(params = {}) {
    this.base = new GeneralName();
    this.minimum = 0;
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: GeneralName })
], GeneralSubtree.prototype, "base", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, context: 0, defaultValue: 0, implicit: true })
], GeneralSubtree.prototype, "minimum", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, context: 1, optional: true, implicit: true })
], GeneralSubtree.prototype, "maximum", void 0);
var GeneralSubtrees = GeneralSubtrees_1 = class GeneralSubtrees2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, GeneralSubtrees_1.prototype);
  }
};
GeneralSubtrees = GeneralSubtrees_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: GeneralSubtree })
], GeneralSubtrees);
var NameConstraints = class {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: GeneralSubtrees, context: 0, optional: true, implicit: true })
], NameConstraints.prototype, "permittedSubtrees", void 0);
__decorate([
  AsnProp({ type: GeneralSubtrees, context: 1, optional: true, implicit: true })
], NameConstraints.prototype, "excludedSubtrees", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js
var id_ce_policyConstraints = `${id_ce}.36`;
var PolicyConstraints = class {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    context: 0,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter
  })
], PolicyConstraints.prototype, "requireExplicitPolicy", void 0);
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    context: 1,
    implicit: true,
    optional: true,
    converter: AsnIntegerArrayBufferConverter
  })
], PolicyConstraints.prototype, "inhibitPolicyMapping", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js
var PolicyMappings_1;
var id_ce_policyMappings = `${id_ce}.33`;
var PolicyMapping = class {
  constructor(params = {}) {
    this.issuerDomainPolicy = "";
    this.subjectDomainPolicy = "";
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PolicyMapping.prototype, "issuerDomainPolicy", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PolicyMapping.prototype, "subjectDomainPolicy", void 0);
var PolicyMappings = PolicyMappings_1 = class PolicyMappings2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, PolicyMappings_1.prototype);
  }
};
PolicyMappings = PolicyMappings_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: PolicyMapping })
], PolicyMappings);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js
var SubjectAlternativeName_1;
var id_ce_subjectAltName = `${id_ce}.17`;
var SubjectAlternativeName = SubjectAlternativeName_1 = class SubjectAlternativeName2 extends GeneralNames {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectAlternativeName_1.prototype);
  }
};
SubjectAlternativeName = SubjectAlternativeName_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence })
], SubjectAlternativeName);

// node_modules/@peculiar/asn1-x509/build/es2015/attribute.js
var Attribute = class {
  constructor(params = {}) {
    this.type = "";
    this.values = [];
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], Attribute.prototype, "type", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.Any, repeated: "set" })
], Attribute.prototype, "values", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js
var SubjectDirectoryAttributes_1;
var id_ce_subjectDirectoryAttributes = `${id_ce}.9`;
var SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = class SubjectDirectoryAttributes2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectDirectoryAttributes_1.prototype);
  }
};
SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: Attribute })
], SubjectDirectoryAttributes);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js
var id_ce_subjectKeyIdentifier = `${id_ce}.14`;
var SubjectKeyIdentifier = class extends KeyIdentifier {
};

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js
var id_ce_privateKeyUsagePeriod = `${id_ce}.16`;
var PrivateKeyUsagePeriod = class {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.GeneralizedTime, context: 0, implicit: true, optional: true })
], PrivateKeyUsagePeriod.prototype, "notBefore", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.GeneralizedTime, context: 1, implicit: true, optional: true })
], PrivateKeyUsagePeriod.prototype, "notAfter", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js
var EntrustInfoFlags;
(function(EntrustInfoFlags2) {
  EntrustInfoFlags2[EntrustInfoFlags2["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
  EntrustInfoFlags2[EntrustInfoFlags2["newExtensions"] = 2] = "newExtensions";
  EntrustInfoFlags2[EntrustInfoFlags2["pKIXCertificate"] = 4] = "pKIXCertificate";
})(EntrustInfoFlags || (EntrustInfoFlags = {}));
var EntrustInfo = class extends BitString2 {
  toJSON() {
    const res = [];
    const flags = this.toNumber();
    if (flags & EntrustInfoFlags.pKIXCertificate) {
      res.push("pKIXCertificate");
    }
    if (flags & EntrustInfoFlags.newExtensions) {
      res.push("newExtensions");
    }
    if (flags & EntrustInfoFlags.keyUpdateAllowed) {
      res.push("keyUpdateAllowed");
    }
    return res;
  }
  toString() {
    return `[${this.toJSON().join(", ")}]`;
  }
};
var EntrustVersionInfo = class {
  constructor(params = {}) {
    this.entrustVers = "";
    this.entrustInfoFlags = new EntrustInfo();
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.GeneralString })
], EntrustVersionInfo.prototype, "entrustVers", void 0);
__decorate([
  AsnProp({ type: EntrustInfo })
], EntrustVersionInfo.prototype, "entrustInfoFlags", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js
var SubjectInfoAccessSyntax_1;
var id_pe_subjectInfoAccess = `${id_pe}.11`;
var SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = class SubjectInfoAccessSyntax2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SubjectInfoAccessSyntax_1.prototype);
  }
};
SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: AccessDescription })
], SubjectInfoAccessSyntax);

// node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js
var AlgorithmIdentifier = class _AlgorithmIdentifier {
  constructor(params = {}) {
    this.algorithm = "";
    Object.assign(this, params);
  }
  isEqual(data) {
    return data instanceof _AlgorithmIdentifier && data.algorithm == this.algorithm && (data.parameters && this.parameters && isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
  }
};
__decorate([
  AsnProp({
    type: AsnPropTypes.ObjectIdentifier
  })
], AlgorithmIdentifier.prototype, "algorithm", void 0);
__decorate([
  AsnProp({
    type: AsnPropTypes.Any,
    optional: true
  })
], AlgorithmIdentifier.prototype, "parameters", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js
var SubjectPublicKeyInfo = class {
  constructor(params = {}) {
    this.algorithm = new AlgorithmIdentifier();
    this.subjectPublicKey = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], SubjectPublicKeyInfo.prototype, "algorithm", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString })
], SubjectPublicKeyInfo.prototype, "subjectPublicKey", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/time.js
var Time = class Time2 {
  constructor(time) {
    if (time) {
      if (typeof time === "string" || typeof time === "number" || time instanceof Date) {
        const date = new Date(time);
        if (date.getUTCFullYear() > 2049) {
          this.generalTime = date;
        } else {
          this.utcTime = date;
        }
      } else {
        Object.assign(this, time);
      }
    }
  }
  getTime() {
    const time = this.utcTime || this.generalTime;
    if (!time) {
      throw new Error("Cannot get time from CHOICE object");
    }
    return time;
  }
};
__decorate([
  AsnProp({
    type: AsnPropTypes.UTCTime
  })
], Time.prototype, "utcTime", void 0);
__decorate([
  AsnProp({
    type: AsnPropTypes.GeneralizedTime
  })
], Time.prototype, "generalTime", void 0);
Time = __decorate([
  AsnType({ type: AsnTypeTypes.Choice })
], Time);

// node_modules/@peculiar/asn1-x509/build/es2015/validity.js
var Validity = class {
  constructor(params) {
    this.notBefore = new Time(/* @__PURE__ */ new Date());
    this.notAfter = new Time(/* @__PURE__ */ new Date());
    if (params) {
      this.notBefore = new Time(params.notBefore);
      this.notAfter = new Time(params.notAfter);
    }
  }
};
__decorate([
  AsnProp({ type: Time })
], Validity.prototype, "notBefore", void 0);
__decorate([
  AsnProp({ type: Time })
], Validity.prototype, "notAfter", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/extension.js
var Extensions_1;
var Extension = class _Extension {
  constructor(params = {}) {
    this.extnID = "";
    this.critical = _Extension.CRITICAL;
    this.extnValue = new OctetString2();
    Object.assign(this, params);
  }
};
Extension.CRITICAL = false;
__decorate([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], Extension.prototype, "extnID", void 0);
__decorate([
  AsnProp({
    type: AsnPropTypes.Boolean,
    defaultValue: Extension.CRITICAL
  })
], Extension.prototype, "critical", void 0);
__decorate([
  AsnProp({ type: OctetString2 })
], Extension.prototype, "extnValue", void 0);
var Extensions = Extensions_1 = class Extensions2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Extensions_1.prototype);
  }
};
Extensions = Extensions_1 = __decorate([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: Extension })
], Extensions);

// node_modules/@peculiar/asn1-x509/build/es2015/types.js
var Version;
(function(Version3) {
  Version3[Version3["v1"] = 0] = "v1";
  Version3[Version3["v2"] = 1] = "v2";
  Version3[Version3["v3"] = 2] = "v3";
})(Version || (Version = {}));

// node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js
var TBSCertificate = class {
  constructor(params = {}) {
    this.version = Version.v1;
    this.serialNumber = new ArrayBuffer(0);
    this.signature = new AlgorithmIdentifier();
    this.issuer = new Name();
    this.validity = new Validity();
    this.subject = new Name();
    this.subjectPublicKeyInfo = new SubjectPublicKeyInfo();
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    context: 0,
    defaultValue: Version.v1
  })
], TBSCertificate.prototype, "version", void 0);
__decorate([
  AsnProp({
    type: AsnPropTypes.Integer,
    converter: AsnIntegerArrayBufferConverter
  })
], TBSCertificate.prototype, "serialNumber", void 0);
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], TBSCertificate.prototype, "signature", void 0);
__decorate([
  AsnProp({ type: Name })
], TBSCertificate.prototype, "issuer", void 0);
__decorate([
  AsnProp({ type: Validity })
], TBSCertificate.prototype, "validity", void 0);
__decorate([
  AsnProp({ type: Name })
], TBSCertificate.prototype, "subject", void 0);
__decorate([
  AsnProp({ type: SubjectPublicKeyInfo })
], TBSCertificate.prototype, "subjectPublicKeyInfo", void 0);
__decorate([
  AsnProp({
    type: AsnPropTypes.BitString,
    context: 1,
    implicit: true,
    optional: true
  })
], TBSCertificate.prototype, "issuerUniqueID", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString, context: 2, implicit: true, optional: true })
], TBSCertificate.prototype, "subjectUniqueID", void 0);
__decorate([
  AsnProp({ type: Extensions, context: 3, optional: true })
], TBSCertificate.prototype, "extensions", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/certificate.js
var Certificate = class {
  constructor(params = {}) {
    this.tbsCertificate = new TBSCertificate();
    this.signatureAlgorithm = new AlgorithmIdentifier();
    this.signatureValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: TBSCertificate })
], Certificate.prototype, "tbsCertificate", void 0);
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], Certificate.prototype, "signatureAlgorithm", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString })
], Certificate.prototype, "signatureValue", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js
var RevokedCertificate = class {
  constructor(params = {}) {
    this.userCertificate = new ArrayBuffer(0);
    this.revocationDate = new Time();
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RevokedCertificate.prototype, "userCertificate", void 0);
__decorate([
  AsnProp({ type: Time })
], RevokedCertificate.prototype, "revocationDate", void 0);
__decorate([
  AsnProp({ type: Extension, optional: true, repeated: "sequence" })
], RevokedCertificate.prototype, "crlEntryExtensions", void 0);
var TBSCertList = class {
  constructor(params = {}) {
    this.signature = new AlgorithmIdentifier();
    this.issuer = new Name();
    this.thisUpdate = new Time();
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: AsnPropTypes.Integer, optional: true })
], TBSCertList.prototype, "version", void 0);
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], TBSCertList.prototype, "signature", void 0);
__decorate([
  AsnProp({ type: Name })
], TBSCertList.prototype, "issuer", void 0);
__decorate([
  AsnProp({ type: Time })
], TBSCertList.prototype, "thisUpdate", void 0);
__decorate([
  AsnProp({ type: Time, optional: true })
], TBSCertList.prototype, "nextUpdate", void 0);
__decorate([
  AsnProp({ type: RevokedCertificate, repeated: "sequence", optional: true })
], TBSCertList.prototype, "revokedCertificates", void 0);
__decorate([
  AsnProp({ type: Extension, optional: true, context: 0, repeated: "sequence" })
], TBSCertList.prototype, "crlExtensions", void 0);

// node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js
var CertificateList = class {
  constructor(params = {}) {
    this.tbsCertList = new TBSCertList();
    this.signatureAlgorithm = new AlgorithmIdentifier();
    this.signature = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate([
  AsnProp({ type: TBSCertList })
], CertificateList.prototype, "tbsCertList", void 0);
__decorate([
  AsnProp({ type: AlgorithmIdentifier })
], CertificateList.prototype, "signatureAlgorithm", void 0);
__decorate([
  AsnProp({ type: AsnPropTypes.BitString })
], CertificateList.prototype, "signature", void 0);

// node_modules/@peculiar/asn1-cms/node_modules/tslib/tslib.es6.mjs
function __decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@peculiar/asn1-cms/build/es2015/issuer_and_serial_number.js
var IssuerAndSerialNumber = class {
  constructor(params = {}) {
    this.issuer = new Name();
    this.serialNumber = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: Name })
], IssuerAndSerialNumber.prototype, "issuer", void 0);
__decorate2([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], IssuerAndSerialNumber.prototype, "serialNumber", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/signer_identifier.js
var SignerIdentifier = class SignerIdentifier2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: SubjectKeyIdentifier, context: 0, implicit: true })
], SignerIdentifier.prototype, "subjectKeyIdentifier", void 0);
__decorate2([
  AsnProp({ type: IssuerAndSerialNumber })
], SignerIdentifier.prototype, "issuerAndSerialNumber", void 0);
SignerIdentifier = __decorate2([
  AsnType({ type: AsnTypeTypes.Choice })
], SignerIdentifier);

// node_modules/@peculiar/asn1-cms/build/es2015/types.js
var CMSVersion;
(function(CMSVersion2) {
  CMSVersion2[CMSVersion2["v0"] = 0] = "v0";
  CMSVersion2[CMSVersion2["v1"] = 1] = "v1";
  CMSVersion2[CMSVersion2["v2"] = 2] = "v2";
  CMSVersion2[CMSVersion2["v3"] = 3] = "v3";
  CMSVersion2[CMSVersion2["v4"] = 4] = "v4";
  CMSVersion2[CMSVersion2["v5"] = 5] = "v5";
})(CMSVersion || (CMSVersion = {}));
var DigestAlgorithmIdentifier = class DigestAlgorithmIdentifier2 extends AlgorithmIdentifier {
};
DigestAlgorithmIdentifier = __decorate2([
  AsnType({ type: AsnTypeTypes.Sequence })
], DigestAlgorithmIdentifier);
var SignatureAlgorithmIdentifier = class SignatureAlgorithmIdentifier2 extends AlgorithmIdentifier {
};
SignatureAlgorithmIdentifier = __decorate2([
  AsnType({ type: AsnTypeTypes.Sequence })
], SignatureAlgorithmIdentifier);
var KeyEncryptionAlgorithmIdentifier = class KeyEncryptionAlgorithmIdentifier2 extends AlgorithmIdentifier {
};
KeyEncryptionAlgorithmIdentifier = __decorate2([
  AsnType({ type: AsnTypeTypes.Sequence })
], KeyEncryptionAlgorithmIdentifier);
var ContentEncryptionAlgorithmIdentifier = class ContentEncryptionAlgorithmIdentifier2 extends AlgorithmIdentifier {
};
ContentEncryptionAlgorithmIdentifier = __decorate2([
  AsnType({ type: AsnTypeTypes.Sequence })
], ContentEncryptionAlgorithmIdentifier);
var MessageAuthenticationCodeAlgorithm = class MessageAuthenticationCodeAlgorithm2 extends AlgorithmIdentifier {
};
MessageAuthenticationCodeAlgorithm = __decorate2([
  AsnType({ type: AsnTypeTypes.Sequence })
], MessageAuthenticationCodeAlgorithm);
var KeyDerivationAlgorithmIdentifier = class KeyDerivationAlgorithmIdentifier2 extends AlgorithmIdentifier {
};
KeyDerivationAlgorithmIdentifier = __decorate2([
  AsnType({ type: AsnTypeTypes.Sequence })
], KeyDerivationAlgorithmIdentifier);

// node_modules/@peculiar/asn1-cms/build/es2015/attribute.js
var Attribute2 = class {
  constructor(params = {}) {
    this.attrType = "";
    this.attrValues = [];
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], Attribute2.prototype, "attrType", void 0);
__decorate2([
  AsnProp({ type: AsnPropTypes.Any, repeated: "set" })
], Attribute2.prototype, "attrValues", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/signer_info.js
var SignerInfos_1;
var SignerInfo = class {
  constructor(params = {}) {
    this.version = CMSVersion.v0;
    this.sid = new SignerIdentifier();
    this.digestAlgorithm = new DigestAlgorithmIdentifier();
    this.signatureAlgorithm = new SignatureAlgorithmIdentifier();
    this.signature = new OctetString2();
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.Integer })
], SignerInfo.prototype, "version", void 0);
__decorate2([
  AsnProp({ type: SignerIdentifier })
], SignerInfo.prototype, "sid", void 0);
__decorate2([
  AsnProp({ type: DigestAlgorithmIdentifier })
], SignerInfo.prototype, "digestAlgorithm", void 0);
__decorate2([
  AsnProp({ type: Attribute2, repeated: "set", context: 0, implicit: true, optional: true })
], SignerInfo.prototype, "signedAttrs", void 0);
__decorate2([
  AsnProp({ type: SignatureAlgorithmIdentifier })
], SignerInfo.prototype, "signatureAlgorithm", void 0);
__decorate2([
  AsnProp({ type: OctetString2 })
], SignerInfo.prototype, "signature", void 0);
__decorate2([
  AsnProp({ type: Attribute2, repeated: "set", context: 1, implicit: true, optional: true })
], SignerInfo.prototype, "unsignedAttrs", void 0);
var SignerInfos = SignerInfos_1 = class SignerInfos2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SignerInfos_1.prototype);
  }
};
SignerInfos = SignerInfos_1 = __decorate2([
  AsnType({ type: AsnTypeTypes.Set, itemType: SignerInfo })
], SignerInfos);

// node_modules/@peculiar/asn1-cms/build/es2015/attributes.js
var SigningTime = class SigningTime2 extends Time {
};
SigningTime = __decorate2([
  AsnType({ type: AsnTypeTypes.Choice })
], SigningTime);
var CounterSignature = class CounterSignature2 extends SignerInfo {
};
CounterSignature = __decorate2([
  AsnType({ type: AsnTypeTypes.Sequence })
], CounterSignature);

// node_modules/@peculiar/asn1-x509-attr/node_modules/tslib/tslib.es6.mjs
function __decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@peculiar/asn1-x509-attr/build/es2015/aa_clear_attrs.js
var ACClearAttrs = class {
  constructor(params = {}) {
    this.acIssuer = new GeneralName();
    this.acSerial = 0;
    this.attrs = [];
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: GeneralName })
], ACClearAttrs.prototype, "acIssuer", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.Integer })
], ACClearAttrs.prototype, "acSerial", void 0);
__decorate3([
  AsnProp({ type: Attribute, repeated: "sequence" })
], ACClearAttrs.prototype, "attrs", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_spec.js
var AttrSpec_1;
var AttrSpec = AttrSpec_1 = class AttrSpec2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AttrSpec_1.prototype);
  }
};
AttrSpec = AttrSpec_1 = __decorate3([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: AsnPropTypes.ObjectIdentifier })
], AttrSpec);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/aa_controls.js
var AAControls = class {
  constructor(params = {}) {
    this.permitUnSpecified = true;
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: AsnPropTypes.Integer, optional: true })
], AAControls.prototype, "pathLenConstraint", void 0);
__decorate3([
  AsnProp({ type: AttrSpec, implicit: true, context: 0, optional: true })
], AAControls.prototype, "permittedAttrs", void 0);
__decorate3([
  AsnProp({ type: AttrSpec, implicit: true, context: 1, optional: true })
], AAControls.prototype, "excludedAttrs", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.Boolean, defaultValue: true })
], AAControls.prototype, "permitUnSpecified", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/issuer_serial.js
var IssuerSerial = class {
  constructor(params = {}) {
    this.issuer = new GeneralNames();
    this.serial = new ArrayBuffer(0);
    this.issuerUID = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: GeneralNames })
], IssuerSerial.prototype, "issuer", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], IssuerSerial.prototype, "serial", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.BitString, optional: true })
], IssuerSerial.prototype, "issuerUID", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/object_digest_info.js
var DigestedObjectType;
(function(DigestedObjectType2) {
  DigestedObjectType2[DigestedObjectType2["publicKey"] = 0] = "publicKey";
  DigestedObjectType2[DigestedObjectType2["publicKeyCert"] = 1] = "publicKeyCert";
  DigestedObjectType2[DigestedObjectType2["otherObjectTypes"] = 2] = "otherObjectTypes";
})(DigestedObjectType || (DigestedObjectType = {}));
var ObjectDigestInfo = class {
  constructor(params = {}) {
    this.digestedObjectType = DigestedObjectType.publicKey;
    this.digestAlgorithm = new AlgorithmIdentifier();
    this.objectDigest = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: AsnPropTypes.Enumerated })
], ObjectDigestInfo.prototype, "digestedObjectType", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier, optional: true })
], ObjectDigestInfo.prototype, "otherObjectTypeID", void 0);
__decorate3([
  AsnProp({ type: AlgorithmIdentifier })
], ObjectDigestInfo.prototype, "digestAlgorithm", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.BitString })
], ObjectDigestInfo.prototype, "objectDigest", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/v2_form.js
var V2Form = class {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: GeneralNames, optional: true })
], V2Form.prototype, "issuerName", void 0);
__decorate3([
  AsnProp({ type: IssuerSerial, context: 0, implicit: true, optional: true })
], V2Form.prototype, "baseCertificateID", void 0);
__decorate3([
  AsnProp({ type: ObjectDigestInfo, context: 1, implicit: true, optional: true })
], V2Form.prototype, "objectDigestInfo", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_issuer.js
var AttCertIssuer = class AttCertIssuer2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: GeneralName, repeated: "sequence" })
], AttCertIssuer.prototype, "v1Form", void 0);
__decorate3([
  AsnProp({ type: V2Form, context: 0, implicit: true })
], AttCertIssuer.prototype, "v2Form", void 0);
AttCertIssuer = __decorate3([
  AsnType({ type: AsnTypeTypes.Choice })
], AttCertIssuer);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_validity_period.js
var AttCertValidityPeriod = class {
  constructor(params = {}) {
    this.notBeforeTime = /* @__PURE__ */ new Date();
    this.notAfterTime = /* @__PURE__ */ new Date();
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: AsnPropTypes.GeneralizedTime })
], AttCertValidityPeriod.prototype, "notBeforeTime", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.GeneralizedTime })
], AttCertValidityPeriod.prototype, "notAfterTime", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/holder.js
var Holder = class {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: IssuerSerial, implicit: true, context: 0, optional: true })
], Holder.prototype, "baseCertificateID", void 0);
__decorate3([
  AsnProp({ type: GeneralNames, implicit: true, context: 1, optional: true })
], Holder.prototype, "entityName", void 0);
__decorate3([
  AsnProp({ type: ObjectDigestInfo, implicit: true, context: 2, optional: true })
], Holder.prototype, "objectDigestInfo", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate_info.js
var AttCertVersion;
(function(AttCertVersion2) {
  AttCertVersion2[AttCertVersion2["v2"] = 1] = "v2";
})(AttCertVersion || (AttCertVersion = {}));
var AttributeCertificateInfo = class {
  constructor(params = {}) {
    this.version = AttCertVersion.v2;
    this.holder = new Holder();
    this.issuer = new AttCertIssuer();
    this.signature = new AlgorithmIdentifier();
    this.serialNumber = new ArrayBuffer(0);
    this.attrCertValidityPeriod = new AttCertValidityPeriod();
    this.attributes = [];
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: AsnPropTypes.Integer })
], AttributeCertificateInfo.prototype, "version", void 0);
__decorate3([
  AsnProp({ type: Holder })
], AttributeCertificateInfo.prototype, "holder", void 0);
__decorate3([
  AsnProp({ type: AttCertIssuer })
], AttributeCertificateInfo.prototype, "issuer", void 0);
__decorate3([
  AsnProp({ type: AlgorithmIdentifier })
], AttributeCertificateInfo.prototype, "signature", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], AttributeCertificateInfo.prototype, "serialNumber", void 0);
__decorate3([
  AsnProp({ type: AttCertValidityPeriod })
], AttributeCertificateInfo.prototype, "attrCertValidityPeriod", void 0);
__decorate3([
  AsnProp({ type: Attribute, repeated: "sequence" })
], AttributeCertificateInfo.prototype, "attributes", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.BitString, optional: true })
], AttributeCertificateInfo.prototype, "issuerUniqueID", void 0);
__decorate3([
  AsnProp({ type: Extensions, optional: true })
], AttributeCertificateInfo.prototype, "extensions", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate.js
var AttributeCertificate = class {
  constructor(params = {}) {
    this.acinfo = new AttributeCertificateInfo();
    this.signatureAlgorithm = new AlgorithmIdentifier();
    this.signatureValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: AttributeCertificateInfo })
], AttributeCertificate.prototype, "acinfo", void 0);
__decorate3([
  AsnProp({ type: AlgorithmIdentifier })
], AttributeCertificate.prototype, "signatureAlgorithm", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.BitString })
], AttributeCertificate.prototype, "signatureValue", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/class_list.js
var ClassListFlags;
(function(ClassListFlags2) {
  ClassListFlags2[ClassListFlags2["unmarked"] = 1] = "unmarked";
  ClassListFlags2[ClassListFlags2["unclassified"] = 2] = "unclassified";
  ClassListFlags2[ClassListFlags2["restricted"] = 4] = "restricted";
  ClassListFlags2[ClassListFlags2["confidential"] = 8] = "confidential";
  ClassListFlags2[ClassListFlags2["secret"] = 16] = "secret";
  ClassListFlags2[ClassListFlags2["topSecret"] = 32] = "topSecret";
})(ClassListFlags || (ClassListFlags = {}));
var ClassList = class extends BitString2 {
};

// node_modules/@peculiar/asn1-x509-attr/build/es2015/security_category.js
var SecurityCategory = class {
  constructor(params = {}) {
    this.type = "";
    this.value = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier, implicit: true, context: 0 })
], SecurityCategory.prototype, "type", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.Any, implicit: true, context: 1 })
], SecurityCategory.prototype, "value", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/clearance.js
var Clearance = class {
  constructor(params = {}) {
    this.policyId = "";
    this.classList = new ClassList(ClassListFlags.unclassified);
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], Clearance.prototype, "policyId", void 0);
__decorate3([
  AsnProp({ type: ClassList, defaultValue: new ClassList(ClassListFlags.unclassified) })
], Clearance.prototype, "classList", void 0);
__decorate3([
  AsnProp({ type: SecurityCategory, repeated: "set" })
], Clearance.prototype, "securityCategories", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/ietf_attr_syntax.js
var IetfAttrSyntaxValueChoices = class {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: OctetString2 })
], IetfAttrSyntaxValueChoices.prototype, "cotets", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], IetfAttrSyntaxValueChoices.prototype, "oid", void 0);
__decorate3([
  AsnProp({ type: AsnPropTypes.Utf8String })
], IetfAttrSyntaxValueChoices.prototype, "string", void 0);
var IetfAttrSyntax = class {
  constructor(params = {}) {
    this.values = [];
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: GeneralNames, implicit: true, context: 0, optional: true })
], IetfAttrSyntax.prototype, "policyAuthority", void 0);
__decorate3([
  AsnProp({ type: IetfAttrSyntaxValueChoices, repeated: "sequence" })
], IetfAttrSyntax.prototype, "values", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/object_identifiers.js
var id_pe_ac_auditIdentity = `${id_pe}.4`;
var id_pe_aaControls = `${id_pe}.6`;
var id_pe_ac_proxying = `${id_pe}.10`;
var id_ce_targetInformation = `${id_ce}.55`;
var id_aca = `${id_pkix}.10`;
var id_aca_authenticationInfo = `${id_aca}.1`;
var id_aca_accessIdentity = `${id_aca}.2`;
var id_aca_chargingIdentity = `${id_aca}.3`;
var id_aca_group = `${id_aca}.4`;
var id_aca_encAttrs = `${id_aca}.6`;
var id_at = "2.5.4";
var id_at_role = `${id_at}.72`;

// node_modules/@peculiar/asn1-x509-attr/build/es2015/target.js
var Targets_1;
var TargetCert = class {
  constructor(params = {}) {
    this.targetCertificate = new IssuerSerial();
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: IssuerSerial })
], TargetCert.prototype, "targetCertificate", void 0);
__decorate3([
  AsnProp({ type: GeneralName, optional: true })
], TargetCert.prototype, "targetName", void 0);
__decorate3([
  AsnProp({ type: ObjectDigestInfo, optional: true })
], TargetCert.prototype, "certDigestInfo", void 0);
var Target = class Target2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: GeneralName, context: 0, implicit: true })
], Target.prototype, "targetName", void 0);
__decorate3([
  AsnProp({ type: GeneralName, context: 1, implicit: true })
], Target.prototype, "targetGroup", void 0);
__decorate3([
  AsnProp({ type: TargetCert, context: 2, implicit: true })
], Target.prototype, "targetCert", void 0);
Target = __decorate3([
  AsnType({ type: AsnTypeTypes.Choice })
], Target);
var Targets = Targets_1 = class Targets2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Targets_1.prototype);
  }
};
Targets = Targets_1 = __decorate3([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: Target })
], Targets);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/proxy_info.js
var ProxyInfo_1;
var ProxyInfo = ProxyInfo_1 = class ProxyInfo2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ProxyInfo_1.prototype);
  }
};
ProxyInfo = ProxyInfo_1 = __decorate3([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: Targets })
], ProxyInfo);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/role_syntax.js
var RoleSyntax = class {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: GeneralNames, implicit: true, context: 0, optional: true })
], RoleSyntax.prototype, "roleAuthority", void 0);
__decorate3([
  AsnProp({ type: GeneralName, implicit: true, context: 1 })
], RoleSyntax.prototype, "roleName", void 0);

// node_modules/@peculiar/asn1-x509-attr/build/es2015/svce_auth_info.js
var SvceAuthInfo = class {
  constructor(params = {}) {
    this.service = new GeneralName();
    this.ident = new GeneralName();
    Object.assign(this, params);
  }
};
__decorate3([
  AsnProp({ type: GeneralName })
], SvceAuthInfo.prototype, "service", void 0);
__decorate3([
  AsnProp({ type: GeneralName })
], SvceAuthInfo.prototype, "ident", void 0);
__decorate3([
  AsnProp({ type: OctetString2, optional: true })
], SvceAuthInfo.prototype, "authInfo", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/certificate_choices.js
var CertificateSet_1;
var OtherCertificateFormat = class {
  constructor(params = {}) {
    this.otherCertFormat = "";
    this.otherCert = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], OtherCertificateFormat.prototype, "otherCertFormat", void 0);
__decorate2([
  AsnProp({ type: AsnPropTypes.Any })
], OtherCertificateFormat.prototype, "otherCert", void 0);
var CertificateChoices = class CertificateChoices2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: Certificate })
], CertificateChoices.prototype, "certificate", void 0);
__decorate2([
  AsnProp({ type: AttributeCertificate, context: 2, implicit: true })
], CertificateChoices.prototype, "v2AttrCert", void 0);
__decorate2([
  AsnProp({ type: OtherCertificateFormat, context: 3, implicit: true })
], CertificateChoices.prototype, "other", void 0);
CertificateChoices = __decorate2([
  AsnType({ type: AsnTypeTypes.Choice })
], CertificateChoices);
var CertificateSet = CertificateSet_1 = class CertificateSet2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, CertificateSet_1.prototype);
  }
};
CertificateSet = CertificateSet_1 = __decorate2([
  AsnType({ type: AsnTypeTypes.Set, itemType: CertificateChoices })
], CertificateSet);

// node_modules/@peculiar/asn1-cms/build/es2015/content_info.js
var ContentInfo = class {
  constructor(params = {}) {
    this.contentType = "";
    this.content = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], ContentInfo.prototype, "contentType", void 0);
__decorate2([
  AsnProp({ type: AsnPropTypes.Any, context: 0 })
], ContentInfo.prototype, "content", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/encapsulated_content_info.js
var EncapsulatedContent = class EncapsulatedContent2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: OctetString2 })
], EncapsulatedContent.prototype, "single", void 0);
__decorate2([
  AsnProp({ type: AsnPropTypes.Any })
], EncapsulatedContent.prototype, "any", void 0);
EncapsulatedContent = __decorate2([
  AsnType({ type: AsnTypeTypes.Choice })
], EncapsulatedContent);
var EncapsulatedContentInfo = class {
  constructor(params = {}) {
    this.eContentType = "";
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], EncapsulatedContentInfo.prototype, "eContentType", void 0);
__decorate2([
  AsnProp({ type: EncapsulatedContent, context: 0, optional: true })
], EncapsulatedContentInfo.prototype, "eContent", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/encrypted_content_info.js
var EncryptedContent = class EncryptedContent2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: OctetString2, context: 0, implicit: true, optional: true })
], EncryptedContent.prototype, "value", void 0);
__decorate2([
  AsnProp({
    type: OctetString2,
    converter: AsnConstructedOctetStringConverter,
    context: 0,
    implicit: true,
    optional: true,
    repeated: "sequence"
  })
], EncryptedContent.prototype, "constructedValue", void 0);
EncryptedContent = __decorate2([
  AsnType({ type: AsnTypeTypes.Choice })
], EncryptedContent);
var EncryptedContentInfo = class {
  constructor(params = {}) {
    this.contentType = "";
    this.contentEncryptionAlgorithm = new ContentEncryptionAlgorithmIdentifier();
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], EncryptedContentInfo.prototype, "contentType", void 0);
__decorate2([
  AsnProp({ type: ContentEncryptionAlgorithmIdentifier })
], EncryptedContentInfo.prototype, "contentEncryptionAlgorithm", void 0);
__decorate2([
  AsnProp({ type: EncryptedContent, optional: true })
], EncryptedContentInfo.prototype, "encryptedContent", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/other_key_attribute.js
var OtherKeyAttribute = class {
  constructor(params = {}) {
    this.keyAttrId = "";
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], OtherKeyAttribute.prototype, "keyAttrId", void 0);
__decorate2([
  AsnProp({ type: AsnPropTypes.Any, optional: true })
], OtherKeyAttribute.prototype, "keyAttr", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/key_agree_recipient_info.js
var RecipientEncryptedKeys_1;
var RecipientKeyIdentifier = class {
  constructor(params = {}) {
    this.subjectKeyIdentifier = new SubjectKeyIdentifier();
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: SubjectKeyIdentifier })
], RecipientKeyIdentifier.prototype, "subjectKeyIdentifier", void 0);
__decorate2([
  AsnProp({ type: AsnPropTypes.GeneralizedTime, optional: true })
], RecipientKeyIdentifier.prototype, "date", void 0);
__decorate2([
  AsnProp({ type: OtherKeyAttribute, optional: true })
], RecipientKeyIdentifier.prototype, "other", void 0);
var KeyAgreeRecipientIdentifier = class KeyAgreeRecipientIdentifier2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: RecipientKeyIdentifier, context: 0, implicit: true, optional: true })
], KeyAgreeRecipientIdentifier.prototype, "rKeyId", void 0);
__decorate2([
  AsnProp({ type: IssuerAndSerialNumber, optional: true })
], KeyAgreeRecipientIdentifier.prototype, "issuerAndSerialNumber", void 0);
KeyAgreeRecipientIdentifier = __decorate2([
  AsnType({ type: AsnTypeTypes.Choice })
], KeyAgreeRecipientIdentifier);
var RecipientEncryptedKey = class {
  constructor(params = {}) {
    this.rid = new KeyAgreeRecipientIdentifier();
    this.encryptedKey = new OctetString2();
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: KeyAgreeRecipientIdentifier })
], RecipientEncryptedKey.prototype, "rid", void 0);
__decorate2([
  AsnProp({ type: OctetString2 })
], RecipientEncryptedKey.prototype, "encryptedKey", void 0);
var RecipientEncryptedKeys = RecipientEncryptedKeys_1 = class RecipientEncryptedKeys2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RecipientEncryptedKeys_1.prototype);
  }
};
RecipientEncryptedKeys = RecipientEncryptedKeys_1 = __decorate2([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: RecipientEncryptedKey })
], RecipientEncryptedKeys);
var OriginatorPublicKey = class {
  constructor(params = {}) {
    this.algorithm = new AlgorithmIdentifier();
    this.publicKey = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AlgorithmIdentifier })
], OriginatorPublicKey.prototype, "algorithm", void 0);
__decorate2([
  AsnProp({ type: AsnPropTypes.BitString })
], OriginatorPublicKey.prototype, "publicKey", void 0);
var OriginatorIdentifierOrKey = class OriginatorIdentifierOrKey2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: SubjectKeyIdentifier, context: 0, implicit: true, optional: true })
], OriginatorIdentifierOrKey.prototype, "subjectKeyIdentifier", void 0);
__decorate2([
  AsnProp({ type: OriginatorPublicKey, context: 1, implicit: true, optional: true })
], OriginatorIdentifierOrKey.prototype, "originatorKey", void 0);
__decorate2([
  AsnProp({ type: IssuerAndSerialNumber, optional: true })
], OriginatorIdentifierOrKey.prototype, "issuerAndSerialNumber", void 0);
OriginatorIdentifierOrKey = __decorate2([
  AsnType({ type: AsnTypeTypes.Choice })
], OriginatorIdentifierOrKey);
var KeyAgreeRecipientInfo = class {
  constructor(params = {}) {
    this.version = CMSVersion.v3;
    this.originator = new OriginatorIdentifierOrKey();
    this.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier();
    this.recipientEncryptedKeys = new RecipientEncryptedKeys();
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.Integer })
], KeyAgreeRecipientInfo.prototype, "version", void 0);
__decorate2([
  AsnProp({ type: OriginatorIdentifierOrKey, context: 0 })
], KeyAgreeRecipientInfo.prototype, "originator", void 0);
__decorate2([
  AsnProp({ type: OctetString2, context: 1, optional: true })
], KeyAgreeRecipientInfo.prototype, "ukm", void 0);
__decorate2([
  AsnProp({ type: KeyEncryptionAlgorithmIdentifier })
], KeyAgreeRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
__decorate2([
  AsnProp({ type: RecipientEncryptedKeys })
], KeyAgreeRecipientInfo.prototype, "recipientEncryptedKeys", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/key_trans_recipient_info.js
var RecipientIdentifier = class RecipientIdentifier2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: SubjectKeyIdentifier, context: 0, implicit: true })
], RecipientIdentifier.prototype, "subjectKeyIdentifier", void 0);
__decorate2([
  AsnProp({ type: IssuerAndSerialNumber })
], RecipientIdentifier.prototype, "issuerAndSerialNumber", void 0);
RecipientIdentifier = __decorate2([
  AsnType({ type: AsnTypeTypes.Choice })
], RecipientIdentifier);
var KeyTransRecipientInfo = class {
  constructor(params = {}) {
    this.version = CMSVersion.v0;
    this.rid = new RecipientIdentifier();
    this.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier();
    this.encryptedKey = new OctetString2();
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.Integer })
], KeyTransRecipientInfo.prototype, "version", void 0);
__decorate2([
  AsnProp({ type: RecipientIdentifier })
], KeyTransRecipientInfo.prototype, "rid", void 0);
__decorate2([
  AsnProp({ type: KeyEncryptionAlgorithmIdentifier })
], KeyTransRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
__decorate2([
  AsnProp({ type: OctetString2 })
], KeyTransRecipientInfo.prototype, "encryptedKey", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/kek_recipient_info.js
var KEKIdentifier = class {
  constructor(params = {}) {
    this.keyIdentifier = new OctetString2();
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: OctetString2 })
], KEKIdentifier.prototype, "keyIdentifier", void 0);
__decorate2([
  AsnProp({ type: AsnPropTypes.GeneralizedTime, optional: true })
], KEKIdentifier.prototype, "date", void 0);
__decorate2([
  AsnProp({ type: OtherKeyAttribute, optional: true })
], KEKIdentifier.prototype, "other", void 0);
var KEKRecipientInfo = class {
  constructor(params = {}) {
    this.version = CMSVersion.v4;
    this.kekid = new KEKIdentifier();
    this.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier();
    this.encryptedKey = new OctetString2();
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.Integer })
], KEKRecipientInfo.prototype, "version", void 0);
__decorate2([
  AsnProp({ type: KEKIdentifier })
], KEKRecipientInfo.prototype, "kekid", void 0);
__decorate2([
  AsnProp({ type: KeyEncryptionAlgorithmIdentifier })
], KEKRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
__decorate2([
  AsnProp({ type: OctetString2 })
], KEKRecipientInfo.prototype, "encryptedKey", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/password_recipient_info.js
var PasswordRecipientInfo = class {
  constructor(params = {}) {
    this.version = CMSVersion.v0;
    this.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier();
    this.encryptedKey = new OctetString2();
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.Integer })
], PasswordRecipientInfo.prototype, "version", void 0);
__decorate2([
  AsnProp({ type: KeyDerivationAlgorithmIdentifier, context: 0, optional: true })
], PasswordRecipientInfo.prototype, "keyDerivationAlgorithm", void 0);
__decorate2([
  AsnProp({ type: KeyEncryptionAlgorithmIdentifier })
], PasswordRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
__decorate2([
  AsnProp({ type: OctetString2 })
], PasswordRecipientInfo.prototype, "encryptedKey", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/recipient_info.js
var OtherRecipientInfo = class {
  constructor(params = {}) {
    this.oriType = "";
    this.oriValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], OtherRecipientInfo.prototype, "oriType", void 0);
__decorate2([
  AsnProp({ type: AsnPropTypes.Any })
], OtherRecipientInfo.prototype, "oriValue", void 0);
var RecipientInfo = class RecipientInfo2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: KeyTransRecipientInfo, optional: true })
], RecipientInfo.prototype, "ktri", void 0);
__decorate2([
  AsnProp({ type: KeyAgreeRecipientInfo, context: 1, implicit: true, optional: true })
], RecipientInfo.prototype, "kari", void 0);
__decorate2([
  AsnProp({ type: KEKRecipientInfo, context: 2, implicit: true, optional: true })
], RecipientInfo.prototype, "kekri", void 0);
__decorate2([
  AsnProp({ type: PasswordRecipientInfo, context: 3, implicit: true, optional: true })
], RecipientInfo.prototype, "pwri", void 0);
__decorate2([
  AsnProp({ type: OtherRecipientInfo, context: 4, implicit: true, optional: true })
], RecipientInfo.prototype, "ori", void 0);
RecipientInfo = __decorate2([
  AsnType({ type: AsnTypeTypes.Choice })
], RecipientInfo);

// node_modules/@peculiar/asn1-cms/build/es2015/recipient_infos.js
var RecipientInfos_1;
var RecipientInfos = RecipientInfos_1 = class RecipientInfos2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RecipientInfos_1.prototype);
  }
};
RecipientInfos = RecipientInfos_1 = __decorate2([
  AsnType({ type: AsnTypeTypes.Set, itemType: RecipientInfo })
], RecipientInfos);

// node_modules/@peculiar/asn1-cms/build/es2015/revocation_info_choice.js
var RevocationInfoChoices_1;
var id_ri = `${id_pkix}.16`;
var id_ri_ocsp_response = `${id_ri}.2`;
var id_ri_scvp = `${id_ri}.4`;
var OtherRevocationInfoFormat = class {
  constructor(params = {}) {
    this.otherRevInfoFormat = "";
    this.otherRevInfo = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], OtherRevocationInfoFormat.prototype, "otherRevInfoFormat", void 0);
__decorate2([
  AsnProp({ type: AsnPropTypes.Any })
], OtherRevocationInfoFormat.prototype, "otherRevInfo", void 0);
var RevocationInfoChoice = class RevocationInfoChoice2 {
  constructor(params = {}) {
    this.other = new OtherRevocationInfoFormat();
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: OtherRevocationInfoFormat, context: 1, implicit: true })
], RevocationInfoChoice.prototype, "other", void 0);
RevocationInfoChoice = __decorate2([
  AsnType({ type: AsnTypeTypes.Choice })
], RevocationInfoChoice);
var RevocationInfoChoices = RevocationInfoChoices_1 = class RevocationInfoChoices2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, RevocationInfoChoices_1.prototype);
  }
};
RevocationInfoChoices = RevocationInfoChoices_1 = __decorate2([
  AsnType({ type: AsnTypeTypes.Set, itemType: RevocationInfoChoice })
], RevocationInfoChoices);

// node_modules/@peculiar/asn1-cms/build/es2015/originator_info.js
var OriginatorInfo = class {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: CertificateSet, context: 0, implicit: true, optional: true })
], OriginatorInfo.prototype, "certs", void 0);
__decorate2([
  AsnProp({ type: RevocationInfoChoices, context: 1, implicit: true, optional: true })
], OriginatorInfo.prototype, "crls", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/enveloped_data.js
var UnprotectedAttributes_1;
var UnprotectedAttributes = UnprotectedAttributes_1 = class UnprotectedAttributes2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, UnprotectedAttributes_1.prototype);
  }
};
UnprotectedAttributes = UnprotectedAttributes_1 = __decorate2([
  AsnType({ type: AsnTypeTypes.Set, itemType: Attribute2 })
], UnprotectedAttributes);
var EnvelopedData = class {
  constructor(params = {}) {
    this.version = CMSVersion.v0;
    this.recipientInfos = new RecipientInfos();
    this.encryptedContentInfo = new EncryptedContentInfo();
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.Integer })
], EnvelopedData.prototype, "version", void 0);
__decorate2([
  AsnProp({ type: OriginatorInfo, context: 0, implicit: true, optional: true })
], EnvelopedData.prototype, "originatorInfo", void 0);
__decorate2([
  AsnProp({ type: RecipientInfos })
], EnvelopedData.prototype, "recipientInfos", void 0);
__decorate2([
  AsnProp({ type: EncryptedContentInfo })
], EnvelopedData.prototype, "encryptedContentInfo", void 0);
__decorate2([
  AsnProp({ type: UnprotectedAttributes, context: 1, implicit: true, optional: true })
], EnvelopedData.prototype, "unprotectedAttrs", void 0);

// node_modules/@peculiar/asn1-cms/build/es2015/object_identifiers.js
var id_signedData = "1.2.840.113549.1.7.2";

// node_modules/@peculiar/asn1-cms/build/es2015/signed_data.js
var DigestAlgorithmIdentifiers_1;
var DigestAlgorithmIdentifiers = DigestAlgorithmIdentifiers_1 = class DigestAlgorithmIdentifiers2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, DigestAlgorithmIdentifiers_1.prototype);
  }
};
DigestAlgorithmIdentifiers = DigestAlgorithmIdentifiers_1 = __decorate2([
  AsnType({ type: AsnTypeTypes.Set, itemType: DigestAlgorithmIdentifier })
], DigestAlgorithmIdentifiers);
var SignedData = class {
  constructor(params = {}) {
    this.version = CMSVersion.v0;
    this.digestAlgorithms = new DigestAlgorithmIdentifiers();
    this.encapContentInfo = new EncapsulatedContentInfo();
    this.signerInfos = new SignerInfos();
    Object.assign(this, params);
  }
};
__decorate2([
  AsnProp({ type: AsnPropTypes.Integer })
], SignedData.prototype, "version", void 0);
__decorate2([
  AsnProp({ type: DigestAlgorithmIdentifiers })
], SignedData.prototype, "digestAlgorithms", void 0);
__decorate2([
  AsnProp({ type: EncapsulatedContentInfo })
], SignedData.prototype, "encapContentInfo", void 0);
__decorate2([
  AsnProp({ type: CertificateSet, context: 0, implicit: true, optional: true })
], SignedData.prototype, "certificates", void 0);
__decorate2([
  AsnProp({ type: RevocationInfoChoices, context: 1, implicit: true, optional: true })
], SignedData.prototype, "crls", void 0);
__decorate2([
  AsnProp({ type: SignerInfos })
], SignedData.prototype, "signerInfos", void 0);

// node_modules/@peculiar/asn1-ecc/build/es2015/object_identifiers.js
var id_ecPublicKey = "1.2.840.10045.2.1";
var id_ecdsaWithSHA1 = "1.2.840.10045.4.1";
var id_ecdsaWithSHA224 = "1.2.840.10045.4.3.1";
var id_ecdsaWithSHA256 = "1.2.840.10045.4.3.2";
var id_ecdsaWithSHA384 = "1.2.840.10045.4.3.3";
var id_ecdsaWithSHA512 = "1.2.840.10045.4.3.4";
var id_secp256r1 = "1.2.840.10045.3.1.7";
var id_secp384r1 = "1.3.132.0.34";
var id_secp521r1 = "1.3.132.0.35";

// node_modules/@peculiar/asn1-ecc/build/es2015/algorithms.js
function create12(algorithm) {
  return new AlgorithmIdentifier({ algorithm });
}
var ecdsaWithSHA1 = create12(id_ecdsaWithSHA1);
var ecdsaWithSHA224 = create12(id_ecdsaWithSHA224);
var ecdsaWithSHA256 = create12(id_ecdsaWithSHA256);
var ecdsaWithSHA384 = create12(id_ecdsaWithSHA384);
var ecdsaWithSHA512 = create12(id_ecdsaWithSHA512);

// node_modules/@peculiar/asn1-ecc/node_modules/tslib/tslib.es6.mjs
function __decorate4(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@peculiar/asn1-ecc/build/es2015/rfc3279.js
var FieldID = class FieldID2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate4([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], FieldID.prototype, "fieldType", void 0);
__decorate4([
  AsnProp({ type: AsnPropTypes.Any })
], FieldID.prototype, "parameters", void 0);
FieldID = __decorate4([
  AsnType({ type: AsnTypeTypes.Sequence })
], FieldID);
var ECPoint = class extends OctetString2 {
};
var Curve = class Curve2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate4([
  AsnProp({ type: AsnPropTypes.OctetString })
], Curve.prototype, "a", void 0);
__decorate4([
  AsnProp({ type: AsnPropTypes.OctetString })
], Curve.prototype, "b", void 0);
__decorate4([
  AsnProp({ type: AsnPropTypes.BitString, optional: true })
], Curve.prototype, "seed", void 0);
Curve = __decorate4([
  AsnType({ type: AsnTypeTypes.Sequence })
], Curve);
var ECPVer;
(function(ECPVer2) {
  ECPVer2[ECPVer2["ecpVer1"] = 1] = "ecpVer1";
})(ECPVer || (ECPVer = {}));
var SpecifiedECDomain = class SpecifiedECDomain2 {
  constructor(params = {}) {
    this.version = ECPVer.ecpVer1;
    Object.assign(this, params);
  }
};
__decorate4([
  AsnProp({ type: AsnPropTypes.Integer })
], SpecifiedECDomain.prototype, "version", void 0);
__decorate4([
  AsnProp({ type: FieldID })
], SpecifiedECDomain.prototype, "fieldID", void 0);
__decorate4([
  AsnProp({ type: Curve })
], SpecifiedECDomain.prototype, "curve", void 0);
__decorate4([
  AsnProp({ type: ECPoint })
], SpecifiedECDomain.prototype, "base", void 0);
__decorate4([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], SpecifiedECDomain.prototype, "order", void 0);
__decorate4([
  AsnProp({ type: AsnPropTypes.Integer, optional: true })
], SpecifiedECDomain.prototype, "cofactor", void 0);
SpecifiedECDomain = __decorate4([
  AsnType({ type: AsnTypeTypes.Sequence })
], SpecifiedECDomain);

// node_modules/@peculiar/asn1-ecc/build/es2015/ec_parameters.js
var ECParameters = class ECParameters2 {
  constructor(params = {}) {
    Object.assign(this, params);
  }
};
__decorate4([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], ECParameters.prototype, "namedCurve", void 0);
__decorate4([
  AsnProp({ type: AsnPropTypes.Null })
], ECParameters.prototype, "implicitCurve", void 0);
__decorate4([
  AsnProp({ type: SpecifiedECDomain })
], ECParameters.prototype, "specifiedCurve", void 0);
ECParameters = __decorate4([
  AsnType({ type: AsnTypeTypes.Choice })
], ECParameters);

// node_modules/@peculiar/asn1-ecc/build/es2015/ec_private_key.js
var ECPrivateKey = class {
  constructor(params = {}) {
    this.version = 1;
    this.privateKey = new OctetString2();
    Object.assign(this, params);
  }
};
__decorate4([
  AsnProp({ type: AsnPropTypes.Integer })
], ECPrivateKey.prototype, "version", void 0);
__decorate4([
  AsnProp({ type: OctetString2 })
], ECPrivateKey.prototype, "privateKey", void 0);
__decorate4([
  AsnProp({ type: ECParameters, context: 0, optional: true })
], ECPrivateKey.prototype, "parameters", void 0);
__decorate4([
  AsnProp({ type: AsnPropTypes.BitString, context: 1, optional: true })
], ECPrivateKey.prototype, "publicKey", void 0);

// node_modules/@peculiar/asn1-ecc/build/es2015/ec_signature_value.js
var ECDSASigValue = class {
  constructor(params = {}) {
    this.r = new ArrayBuffer(0);
    this.s = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate4([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], ECDSASigValue.prototype, "r", void 0);
__decorate4([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], ECDSASigValue.prototype, "s", void 0);

// node_modules/@peculiar/asn1-rsa/node_modules/tslib/tslib.es6.mjs
function __decorate5(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js
var id_pkcs_1 = "1.2.840.113549.1.1";
var id_rsaEncryption = `${id_pkcs_1}.1`;
var id_RSAES_OAEP = `${id_pkcs_1}.7`;
var id_pSpecified = `${id_pkcs_1}.9`;
var id_RSASSA_PSS = `${id_pkcs_1}.10`;
var id_md2WithRSAEncryption = `${id_pkcs_1}.2`;
var id_md5WithRSAEncryption = `${id_pkcs_1}.4`;
var id_sha1WithRSAEncryption = `${id_pkcs_1}.5`;
var id_sha224WithRSAEncryption = `${id_pkcs_1}.14`;
var id_sha256WithRSAEncryption = `${id_pkcs_1}.11`;
var id_sha384WithRSAEncryption = `${id_pkcs_1}.12`;
var id_sha512WithRSAEncryption = `${id_pkcs_1}.13`;
var id_sha512_224WithRSAEncryption = `${id_pkcs_1}.15`;
var id_sha512_256WithRSAEncryption = `${id_pkcs_1}.16`;
var id_sha1 = "1.3.14.3.2.26";
var id_sha224 = "2.16.840.1.101.3.4.2.4";
var id_sha256 = "2.16.840.1.101.3.4.2.1";
var id_sha384 = "2.16.840.1.101.3.4.2.2";
var id_sha512 = "2.16.840.1.101.3.4.2.3";
var id_sha512_224 = "2.16.840.1.101.3.4.2.5";
var id_sha512_256 = "2.16.840.1.101.3.4.2.6";
var id_md2 = "1.2.840.113549.2.2";
var id_md5 = "1.2.840.113549.2.5";
var id_mgf1 = `${id_pkcs_1}.8`;

// node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js
function create13(algorithm) {
  return new AlgorithmIdentifier({ algorithm, parameters: null });
}
var md2 = create13(id_md2);
var md4 = create13(id_md5);
var sha1 = create13(id_sha1);
var sha224 = create13(id_sha224);
var sha2568 = create13(id_sha256);
var sha384 = create13(id_sha384);
var sha5128 = create13(id_sha512);
var sha512_224 = create13(id_sha512_224);
var sha512_256 = create13(id_sha512_256);
var mgf1SHA1 = new AlgorithmIdentifier({
  algorithm: id_mgf1,
  parameters: AsnConvert.serialize(sha1)
});
var pSpecifiedEmpty = new AlgorithmIdentifier({
  algorithm: id_pSpecified,
  parameters: AsnConvert.serialize(AsnOctetStringConverter.toASN(new Uint8Array([
    218,
    57,
    163,
    238,
    94,
    107,
    75,
    13,
    50,
    85,
    191,
    239,
    149,
    96,
    24,
    144,
    175,
    216,
    7,
    9
  ]).buffer))
});
var rsaEncryption = create13(id_rsaEncryption);
var md2WithRSAEncryption = create13(id_md2WithRSAEncryption);
var md5WithRSAEncryption = create13(id_md5WithRSAEncryption);
var sha1WithRSAEncryption = create13(id_sha1WithRSAEncryption);
var sha224WithRSAEncryption = create13(id_sha512_224WithRSAEncryption);
var sha256WithRSAEncryption = create13(id_sha512_256WithRSAEncryption);
var sha384WithRSAEncryption = create13(id_sha384WithRSAEncryption);
var sha512WithRSAEncryption = create13(id_sha512WithRSAEncryption);
var sha512_224WithRSAEncryption = create13(id_sha512_224WithRSAEncryption);
var sha512_256WithRSAEncryption = create13(id_sha512_256WithRSAEncryption);

// node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsaes_oaep.js
var RsaEsOaepParams = class {
  constructor(params = {}) {
    this.hashAlgorithm = new AlgorithmIdentifier(sha1);
    this.maskGenAlgorithm = new AlgorithmIdentifier({
      algorithm: id_mgf1,
      parameters: AsnConvert.serialize(sha1)
    });
    this.pSourceAlgorithm = new AlgorithmIdentifier(pSpecifiedEmpty);
    Object.assign(this, params);
  }
};
__decorate5([
  AsnProp({ type: AlgorithmIdentifier, context: 0, defaultValue: sha1 })
], RsaEsOaepParams.prototype, "hashAlgorithm", void 0);
__decorate5([
  AsnProp({ type: AlgorithmIdentifier, context: 1, defaultValue: mgf1SHA1 })
], RsaEsOaepParams.prototype, "maskGenAlgorithm", void 0);
__decorate5([
  AsnProp({ type: AlgorithmIdentifier, context: 2, defaultValue: pSpecifiedEmpty })
], RsaEsOaepParams.prototype, "pSourceAlgorithm", void 0);
var RSAES_OAEP = new AlgorithmIdentifier({
  algorithm: id_RSAES_OAEP,
  parameters: AsnConvert.serialize(new RsaEsOaepParams())
});

// node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pss.js
var RsaSaPssParams = class {
  constructor(params = {}) {
    this.hashAlgorithm = new AlgorithmIdentifier(sha1);
    this.maskGenAlgorithm = new AlgorithmIdentifier({
      algorithm: id_mgf1,
      parameters: AsnConvert.serialize(sha1)
    });
    this.saltLength = 20;
    this.trailerField = 1;
    Object.assign(this, params);
  }
};
__decorate5([
  AsnProp({ type: AlgorithmIdentifier, context: 0, defaultValue: sha1 })
], RsaSaPssParams.prototype, "hashAlgorithm", void 0);
__decorate5([
  AsnProp({ type: AlgorithmIdentifier, context: 1, defaultValue: mgf1SHA1 })
], RsaSaPssParams.prototype, "maskGenAlgorithm", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, context: 2, defaultValue: 20 })
], RsaSaPssParams.prototype, "saltLength", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, context: 3, defaultValue: 1 })
], RsaSaPssParams.prototype, "trailerField", void 0);
var RSASSA_PSS = new AlgorithmIdentifier({
  algorithm: id_RSASSA_PSS,
  parameters: AsnConvert.serialize(new RsaSaPssParams())
});

// node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pkcs1_v1_5.js
var DigestInfo = class {
  constructor(params = {}) {
    this.digestAlgorithm = new AlgorithmIdentifier();
    this.digest = new OctetString2();
    Object.assign(this, params);
  }
};
__decorate5([
  AsnProp({ type: AlgorithmIdentifier })
], DigestInfo.prototype, "digestAlgorithm", void 0);
__decorate5([
  AsnProp({ type: OctetString2 })
], DigestInfo.prototype, "digest", void 0);

// node_modules/@peculiar/asn1-rsa/build/es2015/other_prime_info.js
var OtherPrimeInfos_1;
var OtherPrimeInfo = class {
  constructor(params = {}) {
    this.prime = new ArrayBuffer(0);
    this.exponent = new ArrayBuffer(0);
    this.coefficient = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], OtherPrimeInfo.prototype, "prime", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], OtherPrimeInfo.prototype, "exponent", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], OtherPrimeInfo.prototype, "coefficient", void 0);
var OtherPrimeInfos = OtherPrimeInfos_1 = class OtherPrimeInfos2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, OtherPrimeInfos_1.prototype);
  }
};
OtherPrimeInfos = OtherPrimeInfos_1 = __decorate5([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: OtherPrimeInfo })
], OtherPrimeInfos);

// node_modules/@peculiar/asn1-rsa/build/es2015/rsa_private_key.js
var RSAPrivateKey = class {
  constructor(params = {}) {
    this.version = 0;
    this.modulus = new ArrayBuffer(0);
    this.publicExponent = new ArrayBuffer(0);
    this.privateExponent = new ArrayBuffer(0);
    this.prime1 = new ArrayBuffer(0);
    this.prime2 = new ArrayBuffer(0);
    this.exponent1 = new ArrayBuffer(0);
    this.exponent2 = new ArrayBuffer(0);
    this.coefficient = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer })
], RSAPrivateKey.prototype, "version", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "modulus", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "publicExponent", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "privateExponent", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "prime1", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "prime2", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "exponent1", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "exponent2", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPrivateKey.prototype, "coefficient", void 0);
__decorate5([
  AsnProp({ type: OtherPrimeInfos, optional: true })
], RSAPrivateKey.prototype, "otherPrimeInfos", void 0);

// node_modules/@peculiar/asn1-rsa/build/es2015/rsa_public_key.js
var RSAPublicKey = class {
  constructor(params = {}) {
    this.modulus = new ArrayBuffer(0);
    this.publicExponent = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPublicKey.prototype, "modulus", void 0);
__decorate5([
  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
], RSAPublicKey.prototype, "publicExponent", void 0);

// node_modules/@peculiar/x509/node_modules/tslib/tslib.es6.mjs
function __decorate6(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/tsyringe/dist/esm5/types/lifecycle.js
var Lifecycle;
(function(Lifecycle2) {
  Lifecycle2[Lifecycle2["Transient"] = 0] = "Transient";
  Lifecycle2[Lifecycle2["Singleton"] = 1] = "Singleton";
  Lifecycle2[Lifecycle2["ResolutionScoped"] = 2] = "ResolutionScoped";
  Lifecycle2[Lifecycle2["ContainerScoped"] = 3] = "ContainerScoped";
})(Lifecycle || (Lifecycle = {}));
var lifecycle_default = Lifecycle;

// node_modules/tsyringe/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value7) {
    return value7 instanceof P ? value7 : new P(function(resolve) {
      resolve(value7);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value7) {
      try {
        step(generator.next(value7));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value7) {
      try {
        step(generator["throw"](value7));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}

// node_modules/tsyringe/dist/esm5/reflection-helpers.js
var INJECTION_TOKEN_METADATA_KEY = "injectionTokens";
function getParamInfo(target) {
  var params = Reflect.getMetadata("design:paramtypes", target) || [];
  var injectionTokens = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
  Object.keys(injectionTokens).forEach(function(key) {
    params[+key] = injectionTokens[key];
  });
  return params;
}

// node_modules/tsyringe/dist/esm5/providers/class-provider.js
function isClassProvider(provider) {
  return !!provider.useClass;
}

// node_modules/tsyringe/dist/esm5/providers/factory-provider.js
function isFactoryProvider(provider) {
  return !!provider.useFactory;
}

// node_modules/tsyringe/dist/esm5/lazy-helpers.js
var DelayedConstructor = function() {
  function DelayedConstructor2(wrap) {
    this.wrap = wrap;
    this.reflectMethods = [
      "get",
      "getPrototypeOf",
      "setPrototypeOf",
      "getOwnPropertyDescriptor",
      "defineProperty",
      "has",
      "set",
      "deleteProperty",
      "apply",
      "construct",
      "ownKeys"
    ];
  }
  DelayedConstructor2.prototype.createProxy = function(createObject) {
    var _this = this;
    var target = {};
    var init = false;
    var value7;
    var delayedObject = function() {
      if (!init) {
        value7 = createObject(_this.wrap());
        init = true;
      }
      return value7;
    };
    return new Proxy(target, this.createHandler(delayedObject));
  };
  DelayedConstructor2.prototype.createHandler = function(delayedObject) {
    var handler = {};
    var install = function(name9) {
      handler[name9] = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        args[0] = delayedObject();
        var method = Reflect[name9];
        return method.apply(void 0, __spread(args));
      };
    };
    this.reflectMethods.forEach(install);
    return handler;
  };
  return DelayedConstructor2;
}();

// node_modules/tsyringe/dist/esm5/providers/injection-token.js
function isNormalToken(token) {
  return typeof token === "string" || typeof token === "symbol";
}
function isTokenDescriptor(descriptor) {
  return typeof descriptor === "object" && "token" in descriptor && "multiple" in descriptor;
}
function isTransformDescriptor(descriptor) {
  return typeof descriptor === "object" && "token" in descriptor && "transform" in descriptor;
}
function isConstructorToken(token) {
  return typeof token === "function" || token instanceof DelayedConstructor;
}

// node_modules/tsyringe/dist/esm5/providers/token-provider.js
function isTokenProvider(provider) {
  return !!provider.useToken;
}

// node_modules/tsyringe/dist/esm5/providers/value-provider.js
function isValueProvider(provider) {
  return provider.useValue != void 0;
}

// node_modules/tsyringe/dist/esm5/providers/provider.js
function isProvider(provider) {
  return isClassProvider(provider) || isValueProvider(provider) || isTokenProvider(provider) || isFactoryProvider(provider);
}

// node_modules/tsyringe/dist/esm5/registry-base.js
var RegistryBase = function() {
  function RegistryBase2() {
    this._registryMap = /* @__PURE__ */ new Map();
  }
  RegistryBase2.prototype.entries = function() {
    return this._registryMap.entries();
  };
  RegistryBase2.prototype.getAll = function(key) {
    this.ensure(key);
    return this._registryMap.get(key);
  };
  RegistryBase2.prototype.get = function(key) {
    this.ensure(key);
    var value7 = this._registryMap.get(key);
    return value7[value7.length - 1] || null;
  };
  RegistryBase2.prototype.set = function(key, value7) {
    this.ensure(key);
    this._registryMap.get(key).push(value7);
  };
  RegistryBase2.prototype.setAll = function(key, value7) {
    this._registryMap.set(key, value7);
  };
  RegistryBase2.prototype.has = function(key) {
    this.ensure(key);
    return this._registryMap.get(key).length > 0;
  };
  RegistryBase2.prototype.clear = function() {
    this._registryMap.clear();
  };
  RegistryBase2.prototype.ensure = function(key) {
    if (!this._registryMap.has(key)) {
      this._registryMap.set(key, []);
    }
  };
  return RegistryBase2;
}();
var registry_base_default = RegistryBase;

// node_modules/tsyringe/dist/esm5/registry.js
var Registry = function(_super) {
  __extends(Registry2, _super);
  function Registry2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return Registry2;
}(registry_base_default);
var registry_default = Registry;

// node_modules/tsyringe/dist/esm5/resolution-context.js
var ResolutionContext = /* @__PURE__ */ function() {
  function ResolutionContext2() {
    this.scopedResolutions = /* @__PURE__ */ new Map();
  }
  return ResolutionContext2;
}();
var resolution_context_default = ResolutionContext;

// node_modules/tsyringe/dist/esm5/error-helpers.js
function formatDependency(params, idx) {
  if (params === null) {
    return "at position #" + idx;
  }
  var argName = params.split(",")[idx].trim();
  return '"' + argName + '" at position #' + idx;
}
function composeErrorMessage(msg, e, indent) {
  if (indent === void 0) {
    indent = "    ";
  }
  return __spread([msg], e.message.split("\n").map(function(l) {
    return indent + l;
  })).join("\n");
}
function formatErrorCtor(ctor, paramIdx, error) {
  var _a3 = __read(ctor.toString().match(/constructor\(([\w, ]+)\)/) || [], 2), _b = _a3[1], params = _b === void 0 ? null : _b;
  var dep = formatDependency(params, paramIdx);
  return composeErrorMessage("Cannot inject the dependency " + dep + ' of "' + ctor.name + '" constructor. Reason:', error);
}

// node_modules/tsyringe/dist/esm5/types/disposable.js
function isDisposable(value7) {
  if (typeof value7.dispose !== "function")
    return false;
  var disposeFun = value7.dispose;
  if (disposeFun.length > 0) {
    return false;
  }
  return true;
}

// node_modules/tsyringe/dist/esm5/interceptors.js
var PreResolutionInterceptors = function(_super) {
  __extends(PreResolutionInterceptors2, _super);
  function PreResolutionInterceptors2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return PreResolutionInterceptors2;
}(registry_base_default);
var PostResolutionInterceptors = function(_super) {
  __extends(PostResolutionInterceptors2, _super);
  function PostResolutionInterceptors2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return PostResolutionInterceptors2;
}(registry_base_default);
var Interceptors = /* @__PURE__ */ function() {
  function Interceptors2() {
    this.preResolution = new PreResolutionInterceptors();
    this.postResolution = new PostResolutionInterceptors();
  }
  return Interceptors2;
}();
var interceptors_default = Interceptors;

// node_modules/tsyringe/dist/esm5/dependency-container.js
var typeInfo = /* @__PURE__ */ new Map();
var InternalDependencyContainer = function() {
  function InternalDependencyContainer2(parent) {
    this.parent = parent;
    this._registry = new registry_default();
    this.interceptors = new interceptors_default();
    this.disposed = false;
    this.disposables = /* @__PURE__ */ new Set();
  }
  InternalDependencyContainer2.prototype.register = function(token, providerOrConstructor, options2) {
    if (options2 === void 0) {
      options2 = { lifecycle: lifecycle_default.Transient };
    }
    this.ensureNotDisposed();
    var provider;
    if (!isProvider(providerOrConstructor)) {
      provider = { useClass: providerOrConstructor };
    } else {
      provider = providerOrConstructor;
    }
    if (isTokenProvider(provider)) {
      var path = [token];
      var tokenProvider = provider;
      while (tokenProvider != null) {
        var currentToken = tokenProvider.useToken;
        if (path.includes(currentToken)) {
          throw new Error("Token registration cycle detected! " + __spread(path, [currentToken]).join(" -> "));
        }
        path.push(currentToken);
        var registration = this._registry.get(currentToken);
        if (registration && isTokenProvider(registration.provider)) {
          tokenProvider = registration.provider;
        } else {
          tokenProvider = null;
        }
      }
    }
    if (options2.lifecycle === lifecycle_default.Singleton || options2.lifecycle == lifecycle_default.ContainerScoped || options2.lifecycle == lifecycle_default.ResolutionScoped) {
      if (isValueProvider(provider) || isFactoryProvider(provider)) {
        throw new Error('Cannot use lifecycle "' + lifecycle_default[options2.lifecycle] + '" with ValueProviders or FactoryProviders');
      }
    }
    this._registry.set(token, { provider, options: options2 });
    return this;
  };
  InternalDependencyContainer2.prototype.registerType = function(from22, to) {
    this.ensureNotDisposed();
    if (isNormalToken(to)) {
      return this.register(from22, {
        useToken: to
      });
    }
    return this.register(from22, {
      useClass: to
    });
  };
  InternalDependencyContainer2.prototype.registerInstance = function(token, instance2) {
    this.ensureNotDisposed();
    return this.register(token, {
      useValue: instance2
    });
  };
  InternalDependencyContainer2.prototype.registerSingleton = function(from22, to) {
    this.ensureNotDisposed();
    if (isNormalToken(from22)) {
      if (isNormalToken(to)) {
        return this.register(from22, {
          useToken: to
        }, { lifecycle: lifecycle_default.Singleton });
      } else if (to) {
        return this.register(from22, {
          useClass: to
        }, { lifecycle: lifecycle_default.Singleton });
      }
      throw new Error('Cannot register a type name as a singleton without a "to" token');
    }
    var useClass = from22;
    if (to && !isNormalToken(to)) {
      useClass = to;
    }
    return this.register(from22, {
      useClass
    }, { lifecycle: lifecycle_default.Singleton });
  };
  InternalDependencyContainer2.prototype.resolve = function(token, context, isOptional) {
    if (context === void 0) {
      context = new resolution_context_default();
    }
    if (isOptional === void 0) {
      isOptional = false;
    }
    this.ensureNotDisposed();
    var registration = this.getRegistration(token);
    if (!registration && isNormalToken(token)) {
      if (isOptional) {
        return void 0;
      }
      throw new Error('Attempted to resolve unregistered dependency token: "' + token.toString() + '"');
    }
    this.executePreResolutionInterceptor(token, "Single");
    if (registration) {
      var result = this.resolveRegistration(registration, context);
      this.executePostResolutionInterceptor(token, result, "Single");
      return result;
    }
    if (isConstructorToken(token)) {
      var result = this.construct(token, context);
      this.executePostResolutionInterceptor(token, result, "Single");
      return result;
    }
    throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.");
  };
  InternalDependencyContainer2.prototype.executePreResolutionInterceptor = function(token, resolutionType) {
    var e_1, _a3;
    if (this.interceptors.preResolution.has(token)) {
      var remainingInterceptors = [];
      try {
        for (var _b = __values(this.interceptors.preResolution.getAll(token)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var interceptor = _c.value;
          if (interceptor.options.frequency != "Once") {
            remainingInterceptors.push(interceptor);
          }
          interceptor.callback(token, resolutionType);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return)) _a3.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      this.interceptors.preResolution.setAll(token, remainingInterceptors);
    }
  };
  InternalDependencyContainer2.prototype.executePostResolutionInterceptor = function(token, result, resolutionType) {
    var e_2, _a3;
    if (this.interceptors.postResolution.has(token)) {
      var remainingInterceptors = [];
      try {
        for (var _b = __values(this.interceptors.postResolution.getAll(token)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var interceptor = _c.value;
          if (interceptor.options.frequency != "Once") {
            remainingInterceptors.push(interceptor);
          }
          interceptor.callback(token, result, resolutionType);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return)) _a3.call(_b);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
      this.interceptors.postResolution.setAll(token, remainingInterceptors);
    }
  };
  InternalDependencyContainer2.prototype.resolveRegistration = function(registration, context) {
    this.ensureNotDisposed();
    if (registration.options.lifecycle === lifecycle_default.ResolutionScoped && context.scopedResolutions.has(registration)) {
      return context.scopedResolutions.get(registration);
    }
    var isSingleton = registration.options.lifecycle === lifecycle_default.Singleton;
    var isContainerScoped = registration.options.lifecycle === lifecycle_default.ContainerScoped;
    var returnInstance = isSingleton || isContainerScoped;
    var resolved;
    if (isValueProvider(registration.provider)) {
      resolved = registration.provider.useValue;
    } else if (isTokenProvider(registration.provider)) {
      resolved = returnInstance ? registration.instance || (registration.instance = this.resolve(registration.provider.useToken, context)) : this.resolve(registration.provider.useToken, context);
    } else if (isClassProvider(registration.provider)) {
      resolved = returnInstance ? registration.instance || (registration.instance = this.construct(registration.provider.useClass, context)) : this.construct(registration.provider.useClass, context);
    } else if (isFactoryProvider(registration.provider)) {
      resolved = registration.provider.useFactory(this);
    } else {
      resolved = this.construct(registration.provider, context);
    }
    if (registration.options.lifecycle === lifecycle_default.ResolutionScoped) {
      context.scopedResolutions.set(registration, resolved);
    }
    return resolved;
  };
  InternalDependencyContainer2.prototype.resolveAll = function(token, context, isOptional) {
    var _this = this;
    if (context === void 0) {
      context = new resolution_context_default();
    }
    if (isOptional === void 0) {
      isOptional = false;
    }
    this.ensureNotDisposed();
    var registrations = this.getAllRegistrations(token);
    if (!registrations && isNormalToken(token)) {
      if (isOptional) {
        return [];
      }
      throw new Error('Attempted to resolve unregistered dependency token: "' + token.toString() + '"');
    }
    this.executePreResolutionInterceptor(token, "All");
    if (registrations) {
      var result_1 = registrations.map(function(item) {
        return _this.resolveRegistration(item, context);
      });
      this.executePostResolutionInterceptor(token, result_1, "All");
      return result_1;
    }
    var result = [this.construct(token, context)];
    this.executePostResolutionInterceptor(token, result, "All");
    return result;
  };
  InternalDependencyContainer2.prototype.isRegistered = function(token, recursive) {
    if (recursive === void 0) {
      recursive = false;
    }
    this.ensureNotDisposed();
    return this._registry.has(token) || recursive && (this.parent || false) && this.parent.isRegistered(token, true);
  };
  InternalDependencyContainer2.prototype.reset = function() {
    this.ensureNotDisposed();
    this._registry.clear();
    this.interceptors.preResolution.clear();
    this.interceptors.postResolution.clear();
  };
  InternalDependencyContainer2.prototype.clearInstances = function() {
    var e_3, _a3;
    this.ensureNotDisposed();
    try {
      for (var _b = __values(this._registry.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2), token = _d[0], registrations = _d[1];
        this._registry.setAll(token, registrations.filter(function(registration) {
          return !isValueProvider(registration.provider);
        }).map(function(registration) {
          registration.instance = void 0;
          return registration;
        }));
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a3 = _b.return)) _a3.call(_b);
      } finally {
        if (e_3) throw e_3.error;
      }
    }
  };
  InternalDependencyContainer2.prototype.createChildContainer = function() {
    var e_4, _a3;
    this.ensureNotDisposed();
    var childContainer = new InternalDependencyContainer2(this);
    try {
      for (var _b = __values(this._registry.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2), token = _d[0], registrations = _d[1];
        if (registrations.some(function(_a4) {
          var options2 = _a4.options;
          return options2.lifecycle === lifecycle_default.ContainerScoped;
        })) {
          childContainer._registry.setAll(token, registrations.map(function(registration) {
            if (registration.options.lifecycle === lifecycle_default.ContainerScoped) {
              return {
                provider: registration.provider,
                options: registration.options
              };
            }
            return registration;
          }));
        }
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a3 = _b.return)) _a3.call(_b);
      } finally {
        if (e_4) throw e_4.error;
      }
    }
    return childContainer;
  };
  InternalDependencyContainer2.prototype.beforeResolution = function(token, callback, options2) {
    if (options2 === void 0) {
      options2 = { frequency: "Always" };
    }
    this.interceptors.preResolution.set(token, {
      callback,
      options: options2
    });
  };
  InternalDependencyContainer2.prototype.afterResolution = function(token, callback, options2) {
    if (options2 === void 0) {
      options2 = { frequency: "Always" };
    }
    this.interceptors.postResolution.set(token, {
      callback,
      options: options2
    });
  };
  InternalDependencyContainer2.prototype.dispose = function() {
    return __awaiter(this, void 0, void 0, function() {
      var promises;
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            this.disposed = true;
            promises = [];
            this.disposables.forEach(function(disposable) {
              var maybePromise = disposable.dispose();
              if (maybePromise) {
                promises.push(maybePromise);
              }
            });
            return [4, Promise.all(promises)];
          case 1:
            _a3.sent();
            return [2];
        }
      });
    });
  };
  InternalDependencyContainer2.prototype.getRegistration = function(token) {
    if (this.isRegistered(token)) {
      return this._registry.get(token);
    }
    if (this.parent) {
      return this.parent.getRegistration(token);
    }
    return null;
  };
  InternalDependencyContainer2.prototype.getAllRegistrations = function(token) {
    if (this.isRegistered(token)) {
      return this._registry.getAll(token);
    }
    if (this.parent) {
      return this.parent.getAllRegistrations(token);
    }
    return null;
  };
  InternalDependencyContainer2.prototype.construct = function(ctor, context) {
    var _this = this;
    if (ctor instanceof DelayedConstructor) {
      return ctor.createProxy(function(target) {
        return _this.resolve(target, context);
      });
    }
    var instance2 = function() {
      var paramInfo = typeInfo.get(ctor);
      if (!paramInfo || paramInfo.length === 0) {
        if (ctor.length === 0) {
          return new ctor();
        } else {
          throw new Error('TypeInfo not known for "' + ctor.name + '"');
        }
      }
      var params = paramInfo.map(_this.resolveParams(context, ctor));
      return new (ctor.bind.apply(ctor, __spread([void 0], params)))();
    }();
    if (isDisposable(instance2)) {
      this.disposables.add(instance2);
    }
    return instance2;
  };
  InternalDependencyContainer2.prototype.resolveParams = function(context, ctor) {
    var _this = this;
    return function(param, idx) {
      var _a3, _b, _c;
      try {
        if (isTokenDescriptor(param)) {
          if (isTransformDescriptor(param)) {
            return param.multiple ? (_a3 = _this.resolve(param.transform)).transform.apply(_a3, __spread([_this.resolveAll(param.token, new resolution_context_default(), param.isOptional)], param.transformArgs)) : (_b = _this.resolve(param.transform)).transform.apply(_b, __spread([_this.resolve(param.token, context, param.isOptional)], param.transformArgs));
          } else {
            return param.multiple ? _this.resolveAll(param.token, new resolution_context_default(), param.isOptional) : _this.resolve(param.token, context, param.isOptional);
          }
        } else if (isTransformDescriptor(param)) {
          return (_c = _this.resolve(param.transform, context)).transform.apply(_c, __spread([_this.resolve(param.token, context)], param.transformArgs));
        }
        return _this.resolve(param, context);
      } catch (e) {
        throw new Error(formatErrorCtor(ctor, idx, e));
      }
    };
  };
  InternalDependencyContainer2.prototype.ensureNotDisposed = function() {
    if (this.disposed) {
      throw new Error("This container has been disposed, you cannot interact with a disposed container");
    }
  };
  return InternalDependencyContainer2;
}();
var instance = new InternalDependencyContainer();

// node_modules/tsyringe/dist/esm5/decorators/injectable.js
function injectable(options2) {
  return function(target) {
    typeInfo.set(target, getParamInfo(target));
    if (options2 && options2.token) {
      if (!Array.isArray(options2.token)) {
        instance.register(options2.token, target);
      } else {
        options2.token.forEach(function(token) {
          instance.register(token, target);
        });
      }
    }
  };
}
var injectable_default = injectable;

// node_modules/tsyringe/dist/esm5/index.js
if (typeof Reflect === "undefined" || !Reflect.getMetadata) {
  throw new Error(`tsyringe requires a reflect polyfill. Please add 'import "reflect-metadata"' to the top of your entry point.`);
}

// node_modules/@peculiar/asn1-pkcs9/node_modules/tslib/tslib.es6.mjs
function __decorate7(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@peculiar/asn1-pfx/node_modules/tslib/tslib.es6.mjs
function __decorate8(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@peculiar/asn1-pfx/build/es2015/attribute.js
var PKCS12AttrSet_1;
var PKCS12Attribute = class {
  constructor(params = {}) {
    this.attrId = "";
    this.attrValues = [];
    Object.assign(params);
  }
};
__decorate8([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], PKCS12Attribute.prototype, "attrId", void 0);
__decorate8([
  AsnProp({ type: AsnPropTypes.Any, repeated: "set" })
], PKCS12Attribute.prototype, "attrValues", void 0);
var PKCS12AttrSet = PKCS12AttrSet_1 = class PKCS12AttrSet2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, PKCS12AttrSet_1.prototype);
  }
};
PKCS12AttrSet = PKCS12AttrSet_1 = __decorate8([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: PKCS12Attribute })
], PKCS12AttrSet);

// node_modules/@peculiar/asn1-pfx/build/es2015/authenticated_safe.js
var AuthenticatedSafe_1;
var AuthenticatedSafe = AuthenticatedSafe_1 = class AuthenticatedSafe2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, AuthenticatedSafe_1.prototype);
  }
};
AuthenticatedSafe = AuthenticatedSafe_1 = __decorate8([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: ContentInfo })
], AuthenticatedSafe);

// node_modules/@peculiar/asn1-pfx/build/es2015/object_identifiers.js
var id_rsadsi = "1.2.840.113549";
var id_pkcs = `${id_rsadsi}.1`;
var id_pkcs_12 = `${id_pkcs}.12`;
var id_pkcs_12PbeIds = `${id_pkcs_12}.1`;
var id_pbeWithSHAAnd128BitRC4 = `${id_pkcs_12PbeIds}.1`;
var id_pbeWithSHAAnd40BitRC4 = `${id_pkcs_12PbeIds}.2`;
var id_pbeWithSHAAnd3_KeyTripleDES_CBC = `${id_pkcs_12PbeIds}.3`;
var id_pbeWithSHAAnd2_KeyTripleDES_CBC = `${id_pkcs_12PbeIds}.4`;
var id_pbeWithSHAAnd128BitRC2_CBC = `${id_pkcs_12PbeIds}.5`;
var id_pbewithSHAAnd40BitRC2_CBC = `${id_pkcs_12PbeIds}.6`;
var id_bagtypes = `${id_pkcs_12}.10.1`;

// node_modules/@peculiar/asn1-pfx/build/es2015/bags/types.js
var id_keyBag = `${id_bagtypes}.1`;
var id_pkcs8ShroudedKeyBag = `${id_bagtypes}.2`;
var id_certBag = `${id_bagtypes}.3`;
var id_CRLBag = `${id_bagtypes}.4`;
var id_SecretBag = `${id_bagtypes}.5`;
var id_SafeContents = `${id_bagtypes}.6`;
var id_pkcs_9 = "1.2.840.113549.1.9";

// node_modules/@peculiar/asn1-pfx/build/es2015/bags/cert_bag.js
var CertBag = class {
  constructor(params = {}) {
    this.certId = "";
    this.certValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate8([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], CertBag.prototype, "certId", void 0);
__decorate8([
  AsnProp({ type: AsnPropTypes.Any, context: 0 })
], CertBag.prototype, "certValue", void 0);
var id_certTypes = `${id_pkcs_9}.22`;
var id_x509Certificate = `${id_certTypes}.1`;
var id_sdsiCertificate = `${id_certTypes}.2`;

// node_modules/@peculiar/asn1-pfx/build/es2015/bags/crl_bag.js
var CRLBag = class {
  constructor(params = {}) {
    this.crlId = "";
    this.crltValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate8([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], CRLBag.prototype, "crlId", void 0);
__decorate8([
  AsnProp({ type: AsnPropTypes.Any, context: 0 })
], CRLBag.prototype, "crltValue", void 0);
var id_crlTypes = `${id_pkcs_9}.23`;
var id_x509CRL = `${id_crlTypes}.1`;

// node_modules/@peculiar/asn1-pkcs8/node_modules/tslib/tslib.es6.mjs
function __decorate9(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@peculiar/asn1-pkcs8/build/es2015/encrypted_private_key_info.js
var EncryptedData = class extends OctetString2 {
};
var EncryptedPrivateKeyInfo = class {
  constructor(params = {}) {
    this.encryptionAlgorithm = new AlgorithmIdentifier();
    this.encryptedData = new EncryptedData();
    Object.assign(this, params);
  }
};
__decorate9([
  AsnProp({ type: AlgorithmIdentifier })
], EncryptedPrivateKeyInfo.prototype, "encryptionAlgorithm", void 0);
__decorate9([
  AsnProp({ type: EncryptedData })
], EncryptedPrivateKeyInfo.prototype, "encryptedData", void 0);

// node_modules/@peculiar/asn1-pkcs8/build/es2015/private_key_info.js
var Attributes_1;
var Version2;
(function(Version3) {
  Version3[Version3["v1"] = 0] = "v1";
})(Version2 || (Version2 = {}));
var PrivateKey = class extends OctetString2 {
};
var Attributes = Attributes_1 = class Attributes2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Attributes_1.prototype);
  }
};
Attributes = Attributes_1 = __decorate9([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: Attribute })
], Attributes);
var PrivateKeyInfo = class {
  constructor(params = {}) {
    this.version = Version2.v1;
    this.privateKeyAlgorithm = new AlgorithmIdentifier();
    this.privateKey = new PrivateKey();
    Object.assign(this, params);
  }
};
__decorate9([
  AsnProp({ type: AsnPropTypes.Integer })
], PrivateKeyInfo.prototype, "version", void 0);
__decorate9([
  AsnProp({ type: AlgorithmIdentifier })
], PrivateKeyInfo.prototype, "privateKeyAlgorithm", void 0);
__decorate9([
  AsnProp({ type: PrivateKey })
], PrivateKeyInfo.prototype, "privateKey", void 0);
__decorate9([
  AsnProp({ type: Attributes, implicit: true, context: 0, optional: true })
], PrivateKeyInfo.prototype, "attributes", void 0);

// node_modules/@peculiar/asn1-pfx/build/es2015/bags/key_bag.js
var KeyBag = class KeyBag2 extends PrivateKeyInfo {
};
KeyBag = __decorate8([
  AsnType({ type: AsnTypeTypes.Sequence })
], KeyBag);

// node_modules/@peculiar/asn1-pfx/build/es2015/bags/pkcs8_shrouded_key_bag.js
var PKCS8ShroudedKeyBag = class PKCS8ShroudedKeyBag2 extends EncryptedPrivateKeyInfo {
};
PKCS8ShroudedKeyBag = __decorate8([
  AsnType({ type: AsnTypeTypes.Sequence })
], PKCS8ShroudedKeyBag);

// node_modules/@peculiar/asn1-pfx/build/es2015/bags/secret_bag.js
var SecretBag = class {
  constructor(params = {}) {
    this.secretTypeId = "";
    this.secretValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate8([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], SecretBag.prototype, "secretTypeId", void 0);
__decorate8([
  AsnProp({ type: AsnPropTypes.Any, context: 0 })
], SecretBag.prototype, "secretValue", void 0);

// node_modules/@peculiar/asn1-pfx/build/es2015/mac_data.js
var MacData = class {
  constructor(params = {}) {
    this.mac = new DigestInfo();
    this.macSalt = new OctetString2();
    this.iterations = 1;
    Object.assign(this, params);
  }
};
__decorate8([
  AsnProp({ type: DigestInfo })
], MacData.prototype, "mac", void 0);
__decorate8([
  AsnProp({ type: OctetString2 })
], MacData.prototype, "macSalt", void 0);
__decorate8([
  AsnProp({ type: AsnPropTypes.Integer, defaultValue: 1 })
], MacData.prototype, "iterations", void 0);

// node_modules/@peculiar/asn1-pfx/build/es2015/pfx.js
var PFX = class {
  constructor(params = {}) {
    this.version = 3;
    this.authSafe = new ContentInfo();
    this.macData = new MacData();
    Object.assign(this, params);
  }
};
__decorate8([
  AsnProp({ type: AsnPropTypes.Integer })
], PFX.prototype, "version", void 0);
__decorate8([
  AsnProp({ type: ContentInfo })
], PFX.prototype, "authSafe", void 0);
__decorate8([
  AsnProp({ type: MacData, optional: true })
], PFX.prototype, "macData", void 0);

// node_modules/@peculiar/asn1-pfx/build/es2015/safe_bag.js
var SafeContents_1;
var SafeBag = class {
  constructor(params = {}) {
    this.bagId = "";
    this.bagValue = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate8([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], SafeBag.prototype, "bagId", void 0);
__decorate8([
  AsnProp({ type: AsnPropTypes.Any, context: 0 })
], SafeBag.prototype, "bagValue", void 0);
__decorate8([
  AsnProp({ type: PKCS12Attribute, repeated: "set", optional: true })
], SafeBag.prototype, "bagAttributes", void 0);
var SafeContents = SafeContents_1 = class SafeContents2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SafeContents_1.prototype);
  }
};
SafeContents = SafeContents_1 = __decorate8([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: SafeBag })
], SafeContents);

// node_modules/@peculiar/asn1-pkcs9/build/es2015/index.js
var ExtensionRequest_1;
var ExtendedCertificateAttributes_1;
var SMIMECapabilities_1;
var id_pkcs9 = "1.2.840.113549.1.9";
var id_pkcs9_mo = `${id_pkcs9}.0`;
var id_pkcs9_oc = `${id_pkcs9}.24`;
var id_pkcs9_at = `${id_pkcs9}.25`;
var id_pkcs9_sx = `${id_pkcs9}.26`;
var id_pkcs9_mr = `${id_pkcs9}.27`;
var id_pkcs9_oc_pkcsEntity = `${id_pkcs9_oc}.1`;
var id_pkcs9_oc_naturalPerson = `${id_pkcs9_oc}.2`;
var id_pkcs9_at_emailAddress = `${id_pkcs9}.1`;
var id_pkcs9_at_unstructuredName = `${id_pkcs9}.2`;
var id_pkcs9_at_contentType = `${id_pkcs9}.3`;
var id_pkcs9_at_messageDigest = `${id_pkcs9}.4`;
var id_pkcs9_at_signingTime = `${id_pkcs9}.5`;
var id_pkcs9_at_counterSignature = `${id_pkcs9}.6`;
var id_pkcs9_at_challengePassword = `${id_pkcs9}.7`;
var id_pkcs9_at_unstructuredAddress = `${id_pkcs9}.8`;
var id_pkcs9_at_extendedCertificateAttributes = `${id_pkcs9}.9`;
var id_pkcs9_at_signingDescription = `${id_pkcs9}.13`;
var id_pkcs9_at_extensionRequest = `${id_pkcs9}.14`;
var id_pkcs9_at_smimeCapabilities = `${id_pkcs9}.15`;
var id_pkcs9_at_friendlyName = `${id_pkcs9}.20`;
var id_pkcs9_at_localKeyId = `${id_pkcs9}.21`;
var id_pkcs9_at_pkcs15Token = `${id_pkcs9_at}.1`;
var id_pkcs9_at_encryptedPrivateKeyInfo = `${id_pkcs9_at}.2`;
var id_pkcs9_at_randomNonce = `${id_pkcs9_at}.3`;
var id_pkcs9_at_sequenceNumber = `${id_pkcs9_at}.4`;
var id_pkcs9_at_pkcs7PDU = `${id_pkcs9_at}.5`;
var id_ietf_at = `1.3.6.1.5.5.7.9`;
var id_pkcs9_at_dateOfBirth = `${id_ietf_at}.1`;
var id_pkcs9_at_placeOfBirth = `${id_ietf_at}.2`;
var id_pkcs9_at_gender = `${id_ietf_at}.3`;
var id_pkcs9_at_countryOfCitizenship = `${id_ietf_at}.4`;
var id_pkcs9_at_countryOfResidence = `${id_ietf_at}.5`;
var id_pkcs9_sx_pkcs9String = `${id_pkcs9_sx}.1`;
var id_pkcs9_sx_signingTime = `${id_pkcs9_sx}.2`;
var id_pkcs9_mr_caseIgnoreMatch = `${id_pkcs9_mr}.1`;
var id_pkcs9_mr_signingTimeMatch = `${id_pkcs9_mr}.2`;
var id_smime = `${id_pkcs9}.16`;
var id_certTypes2 = `${id_pkcs9}.22`;
var crlTypes = `${id_pkcs9}.23`;
var id_at_pseudonym = `${id_at}.65`;
var PKCS9String = class PKCS9String2 extends DirectoryString {
  constructor(params = {}) {
    super(params);
  }
  toString() {
    const o = {};
    o.toString();
    return this.ia5String || super.toString();
  }
};
__decorate7([
  AsnProp({ type: AsnPropTypes.IA5String })
], PKCS9String.prototype, "ia5String", void 0);
PKCS9String = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], PKCS9String);
var Pkcs7PDU = class Pkcs7PDU2 extends ContentInfo {
};
Pkcs7PDU = __decorate7([
  AsnType({ type: AsnTypeTypes.Sequence })
], Pkcs7PDU);
var UserPKCS12 = class UserPKCS122 extends PFX {
};
UserPKCS12 = __decorate7([
  AsnType({ type: AsnTypeTypes.Sequence })
], UserPKCS12);
var EncryptedPrivateKeyInfo2 = class EncryptedPrivateKeyInfo3 extends EncryptedPrivateKeyInfo {
};
EncryptedPrivateKeyInfo2 = __decorate7([
  AsnType({ type: AsnTypeTypes.Sequence })
], EncryptedPrivateKeyInfo2);
var EmailAddress = class EmailAddress2 {
  constructor(value7 = "") {
    this.value = value7;
  }
  toString() {
    return this.value;
  }
};
__decorate7([
  AsnProp({ type: AsnPropTypes.IA5String })
], EmailAddress.prototype, "value", void 0);
EmailAddress = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], EmailAddress);
var UnstructuredName = class UnstructuredName2 extends PKCS9String {
};
UnstructuredName = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], UnstructuredName);
var UnstructuredAddress = class UnstructuredAddress2 extends DirectoryString {
};
UnstructuredAddress = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], UnstructuredAddress);
var DateOfBirth = class DateOfBirth2 {
  constructor(value7 = /* @__PURE__ */ new Date()) {
    this.value = value7;
  }
};
__decorate7([
  AsnProp({ type: AsnPropTypes.GeneralizedTime })
], DateOfBirth.prototype, "value", void 0);
DateOfBirth = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], DateOfBirth);
var PlaceOfBirth = class PlaceOfBirth2 extends DirectoryString {
};
PlaceOfBirth = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], PlaceOfBirth);
var Gender = class Gender2 {
  constructor(value7 = "M") {
    this.value = value7;
  }
  toString() {
    return this.value;
  }
};
__decorate7([
  AsnProp({ type: AsnPropTypes.PrintableString })
], Gender.prototype, "value", void 0);
Gender = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], Gender);
var CountryOfCitizenship = class CountryOfCitizenship2 {
  constructor(value7 = "") {
    this.value = value7;
  }
  toString() {
    return this.value;
  }
};
__decorate7([
  AsnProp({ type: AsnPropTypes.PrintableString })
], CountryOfCitizenship.prototype, "value", void 0);
CountryOfCitizenship = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], CountryOfCitizenship);
var CountryOfResidence = class CountryOfResidence2 extends CountryOfCitizenship {
};
CountryOfResidence = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], CountryOfResidence);
var Pseudonym = class Pseudonym2 extends DirectoryString {
};
Pseudonym = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], Pseudonym);
var ContentType = class ContentType2 {
  constructor(value7 = "") {
    this.value = value7;
  }
  toString() {
    return this.value;
  }
};
__decorate7([
  AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], ContentType.prototype, "value", void 0);
ContentType = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], ContentType);
var SigningTime3 = class SigningTime4 extends Time {
};
SigningTime3 = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], SigningTime3);
var SequenceNumber = class SequenceNumber2 {
  constructor(value7 = 0) {
    this.value = value7;
  }
  toString() {
    return this.value.toString();
  }
};
__decorate7([
  AsnProp({ type: AsnPropTypes.Integer })
], SequenceNumber.prototype, "value", void 0);
SequenceNumber = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], SequenceNumber);
var CounterSignature3 = class CounterSignature4 extends SignerInfo {
};
CounterSignature3 = __decorate7([
  AsnType({ type: AsnTypeTypes.Sequence })
], CounterSignature3);
var ChallengePassword = class ChallengePassword2 extends DirectoryString {
};
ChallengePassword = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], ChallengePassword);
var ExtensionRequest = ExtensionRequest_1 = class ExtensionRequest2 extends Extensions {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtensionRequest_1.prototype);
  }
};
ExtensionRequest = ExtensionRequest_1 = __decorate7([
  AsnType({ type: AsnTypeTypes.Sequence })
], ExtensionRequest);
var ExtendedCertificateAttributes = ExtendedCertificateAttributes_1 = class ExtendedCertificateAttributes2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, ExtendedCertificateAttributes_1.prototype);
  }
};
ExtendedCertificateAttributes = ExtendedCertificateAttributes_1 = __decorate7([
  AsnType({ type: AsnTypeTypes.Set, itemType: Attribute2 })
], ExtendedCertificateAttributes);
var FriendlyName = class FriendlyName2 {
  constructor(value7 = "") {
    this.value = value7;
  }
  toString() {
    return this.value;
  }
};
__decorate7([
  AsnProp({ type: AsnPropTypes.BmpString })
], FriendlyName.prototype, "value", void 0);
FriendlyName = __decorate7([
  AsnType({ type: AsnTypeTypes.Choice })
], FriendlyName);
var SMIMECapability = class SMIMECapability2 extends AlgorithmIdentifier {
};
SMIMECapability = __decorate7([
  AsnType({ type: AsnTypeTypes.Sequence })
], SMIMECapability);
var SMIMECapabilities = SMIMECapabilities_1 = class SMIMECapabilities2 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, SMIMECapabilities_1.prototype);
  }
};
SMIMECapabilities = SMIMECapabilities_1 = __decorate7([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: SMIMECapability })
], SMIMECapabilities);

// node_modules/@peculiar/asn1-csr/node_modules/tslib/tslib.es6.mjs
function __decorate10(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@peculiar/asn1-csr/build/es2015/attributes.js
var Attributes_12;
var Attributes3 = Attributes_12 = class Attributes4 extends AsnArray {
  constructor(items) {
    super(items);
    Object.setPrototypeOf(this, Attributes_12.prototype);
  }
};
Attributes3 = Attributes_12 = __decorate10([
  AsnType({ type: AsnTypeTypes.Sequence, itemType: Attribute })
], Attributes3);

// node_modules/@peculiar/asn1-csr/build/es2015/certification_request_info.js
var CertificationRequestInfo = class {
  constructor(params = {}) {
    this.version = 0;
    this.subject = new Name();
    this.subjectPKInfo = new SubjectPublicKeyInfo();
    this.attributes = new Attributes3();
    Object.assign(this, params);
  }
};
__decorate10([
  AsnProp({ type: AsnPropTypes.Integer })
], CertificationRequestInfo.prototype, "version", void 0);
__decorate10([
  AsnProp({ type: Name })
], CertificationRequestInfo.prototype, "subject", void 0);
__decorate10([
  AsnProp({ type: SubjectPublicKeyInfo })
], CertificationRequestInfo.prototype, "subjectPKInfo", void 0);
__decorate10([
  AsnProp({ type: Attributes3, implicit: true, context: 0 })
], CertificationRequestInfo.prototype, "attributes", void 0);

// node_modules/@peculiar/asn1-csr/build/es2015/certification_request.js
var CertificationRequest = class {
  constructor(params = {}) {
    this.certificationRequestInfo = new CertificationRequestInfo();
    this.signatureAlgorithm = new AlgorithmIdentifier();
    this.signature = new ArrayBuffer(0);
    Object.assign(this, params);
  }
};
__decorate10([
  AsnProp({ type: CertificationRequestInfo })
], CertificationRequest.prototype, "certificationRequestInfo", void 0);
__decorate10([
  AsnProp({ type: AlgorithmIdentifier })
], CertificationRequest.prototype, "signatureAlgorithm", void 0);
__decorate10([
  AsnProp({ type: AsnPropTypes.BitString })
], CertificationRequest.prototype, "signature", void 0);

// node_modules/@peculiar/x509/build/x509.es.js
var diAlgorithm = "crypto.algorithm";
var AlgorithmProvider = class {
  getAlgorithms() {
    return instance.resolveAll(diAlgorithm);
  }
  toAsnAlgorithm(alg) {
    ({ ...alg });
    for (const algorithm of this.getAlgorithms()) {
      const res = algorithm.toAsnAlgorithm(alg);
      if (res) {
        return res;
      }
    }
    if (/^[0-9.]+$/.test(alg.name)) {
      const res = new AlgorithmIdentifier({
        algorithm: alg.name
      });
      if ("parameters" in alg) {
        const unknown = alg;
        res.parameters = unknown.parameters;
      }
      return res;
    }
    throw new Error("Cannot convert WebCrypto algorithm to ASN.1 algorithm");
  }
  toWebAlgorithm(alg) {
    for (const algorithm of this.getAlgorithms()) {
      const res = algorithm.toWebAlgorithm(alg);
      if (res) {
        return res;
      }
    }
    const unknown = {
      name: alg.algorithm,
      parameters: alg.parameters
    };
    return unknown;
  }
};
var diAlgorithmProvider = "crypto.algorithmProvider";
instance.registerSingleton(diAlgorithmProvider, AlgorithmProvider);
var EcAlgorithm_1;
var idVersionOne = "1.3.36.3.3.2.8.1.1";
var idBrainpoolP160r1 = `${idVersionOne}.1`;
var idBrainpoolP160t1 = `${idVersionOne}.2`;
var idBrainpoolP192r1 = `${idVersionOne}.3`;
var idBrainpoolP192t1 = `${idVersionOne}.4`;
var idBrainpoolP224r1 = `${idVersionOne}.5`;
var idBrainpoolP224t1 = `${idVersionOne}.6`;
var idBrainpoolP256r1 = `${idVersionOne}.7`;
var idBrainpoolP256t1 = `${idVersionOne}.8`;
var idBrainpoolP320r1 = `${idVersionOne}.9`;
var idBrainpoolP320t1 = `${idVersionOne}.10`;
var idBrainpoolP384r1 = `${idVersionOne}.11`;
var idBrainpoolP384t1 = `${idVersionOne}.12`;
var idBrainpoolP512r1 = `${idVersionOne}.13`;
var idBrainpoolP512t1 = `${idVersionOne}.14`;
var brainpoolP160r1 = "brainpoolP160r1";
var brainpoolP160t1 = "brainpoolP160t1";
var brainpoolP192r1 = "brainpoolP192r1";
var brainpoolP192t1 = "brainpoolP192t1";
var brainpoolP224r1 = "brainpoolP224r1";
var brainpoolP224t1 = "brainpoolP224t1";
var brainpoolP256r1 = "brainpoolP256r1";
var brainpoolP256t1 = "brainpoolP256t1";
var brainpoolP320r1 = "brainpoolP320r1";
var brainpoolP320t1 = "brainpoolP320t1";
var brainpoolP384r1 = "brainpoolP384r1";
var brainpoolP384t1 = "brainpoolP384t1";
var brainpoolP512r1 = "brainpoolP512r1";
var brainpoolP512t1 = "brainpoolP512t1";
var ECDSA = "ECDSA";
var EcAlgorithm = EcAlgorithm_1 = class EcAlgorithm2 {
  toAsnAlgorithm(alg) {
    switch (alg.name.toLowerCase()) {
      case ECDSA.toLowerCase():
        if ("hash" in alg) {
          const hash = typeof alg.hash === "string" ? alg.hash : alg.hash.name;
          switch (hash.toLowerCase()) {
            case "sha-1":
              return ecdsaWithSHA1;
            case "sha-256":
              return ecdsaWithSHA256;
            case "sha-384":
              return ecdsaWithSHA384;
            case "sha-512":
              return ecdsaWithSHA512;
          }
        } else if ("namedCurve" in alg) {
          let parameters = "";
          switch (alg.namedCurve) {
            case "P-256":
              parameters = id_secp256r1;
              break;
            case "K-256":
              parameters = EcAlgorithm_1.SECP256K1;
              break;
            case "P-384":
              parameters = id_secp384r1;
              break;
            case "P-521":
              parameters = id_secp521r1;
              break;
            case brainpoolP160r1:
              parameters = idBrainpoolP160r1;
              break;
            case brainpoolP160t1:
              parameters = idBrainpoolP160t1;
              break;
            case brainpoolP192r1:
              parameters = idBrainpoolP192r1;
              break;
            case brainpoolP192t1:
              parameters = idBrainpoolP192t1;
              break;
            case brainpoolP224r1:
              parameters = idBrainpoolP224r1;
              break;
            case brainpoolP224t1:
              parameters = idBrainpoolP224t1;
              break;
            case brainpoolP256r1:
              parameters = idBrainpoolP256r1;
              break;
            case brainpoolP256t1:
              parameters = idBrainpoolP256t1;
              break;
            case brainpoolP320r1:
              parameters = idBrainpoolP320r1;
              break;
            case brainpoolP320t1:
              parameters = idBrainpoolP320t1;
              break;
            case brainpoolP384r1:
              parameters = idBrainpoolP384r1;
              break;
            case brainpoolP384t1:
              parameters = idBrainpoolP384t1;
              break;
            case brainpoolP512r1:
              parameters = idBrainpoolP512r1;
              break;
            case brainpoolP512t1:
              parameters = idBrainpoolP512t1;
              break;
          }
          if (parameters) {
            return new AlgorithmIdentifier({
              algorithm: id_ecPublicKey,
              parameters: AsnConvert.serialize(new ECParameters({ namedCurve: parameters }))
            });
          }
        }
    }
    return null;
  }
  toWebAlgorithm(alg) {
    switch (alg.algorithm) {
      case id_ecdsaWithSHA1:
        return { name: ECDSA, hash: { name: "SHA-1" } };
      case id_ecdsaWithSHA256:
        return { name: ECDSA, hash: { name: "SHA-256" } };
      case id_ecdsaWithSHA384:
        return { name: ECDSA, hash: { name: "SHA-384" } };
      case id_ecdsaWithSHA512:
        return { name: ECDSA, hash: { name: "SHA-512" } };
      case id_ecPublicKey: {
        if (!alg.parameters) {
          throw new TypeError("Cannot get required parameters from EC algorithm");
        }
        const parameters = AsnConvert.parse(alg.parameters, ECParameters);
        switch (parameters.namedCurve) {
          case id_secp256r1:
            return { name: ECDSA, namedCurve: "P-256" };
          case EcAlgorithm_1.SECP256K1:
            return { name: ECDSA, namedCurve: "K-256" };
          case id_secp384r1:
            return { name: ECDSA, namedCurve: "P-384" };
          case id_secp521r1:
            return { name: ECDSA, namedCurve: "P-521" };
          case idBrainpoolP160r1:
            return { name: ECDSA, namedCurve: brainpoolP160r1 };
          case idBrainpoolP160t1:
            return { name: ECDSA, namedCurve: brainpoolP160t1 };
          case idBrainpoolP192r1:
            return { name: ECDSA, namedCurve: brainpoolP192r1 };
          case idBrainpoolP192t1:
            return { name: ECDSA, namedCurve: brainpoolP192t1 };
          case idBrainpoolP224r1:
            return { name: ECDSA, namedCurve: brainpoolP224r1 };
          case idBrainpoolP224t1:
            return { name: ECDSA, namedCurve: brainpoolP224t1 };
          case idBrainpoolP256r1:
            return { name: ECDSA, namedCurve: brainpoolP256r1 };
          case idBrainpoolP256t1:
            return { name: ECDSA, namedCurve: brainpoolP256t1 };
          case idBrainpoolP320r1:
            return { name: ECDSA, namedCurve: brainpoolP320r1 };
          case idBrainpoolP320t1:
            return { name: ECDSA, namedCurve: brainpoolP320t1 };
          case idBrainpoolP384r1:
            return { name: ECDSA, namedCurve: brainpoolP384r1 };
          case idBrainpoolP384t1:
            return { name: ECDSA, namedCurve: brainpoolP384t1 };
          case idBrainpoolP512r1:
            return { name: ECDSA, namedCurve: brainpoolP512r1 };
          case idBrainpoolP512t1:
            return { name: ECDSA, namedCurve: brainpoolP512t1 };
        }
      }
    }
    return null;
  }
};
EcAlgorithm.SECP256K1 = "1.3.132.0.10";
EcAlgorithm = EcAlgorithm_1 = __decorate6([
  injectable_default()
], EcAlgorithm);
instance.registerSingleton(diAlgorithm, EcAlgorithm);
var NAME2 = Symbol("name");
var VALUE = Symbol("value");
var TextObject = class {
  constructor(name9, items = {}, value7 = "") {
    this[NAME2] = name9;
    this[VALUE] = value7;
    for (const key in items) {
      this[key] = items[key];
    }
  }
};
TextObject.NAME = NAME2;
TextObject.VALUE = VALUE;
var DefaultAlgorithmSerializer = class {
  static toTextObject(alg) {
    const obj = new TextObject("Algorithm Identifier", {}, OidSerializer.toString(alg.algorithm));
    if (alg.parameters) {
      switch (alg.algorithm) {
        case id_ecPublicKey: {
          const ecAlg = new EcAlgorithm().toWebAlgorithm(alg);
          if (ecAlg && "namedCurve" in ecAlg) {
            obj["Named Curve"] = ecAlg.namedCurve;
          } else {
            obj["Parameters"] = alg.parameters;
          }
          break;
        }
        default:
          obj["Parameters"] = alg.parameters;
      }
    }
    return obj;
  }
};
var OidSerializer = class {
  static toString(oid) {
    const name9 = this.items[oid];
    if (name9) {
      return name9;
    }
    return oid;
  }
};
OidSerializer.items = {
  [id_sha1]: "sha1",
  [id_sha224]: "sha224",
  [id_sha256]: "sha256",
  [id_sha384]: "sha384",
  [id_sha512]: "sha512",
  [id_rsaEncryption]: "rsaEncryption",
  [id_sha1WithRSAEncryption]: "sha1WithRSAEncryption",
  [id_sha224WithRSAEncryption]: "sha224WithRSAEncryption",
  [id_sha256WithRSAEncryption]: "sha256WithRSAEncryption",
  [id_sha384WithRSAEncryption]: "sha384WithRSAEncryption",
  [id_sha512WithRSAEncryption]: "sha512WithRSAEncryption",
  [id_ecPublicKey]: "ecPublicKey",
  [id_ecdsaWithSHA1]: "ecdsaWithSHA1",
  [id_ecdsaWithSHA224]: "ecdsaWithSHA224",
  [id_ecdsaWithSHA256]: "ecdsaWithSHA256",
  [id_ecdsaWithSHA384]: "ecdsaWithSHA384",
  [id_ecdsaWithSHA512]: "ecdsaWithSHA512",
  [id_kp_serverAuth]: "TLS WWW server authentication",
  [id_kp_clientAuth]: "TLS WWW client authentication",
  [id_kp_codeSigning]: "Code Signing",
  [id_kp_emailProtection]: "E-mail Protection",
  [id_kp_timeStamping]: "Time Stamping",
  [id_kp_OCSPSigning]: "OCSP Signing",
  [id_signedData]: "Signed Data"
};
var TextConverter = class {
  static serialize(obj) {
    return this.serializeObj(obj).join("\n");
  }
  static pad(deep = 0) {
    return "".padStart(2 * deep, " ");
  }
  static serializeObj(obj, deep = 0) {
    const res = [];
    let pad = this.pad(deep++);
    let value7 = "";
    const objValue = obj[TextObject.VALUE];
    if (objValue) {
      value7 = ` ${objValue}`;
    }
    res.push(`${pad}${obj[TextObject.NAME]}:${value7}`);
    pad = this.pad(deep);
    for (const key in obj) {
      if (typeof key === "symbol") {
        continue;
      }
      const value8 = obj[key];
      const keyValue = key ? `${key}: ` : "";
      if (typeof value8 === "string" || typeof value8 === "number" || typeof value8 === "boolean") {
        res.push(`${pad}${keyValue}${value8}`);
      } else if (value8 instanceof Date) {
        res.push(`${pad}${keyValue}${value8.toUTCString()}`);
      } else if (Array.isArray(value8)) {
        for (const obj2 of value8) {
          obj2[TextObject.NAME] = key;
          res.push(...this.serializeObj(obj2, deep));
        }
      } else if (value8 instanceof TextObject) {
        value8[TextObject.NAME] = key;
        res.push(...this.serializeObj(value8, deep));
      } else if (BufferSourceConverter.isBufferSource(value8)) {
        if (key) {
          res.push(`${pad}${keyValue}`);
          res.push(...this.serializeBufferSource(value8, deep + 1));
        } else {
          res.push(...this.serializeBufferSource(value8, deep));
        }
      } else if ("toTextObject" in value8) {
        const obj2 = value8.toTextObject();
        obj2[TextObject.NAME] = key;
        res.push(...this.serializeObj(obj2, deep));
      } else {
        throw new TypeError("Cannot serialize data in text format. Unsupported type.");
      }
    }
    return res;
  }
  static serializeBufferSource(buffer, deep = 0) {
    const pad = this.pad(deep);
    const view = BufferSourceConverter.toUint8Array(buffer);
    const res = [];
    for (let i = 0; i < view.length; ) {
      const row = [];
      for (let j = 0; j < 16 && i < view.length; j++) {
        if (j === 8) {
          row.push("");
        }
        const hex = view[i++].toString(16).padStart(2, "0");
        row.push(hex);
      }
      res.push(`${pad}${row.join(" ")}`);
    }
    return res;
  }
  static serializeAlgorithm(alg) {
    return this.algorithmSerializer.toTextObject(alg);
  }
};
TextConverter.oidSerializer = OidSerializer;
TextConverter.algorithmSerializer = DefaultAlgorithmSerializer;
var AsnData = class _AsnData {
  constructor(...args) {
    if (args.length === 1) {
      const asn = args[0];
      this.rawData = AsnConvert.serialize(asn);
      this.onInit(asn);
    } else {
      const asn = AsnConvert.parse(args[0], args[1]);
      this.rawData = BufferSourceConverter.toArrayBuffer(args[0]);
      this.onInit(asn);
    }
  }
  equal(data) {
    if (data instanceof _AsnData) {
      return isEqual(data.rawData, this.rawData);
    }
    return false;
  }
  toString(format11 = "text") {
    switch (format11) {
      case "asn":
        return AsnConvert.toString(this.rawData);
      case "text":
        return TextConverter.serialize(this.toTextObject());
      case "hex":
        return Convert.ToHex(this.rawData);
      case "base64":
        return Convert.ToBase64(this.rawData);
      case "base64url":
        return Convert.ToBase64Url(this.rawData);
      default:
        throw TypeError("Argument 'format' is unsupported value");
    }
  }
  getTextName() {
    const constructor = this.constructor;
    return constructor.NAME;
  }
  toTextObject() {
    const obj = this.toTextObjectEmpty();
    obj[""] = this.rawData;
    return obj;
  }
  toTextObjectEmpty(value7) {
    return new TextObject(this.getTextName(), {}, value7);
  }
};
AsnData.NAME = "ASN";
var Extension2 = class _Extension extends AsnData {
  constructor(...args) {
    let raw;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      raw = BufferSourceConverter.toArrayBuffer(args[0]);
    } else {
      raw = AsnConvert.serialize(new Extension({
        extnID: args[0],
        critical: args[1],
        extnValue: new OctetString2(BufferSourceConverter.toArrayBuffer(args[2]))
      }));
    }
    super(raw, Extension);
  }
  onInit(asn) {
    this.type = asn.extnID;
    this.critical = asn.critical;
    this.value = asn.extnValue.buffer;
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    obj[""] = this.value;
    return obj;
  }
  toTextObjectWithoutValue() {
    const obj = this.toTextObjectEmpty(this.critical ? "critical" : void 0);
    if (obj[TextObject.NAME] === _Extension.NAME) {
      obj[TextObject.NAME] = OidSerializer.toString(this.type);
    }
    return obj;
  }
};
var _a2;
var CryptoProvider = class _CryptoProvider {
  static isCryptoKeyPair(data) {
    return data && data.privateKey && data.publicKey;
  }
  static isCryptoKey(data) {
    return data && data.usages && data.type && data.algorithm && data.extractable !== void 0;
  }
  constructor() {
    this.items = /* @__PURE__ */ new Map();
    this[_a2] = "CryptoProvider";
    if (typeof self !== "undefined" && typeof crypto !== "undefined") {
      this.set(_CryptoProvider.DEFAULT, crypto);
    } else if (typeof global !== "undefined" && global.crypto && global.crypto.subtle) {
      this.set(_CryptoProvider.DEFAULT, global.crypto);
    }
  }
  clear() {
    this.items.clear();
  }
  delete(key) {
    return this.items.delete(key);
  }
  forEach(callbackfn, thisArg) {
    return this.items.forEach(callbackfn, thisArg);
  }
  has(key) {
    return this.items.has(key);
  }
  get size() {
    return this.items.size;
  }
  entries() {
    return this.items.entries();
  }
  keys() {
    return this.items.keys();
  }
  values() {
    return this.items.values();
  }
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }
  get(key = _CryptoProvider.DEFAULT) {
    const crypto2 = this.items.get(key.toLowerCase());
    if (!crypto2) {
      throw new Error(`Cannot get Crypto by name '${key}'`);
    }
    return crypto2;
  }
  set(key, value7) {
    if (typeof key === "string") {
      if (!value7) {
        throw new TypeError("Argument 'value' is required");
      }
      this.items.set(key.toLowerCase(), value7);
    } else {
      this.items.set(_CryptoProvider.DEFAULT, key);
    }
    return this;
  }
};
_a2 = Symbol.toStringTag;
CryptoProvider.DEFAULT = "default";
var cryptoProvider = new CryptoProvider();
var OID_REGEX = /^[0-2](?:\.[1-9][0-9]*)+$/;
function isOID(id) {
  return new RegExp(OID_REGEX).test(id);
}
var NameIdentifier = class {
  constructor(names2 = {}) {
    this.items = {};
    for (const id in names2) {
      this.register(id, names2[id]);
    }
  }
  get(idOrName) {
    return this.items[idOrName] || null;
  }
  findId(idOrName) {
    if (!isOID(idOrName)) {
      return this.get(idOrName);
    }
    return idOrName;
  }
  register(id, name9) {
    this.items[id] = name9;
    this.items[name9] = id;
  }
};
var names = new NameIdentifier();
names.register("CN", "2.5.4.3");
names.register("L", "2.5.4.7");
names.register("ST", "2.5.4.8");
names.register("O", "2.5.4.10");
names.register("OU", "2.5.4.11");
names.register("C", "2.5.4.6");
names.register("DC", "0.9.2342.19200300.100.1.25");
names.register("E", "1.2.840.113549.1.9.1");
names.register("G", "2.5.4.42");
names.register("I", "2.5.4.43");
names.register("SN", "2.5.4.4");
names.register("T", "2.5.4.12");
function replaceUnknownCharacter(text, char) {
  return `\\${Convert.ToHex(Convert.FromUtf8String(char)).toUpperCase()}`;
}
function escape2(data) {
  return data.replace(/([,+"\\<>;])/g, "\\$1").replace(/^([ #])/, "\\$1").replace(/([ ]$)/, "\\$1").replace(/([\r\n\t])/, replaceUnknownCharacter);
}
var Name3 = class _Name {
  static isASCII(text) {
    for (let i = 0; i < text.length; i++) {
      const code17 = text.charCodeAt(i);
      if (code17 > 255) {
        return false;
      }
    }
    return true;
  }
  static isPrintableString(text) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/g.test(text);
  }
  constructor(data, extraNames = {}) {
    this.extraNames = new NameIdentifier();
    this.asn = new Name();
    for (const key in extraNames) {
      if (Object.prototype.hasOwnProperty.call(extraNames, key)) {
        const value7 = extraNames[key];
        this.extraNames.register(key, value7);
      }
    }
    if (typeof data === "string") {
      this.asn = this.fromString(data);
    } else if (data instanceof Name) {
      this.asn = data;
    } else if (BufferSourceConverter.isBufferSource(data)) {
      this.asn = AsnConvert.parse(data, Name);
    } else {
      this.asn = this.fromJSON(data);
    }
  }
  getField(idOrName) {
    const id = this.extraNames.findId(idOrName) || names.findId(idOrName);
    const res = [];
    for (const name9 of this.asn) {
      for (const rdn of name9) {
        if (rdn.type === id) {
          res.push(rdn.value.toString());
        }
      }
    }
    return res;
  }
  getName(idOrName) {
    return this.extraNames.get(idOrName) || names.get(idOrName);
  }
  toString() {
    return this.asn.map((rdn) => rdn.map((o) => {
      const type = this.getName(o.type) || o.type;
      const value7 = o.value.anyValue ? `#${Convert.ToHex(o.value.anyValue)}` : escape2(o.value.toString());
      return `${type}=${value7}`;
    }).join("+")).join(", ");
  }
  toJSON() {
    var _a3;
    const json = [];
    for (const rdn of this.asn) {
      const jsonItem = {};
      for (const attr of rdn) {
        const type = this.getName(attr.type) || attr.type;
        (_a3 = jsonItem[type]) !== null && _a3 !== void 0 ? _a3 : jsonItem[type] = [];
        jsonItem[type].push(attr.value.anyValue ? `#${Convert.ToHex(attr.value.anyValue)}` : attr.value.toString());
      }
      json.push(jsonItem);
    }
    return json;
  }
  fromString(data) {
    const asn = new Name();
    const regex = /(\d\.[\d.]*\d|[A-Za-z]+)=((?:"")|(?:".*?[^\\]")|(?:[^,+"\\](?=[,+]|$))|(?:[^,+].*?(?:[^\\][,+]))|(?:))([,+])?/g;
    let matches = null;
    let level = ",";
    while (matches = regex.exec(`${data},`)) {
      let [, type, value7] = matches;
      const lastChar = value7[value7.length - 1];
      if (lastChar === "," || lastChar === "+") {
        value7 = value7.slice(0, value7.length - 1);
        matches[3] = lastChar;
      }
      const next = matches[3];
      type = this.getTypeOid(type);
      const attr = this.createAttribute(type, value7);
      if (level === "+") {
        asn[asn.length - 1].push(attr);
      } else {
        asn.push(new RelativeDistinguishedName([attr]));
      }
      level = next;
    }
    return asn;
  }
  fromJSON(data) {
    const asn = new Name();
    for (const item of data) {
      const asnRdn = new RelativeDistinguishedName();
      for (const type in item) {
        const typeId = this.getTypeOid(type);
        const values = item[type];
        for (const value7 of values) {
          const asnAttr = this.createAttribute(typeId, value7);
          asnRdn.push(asnAttr);
        }
      }
      asn.push(asnRdn);
    }
    return asn;
  }
  getTypeOid(type) {
    if (!/[\d.]+/.test(type)) {
      type = this.getName(type) || "";
    }
    if (!type) {
      throw new Error(`Cannot get OID for name type '${type}'`);
    }
    return type;
  }
  createAttribute(type, value7) {
    const attr = new AttributeTypeAndValue({ type });
    if (typeof value7 === "object") {
      for (const key in value7) {
        switch (key) {
          case "ia5String":
            attr.value.ia5String = value7[key];
            break;
          case "utf8String":
            attr.value.utf8String = value7[key];
            break;
          case "universalString":
            attr.value.universalString = value7[key];
            break;
          case "bmpString":
            attr.value.bmpString = value7[key];
            break;
          case "printableString":
            attr.value.printableString = value7[key];
            break;
        }
      }
    } else if (value7[0] === "#") {
      attr.value.anyValue = Convert.FromHex(value7.slice(1));
    } else {
      const processedValue = this.processStringValue(value7);
      if (type === this.getName("E") || type === this.getName("DC")) {
        attr.value.ia5String = processedValue;
      } else {
        if (_Name.isPrintableString(processedValue)) {
          attr.value.printableString = processedValue;
        } else {
          attr.value.utf8String = processedValue;
        }
      }
    }
    return attr;
  }
  processStringValue(value7) {
    const quotedMatches = /"(.*?[^\\])?"/.exec(value7);
    if (quotedMatches) {
      value7 = quotedMatches[1];
    }
    return value7.replace(/\\0a/ig, "\n").replace(/\\0d/ig, "\r").replace(/\\0g/ig, "	").replace(/\\(.)/g, "$1");
  }
  toArrayBuffer() {
    return AsnConvert.serialize(this.asn);
  }
  async getThumbprint(...args) {
    var _a3;
    let crypto2;
    let algorithm = "SHA-1";
    if (args.length >= 1 && !((_a3 = args[0]) === null || _a3 === void 0 ? void 0 : _a3.subtle)) {
      algorithm = args[0] || algorithm;
      crypto2 = args[1] || cryptoProvider.get();
    } else {
      crypto2 = args[0] || cryptoProvider.get();
    }
    return await crypto2.subtle.digest(algorithm, this.toArrayBuffer());
  }
};
var ERR_GN_CONSTRUCTOR = "Cannot initialize GeneralName from ASN.1 data.";
var ERR_GN_STRING_FORMAT = `${ERR_GN_CONSTRUCTOR} Unsupported string format in use.`;
var ERR_GUID = `${ERR_GN_CONSTRUCTOR} Value doesn't match to GUID regular expression.`;
var GUID_REGEX = /^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/i;
var id_GUID = "1.3.6.1.4.1.311.25.1";
var id_UPN = "1.3.6.1.4.1.311.20.2.3";
var DNS10 = "dns";
var DN = "dn";
var EMAIL = "email";
var IP9 = "ip";
var URL2 = "url";
var GUID = "guid";
var UPN = "upn";
var REGISTERED_ID = "id";
var GeneralName3 = class extends AsnData {
  constructor(...args) {
    let name9;
    if (args.length === 2) {
      switch (args[0]) {
        case DN: {
          const derName = new Name3(args[1]).toArrayBuffer();
          const asnName = AsnConvert.parse(derName, Name);
          name9 = new GeneralName({ directoryName: asnName });
          break;
        }
        case DNS10:
          name9 = new GeneralName({ dNSName: args[1] });
          break;
        case EMAIL:
          name9 = new GeneralName({ rfc822Name: args[1] });
          break;
        case GUID: {
          const matches = new RegExp(GUID_REGEX, "i").exec(args[1]);
          if (!matches) {
            throw new Error("Cannot parse GUID value. Value doesn't match to regular expression");
          }
          const hex = matches.slice(1).map((o, i) => {
            if (i < 3) {
              return Convert.ToHex(new Uint8Array(Convert.FromHex(o)).reverse());
            }
            return o;
          }).join("");
          name9 = new GeneralName({
            otherName: new OtherName({
              typeId: id_GUID,
              value: AsnConvert.serialize(new OctetString2(Convert.FromHex(hex)))
            })
          });
          break;
        }
        case IP9:
          name9 = new GeneralName({ iPAddress: args[1] });
          break;
        case REGISTERED_ID:
          name9 = new GeneralName({ registeredID: args[1] });
          break;
        case UPN: {
          name9 = new GeneralName({
            otherName: new OtherName({
              typeId: id_UPN,
              value: AsnConvert.serialize(AsnUtf8StringConverter.toASN(args[1]))
            })
          });
          break;
        }
        case URL2:
          name9 = new GeneralName({ uniformResourceIdentifier: args[1] });
          break;
        default:
          throw new Error("Cannot create GeneralName. Unsupported type of the name");
      }
    } else if (BufferSourceConverter.isBufferSource(args[0])) {
      name9 = AsnConvert.parse(args[0], GeneralName);
    } else {
      name9 = args[0];
    }
    super(name9);
  }
  onInit(asn) {
    if (asn.dNSName != void 0) {
      this.type = DNS10;
      this.value = asn.dNSName;
    } else if (asn.rfc822Name != void 0) {
      this.type = EMAIL;
      this.value = asn.rfc822Name;
    } else if (asn.iPAddress != void 0) {
      this.type = IP9;
      this.value = asn.iPAddress;
    } else if (asn.uniformResourceIdentifier != void 0) {
      this.type = URL2;
      this.value = asn.uniformResourceIdentifier;
    } else if (asn.registeredID != void 0) {
      this.type = REGISTERED_ID;
      this.value = asn.registeredID;
    } else if (asn.directoryName != void 0) {
      this.type = DN;
      this.value = new Name3(asn.directoryName).toString();
    } else if (asn.otherName != void 0) {
      if (asn.otherName.typeId === id_GUID) {
        this.type = GUID;
        const guid = AsnConvert.parse(asn.otherName.value, OctetString2);
        const matches = new RegExp(GUID_REGEX, "i").exec(Convert.ToHex(guid));
        if (!matches) {
          throw new Error(ERR_GUID);
        }
        this.value = matches.slice(1).map((o, i) => {
          if (i < 3) {
            return Convert.ToHex(new Uint8Array(Convert.FromHex(o)).reverse());
          }
          return o;
        }).join("-");
      } else if (asn.otherName.typeId === id_UPN) {
        this.type = UPN;
        this.value = AsnConvert.parse(asn.otherName.value, DirectoryString).toString();
      } else {
        throw new Error(ERR_GN_STRING_FORMAT);
      }
    } else {
      throw new Error(ERR_GN_STRING_FORMAT);
    }
  }
  toJSON() {
    return {
      type: this.type,
      value: this.value
    };
  }
  toTextObject() {
    let type;
    switch (this.type) {
      case DN:
      case DNS10:
      case GUID:
      case IP9:
      case REGISTERED_ID:
      case UPN:
      case URL2:
        type = this.type.toUpperCase();
        break;
      case EMAIL:
        type = "Email";
        break;
      default:
        throw new Error("Unsupported GeneralName type");
    }
    let value7 = this.value;
    if (this.type === REGISTERED_ID) {
      value7 = OidSerializer.toString(value7);
    }
    return new TextObject(type, void 0, value7);
  }
};
var GeneralNames3 = class extends AsnData {
  constructor(params) {
    let names2;
    if (params instanceof GeneralNames) {
      names2 = params;
    } else if (Array.isArray(params)) {
      const items = [];
      for (const name9 of params) {
        if (name9 instanceof GeneralName) {
          items.push(name9);
        } else {
          const asnName = AsnConvert.parse(new GeneralName3(name9.type, name9.value).rawData, GeneralName);
          items.push(asnName);
        }
      }
      names2 = new GeneralNames(items);
    } else if (BufferSourceConverter.isBufferSource(params)) {
      names2 = AsnConvert.parse(params, GeneralNames);
    } else {
      throw new Error("Cannot initialize GeneralNames. Incorrect incoming arguments");
    }
    super(names2);
  }
  onInit(asn) {
    const items = [];
    for (const asnName of asn) {
      let name9 = null;
      try {
        name9 = new GeneralName3(asnName);
      } catch {
        continue;
      }
      items.push(name9);
    }
    this.items = items;
  }
  toJSON() {
    return this.items.map((o) => o.toJSON());
  }
  toTextObject() {
    const res = super.toTextObjectEmpty();
    for (const name9 of this.items) {
      const nameObj = name9.toTextObject();
      let field = res[nameObj[TextObject.NAME]];
      if (!Array.isArray(field)) {
        field = [];
        res[nameObj[TextObject.NAME]] = field;
      }
      field.push(nameObj);
    }
    return res;
  }
};
GeneralNames3.NAME = "GeneralNames";
var rPaddingTag = "-{5}";
var rEolChars = "\\n";
var rNameTag = `[^${rEolChars}]+`;
var rBeginTag = `${rPaddingTag}BEGIN (${rNameTag}(?=${rPaddingTag}))${rPaddingTag}`;
var rEndTag = `${rPaddingTag}END \\1${rPaddingTag}`;
var rEolGroup = "\\n";
var rHeaderKey = `[^:${rEolChars}]+`;
var rHeaderValue = `(?:[^${rEolChars}]+${rEolGroup}(?: +[^${rEolChars}]+${rEolGroup})*)`;
var rBase64Chars = "[a-zA-Z0-9=+/]+";
var rBase64 = `(?:${rBase64Chars}${rEolGroup})+`;
var rPem = `${rBeginTag}${rEolGroup}(?:((?:${rHeaderKey}: ${rHeaderValue})+))?${rEolGroup}?(${rBase64})${rEndTag}`;
var PemConverter = class {
  static isPem(data) {
    return typeof data === "string" && new RegExp(rPem, "g").test(data.replace(/\r/g, ""));
  }
  static decodeWithHeaders(pem) {
    pem = pem.replace(/\r/g, "");
    const pattern = new RegExp(rPem, "g");
    const res = [];
    let matches = null;
    while (matches = pattern.exec(pem)) {
      const base647 = matches[3].replace(new RegExp(`[${rEolChars}]+`, "g"), "");
      const pemStruct = {
        type: matches[1],
        headers: [],
        rawData: Convert.FromBase64(base647)
      };
      const headersString = matches[2];
      if (headersString) {
        const headers = headersString.split(new RegExp(rEolGroup, "g"));
        let lastHeader = null;
        for (const header of headers) {
          const [key, value7] = header.split(/:(.*)/);
          if (value7 === void 0) {
            if (!lastHeader) {
              throw new Error("Cannot parse PEM string. Incorrect header value");
            }
            lastHeader.value += key.trim();
          } else {
            if (lastHeader) {
              pemStruct.headers.push(lastHeader);
            }
            lastHeader = { key, value: value7.trim() };
          }
        }
        if (lastHeader) {
          pemStruct.headers.push(lastHeader);
        }
      }
      res.push(pemStruct);
    }
    return res;
  }
  static decode(pem) {
    const blocks = this.decodeWithHeaders(pem);
    return blocks.map((o) => o.rawData);
  }
  static decodeFirst(pem) {
    const items = this.decode(pem);
    if (!items.length) {
      throw new RangeError("PEM string doesn't contain any objects");
    }
    return items[0];
  }
  static encode(rawData, tag) {
    if (Array.isArray(rawData)) {
      const raws = new Array();
      if (tag) {
        rawData.forEach((element) => {
          if (!BufferSourceConverter.isBufferSource(element)) {
            throw new TypeError("Cannot encode array of BufferSource in PEM format. Not all items of the array are BufferSource");
          }
          raws.push(this.encodeStruct({
            type: tag,
            rawData: BufferSourceConverter.toArrayBuffer(element)
          }));
        });
      } else {
        rawData.forEach((element) => {
          if (!("type" in element)) {
            throw new TypeError("Cannot encode array of PemStruct in PEM format. Not all items of the array are PemStrut");
          }
          raws.push(this.encodeStruct(element));
        });
      }
      return raws.join("\n");
    } else {
      if (!tag) {
        throw new Error("Required argument 'tag' is missed");
      }
      return this.encodeStruct({
        type: tag,
        rawData: BufferSourceConverter.toArrayBuffer(rawData)
      });
    }
  }
  static encodeStruct(pem) {
    var _a3;
    const upperCaseType = pem.type.toLocaleUpperCase();
    const res = [];
    res.push(`-----BEGIN ${upperCaseType}-----`);
    if ((_a3 = pem.headers) === null || _a3 === void 0 ? void 0 : _a3.length) {
      for (const header of pem.headers) {
        res.push(`${header.key}: ${header.value}`);
      }
      res.push("");
    }
    const base647 = Convert.ToBase64(pem.rawData);
    let sliced;
    let offset = 0;
    const rows = Array();
    while (offset < base647.length) {
      if (base647.length - offset < 64) {
        sliced = base647.substring(offset);
      } else {
        sliced = base647.substring(offset, offset + 64);
        offset += 64;
      }
      if (sliced.length !== 0) {
        rows.push(sliced);
        if (sliced.length < 64) {
          break;
        }
      } else {
        break;
      }
    }
    res.push(...rows);
    res.push(`-----END ${upperCaseType}-----`);
    return res.join("\n");
  }
};
PemConverter.CertificateTag = "CERTIFICATE";
PemConverter.CrlTag = "CRL";
PemConverter.CertificateRequestTag = "CERTIFICATE REQUEST";
PemConverter.PublicKeyTag = "PUBLIC KEY";
PemConverter.PrivateKeyTag = "PRIVATE KEY";
var PemData = class _PemData extends AsnData {
  static isAsnEncoded(data) {
    return BufferSourceConverter.isBufferSource(data) || typeof data === "string";
  }
  static toArrayBuffer(raw) {
    if (typeof raw === "string") {
      if (PemConverter.isPem(raw)) {
        return PemConverter.decode(raw)[0];
      } else if (Convert.isHex(raw)) {
        return Convert.FromHex(raw);
      } else if (Convert.isBase64(raw)) {
        return Convert.FromBase64(raw);
      } else if (Convert.isBase64Url(raw)) {
        return Convert.FromBase64Url(raw);
      } else {
        throw new TypeError("Unsupported format of 'raw' argument. Must be one of DER, PEM, HEX, Base64, or Base4Url");
      }
    } else {
      const stringRaw = Convert.ToBinary(raw);
      if (PemConverter.isPem(stringRaw)) {
        return PemConverter.decode(stringRaw)[0];
      } else if (Convert.isHex(stringRaw)) {
        return Convert.FromHex(stringRaw);
      } else if (Convert.isBase64(stringRaw)) {
        return Convert.FromBase64(stringRaw);
      } else if (Convert.isBase64Url(stringRaw)) {
        return Convert.FromBase64Url(stringRaw);
      }
      return BufferSourceConverter.toArrayBuffer(raw);
    }
  }
  constructor(...args) {
    if (_PemData.isAsnEncoded(args[0])) {
      super(_PemData.toArrayBuffer(args[0]), args[1]);
    } else {
      super(args[0]);
    }
  }
  toString(format11 = "pem") {
    switch (format11) {
      case "pem":
        return PemConverter.encode(this.rawData, this.tag);
      default:
        return super.toString(format11);
    }
  }
};
var PublicKey = class _PublicKey extends PemData {
  static async create(data, crypto2 = cryptoProvider.get()) {
    if (data instanceof _PublicKey) {
      return data;
    } else if (CryptoProvider.isCryptoKey(data)) {
      if (data.type !== "public") {
        throw new TypeError("Public key is required");
      }
      const spki = await crypto2.subtle.exportKey("spki", data);
      return new _PublicKey(spki);
    } else if (data.publicKey) {
      return data.publicKey;
    } else if (BufferSourceConverter.isBufferSource(data)) {
      return new _PublicKey(data);
    } else {
      throw new TypeError("Unsupported PublicKeyType");
    }
  }
  constructor(param) {
    if (PemData.isAsnEncoded(param)) {
      super(param, SubjectPublicKeyInfo);
    } else {
      super(param);
    }
    this.tag = PemConverter.PublicKeyTag;
  }
  async export(...args) {
    let crypto2;
    let keyUsages = ["verify"];
    let algorithm = { hash: "SHA-256", ...this.algorithm };
    if (args.length > 1) {
      algorithm = args[0] || algorithm;
      keyUsages = args[1] || keyUsages;
      crypto2 = args[2] || cryptoProvider.get();
    } else {
      crypto2 = args[0] || cryptoProvider.get();
    }
    let raw = this.rawData;
    const asnSpki = AsnConvert.parse(this.rawData, SubjectPublicKeyInfo);
    if (asnSpki.algorithm.algorithm === id_RSASSA_PSS) {
      raw = convertSpkiToRsaPkcs1(asnSpki, raw);
    }
    return crypto2.subtle.importKey("spki", raw, algorithm, true, keyUsages);
  }
  onInit(asn) {
    const algProv = instance.resolve(diAlgorithmProvider);
    const algorithm = this.algorithm = algProv.toWebAlgorithm(asn.algorithm);
    switch (asn.algorithm.algorithm) {
      case id_rsaEncryption: {
        const rsaPublicKey = AsnConvert.parse(asn.subjectPublicKey, RSAPublicKey);
        const modulus = BufferSourceConverter.toUint8Array(rsaPublicKey.modulus);
        algorithm.publicExponent = BufferSourceConverter.toUint8Array(rsaPublicKey.publicExponent);
        algorithm.modulusLength = (!modulus[0] ? modulus.slice(1) : modulus).byteLength << 3;
        break;
      }
    }
  }
  async getThumbprint(...args) {
    var _a3;
    let crypto2;
    let algorithm = "SHA-1";
    if (args.length >= 1 && !((_a3 = args[0]) === null || _a3 === void 0 ? void 0 : _a3.subtle)) {
      algorithm = args[0] || algorithm;
      crypto2 = args[1] || cryptoProvider.get();
    } else {
      crypto2 = args[0] || cryptoProvider.get();
    }
    return await crypto2.subtle.digest(algorithm, this.rawData);
  }
  async getKeyIdentifier(...args) {
    let crypto2;
    let algorithm = "SHA-1";
    if (args.length === 1) {
      if (typeof args[0] === "string") {
        algorithm = args[0];
        crypto2 = cryptoProvider.get();
      } else {
        crypto2 = args[0];
      }
    } else if (args.length === 2) {
      algorithm = args[0];
      crypto2 = args[1];
    } else {
      crypto2 = cryptoProvider.get();
    }
    const asn = AsnConvert.parse(this.rawData, SubjectPublicKeyInfo);
    return await crypto2.subtle.digest(algorithm, asn.subjectPublicKey);
  }
  toTextObject() {
    const obj = this.toTextObjectEmpty();
    const asn = AsnConvert.parse(this.rawData, SubjectPublicKeyInfo);
    obj["Algorithm"] = TextConverter.serializeAlgorithm(asn.algorithm);
    switch (asn.algorithm.algorithm) {
      case id_ecPublicKey:
        obj["EC Point"] = asn.subjectPublicKey;
        break;
      case id_rsaEncryption:
      default:
        obj["Raw Data"] = asn.subjectPublicKey;
    }
    return obj;
  }
};
function convertSpkiToRsaPkcs1(asnSpki, raw) {
  asnSpki.algorithm = new AlgorithmIdentifier({
    algorithm: id_rsaEncryption,
    parameters: null
  });
  raw = AsnConvert.serialize(asnSpki);
  return raw;
}
var AuthorityKeyIdentifierExtension = class _AuthorityKeyIdentifierExtension extends Extension2 {
  static async create(param, critical = false, crypto2 = cryptoProvider.get()) {
    if ("name" in param && "serialNumber" in param) {
      return new _AuthorityKeyIdentifierExtension(param, critical);
    }
    const key = await PublicKey.create(param, crypto2);
    const id = await key.getKeyIdentifier(crypto2);
    return new _AuthorityKeyIdentifierExtension(Convert.ToHex(id), critical);
  }
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else if (typeof args[0] === "string") {
      const value7 = new AuthorityKeyIdentifier({ keyIdentifier: new KeyIdentifier(Convert.FromHex(args[0])) });
      super(id_ce_authorityKeyIdentifier, args[1], AsnConvert.serialize(value7));
    } else {
      const certId = args[0];
      const certIdName = certId.name instanceof GeneralNames3 ? AsnConvert.parse(certId.name.rawData, GeneralNames) : certId.name;
      const value7 = new AuthorityKeyIdentifier({
        authorityCertIssuer: certIdName,
        authorityCertSerialNumber: Convert.FromHex(certId.serialNumber)
      });
      super(id_ce_authorityKeyIdentifier, args[1], AsnConvert.serialize(value7));
    }
  }
  onInit(asn) {
    super.onInit(asn);
    const aki = AsnConvert.parse(asn.extnValue, AuthorityKeyIdentifier);
    if (aki.keyIdentifier) {
      this.keyId = Convert.ToHex(aki.keyIdentifier);
    }
    if (aki.authorityCertIssuer || aki.authorityCertSerialNumber) {
      this.certId = {
        name: aki.authorityCertIssuer || [],
        serialNumber: aki.authorityCertSerialNumber ? Convert.ToHex(aki.authorityCertSerialNumber) : ""
      };
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    const asn = AsnConvert.parse(this.value, AuthorityKeyIdentifier);
    if (asn.authorityCertIssuer) {
      obj["Authority Issuer"] = new GeneralNames3(asn.authorityCertIssuer).toTextObject();
    }
    if (asn.authorityCertSerialNumber) {
      obj["Authority Serial Number"] = asn.authorityCertSerialNumber;
    }
    if (asn.keyIdentifier) {
      obj[""] = asn.keyIdentifier;
    }
    return obj;
  }
};
AuthorityKeyIdentifierExtension.NAME = "Authority Key Identifier";
var BasicConstraintsExtension = class extends Extension2 {
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
      const value7 = AsnConvert.parse(this.value, BasicConstraints);
      this.ca = value7.cA;
      this.pathLength = value7.pathLenConstraint;
    } else {
      const value7 = new BasicConstraints({
        cA: args[0],
        pathLenConstraint: args[1]
      });
      super(id_ce_basicConstraints, args[2], AsnConvert.serialize(value7));
      this.ca = args[0];
      this.pathLength = args[1];
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    if (this.ca) {
      obj["CA"] = this.ca;
    }
    if (this.pathLength !== void 0) {
      obj["Path Length"] = this.pathLength;
    }
    return obj;
  }
};
BasicConstraintsExtension.NAME = "Basic Constraints";
var ExtendedKeyUsage3;
(function(ExtendedKeyUsage4) {
  ExtendedKeyUsage4["serverAuth"] = "1.3.6.1.5.5.7.3.1";
  ExtendedKeyUsage4["clientAuth"] = "1.3.6.1.5.5.7.3.2";
  ExtendedKeyUsage4["codeSigning"] = "1.3.6.1.5.5.7.3.3";
  ExtendedKeyUsage4["emailProtection"] = "1.3.6.1.5.5.7.3.4";
  ExtendedKeyUsage4["timeStamping"] = "1.3.6.1.5.5.7.3.8";
  ExtendedKeyUsage4["ocspSigning"] = "1.3.6.1.5.5.7.3.9";
})(ExtendedKeyUsage3 || (ExtendedKeyUsage3 = {}));
var ExtendedKeyUsageExtension = class extends Extension2 {
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
      const value7 = AsnConvert.parse(this.value, ExtendedKeyUsage);
      this.usages = value7.map((o) => o);
    } else {
      const value7 = new ExtendedKeyUsage(args[0]);
      super(id_ce_extKeyUsage, args[1], AsnConvert.serialize(value7));
      this.usages = args[0];
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    obj[""] = this.usages.map((o) => OidSerializer.toString(o)).join(", ");
    return obj;
  }
};
ExtendedKeyUsageExtension.NAME = "Extended Key Usages";
var KeyUsageFlags2;
(function(KeyUsageFlags3) {
  KeyUsageFlags3[KeyUsageFlags3["digitalSignature"] = 1] = "digitalSignature";
  KeyUsageFlags3[KeyUsageFlags3["nonRepudiation"] = 2] = "nonRepudiation";
  KeyUsageFlags3[KeyUsageFlags3["keyEncipherment"] = 4] = "keyEncipherment";
  KeyUsageFlags3[KeyUsageFlags3["dataEncipherment"] = 8] = "dataEncipherment";
  KeyUsageFlags3[KeyUsageFlags3["keyAgreement"] = 16] = "keyAgreement";
  KeyUsageFlags3[KeyUsageFlags3["keyCertSign"] = 32] = "keyCertSign";
  KeyUsageFlags3[KeyUsageFlags3["cRLSign"] = 64] = "cRLSign";
  KeyUsageFlags3[KeyUsageFlags3["encipherOnly"] = 128] = "encipherOnly";
  KeyUsageFlags3[KeyUsageFlags3["decipherOnly"] = 256] = "decipherOnly";
})(KeyUsageFlags2 || (KeyUsageFlags2 = {}));
var KeyUsagesExtension = class extends Extension2 {
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
      const value7 = AsnConvert.parse(this.value, KeyUsage);
      this.usages = value7.toNumber();
    } else {
      const value7 = new KeyUsage(args[0]);
      super(id_ce_keyUsage, args[1], AsnConvert.serialize(value7));
      this.usages = args[0];
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    const asn = AsnConvert.parse(this.value, KeyUsage);
    obj[""] = asn.toJSON().join(", ");
    return obj;
  }
};
KeyUsagesExtension.NAME = "Key Usages";
var SubjectKeyIdentifierExtension = class _SubjectKeyIdentifierExtension extends Extension2 {
  static async create(publicKey2, critical = false, crypto2 = cryptoProvider.get()) {
    const key = await PublicKey.create(publicKey2, crypto2);
    const id = await key.getKeyIdentifier(crypto2);
    return new _SubjectKeyIdentifierExtension(Convert.ToHex(id), critical);
  }
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
      const value7 = AsnConvert.parse(this.value, SubjectKeyIdentifier);
      this.keyId = Convert.ToHex(value7);
    } else {
      const identifier = typeof args[0] === "string" ? Convert.FromHex(args[0]) : args[0];
      const value7 = new SubjectKeyIdentifier(identifier);
      super(id_ce_subjectKeyIdentifier, args[1], AsnConvert.serialize(value7));
      this.keyId = Convert.ToHex(identifier);
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    const asn = AsnConvert.parse(this.value, SubjectKeyIdentifier);
    obj[""] = asn;
    return obj;
  }
};
SubjectKeyIdentifierExtension.NAME = "Subject Key Identifier";
var SubjectAlternativeNameExtension = class extends Extension2 {
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else {
      super(id_ce_subjectAltName, args[1], new GeneralNames3(args[0] || []).rawData);
    }
  }
  onInit(asn) {
    super.onInit(asn);
    const value7 = AsnConvert.parse(asn.extnValue, SubjectAlternativeName);
    this.names = new GeneralNames3(value7);
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    const namesObj = this.names.toTextObject();
    for (const key in namesObj) {
      obj[key] = namesObj[key];
    }
    return obj;
  }
};
SubjectAlternativeNameExtension.NAME = "Subject Alternative Name";
var ExtensionFactory = class {
  static register(id, type) {
    this.items.set(id, type);
  }
  static create(data) {
    const extension = new Extension2(data);
    const Type = this.items.get(extension.type);
    if (Type) {
      return new Type(data);
    }
    return extension;
  }
};
ExtensionFactory.items = /* @__PURE__ */ new Map();
var CertificatePolicyExtension = class extends Extension2 {
  constructor(...args) {
    var _a3;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
      const asnPolicies = AsnConvert.parse(this.value, CertificatePolicies);
      this.policies = asnPolicies.map((o) => o.policyIdentifier);
    } else {
      const policies = args[0];
      const critical = (_a3 = args[1]) !== null && _a3 !== void 0 ? _a3 : false;
      const value7 = new CertificatePolicies(policies.map((o) => new PolicyInformation({
        policyIdentifier: o
      })));
      super(id_ce_certificatePolicies, critical, AsnConvert.serialize(value7));
      this.policies = policies;
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    obj["Policy"] = this.policies.map((o) => new TextObject("", {}, OidSerializer.toString(o)));
    return obj;
  }
};
CertificatePolicyExtension.NAME = "Certificate Policies";
ExtensionFactory.register(id_ce_certificatePolicies, CertificatePolicyExtension);
var CRLDistributionPointsExtension = class extends Extension2 {
  constructor(...args) {
    var _a3;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else if (Array.isArray(args[0]) && typeof args[0][0] === "string") {
      const urls = args[0];
      const dps = urls.map((url) => {
        return new DistributionPoint({
          distributionPoint: new DistributionPointName({
            fullName: [new GeneralName({ uniformResourceIdentifier: url })]
          })
        });
      });
      const value7 = new CRLDistributionPoints(dps);
      super(id_ce_cRLDistributionPoints, args[1], AsnConvert.serialize(value7));
    } else {
      const value7 = new CRLDistributionPoints(args[0]);
      super(id_ce_cRLDistributionPoints, args[1], AsnConvert.serialize(value7));
    }
    (_a3 = this.distributionPoints) !== null && _a3 !== void 0 ? _a3 : this.distributionPoints = [];
  }
  onInit(asn) {
    super.onInit(asn);
    const crlExt = AsnConvert.parse(asn.extnValue, CRLDistributionPoints);
    this.distributionPoints = crlExt;
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    obj["Distribution Point"] = this.distributionPoints.map((dp) => {
      var _a3;
      const dpObj = {};
      if (dp.distributionPoint) {
        dpObj[""] = (_a3 = dp.distributionPoint.fullName) === null || _a3 === void 0 ? void 0 : _a3.map((name9) => new GeneralName3(name9).toString()).join(", ");
      }
      if (dp.reasons) {
        dpObj["Reasons"] = dp.reasons.toString();
      }
      if (dp.cRLIssuer) {
        dpObj["CRL Issuer"] = dp.cRLIssuer.map((issuer) => issuer.toString()).join(", ");
      }
      return dpObj;
    });
    return obj;
  }
};
CRLDistributionPointsExtension.NAME = "CRL Distribution Points";
var AuthorityInfoAccessExtension = class extends Extension2 {
  constructor(...args) {
    var _a3, _b, _c, _d;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else if (args[0] instanceof AuthorityInfoAccessSyntax) {
      const value7 = new AuthorityInfoAccessSyntax(args[0]);
      super(id_pe_authorityInfoAccess, args[1], AsnConvert.serialize(value7));
    } else {
      const params = args[0];
      const value7 = new AuthorityInfoAccessSyntax();
      addAccessDescriptions(value7, params, id_ad_ocsp, "ocsp");
      addAccessDescriptions(value7, params, id_ad_caIssuers, "caIssuers");
      addAccessDescriptions(value7, params, id_ad_timeStamping, "timeStamping");
      addAccessDescriptions(value7, params, id_ad_caRepository, "caRepository");
      super(id_pe_authorityInfoAccess, args[1], AsnConvert.serialize(value7));
    }
    (_a3 = this.ocsp) !== null && _a3 !== void 0 ? _a3 : this.ocsp = [];
    (_b = this.caIssuers) !== null && _b !== void 0 ? _b : this.caIssuers = [];
    (_c = this.timeStamping) !== null && _c !== void 0 ? _c : this.timeStamping = [];
    (_d = this.caRepository) !== null && _d !== void 0 ? _d : this.caRepository = [];
  }
  onInit(asn) {
    super.onInit(asn);
    this.ocsp = [];
    this.caIssuers = [];
    this.timeStamping = [];
    this.caRepository = [];
    const aia = AsnConvert.parse(asn.extnValue, AuthorityInfoAccessSyntax);
    aia.forEach((accessDescription) => {
      switch (accessDescription.accessMethod) {
        case id_ad_ocsp:
          this.ocsp.push(new GeneralName3(accessDescription.accessLocation));
          break;
        case id_ad_caIssuers:
          this.caIssuers.push(new GeneralName3(accessDescription.accessLocation));
          break;
        case id_ad_timeStamping:
          this.timeStamping.push(new GeneralName3(accessDescription.accessLocation));
          break;
        case id_ad_caRepository:
          this.caRepository.push(new GeneralName3(accessDescription.accessLocation));
          break;
      }
    });
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    if (this.ocsp.length) {
      addUrlsToObject(obj, "OCSP", this.ocsp);
    }
    if (this.caIssuers.length) {
      addUrlsToObject(obj, "CA Issuers", this.caIssuers);
    }
    if (this.timeStamping.length) {
      addUrlsToObject(obj, "Time Stamping", this.timeStamping);
    }
    if (this.caRepository.length) {
      addUrlsToObject(obj, "CA Repository", this.caRepository);
    }
    return obj;
  }
};
AuthorityInfoAccessExtension.NAME = "Authority Info Access";
function addUrlsToObject(obj, key, urls) {
  if (urls.length === 1) {
    obj[key] = urls[0].toTextObject();
  } else {
    const names2 = new TextObject("");
    urls.forEach((name9, index) => {
      const nameObj = name9.toTextObject();
      const indexedKey = `${nameObj[TextObject.NAME]} ${index + 1}`;
      let field = names2[indexedKey];
      if (!Array.isArray(field)) {
        field = [];
        names2[indexedKey] = field;
      }
      field.push(nameObj);
    });
    obj[key] = names2;
  }
}
function addAccessDescriptions(value7, params, method, key) {
  const items = params[key];
  if (items) {
    const array = Array.isArray(items) ? items : [items];
    array.forEach((url) => {
      if (typeof url === "string") {
        url = new GeneralName3("url", url);
      }
      value7.push(new AccessDescription({
        accessMethod: method,
        accessLocation: AsnConvert.parse(url.rawData, GeneralName)
      }));
    });
  }
}
var IssuerAlternativeNameExtension = class extends Extension2 {
  constructor(...args) {
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else {
      super(id_ce_issuerAltName, args[1], new GeneralNames3(args[0] || []).rawData);
    }
  }
  onInit(asn) {
    super.onInit(asn);
    const value7 = AsnConvert.parse(asn.extnValue, GeneralNames);
    this.names = new GeneralNames3(value7);
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    const namesObj = this.names.toTextObject();
    for (const key in namesObj) {
      obj[key] = namesObj[key];
    }
    return obj;
  }
};
IssuerAlternativeNameExtension.NAME = "Issuer Alternative Name";
var Attribute3 = class _Attribute extends AsnData {
  constructor(...args) {
    let raw;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      raw = BufferSourceConverter.toArrayBuffer(args[0]);
    } else {
      const type = args[0];
      const values = Array.isArray(args[1]) ? args[1].map((o) => BufferSourceConverter.toArrayBuffer(o)) : [];
      raw = AsnConvert.serialize(new Attribute({ type, values }));
    }
    super(raw, Attribute);
  }
  onInit(asn) {
    this.type = asn.type;
    this.values = asn.values;
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    obj["Value"] = this.values.map((o) => new TextObject("", { "": o }));
    return obj;
  }
  toTextObjectWithoutValue() {
    const obj = this.toTextObjectEmpty();
    if (obj[TextObject.NAME] === _Attribute.NAME) {
      obj[TextObject.NAME] = OidSerializer.toString(this.type);
    }
    return obj;
  }
};
Attribute3.NAME = "Attribute";
var ChallengePasswordAttribute = class extends Attribute3 {
  constructor(...args) {
    var _a3;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else {
      const value7 = new ChallengePassword({
        printableString: args[0]
      });
      super(id_pkcs9_at_challengePassword, [AsnConvert.serialize(value7)]);
    }
    (_a3 = this.password) !== null && _a3 !== void 0 ? _a3 : this.password = "";
  }
  onInit(asn) {
    super.onInit(asn);
    if (this.values[0]) {
      const value7 = AsnConvert.parse(this.values[0], ChallengePassword);
      this.password = value7.toString();
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    obj[TextObject.VALUE] = this.password;
    return obj;
  }
};
ChallengePasswordAttribute.NAME = "Challenge Password";
var ExtensionsAttribute = class extends Attribute3 {
  constructor(...args) {
    var _a3;
    if (BufferSourceConverter.isBufferSource(args[0])) {
      super(args[0]);
    } else {
      const extensions = args[0];
      const value7 = new Extensions();
      for (const extension of extensions) {
        value7.push(AsnConvert.parse(extension.rawData, Extension));
      }
      super(id_pkcs9_at_extensionRequest, [AsnConvert.serialize(value7)]);
    }
    (_a3 = this.items) !== null && _a3 !== void 0 ? _a3 : this.items = [];
  }
  onInit(asn) {
    super.onInit(asn);
    if (this.values[0]) {
      const value7 = AsnConvert.parse(this.values[0], Extensions);
      this.items = value7.map((o) => ExtensionFactory.create(AsnConvert.serialize(o)));
    }
  }
  toTextObject() {
    const obj = this.toTextObjectWithoutValue();
    const extensions = this.items.map((o) => o.toTextObject());
    for (const extension of extensions) {
      obj[extension[TextObject.NAME]] = extension;
    }
    return obj;
  }
};
ExtensionsAttribute.NAME = "Extensions";
var AttributeFactory = class {
  static register(id, type) {
    this.items.set(id, type);
  }
  static create(data) {
    const attribute = new Attribute3(data);
    const Type = this.items.get(attribute.type);
    if (Type) {
      return new Type(data);
    }
    return attribute;
  }
};
AttributeFactory.items = /* @__PURE__ */ new Map();
var diAsnSignatureFormatter = "crypto.signatureFormatter";
var AsnDefaultSignatureFormatter = class {
  toAsnSignature(algorithm, signature) {
    return BufferSourceConverter.toArrayBuffer(signature);
  }
  toWebSignature(algorithm, signature) {
    return BufferSourceConverter.toArrayBuffer(signature);
  }
};
var RsaAlgorithm_1;
var RsaAlgorithm = RsaAlgorithm_1 = class RsaAlgorithm2 {
  static createPssParams(hash, saltLength) {
    const hashAlgorithm = RsaAlgorithm_1.getHashAlgorithm(hash);
    if (!hashAlgorithm) {
      return null;
    }
    return new RsaSaPssParams({
      hashAlgorithm,
      maskGenAlgorithm: new AlgorithmIdentifier({
        algorithm: id_mgf1,
        parameters: AsnConvert.serialize(hashAlgorithm)
      }),
      saltLength
    });
  }
  static getHashAlgorithm(alg) {
    const algProv = instance.resolve(diAlgorithmProvider);
    if (typeof alg === "string") {
      return algProv.toAsnAlgorithm({ name: alg });
    }
    if (typeof alg === "object" && alg && "name" in alg) {
      return algProv.toAsnAlgorithm(alg);
    }
    return null;
  }
  toAsnAlgorithm(alg) {
    switch (alg.name.toLowerCase()) {
      case "rsassa-pkcs1-v1_5":
        if ("hash" in alg) {
          let hash;
          if (typeof alg.hash === "string") {
            hash = alg.hash;
          } else if (alg.hash && typeof alg.hash === "object" && "name" in alg.hash && typeof alg.hash.name === "string") {
            hash = alg.hash.name.toUpperCase();
          } else {
            throw new Error("Cannot get hash algorithm name");
          }
          switch (hash.toLowerCase()) {
            case "sha-1":
              return new AlgorithmIdentifier({ algorithm: id_sha1WithRSAEncryption, parameters: null });
            case "sha-256":
              return new AlgorithmIdentifier({ algorithm: id_sha256WithRSAEncryption, parameters: null });
            case "sha-384":
              return new AlgorithmIdentifier({ algorithm: id_sha384WithRSAEncryption, parameters: null });
            case "sha-512":
              return new AlgorithmIdentifier({ algorithm: id_sha512WithRSAEncryption, parameters: null });
          }
        } else {
          return new AlgorithmIdentifier({ algorithm: id_rsaEncryption, parameters: null });
        }
        break;
      case "rsa-pss":
        if ("hash" in alg) {
          if (!("saltLength" in alg && typeof alg.saltLength === "number")) {
            throw new Error("Cannot get 'saltLength' from 'alg' argument");
          }
          const pssParams = RsaAlgorithm_1.createPssParams(alg.hash, alg.saltLength);
          if (!pssParams) {
            throw new Error("Cannot create PSS parameters");
          }
          return new AlgorithmIdentifier({ algorithm: id_RSASSA_PSS, parameters: AsnConvert.serialize(pssParams) });
        } else {
          return new AlgorithmIdentifier({ algorithm: id_RSASSA_PSS, parameters: null });
        }
    }
    return null;
  }
  toWebAlgorithm(alg) {
    switch (alg.algorithm) {
      case id_rsaEncryption:
        return { name: "RSASSA-PKCS1-v1_5" };
      case id_sha1WithRSAEncryption:
        return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-1" } };
      case id_sha256WithRSAEncryption:
        return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } };
      case id_sha384WithRSAEncryption:
        return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-384" } };
      case id_sha512WithRSAEncryption:
        return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-512" } };
      case id_RSASSA_PSS:
        if (alg.parameters) {
          const pssParams = AsnConvert.parse(alg.parameters, RsaSaPssParams);
          const algProv = instance.resolve(diAlgorithmProvider);
          const hashAlg = algProv.toWebAlgorithm(pssParams.hashAlgorithm);
          return {
            name: "RSA-PSS",
            hash: hashAlg,
            saltLength: pssParams.saltLength
          };
        } else {
          return { name: "RSA-PSS" };
        }
    }
    return null;
  }
};
RsaAlgorithm = RsaAlgorithm_1 = __decorate6([
  injectable_default()
], RsaAlgorithm);
instance.registerSingleton(diAlgorithm, RsaAlgorithm);
var ShaAlgorithm = class ShaAlgorithm2 {
  toAsnAlgorithm(alg) {
    switch (alg.name.toLowerCase()) {
      case "sha-1":
        return new AlgorithmIdentifier({ algorithm: id_sha1 });
      case "sha-256":
        return new AlgorithmIdentifier({ algorithm: id_sha256 });
      case "sha-384":
        return new AlgorithmIdentifier({ algorithm: id_sha384 });
      case "sha-512":
        return new AlgorithmIdentifier({ algorithm: id_sha512 });
    }
    return null;
  }
  toWebAlgorithm(alg) {
    switch (alg.algorithm) {
      case id_sha1:
        return { name: "SHA-1" };
      case id_sha256:
        return { name: "SHA-256" };
      case id_sha384:
        return { name: "SHA-384" };
      case id_sha512:
        return { name: "SHA-512" };
    }
    return null;
  }
};
ShaAlgorithm = __decorate6([
  injectable_default()
], ShaAlgorithm);
instance.registerSingleton(diAlgorithm, ShaAlgorithm);
var AsnEcSignatureFormatter = class _AsnEcSignatureFormatter {
  addPadding(pointSize, data) {
    const bytes = BufferSourceConverter.toUint8Array(data);
    const res = new Uint8Array(pointSize);
    res.set(bytes, pointSize - bytes.length);
    return res;
  }
  removePadding(data, positive = false) {
    let bytes = BufferSourceConverter.toUint8Array(data);
    for (let i = 0; i < bytes.length; i++) {
      if (!bytes[i]) {
        continue;
      }
      bytes = bytes.slice(i);
      break;
    }
    if (positive && bytes[0] > 127) {
      const result = new Uint8Array(bytes.length + 1);
      result.set(bytes, 1);
      return result.buffer;
    }
    return bytes.buffer;
  }
  toAsnSignature(algorithm, signature) {
    if (algorithm.name === "ECDSA") {
      const namedCurve = algorithm.namedCurve;
      const pointSize = _AsnEcSignatureFormatter.namedCurveSize.get(namedCurve) || _AsnEcSignatureFormatter.defaultNamedCurveSize;
      const ecSignature = new ECDSASigValue();
      const uint8Signature = BufferSourceConverter.toUint8Array(signature);
      ecSignature.r = this.removePadding(uint8Signature.slice(0, pointSize), true);
      ecSignature.s = this.removePadding(uint8Signature.slice(pointSize, pointSize + pointSize), true);
      return AsnConvert.serialize(ecSignature);
    }
    return null;
  }
  toWebSignature(algorithm, signature) {
    if (algorithm.name === "ECDSA") {
      const ecSigValue = AsnConvert.parse(signature, ECDSASigValue);
      const namedCurve = algorithm.namedCurve;
      const pointSize = _AsnEcSignatureFormatter.namedCurveSize.get(namedCurve) || _AsnEcSignatureFormatter.defaultNamedCurveSize;
      const r = this.addPadding(pointSize, this.removePadding(ecSigValue.r));
      const s = this.addPadding(pointSize, this.removePadding(ecSigValue.s));
      return combine(r, s);
    }
    return null;
  }
};
AsnEcSignatureFormatter.namedCurveSize = /* @__PURE__ */ new Map();
AsnEcSignatureFormatter.defaultNamedCurveSize = 32;
var idX25519 = "1.3.101.110";
var idX448 = "1.3.101.111";
var idEd25519 = "1.3.101.112";
var idEd448 = "1.3.101.113";
var EdAlgorithm = class EdAlgorithm2 {
  toAsnAlgorithm(alg) {
    let algorithm = null;
    switch (alg.name.toLowerCase()) {
      case "ed25519":
        algorithm = idEd25519;
        break;
      case "x25519":
        algorithm = idX25519;
        break;
      case "eddsa":
        switch (alg.namedCurve.toLowerCase()) {
          case "ed25519":
            algorithm = idEd25519;
            break;
          case "ed448":
            algorithm = idEd448;
            break;
        }
        break;
      case "ecdh-es":
        switch (alg.namedCurve.toLowerCase()) {
          case "x25519":
            algorithm = idX25519;
            break;
          case "x448":
            algorithm = idX448;
            break;
        }
    }
    if (algorithm) {
      return new AlgorithmIdentifier({
        algorithm
      });
    }
    return null;
  }
  toWebAlgorithm(alg) {
    switch (alg.algorithm) {
      case idEd25519:
        return { name: "Ed25519" };
      case idEd448:
        return { name: "EdDSA", namedCurve: "Ed448" };
      case idX25519:
        return { name: "X25519" };
      case idX448:
        return { name: "ECDH-ES", namedCurve: "X448" };
    }
    return null;
  }
};
EdAlgorithm = __decorate6([
  injectable_default()
], EdAlgorithm);
instance.registerSingleton(diAlgorithm, EdAlgorithm);
var Pkcs10CertificateRequest = class extends PemData {
  constructor(param) {
    if (PemData.isAsnEncoded(param)) {
      super(param, CertificationRequest);
    } else {
      super(param);
    }
    this.tag = PemConverter.CertificateRequestTag;
  }
  onInit(asn) {
    this.tbs = AsnConvert.serialize(asn.certificationRequestInfo);
    this.publicKey = new PublicKey(asn.certificationRequestInfo.subjectPKInfo);
    const algProv = instance.resolve(diAlgorithmProvider);
    this.signatureAlgorithm = algProv.toWebAlgorithm(asn.signatureAlgorithm);
    this.signature = asn.signature;
    this.attributes = asn.certificationRequestInfo.attributes.map((o) => AttributeFactory.create(AsnConvert.serialize(o)));
    const extensions = this.getAttribute(id_pkcs9_at_extensionRequest);
    this.extensions = [];
    if (extensions instanceof ExtensionsAttribute) {
      this.extensions = extensions.items;
    }
    this.subjectName = new Name3(asn.certificationRequestInfo.subject);
    this.subject = this.subjectName.toString();
  }
  getAttribute(type) {
    for (const attr of this.attributes) {
      if (attr.type === type) {
        return attr;
      }
    }
    return null;
  }
  getAttributes(type) {
    return this.attributes.filter((o) => o.type === type);
  }
  getExtension(type) {
    for (const ext of this.extensions) {
      if (ext.type === type) {
        return ext;
      }
    }
    return null;
  }
  getExtensions(type) {
    return this.extensions.filter((o) => o.type === type);
  }
  async verify(crypto2 = cryptoProvider.get()) {
    const algorithm = { ...this.publicKey.algorithm, ...this.signatureAlgorithm };
    const publicKey2 = await this.publicKey.export(algorithm, ["verify"], crypto2);
    const signatureFormatters = instance.resolveAll(diAsnSignatureFormatter).reverse();
    let signature = null;
    for (const signatureFormatter of signatureFormatters) {
      signature = signatureFormatter.toWebSignature(algorithm, this.signature);
      if (signature) {
        break;
      }
    }
    if (!signature) {
      throw Error("Cannot convert WebCrypto signature value to ASN.1 format");
    }
    const ok = await crypto2.subtle.verify(this.signatureAlgorithm, publicKey2, signature, this.tbs);
    return ok;
  }
  toTextObject() {
    const obj = this.toTextObjectEmpty();
    const req = AsnConvert.parse(this.rawData, CertificationRequest);
    const tbs = req.certificationRequestInfo;
    const data = new TextObject("", {
      "Version": `${Version[tbs.version]} (${tbs.version})`,
      "Subject": this.subject,
      "Subject Public Key Info": this.publicKey
    });
    if (this.attributes.length) {
      const attrs = new TextObject("");
      for (const ext of this.attributes) {
        const attrObj = ext.toTextObject();
        attrs[attrObj[TextObject.NAME]] = attrObj;
      }
      data["Attributes"] = attrs;
    }
    obj["Data"] = data;
    obj["Signature"] = new TextObject("", {
      "Algorithm": TextConverter.serializeAlgorithm(req.signatureAlgorithm),
      "": req.signature
    });
    return obj;
  }
};
Pkcs10CertificateRequest.NAME = "PKCS#10 Certificate Request";
var X509Certificate = class extends PemData {
  constructor(param) {
    if (PemData.isAsnEncoded(param)) {
      super(param, Certificate);
    } else {
      super(param);
    }
    this.tag = PemConverter.CertificateTag;
  }
  onInit(asn) {
    const tbs = asn.tbsCertificate;
    this.tbs = AsnConvert.serialize(tbs);
    let serialNumberBytes = new Uint8Array(tbs.serialNumber);
    if (serialNumberBytes.length > 1 && serialNumberBytes[0] === 0 && serialNumberBytes[1] > 127) {
      serialNumberBytes = serialNumberBytes.slice(1);
    }
    this.serialNumber = Convert.ToHex(serialNumberBytes);
    this.subjectName = new Name3(tbs.subject);
    this.subject = new Name3(tbs.subject).toString();
    this.issuerName = new Name3(tbs.issuer);
    this.issuer = this.issuerName.toString();
    const algProv = instance.resolve(diAlgorithmProvider);
    this.signatureAlgorithm = algProv.toWebAlgorithm(asn.signatureAlgorithm);
    this.signature = asn.signatureValue;
    const notBefore = tbs.validity.notBefore.utcTime || tbs.validity.notBefore.generalTime;
    if (!notBefore) {
      throw new Error("Cannot get 'notBefore' value");
    }
    this.notBefore = notBefore;
    const notAfter = tbs.validity.notAfter.utcTime || tbs.validity.notAfter.generalTime;
    if (!notAfter) {
      throw new Error("Cannot get 'notAfter' value");
    }
    this.notAfter = notAfter;
    this.extensions = [];
    if (tbs.extensions) {
      this.extensions = tbs.extensions.map((o) => ExtensionFactory.create(AsnConvert.serialize(o)));
    }
    this.publicKey = new PublicKey(tbs.subjectPublicKeyInfo);
  }
  getExtension(type) {
    for (const ext of this.extensions) {
      if (typeof type === "string") {
        if (ext.type === type) {
          return ext;
        }
      } else {
        if (ext instanceof type) {
          return ext;
        }
      }
    }
    return null;
  }
  getExtensions(type) {
    return this.extensions.filter((o) => {
      if (typeof type === "string") {
        return o.type === type;
      } else {
        return o instanceof type;
      }
    });
  }
  async verify(params = {}, crypto2 = cryptoProvider.get()) {
    let keyAlgorithm;
    let publicKey2;
    const paramsKey = params.publicKey;
    try {
      if (!paramsKey) {
        keyAlgorithm = { ...this.publicKey.algorithm, ...this.signatureAlgorithm };
        publicKey2 = await this.publicKey.export(keyAlgorithm, ["verify"], crypto2);
      } else if ("publicKey" in paramsKey) {
        keyAlgorithm = { ...paramsKey.publicKey.algorithm, ...this.signatureAlgorithm };
        publicKey2 = await paramsKey.publicKey.export(keyAlgorithm, ["verify"], crypto2);
      } else if (paramsKey instanceof PublicKey) {
        keyAlgorithm = { ...paramsKey.algorithm, ...this.signatureAlgorithm };
        publicKey2 = await paramsKey.export(keyAlgorithm, ["verify"], crypto2);
      } else if (BufferSourceConverter.isBufferSource(paramsKey)) {
        const key = new PublicKey(paramsKey);
        keyAlgorithm = { ...key.algorithm, ...this.signatureAlgorithm };
        publicKey2 = await key.export(keyAlgorithm, ["verify"], crypto2);
      } else {
        keyAlgorithm = { ...paramsKey.algorithm, ...this.signatureAlgorithm };
        publicKey2 = paramsKey;
      }
    } catch (_e) {
      return false;
    }
    const signatureFormatters = instance.resolveAll(diAsnSignatureFormatter).reverse();
    let signature = null;
    for (const signatureFormatter of signatureFormatters) {
      signature = signatureFormatter.toWebSignature(keyAlgorithm, this.signature);
      if (signature) {
        break;
      }
    }
    if (!signature) {
      throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
    }
    const ok = await crypto2.subtle.verify(this.signatureAlgorithm, publicKey2, signature, this.tbs);
    if (params.signatureOnly) {
      return ok;
    } else {
      const date = params.date || /* @__PURE__ */ new Date();
      const time = date.getTime();
      return ok && this.notBefore.getTime() < time && time < this.notAfter.getTime();
    }
  }
  async getThumbprint(...args) {
    let crypto2;
    let algorithm = "SHA-1";
    if (args[0]) {
      if (!args[0].subtle) {
        algorithm = args[0] || algorithm;
        crypto2 = args[1];
      } else {
        crypto2 = args[0];
      }
    }
    crypto2 !== null && crypto2 !== void 0 ? crypto2 : crypto2 = cryptoProvider.get();
    return await crypto2.subtle.digest(algorithm, this.rawData);
  }
  async isSelfSigned(crypto2 = cryptoProvider.get()) {
    return this.subject === this.issuer && await this.verify({ signatureOnly: true }, crypto2);
  }
  toTextObject() {
    const obj = this.toTextObjectEmpty();
    const cert = AsnConvert.parse(this.rawData, Certificate);
    const tbs = cert.tbsCertificate;
    const data = new TextObject("", {
      "Version": `${Version[tbs.version]} (${tbs.version})`,
      "Serial Number": tbs.serialNumber,
      "Signature Algorithm": TextConverter.serializeAlgorithm(tbs.signature),
      "Issuer": this.issuer,
      "Validity": new TextObject("", {
        "Not Before": tbs.validity.notBefore.getTime(),
        "Not After": tbs.validity.notAfter.getTime()
      }),
      "Subject": this.subject,
      "Subject Public Key Info": this.publicKey
    });
    if (tbs.issuerUniqueID) {
      data["Issuer Unique ID"] = tbs.issuerUniqueID;
    }
    if (tbs.subjectUniqueID) {
      data["Subject Unique ID"] = tbs.subjectUniqueID;
    }
    if (this.extensions.length) {
      const extensions = new TextObject("");
      for (const ext of this.extensions) {
        const extObj = ext.toTextObject();
        extensions[extObj[TextObject.NAME]] = extObj;
      }
      data["Extensions"] = extensions;
    }
    obj["Data"] = data;
    obj["Signature"] = new TextObject("", {
      "Algorithm": TextConverter.serializeAlgorithm(cert.signatureAlgorithm),
      "": cert.signatureValue
    });
    return obj;
  }
};
X509Certificate.NAME = "Certificate";
var X509CertificateGenerator = class {
  static async createSelfSigned(params, crypto2 = cryptoProvider.get()) {
    if (!params.keys.privateKey) {
      throw new Error("Bad field 'keys' in 'params' argument. 'privateKey' is empty");
    }
    if (!params.keys.publicKey) {
      throw new Error("Bad field 'keys' in 'params' argument. 'publicKey' is empty");
    }
    return this.create({
      serialNumber: params.serialNumber,
      subject: params.name,
      issuer: params.name,
      notBefore: params.notBefore,
      notAfter: params.notAfter,
      publicKey: params.keys.publicKey,
      signingKey: params.keys.privateKey,
      signingAlgorithm: params.signingAlgorithm,
      extensions: params.extensions
    }, crypto2);
  }
  static async create(params, crypto2 = cryptoProvider.get()) {
    var _a3;
    let spki;
    if (params.publicKey instanceof PublicKey) {
      spki = params.publicKey.rawData;
    } else if ("publicKey" in params.publicKey) {
      spki = params.publicKey.publicKey.rawData;
    } else if (BufferSourceConverter.isBufferSource(params.publicKey)) {
      spki = params.publicKey;
    } else {
      spki = await crypto2.subtle.exportKey("spki", params.publicKey);
    }
    let serialNumber = params.serialNumber ? BufferSourceConverter.toUint8Array(Convert.FromHex(params.serialNumber)) : void 0;
    serialNumber = this.generateSerialNumber(serialNumber, crypto2);
    const notBefore = params.notBefore || /* @__PURE__ */ new Date();
    const notAfter = params.notAfter || new Date(notBefore.getTime() + 31536e6);
    const asnX509 = new Certificate({
      tbsCertificate: new TBSCertificate({
        version: Version.v3,
        serialNumber,
        validity: new Validity({
          notBefore,
          notAfter
        }),
        extensions: new Extensions(((_a3 = params.extensions) === null || _a3 === void 0 ? void 0 : _a3.map((o) => AsnConvert.parse(o.rawData, Extension))) || []),
        subjectPublicKeyInfo: AsnConvert.parse(spki, SubjectPublicKeyInfo)
      })
    });
    if (params.subject) {
      const name9 = params.subject instanceof Name3 ? params.subject : new Name3(params.subject);
      asnX509.tbsCertificate.subject = AsnConvert.parse(name9.toArrayBuffer(), Name);
    }
    if (params.issuer) {
      const name9 = params.issuer instanceof Name3 ? params.issuer : new Name3(params.issuer);
      asnX509.tbsCertificate.issuer = AsnConvert.parse(name9.toArrayBuffer(), Name);
    }
    const defaultSigningAlgorithm = {
      hash: "SHA-256"
    };
    const signatureAlgorithm = "signingKey" in params ? { ...defaultSigningAlgorithm, ...params.signingAlgorithm, ...params.signingKey.algorithm } : { ...defaultSigningAlgorithm, ...params.signingAlgorithm };
    const algProv = instance.resolve(diAlgorithmProvider);
    asnX509.tbsCertificate.signature = asnX509.signatureAlgorithm = algProv.toAsnAlgorithm(signatureAlgorithm);
    const tbs = AsnConvert.serialize(asnX509.tbsCertificate);
    const signatureValue = "signingKey" in params ? await crypto2.subtle.sign(signatureAlgorithm, params.signingKey, tbs) : params.signature;
    const signatureFormatters = instance.resolveAll(diAsnSignatureFormatter).reverse();
    let asnSignature = null;
    for (const signatureFormatter of signatureFormatters) {
      asnSignature = signatureFormatter.toAsnSignature(signatureAlgorithm, signatureValue);
      if (asnSignature) {
        break;
      }
    }
    if (!asnSignature) {
      throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
    }
    asnX509.signatureValue = asnSignature;
    return new X509Certificate(AsnConvert.serialize(asnX509));
  }
  static generateSerialNumber(input, crypto2) {
    let serialNumber = input && input.length && input.some((o) => o > 0) ? new Uint8Array(input) : void 0;
    if (!serialNumber) {
      serialNumber = crypto2.getRandomValues(new Uint8Array(16));
    }
    let firstNonZero = 0;
    while (firstNonZero < serialNumber.length - 1 && serialNumber[firstNonZero] === 0) {
      firstNonZero++;
    }
    serialNumber = serialNumber.slice(firstNonZero);
    if (serialNumber[0] > 127) {
      const newSerialNumber = new Uint8Array(serialNumber.length + 1);
      newSerialNumber[0] = 0;
      newSerialNumber.set(serialNumber, 1);
      serialNumber = newSerialNumber;
    }
    return serialNumber;
  }
};
var X509CrlReason;
(function(X509CrlReason2) {
  X509CrlReason2[X509CrlReason2["unspecified"] = 0] = "unspecified";
  X509CrlReason2[X509CrlReason2["keyCompromise"] = 1] = "keyCompromise";
  X509CrlReason2[X509CrlReason2["cACompromise"] = 2] = "cACompromise";
  X509CrlReason2[X509CrlReason2["affiliationChanged"] = 3] = "affiliationChanged";
  X509CrlReason2[X509CrlReason2["superseded"] = 4] = "superseded";
  X509CrlReason2[X509CrlReason2["cessationOfOperation"] = 5] = "cessationOfOperation";
  X509CrlReason2[X509CrlReason2["certificateHold"] = 6] = "certificateHold";
  X509CrlReason2[X509CrlReason2["removeFromCRL"] = 8] = "removeFromCRL";
  X509CrlReason2[X509CrlReason2["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
  X509CrlReason2[X509CrlReason2["aACompromise"] = 10] = "aACompromise";
})(X509CrlReason || (X509CrlReason = {}));
ExtensionFactory.register(id_ce_basicConstraints, BasicConstraintsExtension);
ExtensionFactory.register(id_ce_extKeyUsage, ExtendedKeyUsageExtension);
ExtensionFactory.register(id_ce_keyUsage, KeyUsagesExtension);
ExtensionFactory.register(id_ce_subjectKeyIdentifier, SubjectKeyIdentifierExtension);
ExtensionFactory.register(id_ce_authorityKeyIdentifier, AuthorityKeyIdentifierExtension);
ExtensionFactory.register(id_ce_subjectAltName, SubjectAlternativeNameExtension);
ExtensionFactory.register(id_ce_cRLDistributionPoints, CRLDistributionPointsExtension);
ExtensionFactory.register(id_pe_authorityInfoAccess, AuthorityInfoAccessExtension);
ExtensionFactory.register(id_ce_issuerAltName, IssuerAlternativeNameExtension);
AttributeFactory.register(id_pkcs9_at_challengePassword, ChallengePasswordAttribute);
AttributeFactory.register(id_pkcs9_at_extensionRequest, ExtensionsAttribute);
instance.registerSingleton(diAsnSignatureFormatter, AsnDefaultSignatureFormatter);
instance.registerSingleton(diAsnSignatureFormatter, AsnEcSignatureFormatter);
AsnEcSignatureFormatter.namedCurveSize.set("P-256", 32);
AsnEcSignatureFormatter.namedCurveSize.set("K-256", 32);
AsnEcSignatureFormatter.namedCurveSize.set("P-384", 48);
AsnEcSignatureFormatter.namedCurveSize.set("P-521", 66);

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base646,
  base64pad: () => base64pad6,
  base64url: () => base64url6,
  base64urlpad: () => base64urlpad6
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bytes.js
var empty16 = new Uint8Array(0);
function equals24(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce16(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString2(str) {
  return new TextEncoder().encode(str);
}
function toString3(b) {
  return new TextDecoder().decode(b);
}

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/vendor/base-x.js
function base13(ALPHABET, name9) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode39(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length16 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length16) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      pbegin++;
    }
    var it2 = size - length16;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length16 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length16) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length16 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length16;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode61(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name9} character`);
  }
  return {
    encode: encode39,
    decodeUnsafe,
    decode: decode61
  };
}
var src13 = base13;
var _brrp__multiformats_scope_baseX13 = src13;
var base_x_default14 = _brrp__multiformats_scope_baseX13;

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base.js
var Encoder15 = class {
  name;
  prefix;
  baseEncode;
  constructor(name9, prefix, baseEncode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder16 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name9, prefix, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or20(this, decoder);
  }
};
var ComposedDecoder14 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or20(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or20(left, right) {
  return new ComposedDecoder14({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec14 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name9, prefix, baseEncode, baseDecode) {
    this.name = name9;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder15(name9, prefix, baseEncode);
    this.decoder = new Decoder16(name9, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from20({ name: name9, prefix, encode: encode39, decode: decode61 }) {
  return new Codec14(name9, prefix, encode39, decode61);
}
function baseX13({ name: name9, prefix, alphabet: alphabet2 }) {
  const { encode: encode39, decode: decode61 } = base_x_default14(alphabet2, name9);
  return from20({
    prefix,
    name: name9,
    encode: encode39,
    decode: (text) => coerce16(decode61(text))
  });
}
function decode56(string2, alphabetIdx, bitsPerChar, name9) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value7 = alphabetIdx[string2[i]];
    if (value7 === void 0) {
      throw new SyntaxError(`Non-${name9} character`);
    }
    buffer = buffer << bitsPerChar | value7;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode35(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx13(alphabet2) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    alphabetIdx[alphabet2[i]] = i;
  }
  return alphabetIdx;
}
function rfc464813({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx13(alphabet2);
  return from20({
    prefix,
    name: name9,
    encode(input) {
      return encode35(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode56(input, alphabetIdx, bitsPerChar, name9);
    }
  });
}

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base64.js
var base646 = rfc464813({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad6 = rfc464813({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url6 = rfc464813({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad6 = rfc464813({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha2569,
  sha512: () => sha5129
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/hashes/digest.js
var digest_exports14 = {};
__export(digest_exports14, {
  Digest: () => Digest14,
  create: () => create14,
  decode: () => decode59,
  equals: () => equals25,
  hasCode: () => hasCode
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/vendor/varint.js
var encode_114 = encode36;
var MSB15 = 128;
var REST15 = 127;
var MSBALL14 = ~REST15;
var INT14 = Math.pow(2, 31);
function encode36(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT14) {
    out[offset++] = num & 255 | MSB15;
    num /= 128;
  }
  while (num & MSBALL14) {
    out[offset++] = num & 255 | MSB15;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode36.bytes = offset - oldOffset + 1;
  return out;
}
var decode57 = read15;
var MSB$114 = 128;
var REST$114 = 127;
function read15(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read15.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$114) << shift : (b & REST$114) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$114);
  read15.bytes = counter - offset;
  return res;
}
var N114 = Math.pow(2, 7);
var N214 = Math.pow(2, 14);
var N314 = Math.pow(2, 21);
var N414 = Math.pow(2, 28);
var N514 = Math.pow(2, 35);
var N614 = Math.pow(2, 42);
var N714 = Math.pow(2, 49);
var N814 = Math.pow(2, 56);
var N914 = Math.pow(2, 63);
var length15 = function(value7) {
  return value7 < N114 ? 1 : value7 < N214 ? 2 : value7 < N314 ? 3 : value7 < N414 ? 4 : value7 < N514 ? 5 : value7 < N614 ? 6 : value7 < N714 ? 7 : value7 < N814 ? 8 : value7 < N914 ? 9 : 10;
};
var varint14 = {
  encode: encode_114,
  decode: decode57,
  encodingLength: length15
};
var _brrp_varint14 = varint14;
var varint_default14 = _brrp_varint14;

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/varint.js
function decode58(data, offset = 0) {
  const code17 = varint_default14.decode(data, offset);
  return [code17, varint_default14.decode.bytes];
}
function encodeTo14(int, target, offset = 0) {
  varint_default14.encode(int, target, offset);
  return target;
}
function encodingLength15(int) {
  return varint_default14.encodingLength(int);
}

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/hashes/digest.js
function create14(code17, digest5) {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength15(code17);
  const digestOffset = sizeOffset + encodingLength15(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo14(code17, bytes, 0);
  encodeTo14(size, bytes, sizeOffset);
  bytes.set(digest5, digestOffset);
  return new Digest14(code17, size, digest5, bytes);
}
function decode59(multihash) {
  const bytes = coerce16(multihash);
  const [code17, sizeOffset] = decode58(bytes);
  const [size, digestOffset] = decode58(bytes.subarray(sizeOffset));
  const digest5 = bytes.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest14(code17, size, digest5, bytes);
}
function equals25(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals24(a.bytes, data.bytes);
  }
}
var Digest14 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code17, size, digest5, bytes) {
    this.code = code17;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes;
  }
};
function hasCode(digest5, code17) {
  return digest5.code === code17;
}

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/hashes/hasher.js
function from21({ name: name9, code: code17, encode: encode39 }) {
  return new Hasher7(name9, code17, encode39);
}
var Hasher7 = class {
  name;
  code;
  encode;
  constructor(name9, code17, encode39) {
    this.name = name9;
    this.code = code17;
    this.encode = encode39;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create14(this.code, result) : result.then((digest5) => create14(this.code, digest5));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha7(name9) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name9, data));
}
var sha2569 = from21({
  name: "sha2-256",
  code: 18,
  encode: sha7("SHA-256")
});
var sha5129 = from21({
  name: "sha2-512",
  code: 19,
  encode: sha7("SHA-512")
});

// node_modules/@libp2p/webrtc/dist/src/private-to-public/listener.browser.js
var WebRTCDirectListener = class extends TypedEventEmitter {
  async listen() {
    throw new UnimplementedError("WebRTCTransport.createListener");
  }
  getAddrs() {
    return [];
  }
  updateAnnounceAddrs() {
  }
  async close() {
  }
};

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base102
});
var base102 = baseX13({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc464813({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc464813({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base22
});
var base22 = rfc464813({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
  const codePoint = c.codePointAt(0);
  if (codePoint == null) {
    throw new Error(`Invalid character: ${c}`);
  }
  p[codePoint] = i;
  return p;
}, []);
function encode37(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode60(str) {
  const byts = [];
  for (const char of str) {
    const codePoint = char.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${char}`);
    }
    const byt = alphabetCharsToBytes[codePoint];
    if (byt == null) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from20({
  prefix: "🚀",
  name: "base256emoji",
  encode: encode37,
  decode: decode60
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base3210,
  base32hex: () => base32hex10,
  base32hexpad: () => base32hexpad10,
  base32hexpadupper: () => base32hexpadupper10,
  base32hexupper: () => base32hexupper10,
  base32pad: () => base32pad10,
  base32padupper: () => base32padupper10,
  base32upper: () => base32upper10,
  base32z: () => base32z10
});
var base3210 = rfc464813({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper10 = rfc464813({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad10 = rfc464813({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper10 = rfc464813({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex10 = rfc464813({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper10 = rfc464813({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad10 = rfc464813({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper10 = rfc464813({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z10 = rfc464813({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base3610,
  base36upper: () => base36upper10
});
var base3610 = baseX13({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper10 = baseX13({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc13,
  base58flickr: () => base58flickr13
});
var base58btc13 = baseX13({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr13 = baseX13({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base82
});
var base82 = rfc464813({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity4
});
var identity4 = from20({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString3(buf),
  decode: (str) => fromString2(str)
});

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder2 = new TextEncoder();
var textDecoder2 = new TextDecoder();

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity5
});
var code15 = 0;
var name7 = "identity";
var encode38 = coerce16;
function digest4(input) {
  return create14(code15, encode38(input));
}
var identity5 = { code: code15, name: name7, encode: encode38, digest: digest4 };

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/cid.js
function format10(link, base14) {
  const { bytes, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV010(bytes, baseCache10(link), base14 ?? base58btc13.encoder);
    default:
      return toStringV110(bytes, baseCache10(link), base14 ?? base3210.encoder);
  }
}
var cache11 = /* @__PURE__ */ new WeakMap();
function baseCache10(cid) {
  const baseCache11 = cache11.get(cid);
  if (baseCache11 == null) {
    const baseCache12 = /* @__PURE__ */ new Map();
    cache11.set(cid, baseCache12);
    return baseCache12;
  }
  return baseCache11;
}
var CID10 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code17, multihash, bytes) {
    this.code = code17;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code17, multihash } = this;
        if (code17 !== DAG_PB_CODE10) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE10) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code17, digest: digest5 } = this.multihash;
        const multihash = create14(code17, digest5);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals25(self2.multihash, unknown.multihash);
  }
  toString(base14) {
    return format10(this, base14);
  }
  toJSON() {
    return { "/": format10(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value7 = input;
    if (value7 instanceof _CID) {
      return value7;
    } else if (value7["/"] != null && value7["/"] === value7.bytes || value7.asCID === value7) {
      const { version: version3, code: code17, multihash, bytes } = value7;
      return new _CID(version3, code17, multihash, bytes ?? encodeCID10(version3, code17, multihash.bytes));
    } else if (value7[cidSymbol10] === true) {
      const { version: version3, multihash, code: code17 } = value7;
      const digest5 = decode59(multihash);
      return _CID.create(version3, code17, digest5);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code17, digest5) {
    if (typeof code17 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code17 !== DAG_PB_CODE10) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE10}) block encoding`);
        } else {
          return new _CID(version3, code17, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID10(version3, code17, digest5.bytes);
        return new _CID(version3, code17, digest5, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE10, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code17, digest5) {
    return _CID.create(1, code17, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce16(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest5 = new Digest14(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest5) : _CID.createV1(specs.codec, digest5);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length16] = decode58(initialBytes.subarray(offset));
      offset += length16;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE10;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base14) {
    const [prefix, bytes] = parseCIDtoBytes10(source, base14);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache10(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes10(source, base14) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base14 ?? base58btc13;
      return [
        base58btc13.prefix,
        decoder.decode(`${base58btc13.prefix}${source}`)
      ];
    }
    case base58btc13.prefix: {
      const decoder = base14 ?? base58btc13;
      return [base58btc13.prefix, decoder.decode(source)];
    }
    case base3210.prefix: {
      const decoder = base14 ?? base3210;
      return [base3210.prefix, decoder.decode(source)];
    }
    case base3610.prefix: {
      const decoder = base14 ?? base3610;
      return [base3610.prefix, decoder.decode(source)];
    }
    default: {
      if (base14 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base14.decode(source)];
    }
  }
}
function toStringV010(bytes, cache12, base14) {
  const { prefix } = base14;
  if (prefix !== base58btc13.prefix) {
    throw Error(`Cannot string encode V0 in ${base14.name} encoding`);
  }
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes).slice(1);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV110(bytes, cache12, base14) {
  const { prefix } = base14;
  const cid = cache12.get(prefix);
  if (cid == null) {
    const cid2 = base14.encode(bytes);
    cache12.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE10 = 112;
var SHA_256_CODE10 = 18;
function encodeCID10(version3, code17, multihash) {
  const codeOffset = encodingLength15(version3);
  const hashOffset = codeOffset + encodingLength15(code17);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo14(version3, bytes, 0);
  encodeTo14(code17, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol10 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/webrtc/node_modules/multiformats/dist/src/basics.js
var bases = { ...identity_exports, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
var hashes = { ...sha2_browser_exports, ...identity_exports2 };

// node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/sdp.js
var multibaseDecoder = Object.values(bases).map((b) => b.decoder).reduce((d, b) => d.or(b));
var fingerprintRegex = /^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;
function getFingerprintFromSdp(sdp) {
  if (sdp == null) {
    return void 0;
  }
  const searchResult = sdp.match(fingerprintRegex);
  return searchResult?.groups?.fingerprint;
}
function certhash2(ma) {
  const tups = ma.stringTuples();
  const certhash3 = tups.filter((tup) => tup[0] === CODEC_CERTHASH).map((tup) => tup[1])[0];
  if (certhash3 === void 0 || certhash3 === "") {
    throw new InvalidParametersError(`Couldn't find a certhash component of multiaddr: ${ma.toString()}`);
  }
  return certhash3;
}
function decodeCerthash(certhash3) {
  return digest_exports14.decode(multibaseDecoder.decode(certhash3));
}
function ma2Fingerprint(ma) {
  const multihashDecoded = decodeCerthash(certhash2(ma));
  const prefix = toSupportedHashFunction(multihashDecoded.code);
  const fingerprint = multihashDecoded.digest.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
  const sdp = fingerprint.match(/.{1,2}/g);
  if (sdp == null) {
    throw new InvalidFingerprintError(fingerprint, ma.toString());
  }
  return `${prefix} ${sdp.join(":").toUpperCase()}`;
}
function fingerprint2Ma(fingerprint) {
  const output = fingerprint.split(":").map((str) => parseInt(str, 16));
  const encoded = Uint8Array.from(output);
  const digest5 = create14(sha2569.code, encoded);
  return multiaddr(`/certhash/${base64url6.encode(digest5.bytes)}`);
}
function toSupportedHashFunction(code17) {
  switch (code17) {
    case 17:
      return "sha-1";
    case 18:
      return "sha-256";
    case 19:
      return "sha-512";
    default:
      throw new UnsupportedHashAlgorithmError(code17);
  }
}
function serverAnswerFromMultiaddr(ma, ufrag) {
  const { host, port, family } = ma.toOptions();
  const fingerprint = ma2Fingerprint(ma);
  const sdp = `v=0
o=- 0 0 IN IP${family} ${host}
s=-
t=0 0
a=ice-lite
m=application ${port} UDP/DTLS/SCTP webrtc-datachannel
c=IN IP${family} ${host}
a=mid:0
a=ice-options:ice2
a=ice-ufrag:${ufrag}
a=ice-pwd:${ufrag}
a=fingerprint:${fingerprint}
a=setup:passive
a=sctp-port:5000
a=max-message-size:${MAX_MESSAGE_SIZE2}
a=candidate:1467250027 1 UDP 1467250027 ${host} ${port} typ host
a=end-of-candidates
`;
  return {
    type: "answer",
    sdp
  };
}
function clientOfferFromMultiAddr(ma, ufrag) {
  const { host, port, family } = ma.toOptions();
  const sdp = `v=0
o=- 0 0 IN IP${family} ${host}
s=-
c=IN IP${family} ${host}
t=0 0
a=ice-options:ice2,trickle
m=application ${port} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:active
a=ice-ufrag:${ufrag}
a=ice-pwd:${ufrag}
a=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
a=sctp-port:5000
a=max-message-size:${MAX_MESSAGE_SIZE2}
a=candidate:1467250027 1 UDP 1467250027 ${host} ${port} typ host
a=end-of-candidates
`;
  return {
    type: "offer",
    sdp
  };
}
function munge(desc, ufrag) {
  if (desc.sdp === void 0) {
    throw new InvalidParametersError("Can't munge a missing SDP");
  }
  const lineBreak = desc.sdp.includes("\r\n") ? "\r\n" : "\n";
  desc.sdp = desc.sdp.replace(/\na=ice-ufrag:[^\n]*\n/, "\na=ice-ufrag:" + ufrag + lineBreak).replace(/\na=ice-pwd:[^\n]*\n/, "\na=ice-pwd:" + ufrag + lineBreak);
  return desc;
}

// node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/generate-noise-prologue.js
var PREFIX = fromString("libp2p-webrtc-noise:");
function generateNoisePrologue(localFingerprint, remoteAddr, role) {
  const localFpString = localFingerprint.trim().toLowerCase().replaceAll(":", "");
  const localFpArray = fromString(localFpString, "hex");
  const local = create14(sha2569.code, localFpArray);
  const remote = multibaseDecoder.decode(certhash2(remoteAddr));
  const byteLength = PREFIX.byteLength + local.bytes.byteLength + remote.byteLength;
  if (role === "server") {
    return concat([PREFIX, remote, local.bytes], byteLength);
  }
  return concat([PREFIX, local.bytes, remote], byteLength);
}

// node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/connect.js
var CONNECTION_STATE_CHANGE_EVENT = isFirefox ? "iceconnectionstatechange" : "connectionstatechange";
async function connect(peerConnection, ufrag, options2) {
  const handshakeDataChannel = peerConnection.createDataChannel("", { negotiated: true, id: 0 });
  try {
    if (options2.role === "client") {
      options2.log.trace("client creating local offer");
      const offerSdp = await peerConnection.createOffer();
      options2.log.trace("client created local offer %s", offerSdp.sdp);
      const mungedOfferSdp = munge(offerSdp, ufrag);
      options2.log.trace("client setting local offer %s", mungedOfferSdp.sdp);
      await peerConnection.setLocalDescription(mungedOfferSdp);
      const answerSdp = serverAnswerFromMultiaddr(options2.remoteAddr, ufrag);
      options2.log.trace("client setting server description %s", answerSdp.sdp);
      await peerConnection.setRemoteDescription(answerSdp);
    } else {
      const offerSdp = clientOfferFromMultiAddr(options2.remoteAddr, ufrag);
      options2.log.trace("server setting client %s %s", offerSdp.type, offerSdp.sdp);
      await peerConnection.setRemoteDescription(offerSdp);
      options2.log.trace("server creating local answer");
      const answerSdp = await peerConnection.createAnswer();
      options2.log.trace("server created local answer");
      const mungedAnswerSdp = munge(answerSdp, ufrag);
      options2.log.trace("server setting local description %s", answerSdp.sdp);
      await peerConnection.setLocalDescription(mungedAnswerSdp);
    }
    if (handshakeDataChannel.readyState !== "open") {
      options2.log.trace("%s wait for handshake channel to open, starting status %s", options2.role, handshakeDataChannel.readyState);
      await raceEvent(handshakeDataChannel, "open", options2.signal);
    }
    options2.log.trace("%s handshake channel opened", options2.role);
    if (options2.role === "server") {
      const remoteFingerprint = peerConnection.remoteFingerprint()?.value ?? "";
      options2.remoteAddr = options2.remoteAddr.encapsulate(fingerprint2Ma(remoteFingerprint));
    }
    const localFingerprint = getFingerprintFromSdp(peerConnection.localDescription?.sdp);
    if (localFingerprint == null) {
      throw new WebRTCTransportError("Could not get fingerprint from local description sdp");
    }
    options2.log.trace("%s performing noise handshake", options2.role);
    const noisePrologue = generateNoisePrologue(localFingerprint, options2.remoteAddr, options2.role);
    const connectionEncrypter = noise({ prologueBytes: noisePrologue })(options2);
    const handshakeStream = createStream2({
      channel: handshakeDataChannel,
      direction: "outbound",
      handshake: true,
      logger: options2.logger,
      ...options2.dataChannel ?? {}
    });
    const maConn = new WebRTCMultiaddrConnection(options2, {
      peerConnection,
      remoteAddr: options2.remoteAddr,
      timeline: {
        open: Date.now()
      },
      metrics: options2.events
    });
    peerConnection.addEventListener(CONNECTION_STATE_CHANGE_EVENT, () => {
      switch (peerConnection.connectionState) {
        case "failed":
        case "disconnected":
        case "closed":
          maConn.close().catch((err) => {
            options2.log.error("error closing connection", err);
            maConn.abort(err);
          });
          break;
        default:
          break;
      }
    });
    options2.events?.increment({ peer_connection: true });
    const muxerFactory = new DataChannelMuxerFactory(options2, {
      peerConnection,
      metrics: options2.events,
      dataChannelOptions: options2.dataChannel
    });
    if (options2.role === "client") {
      options2.log.trace("%s secure inbound", options2.role);
      await connectionEncrypter.secureInbound(handshakeStream, {
        remotePeer: options2.remotePeerId,
        signal: options2.signal,
        skipStreamMuxerNegotiation: true
      });
      options2.log.trace("%s upgrade outbound", options2.role);
      return await options2.upgrader.upgradeOutbound(maConn, {
        skipProtection: true,
        skipEncryption: true,
        muxerFactory,
        signal: options2.signal
      });
    }
    options2.log.trace("%s secure outbound", options2.role);
    const result = await connectionEncrypter.secureOutbound(handshakeStream, {
      remotePeer: options2.remotePeerId,
      signal: options2.signal,
      skipStreamMuxerNegotiation: true
    });
    maConn.remoteAddr = maConn.remoteAddr.encapsulate(`/p2p/${result.remotePeer}`);
    options2.log.trace("%s upgrade inbound", options2.role);
    await options2.upgrader.upgradeInbound(maConn, {
      skipProtection: true,
      skipEncryption: true,
      muxerFactory,
      signal: options2.signal
    });
  } catch (err) {
    handshakeDataChannel.close();
    throw err;
  }
}

// node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/get-rtcpeerconnection.browser.js
async function createDialerRTCPeerConnection(role, ufrag, rtcConfiguration, certificate) {
  if (certificate == null) {
    certificate = await RTCPeerConnection.generateCertificate({
      name: "ECDSA",
      // @ts-expect-error missing from lib.dom.d.ts but required by chrome
      namedCurve: "P-256"
      // hash: sdp.toSupportedHashFunction(hashName)
    });
  }
  const rtcConfig = typeof rtcConfiguration === "function" ? await rtcConfiguration() : rtcConfiguration;
  return new RTCPeerConnection({
    ...rtcConfig ?? {},
    certificates: [certificate]
  });
}

// node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/pem.js
async function formatAsPem(privateKey) {
  const keyPair = await privateKeyToCryptoKeyPair(privateKey);
  const exported = await crypto.subtle.exportKey("pkcs8", keyPair.privateKey);
  return [
    "-----BEGIN PRIVATE KEY-----",
    ...toString(new Uint8Array(exported), "base64pad").split(/(.{64})/).filter(Boolean),
    "-----END PRIVATE KEY-----"
  ].join("\n");
}

// node_modules/@libp2p/webrtc/dist/src/private-to-public/transport.js
var WebRTCDirectTransport = class {
  log;
  metrics;
  components;
  init;
  certificate;
  privateKey;
  emitter;
  renewCertificateTask;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:webrtc-direct");
    this.components = components;
    this.init = init;
    this.emitter = new TypedEventEmitter();
    if (init.certificateLifespan != null && init.certificateRenewalThreshold != null && init.certificateRenewalThreshold >= init.certificateLifespan) {
      throw new InvalidParametersError("Certificate renewal threshold must be less than certificate lifespan");
    }
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total", {
          label: "event",
          help: "Total count of WebRTC-direct dial events by type"
        })
      };
    }
  }
  [transportSymbol] = true;
  [Symbol.toStringTag] = "@libp2p/webrtc-direct";
  [serviceCapabilities] = [
    "@libp2p/transport"
  ];
  async start() {
    this.certificate = await this.getCertificate();
  }
  async stop() {
    if (this.renewCertificateTask != null) {
      clearTimeout(this.renewCertificateTask);
    }
    this.certificate = void 0;
  }
  /**
   * Dial a given multiaddr
   */
  async dial(ma, options2) {
    this.log("dial %a", ma);
    options2.signal.throwIfAborted();
    let theirPeerId;
    const remotePeerString = ma.getPeerId();
    if (remotePeerString != null) {
      theirPeerId = peerIdFromString(remotePeerString);
    }
    const ufrag = genUfrag();
    const peerConnection = await createDialerRTCPeerConnection("client", ufrag, typeof this.init.rtcConfiguration === "function" ? await this.init.rtcConfiguration() : this.init.rtcConfiguration ?? {});
    try {
      return await connect(peerConnection, ufrag, {
        role: "client",
        log: this.log,
        logger: this.components.logger,
        metrics: this.components.metrics,
        events: this.metrics?.dialerEvents,
        signal: options2.signal,
        remoteAddr: ma,
        dataChannel: this.init.dataChannel,
        upgrader: options2.upgrader,
        peerId: this.components.peerId,
        remotePeerId: theirPeerId,
        privateKey: this.components.privateKey
      });
    } catch (err) {
      peerConnection.close();
      throw err;
    }
  }
  /**
   * Create a transport listener - this will throw in browsers
   */
  createListener(options2) {
    if (this.certificate == null) {
      throw new NotStartedError();
    }
    return new WebRTCDirectListener(this.components, {
      ...this.init,
      ...options2,
      certificate: this.certificate,
      emitter: this.emitter
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    return multiaddrs.filter(WebRTCDirect6.exactMatch);
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
  async getCertificate(forceRenew) {
    if (isTransportCertificate(this.init.certificate)) {
      this.log("using provided TLS certificate");
      return this.init.certificate;
    }
    const privateKey = await this.loadOrCreatePrivateKey();
    const { pem, certhash: certhash3 } = await this.loadOrCreateCertificate(privateKey, forceRenew);
    return {
      privateKey: await formatAsPem(privateKey),
      pem,
      certhash: certhash3
    };
  }
  async loadOrCreatePrivateKey() {
    if (this.privateKey != null) {
      return this.privateKey;
    }
    const keychainName = this.init.certificateKeychainName ?? DEFAULT_CERTIFICATE_PRIVATE_KEY_NAME;
    const keychain2 = this.getKeychain();
    try {
      if (keychain2 == null) {
        this.log("no keychain configured - not checking for stored private key");
        throw new NotFoundError();
      }
      this.log.trace("checking for stored private key");
      this.privateKey = await keychain2.exportKey(keychainName);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
      this.log.trace("generating private key");
      this.privateKey = await generateKeyPair("ECDSA", "P-256");
      if (keychain2 != null) {
        this.log.trace("storing private key");
        await keychain2.importKey(keychainName, this.privateKey);
      } else {
        this.log("no keychain configured - not storing private key");
      }
    }
    return this.privateKey;
  }
  async loadOrCreateCertificate(privateKey, forceRenew) {
    if (this.certificate != null && forceRenew !== true) {
      return this.certificate;
    }
    let cert;
    const dsKey = new Key(this.init.certificateDatastoreKey ?? DEFAULT_CERTIFICATE_DATASTORE_KEY);
    const keyPair = await privateKeyToCryptoKeyPair(privateKey);
    try {
      if (forceRenew === true) {
        this.log.trace("forcing renewal of TLS certificate");
        throw new NotFoundError();
      }
      this.log.trace("checking for stored TLS certificate");
      cert = await this.loadCertificate(dsKey, keyPair);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
      this.log.trace("generating new TLS certificate");
      cert = await this.createCertificate(dsKey, keyPair);
    }
    let renewTime = cert.notAfter.getTime() - (this.init.certificateRenewalThreshold ?? DEFAULT_CERTIFICATE_RENEWAL_THRESHOLD) - Date.now();
    if (renewTime < 0) {
      renewTime = 100;
    }
    this.log("will renew TLS certificate after %d ms", renewTime);
    this.renewCertificateTask = setTimeout(() => {
      this.log("renewing TLS certificate");
      this.getCertificate(true).then((cert2) => {
        this.certificate = cert2;
        this.emitter.safeDispatchEvent("certificate:renew", {
          detail: cert2
        });
      }).catch((err) => {
        this.log.error("could not renew certificate - %e", err);
      });
    }, renewTime);
    return {
      pem: cert.toString("pem"),
      certhash: base64url6.encode((await sha2569.digest(new Uint8Array(cert.rawData))).bytes)
    };
  }
  async loadCertificate(dsKey, keyPair) {
    const buf = await this.components.datastore.get(dsKey);
    const cert = new X509Certificate(buf);
    const expiryTime = cert.notAfter.getTime() - (this.init.certificateRenewalThreshold ?? DEFAULT_CERTIFICATE_RENEWAL_THRESHOLD);
    if (Date.now() > expiryTime) {
      this.log("stored TLS certificate has expired");
      throw new NotFoundError();
    }
    this.log("loaded certificate, expires in %d ms", expiryTime);
    const exportedCertKey = await cert.publicKey.export(crypto);
    const rawCertKey = await crypto.subtle.exportKey("raw", exportedCertKey);
    const rawKeyPairKey = await crypto.subtle.exportKey("raw", keyPair.publicKey);
    if (!equals(new Uint8Array(rawCertKey, 0, rawCertKey.byteLength), new Uint8Array(rawKeyPairKey, 0, rawKeyPairKey.byteLength))) {
      this.log("stored TLS certificate public key did not match public key from private key");
      throw new NotFoundError();
    }
    this.log("loaded certificate, expiry time is %o", expiryTime);
    return cert;
  }
  async createCertificate(dsKey, keyPair) {
    const notBefore = /* @__PURE__ */ new Date();
    const notAfter = new Date(Date.now() + (this.init.certificateLifespan ?? DEFAULT_CERTIFICATE_LIFESPAN));
    notBefore.setMilliseconds(0);
    notAfter.setMilliseconds(0);
    const cert = await X509CertificateGenerator.createSelfSigned({
      serialNumber: (BigInt(Math.random().toString().replace(".", "")) * 100000n).toString(16),
      name: "CN=example.com, C=US, L=CA, O=example, ST=CA",
      notBefore,
      notAfter,
      keys: keyPair,
      extensions: [
        new BasicConstraintsExtension(false, void 0, true)
      ]
    }, crypto);
    if (this.getKeychain() != null) {
      this.log.trace("storing TLS certificate");
      await this.components.datastore.put(dsKey, fromString(cert.toString("pem")));
    } else {
      this.log("no keychain is configured so not storing TLS certificate since the private key will not be reused");
    }
    return cert;
  }
  getKeychain() {
    try {
      return this.components.keychain;
    } catch {
    }
  }
};
function isTransportCertificate(obj) {
  if (obj == null) {
    return false;
  }
  return typeof obj.privateKey === "string" && typeof obj.pem === "string" && typeof obj.certhash === "string";
}

// node_modules/@libp2p/webrtc/dist/src/index.js
function webRTCDirect(init) {
  return (components) => new WebRTCDirectTransport(components, init);
}
function webRTC(init) {
  return (components) => new WebRTCTransport(components, init);
}

// node_modules/it-ws/dist/src/ready.js
var ready_default = async (socket) => {
  if (socket.readyState >= 2) {
    throw new Error("socket closed");
  }
  if (socket.readyState === 1) {
    return;
  }
  await new Promise((resolve, reject) => {
    function cleanup() {
      socket.removeEventListener("open", handleOpen);
      socket.removeEventListener("error", handleErr);
    }
    function handleOpen() {
      cleanup();
      resolve();
    }
    function handleErr(event) {
      cleanup();
      reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
    }
    socket.addEventListener("open", handleOpen);
    socket.addEventListener("error", handleErr);
  });
};

// node_modules/it-ws/dist/src/sink.js
var sink_default = (socket, options2) => {
  options2 = options2 ?? {};
  options2.closeOnEnd = options2.closeOnEnd !== false;
  const sink = async (source) => {
    for await (const data of source) {
      try {
        await ready_default(socket);
      } catch (err) {
        if (err.message === "socket closed")
          break;
        throw err;
      }
      if (socket.readyState === socket.CLOSING || socket.readyState === socket.CLOSED) {
        break;
      }
      socket.send(data);
    }
    if (options2.closeOnEnd != null && socket.readyState <= 1) {
      await new Promise((resolve, reject) => {
        socket.addEventListener("close", (event) => {
          if (event.wasClean || event.code === 1006) {
            resolve();
          } else {
            const err = Object.assign(new Error("ws error"), { event });
            reject(err);
          }
        });
        setTimeout(() => {
          socket.close();
        });
      });
    }
  };
  return sink;
};

// node_modules/it-ws/dist/src/source.js
var import_event_iterator = __toESM(require_dom(), 1);
function isArrayBuffer(obj) {
  return obj instanceof ArrayBuffer || obj?.constructor?.name === "ArrayBuffer" && typeof obj?.byteLength === "number";
}
var source_default = (socket) => {
  socket.binaryType = "arraybuffer";
  const connected = async () => {
    await new Promise((resolve, reject) => {
      if (isConnected) {
        resolve();
        return;
      }
      if (connError != null) {
        reject(connError);
        return;
      }
      const cleanUp = (cont) => {
        socket.removeEventListener("open", onOpen);
        socket.removeEventListener("error", onError);
        cont();
      };
      const onOpen = () => {
        cleanUp(resolve);
      };
      const onError = (event) => {
        cleanUp(() => {
          reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
        });
      };
      socket.addEventListener("open", onOpen);
      socket.addEventListener("error", onError);
    });
  };
  const source = async function* () {
    const messages2 = new import_event_iterator.EventIterator(({ push, stop: stop2, fail }) => {
      const onMessage = (event) => {
        let data = null;
        if (typeof event.data === "string") {
          data = fromString(event.data);
        }
        if (isArrayBuffer(event.data)) {
          data = new Uint8Array(event.data);
        }
        if (event.data instanceof Uint8Array) {
          data = event.data;
        }
        if (data == null) {
          return;
        }
        push(data);
      };
      const onError = (event) => {
        fail(event.error ?? new Error("Socket error"));
      };
      socket.addEventListener("message", onMessage);
      socket.addEventListener("error", onError);
      socket.addEventListener("close", stop2);
      return () => {
        socket.removeEventListener("message", onMessage);
        socket.removeEventListener("error", onError);
        socket.removeEventListener("close", stop2);
      };
    }, { highWaterMark: Infinity });
    await connected();
    for await (const chunk of messages2) {
      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;
    }
  }();
  let isConnected = socket.readyState === 1;
  let connError;
  socket.addEventListener("open", () => {
    isConnected = true;
    connError = null;
  });
  socket.addEventListener("close", () => {
    isConnected = false;
    connError = null;
  });
  socket.addEventListener("error", (event) => {
    if (!isConnected) {
      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
    }
  });
  return Object.assign(source, {
    connected
  });
};

// node_modules/it-ws/dist/src/duplex.js
var duplex_default = (socket, options2) => {
  options2 = options2 ?? {};
  const connectedSource = source_default(socket);
  let remoteAddress = options2.remoteAddress;
  let remotePort = options2.remotePort;
  if (socket.url != null) {
    try {
      const url = new URL(socket.url);
      remoteAddress = url.hostname;
      remotePort = parseInt(url.port, 10);
    } catch {
    }
  }
  if (remoteAddress == null || remotePort == null) {
    throw new Error("Remote connection did not have address and/or port");
  }
  const duplex = {
    sink: sink_default(socket, options2),
    source: connectedSource,
    connected: async () => {
      await connectedSource.connected();
    },
    close: async () => {
      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
        await new Promise((resolve) => {
          socket.addEventListener("close", () => {
            resolve();
          });
          socket.close();
        });
      }
    },
    destroy: () => {
      if (socket.terminate != null) {
        socket.terminate();
      } else {
        socket.close();
      }
    },
    remoteAddress,
    remotePort,
    socket
  };
  return duplex;
};

// node_modules/it-ws/dist/src/web-socket.browser.js
var web_socket_browser_default = WebSocket;

// node_modules/it-ws/dist/src/ws-url.js
var map = { "http:": "ws:", "https:": "wss:" };
var defaultProtocol = "ws:";
var ws_url_default = (url, location) => {
  if (url.startsWith("//")) {
    url = `${location?.protocol ?? defaultProtocol}${url}`;
  }
  if (url.startsWith("/") && location != null) {
    const proto = location.protocol ?? defaultProtocol;
    const host = location.host;
    const port = location.port != null && host?.endsWith(`:${location.port}`) !== true ? `:${location.port}` : "";
    url = `${proto}//${host}${port}${url}`;
  }
  const wsUrl = new URL(url);
  for (const [httpProto, wsProto] of Object.entries(map)) {
    if (wsUrl.protocol === httpProto) {
      wsUrl.protocol = wsProto;
    }
  }
  return wsUrl;
};

// node_modules/it-ws/dist/src/client.js
function connect2(addr, opts) {
  const location = typeof window === "undefined" ? void 0 : window.location;
  opts = opts ?? {};
  const url = ws_url_default(addr, location);
  const socket = new web_socket_browser_default(url.toString(), opts.websocket);
  return duplex_default(socket, opts);
}

// node_modules/@libp2p/websockets/node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
var code16 = (code17) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component == null) {
        return false;
      }
      if (component.code !== code17) {
        return false;
      }
      if (component.value != null) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var value6 = (code17, value7) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component?.code !== code17) {
        return false;
      }
      if (component.value == null) {
        return false;
      }
      if (value7 != null && component.value !== value7) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var optional7 = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    }
  };
};
var or21 = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    }
  };
};
var and7 = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    }
  };
};
function fmt7(...matchers) {
  function match(ma) {
    if (ma == null) {
      return false;
    }
    let parts = ma.getComponents();
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matchers,
    matches,
    exactMatch
  };
}

// node_modules/@libp2p/websockets/node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var _PEER_ID7 = value6(CODE_P2P);
var PEER_ID7 = fmt7(_PEER_ID7);
var _DNS47 = value6(CODE_DNS4);
var _DNS67 = value6(CODE_DNS6);
var _DNSADDR7 = value6(CODE_DNSADDR);
var _DNS9 = value6(CODE_DNS);
var DNS47 = fmt7(_DNS47, optional7(value6(CODE_P2P)));
var DNS67 = fmt7(_DNS67, optional7(value6(CODE_P2P)));
var DNSADDR7 = fmt7(_DNSADDR7, optional7(value6(CODE_P2P)));
var DNS11 = fmt7(or21(_DNS9, _DNSADDR7, _DNS47, _DNS67), optional7(value6(CODE_P2P)));
var _IP47 = and7(value6(CODE_IP4), optional7(value6(CODE_IPCIDR)));
var _IP67 = and7(optional7(value6(CODE_IP6ZONE)), value6(CODE_IP6), optional7(value6(CODE_IPCIDR)));
var _IP9 = or21(_IP47, _IP67);
var _IP_OR_DOMAIN7 = or21(_IP9, _DNS9, _DNS47, _DNS67, _DNSADDR7);
var IP_OR_DOMAIN7 = fmt7(or21(_IP9, and7(or21(_DNS9, _DNSADDR7, _DNS47, _DNS67), optional7(value6(CODE_P2P)))));
var IP47 = fmt7(_IP47);
var IP67 = fmt7(_IP67);
var IP10 = fmt7(_IP9);
var _TCP7 = and7(_IP_OR_DOMAIN7, value6(CODE_TCP));
var _UDP7 = and7(_IP_OR_DOMAIN7, value6(CODE_UDP));
var TCP7 = fmt7(and7(_TCP7, optional7(value6(CODE_P2P))));
var UDP7 = fmt7(_UDP7);
var _QUIC7 = and7(_UDP7, code16(CODE_QUIC), optional7(value6(CODE_P2P)));
var _QUIC_V16 = and7(_UDP7, code16(CODE_QUIC_V1), optional7(value6(CODE_P2P)));
var QUIC_V0_OR_V17 = or21(_QUIC7, _QUIC_V16);
var QUIC7 = fmt7(_QUIC7);
var QUIC_V16 = fmt7(_QUIC_V16);
var _WEB7 = or21(_IP_OR_DOMAIN7, _TCP7, _UDP7, _QUIC7, _QUIC_V16);
var _WebSockets7 = or21(and7(_WEB7, code16(CODE_WS), optional7(value6(CODE_P2P))));
var WebSockets7 = fmt7(_WebSockets7);
var _WebSocketsSecure7 = or21(and7(_WEB7, code16(CODE_WSS), optional7(value6(CODE_P2P))), and7(_WEB7, code16(CODE_TLS), optional7(value6(CODE_SNI)), code16(CODE_WS), optional7(value6(CODE_P2P))));
var WebSocketsSecure7 = fmt7(_WebSocketsSecure7);
var _WebRTCDirect7 = and7(_UDP7, code16(CODE_WEBRTC_DIRECT), optional7(value6(CODE_CERTHASH)), optional7(value6(CODE_CERTHASH)), optional7(value6(CODE_P2P)));
var WebRTCDirect7 = fmt7(_WebRTCDirect7);
var _WebTransport7 = and7(_QUIC_V16, code16(CODE_WEBTRANSPORT), optional7(value6(CODE_CERTHASH)), optional7(value6(CODE_CERTHASH)), optional7(value6(CODE_P2P)));
var WebTransport7 = fmt7(_WebTransport7);
var _P2P7 = or21(_WebSockets7, _WebSocketsSecure7, and7(_TCP7, optional7(value6(CODE_P2P))), and7(QUIC_V0_OR_V17, optional7(value6(CODE_P2P))), and7(_IP_OR_DOMAIN7, optional7(value6(CODE_P2P))), _WebRTCDirect7, _WebTransport7, value6(CODE_P2P));
var P2P8 = fmt7(_P2P7);
var _Circuit7 = and7(_P2P7, code16(CODE_P2P_CIRCUIT), value6(CODE_P2P));
var Circuit8 = fmt7(_Circuit7);
var _WebRTC7 = or21(and7(_P2P7, code16(CODE_P2P_CIRCUIT), code16(CODE_WEBRTC), optional7(value6(CODE_P2P))), and7(_P2P7, code16(CODE_WEBRTC), optional7(value6(CODE_P2P))), and7(code16(CODE_WEBRTC), optional7(value6(CODE_P2P))));
var WebRTC7 = fmt7(_WebRTC7);
var _HTTP7 = or21(and7(_IP_OR_DOMAIN7, value6(CODE_TCP), code16(CODE_HTTP), optional7(value6(CODE_P2P))), and7(_IP_OR_DOMAIN7, code16(CODE_HTTP), optional7(value6(CODE_P2P))));
var HTTP7 = fmt7(_HTTP7);
var _HTTPS7 = and7(_IP_OR_DOMAIN7, or21(and7(value6(CODE_TCP, "443"), code16(CODE_HTTP)), and7(value6(CODE_TCP), code16(CODE_HTTPS)), and7(value6(CODE_TCP), code16(CODE_TLS), code16(CODE_HTTP)), and7(code16(CODE_TLS), code16(CODE_HTTP)), code16(CODE_TLS), code16(CODE_HTTPS)), optional7(value6(CODE_P2P)));
var HTTPS7 = fmt7(_HTTPS7);
var _Memory7 = or21(and7(value6(CODE_MEMORY), optional7(value6(CODE_P2P))));
var Memory7 = fmt7(_Memory7);
var _Unix7 = or21(and7(value6(CODE_UNIX), optional7(value6(CODE_P2P))));
var Unix7 = fmt7(_Unix7);

// node_modules/@libp2p/websockets/dist/src/filters.js
function all(multiaddrs) {
  return multiaddrs.filter((ma) => {
    return WebSocketsSecure7.exactMatch(ma) || WebSockets7.exactMatch(ma);
  });
}

// node_modules/@libp2p/websockets/dist/src/listener.browser.js
function createListener2() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}

// node_modules/@libp2p/websockets/dist/src/constants.js
var CLOSE_TIMEOUT4 = 500;

// node_modules/@libp2p/websockets/dist/src/socket-to-conn.js
function socketToMaConn(stream, remoteAddr, options2) {
  const log5 = options2.logger.forComponent("libp2p:websockets:maconn");
  const metrics = options2.metrics;
  const metricPrefix = options2.metricPrefix ?? "";
  const maConn = {
    log: log5,
    async sink(source) {
      try {
        await stream.sink(async function* () {
          for await (const buf of source) {
            if (buf instanceof Uint8Array) {
              yield buf;
            } else {
              yield buf.subarray();
            }
          }
        }());
      } catch (err) {
        if (err.type !== "aborted") {
          log5.error(err);
        }
      }
    },
    source: stream.source,
    remoteAddr,
    timeline: { open: Date.now() },
    async close(options3 = {}) {
      const start2 = Date.now();
      if (options3.signal == null) {
        const signal = AbortSignal.timeout(CLOSE_TIMEOUT4);
        options3 = {
          ...options3,
          signal
        };
      }
      const listener = () => {
        const { host, port } = maConn.remoteAddr.toOptions();
        log5("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start2);
        this.abort(new AbortError("Socket close timeout"));
      };
      options3.signal?.addEventListener("abort", listener);
      try {
        await stream.close();
      } catch (err) {
        log5.error("error closing WebSocket gracefully", err);
        this.abort(err);
      } finally {
        options3.signal?.removeEventListener("abort", listener);
        maConn.timeline.close = Date.now();
      }
    },
    abort(err) {
      const { host, port } = maConn.remoteAddr.toOptions();
      log5("timeout closing stream to %s:%s due to error", host, port, err);
      stream.destroy();
      maConn.timeline.close = Date.now();
      metrics?.increment({ [`${metricPrefix}error`]: true });
    }
  };
  stream.socket.addEventListener("close", () => {
    metrics?.increment({ [`${metricPrefix}close`]: true });
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, { once: true });
  return maConn;
}

// node_modules/@libp2p/websockets/dist/src/index.js
var WebSockets8 = class {
  log;
  init;
  logger;
  metrics;
  components;
  constructor(components, init = {}) {
    this.log = components.logger.forComponent("libp2p:websockets");
    this.logger = components.logger;
    this.components = components;
    this.init = init;
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total", {
          label: "event",
          help: "Total count of WebSockets dialer events by type"
        })
      };
    }
  }
  [transportSymbol] = true;
  [Symbol.toStringTag] = "@libp2p/websockets";
  [serviceCapabilities] = [
    "@libp2p/transport"
  ];
  async dial(ma, options2) {
    this.log("dialing %s", ma);
    options2 = options2 ?? {};
    const socket = await this._connect(ma, options2);
    const maConn = socketToMaConn(socket, ma, {
      logger: this.logger,
      metrics: this.metrics?.dialerEvents
    });
    this.log("new outbound connection %s", maConn.remoteAddr);
    const conn = await options2.upgrader.upgradeOutbound(maConn, options2);
    this.log("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options2) {
    options2?.signal?.throwIfAborted();
    const cOpts = ma.toOptions();
    this.log("dialing %s:%s", cOpts.host, cOpts.port);
    const errorPromise = pDefer();
    const rawSocket = connect2(multiaddrToUri(ma), this.init);
    rawSocket.socket.addEventListener("error", () => {
      const err = new ConnectionFailedError(`Could not connect to ${ma.toString()}`);
      this.log.error("connection error:", err);
      this.metrics?.dialerEvents.increment({ error: true });
      errorPromise.reject(err);
    });
    try {
      options2.onProgress?.(new CustomProgressEvent("websockets:open-connection"));
      await raceSignal(Promise.race([rawSocket.connected(), errorPromise.promise]), options2.signal);
    } catch (err) {
      if (options2.signal?.aborted) {
        this.metrics?.dialerEvents.increment({ abort: true });
      }
      rawSocket.close().catch((err2) => {
        this.log.error("error closing raw socket", err2);
      });
      throw err;
    }
    this.log("connected %s", ma);
    this.metrics?.dialerEvents.increment({ connect: true });
    return rawSocket;
  }
  /**
   * Creates a WebSockets listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`
   */
  createListener(options2) {
    return createListener2({
      logger: this.logger,
      events: this.components.events,
      metrics: this.components.metrics
    }, {
      ...this.init,
      ...options2
    });
  }
  /**
   * Takes a list of `Multiaddr`s and returns only valid WebSockets addresses.
   * By default, in a browser environment only DNS+WSS multiaddr is accepted,
   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.
   */
  listenFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    if (this.init?.filter != null) {
      return this.init?.filter(multiaddrs);
    }
    return all(multiaddrs);
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
};
function webSockets(init = {}) {
  return (components) => {
    return new WebSockets8(components, init);
  };
}

// node_modules/ipns/dist/src/selector.js
var import_timestamp_nano3 = __toESM(require_timestamp_min());
function ipnsSelector(key, data) {
  const entries = data.map((buf, index) => ({
    record: unmarshalIPNSRecord(buf),
    index
  }));
  entries.sort((a, b) => {
    const aSeq = a.record.sequence;
    const bSeq = b.record.sequence;
    if (aSeq > bSeq) {
      return -1;
    } else if (aSeq < bSeq) {
      return 1;
    }
    if (a.record.validityType === IpnsEntry.ValidityType.EOL && b.record.validityType === IpnsEntry.ValidityType.EOL) {
      const recordAValidityDate = import_timestamp_nano3.default.fromString(a.record.validity).toDate();
      const recordBValidityDate = import_timestamp_nano3.default.fromString(b.record.validity).toDate();
      if (recordAValidityDate.getTime() > recordBValidityDate.getTime()) {
        return -1;
      }
      if (recordAValidityDate.getTime() < recordBValidityDate.getTime()) {
        return 1;
      }
    }
    return 0;
  });
  return entries[0].index;
}

// node_modules/helia/dist/src/version.js
var version2 = "5.4.2";
var name8 = "helia";

// node_modules/helia/dist/src/utils/bootstrappers.js
var bootstrapConfig = {
  list: [
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
    // va1 is not in the TXT records for _dnsaddr.bootstrap.libp2p.io yet
    // so use the host name directly
    "/dnsaddr/va1.bootstrap.libp2p.io/p2p/12D3KooWKnDdG3iXw9eTFijk3EWSunZcFi54Zka4wmtqtt6rPxc8",
    "/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ"
  ]
};

// node_modules/helia/dist/src/utils/libp2p-defaults.browser.js
function libp2pDefaults(options2 = {}) {
  const agentVersion = `${name8}/${version2} ${userAgent()}`;
  return {
    privateKey: options2.privateKey,
    dns: options2.dns,
    nodeInfo: {
      userAgent: agentVersion
    },
    addresses: {
      listen: [
        "/p2p-circuit",
        "/webrtc"
      ]
    },
    transports: [
      circuitRelayTransport(),
      webRTC(),
      webRTCDirect(),
      webSockets()
    ],
    connectionEncrypters: [
      noise()
    ],
    streamMuxers: [
      yamux(),
      mplex()
    ],
    peerDiscovery: [
      bootstrap(bootstrapConfig)
    ],
    services: {
      autoNAT: autoNAT(),
      dcutr: dcutr(),
      delegatedRouting: () => createDelegatedRoutingV1HttpApiClient("https://delegated-ipfs.dev", delegatedHTTPRoutingDefaults()),
      dht: kadDHT({
        clientMode: true,
        validators: {
          ipns: ipnsValidator
        },
        selectors: {
          ipns: ipnsSelector
        }
      }),
      identify: identify(),
      identifyPush: identifyPush(),
      keychain: keychain(options2.keychain),
      ping: ping()
    }
  };
}

// node_modules/helia/dist/src/utils/libp2p.js
async function createLibp2p2(options2) {
  const libp2pOptions = options2.libp2p ?? {};
  if (libp2pOptions.privateKey == null && options2.datastore != null) {
    libp2pOptions.privateKey = await loadOrCreateSelfKey(options2.datastore, options2.keychain);
  }
  const defaults2 = libp2pDefaults(libp2pOptions);
  defaults2.datastore = defaults2.datastore ?? options2.datastore;
  const node = await createLibp2p({
    ...defaults2,
    ...libp2pOptions,
    start: false
  });
  return node;
}

// node_modules/helia/dist/src/utils/helia-defaults.js
async function heliaDefaults(init = {}) {
  const datastore = init.datastore ?? new MemoryDatastore();
  const blockstore = init.blockstore ?? new MemoryBlockstore();
  let libp2p;
  if (isLibp2p(init.libp2p)) {
    libp2p = init.libp2p;
  } else {
    libp2p = await createLibp2p2({
      ...init,
      libp2p: {
        dns: init.dns,
        ...init.libp2p,
        // ignore the libp2p start parameter as it should be on the main init
        // object instead
        start: void 0
      },
      datastore
    });
  }
  return {
    ...init,
    libp2p,
    datastore,
    blockstore,
    blockBrokers: init.blockBrokers ?? [
      trustlessGateway(),
      bitswap()
    ],
    routers: init.routers ?? [
      libp2pRouting(libp2p),
      httpGatewayRouting()
    ],
    metrics: libp2p.metrics,
    start: init.start ?? true
  };
}
function isLibp2p(obj) {
  if (obj == null) {
    return false;
  }
  const funcs = ["dial", "dialProtocol", "hangUp", "handle", "unhandle", "getMultiaddrs", "getProtocols"];
  return funcs.every((m) => typeof obj[m] === "function");
}

// node_modules/helia/dist/src/index.js
async function createHelia(init = {}) {
  const options2 = await heliaDefaults(init);
  const helia = new HeliaP2P(options2);
  if (init.start !== false) {
    await helia.start();
  }
  return helia;
}
export {
  DEFAULT_SESSION_MAX_PROVIDERS,
  DEFAULT_SESSION_MIN_PROVIDERS,
  InsufficientProvidersError,
  NoRoutersAvailableError,
  UnknownCodecError,
  UnknownHashAlgorithmError,
  createHelia,
  heliaDefaults,
  libp2pDefaults
};
/*! Bundled license information:

pvtsutils/build/index.es.js:
  (*!
   * MIT License
   * 
   * Copyright (c) 2017-2024 Peculiar Ventures, LLC
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

pvutils/build/utils.es.js:
  (*!
   Copyright (c) Peculiar Ventures, LLC
  *)

asn1js/build/index.es.js:
  (*!
   * Copyright (c) 2014, GMO GlobalSign
   * Copyright (c) 2015-2022, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the copyright holder nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@peculiar/x509/build/x509.es.js:
  (*!
   * MIT License
   * 
   * Copyright (c) Peculiar Ventures. All rights reserved.
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)
*/
//# sourceMappingURL=helia.js.map

import {
  DeleteFailedError,
  NotFoundError,
  OpenFailedError,
  PutFailedError
} from "./chunk-O4B2SC4X.js";
import {
  pipe,
  src_default as src_default3,
  src_default2 as src_default4
} from "./chunk-U7AWOMBT.js";
import {
  logger,
  src_default,
  src_default3 as src_default2
} from "./chunk-K7PRM5O7.js";
import {
  fromString,
  toString
} from "./chunk-E7RDS3JU.js";
import {
  __export
} from "./chunk-QEK2ZTOW.js";

// node_modules/datastore-core/dist/src/shard.js
var shard_exports = {};
__export(shard_exports, {
  NextToLast: () => NextToLast,
  PREFIX: () => PREFIX,
  Prefix: () => Prefix,
  SHARDING_FN: () => SHARDING_FN,
  ShardBase: () => ShardBase,
  Suffix: () => Suffix,
  parseShardFun: () => parseShardFun,
  readShardFun: () => readShardFun
});

// node_modules/interface-datastore/dist/src/key.js
var pathSepS = "/";
var pathSepB = new TextEncoder().encode(pathSepS);
var pathSep = pathSepB[0];
var Key = class _Key {
  _buf;
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s, clean) {
    if (typeof s === "string") {
      this._buf = fromString(s);
    } else if (s instanceof Uint8Array) {
      this._buf = s;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean == null) {
      clean = true;
    }
    if (clean) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new _Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes = new Uint8Array(this._buf.byteLength + 1);
      bytes.fill(pathSep, 0, 1);
      bytes.set(this._buf, 1);
      this._buf = bytes;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /**
   * Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s) {
    return new _Key(this.toString() + ":" + s);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS)) {
      p += pathSepS;
    }
    p += this.type();
    return new _Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS);
    }
    return new _Key(list.slice(0, -1).join(pathSepS));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}

// node_modules/datastore-core/dist/src/shard.js
var PREFIX = "/repo/flatfs/shard/";
var SHARDING_FN = "SHARDING";
var ShardBase = class {
  param;
  name;
  _padding;
  constructor(param) {
    this.param = param;
    this.name = "base";
    this._padding = "";
  }
  fun(s) {
    return "implement me";
  }
  toString() {
    return `${PREFIX}v1/${this.name}/${this.param}`;
  }
};
var Prefix = class extends ShardBase {
  constructor(prefixLen) {
    super(prefixLen);
    this._padding = "".padStart(prefixLen, "_");
    this.name = "prefix";
  }
  fun(noslash) {
    return (noslash + this._padding).slice(0, this.param);
  }
};
var Suffix = class extends ShardBase {
  constructor(suffixLen) {
    super(suffixLen);
    this._padding = "".padStart(suffixLen, "_");
    this.name = "suffix";
  }
  fun(noslash) {
    const s = this._padding + noslash;
    return s.slice(s.length - this.param);
  }
};
var NextToLast = class extends ShardBase {
  constructor(suffixLen) {
    super(suffixLen);
    this._padding = "".padStart(suffixLen + 1, "_");
    this.name = "next-to-last";
  }
  fun(noslash) {
    const s = this._padding + noslash;
    const offset = s.length - this.param - 1;
    return s.slice(offset, offset + this.param);
  }
};
function parseShardFun(str) {
  str = str.trim();
  if (str.length === 0) {
    throw new Error("empty shard string");
  }
  if (!str.startsWith(PREFIX)) {
    throw new Error(`invalid or no path prefix: ${str}`);
  }
  const parts = str.slice(PREFIX.length).split("/");
  const version = parts[0];
  if (version !== "v1") {
    throw new Error(`expect 'v1' version, got '${version}'`);
  }
  const name = parts[1];
  if (parts[2] == null || parts[2] === "") {
    throw new Error("missing param");
  }
  const param = parseInt(parts[2], 10);
  switch (name) {
    case "prefix":
      return new Prefix(param);
    case "suffix":
      return new Suffix(param);
    case "next-to-last":
      return new NextToLast(param);
    default:
      throw new Error(`unkown sharding function: ${name}`);
  }
}
var readShardFun = async (path, store) => {
  const key = new Key(path).child(new Key(SHARDING_FN));
  const get = typeof store.getRaw === "function" ? store.getRaw.bind(store) : store.get.bind(store);
  const res = await get(key);
  return parseShardFun(new TextDecoder().decode(res ?? "").trim());
};

// node_modules/it-drain/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function drain(source) {
  if (isAsyncIterable(source)) {
    return (async () => {
      for await (const _ of source) {
      }
    })();
  } else {
    for (const _ of source) {
    }
  }
}
var src_default5 = drain;

// node_modules/it-sort/dist/src/index.js
function isAsyncIterable2(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function sort(source, sorter) {
  if (isAsyncIterable2(source)) {
    return async function* () {
      const arr = await src_default4(source);
      yield* arr.sort(sorter);
    }();
  }
  return function* () {
    const arr = src_default4(source);
    yield* arr.sort(sorter);
  }();
}
var src_default6 = sort;

// node_modules/it-take/dist/src/index.js
function isAsyncIterable3(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function take(source, limit) {
  if (isAsyncIterable3(source)) {
    return async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  }
  return function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  }();
}
var src_default7 = take;

// node_modules/datastore-core/dist/src/base.js
var BaseDatastore = class {
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield key;
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield {
        key,
        value: await this.get(key, options)
      };
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await src_default5(this.putMany(puts, options));
        puts = [];
        await src_default5(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default2(it, (e) => e.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default2(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default6(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      const offset = q.offset;
      it = src_default2(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default7(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default2(it, (key) => key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default2(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default6(it2, f), it);
    }
    if (q.offset != null) {
      const offset = q.offset;
      let i = 0;
      it = src_default2(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default7(it, q.limit);
    }
    return it;
  }
};

// node_modules/datastore-core/dist/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  data;
  constructor() {
    super();
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val, options) {
    options?.signal?.throwIfAborted();
    this.data.set(key.toString(), val);
    return key;
  }
  get(key, options) {
    options?.signal?.throwIfAborted();
    const result = this.data.get(key.toString());
    if (result == null) {
      throw new NotFoundError();
    }
    return result;
  }
  has(key, options) {
    options?.signal?.throwIfAborted();
    return this.data.has(key.toString());
  }
  delete(key, options) {
    options?.signal?.throwIfAborted();
    this.data.delete(key.toString());
  }
  *_all(q, options) {
    options?.signal?.throwIfAborted();
    for (const [key, value] of this.data.entries()) {
      yield { key: new Key(key), value };
      options?.signal?.throwIfAborted();
    }
  }
  *_allKeys(q, options) {
    options?.signal?.throwIfAborted();
    for (const key of this.data.keys()) {
      yield new Key(key);
      options?.signal?.throwIfAborted();
    }
  }
};

// node_modules/datastore-core/dist/src/keytransform.js
var KeyTransformDatastore = class extends BaseDatastore {
  child;
  transform;
  constructor(child, transform) {
    super();
    this.child = child;
    this.transform = transform;
  }
  async put(key, val, options) {
    await this.child.put(this.transform.convert(key), val, options);
    return key;
  }
  async get(key, options) {
    return this.child.get(this.transform.convert(key), options);
  }
  async has(key, options) {
    return this.child.has(this.transform.convert(key), options);
  }
  async delete(key, options) {
    await this.child.delete(this.transform.convert(key), options);
  }
  async *putMany(source, options = {}) {
    const transform = this.transform;
    const child = this.child;
    yield* pipe(source, async function* (source2) {
      yield* src_default3(source2, ({ key, value }) => ({
        key: transform.convert(key),
        value
      }));
    }, async function* (source2) {
      yield* child.putMany(source2, options);
    }, async function* (source2) {
      yield* src_default3(source2, (key) => transform.invert(key));
    });
  }
  async *getMany(source, options = {}) {
    const transform = this.transform;
    const child = this.child;
    yield* pipe(source, async function* (source2) {
      yield* src_default3(source2, (key) => transform.convert(key));
    }, async function* (source2) {
      yield* child.getMany(source2, options);
    }, async function* (source2) {
      yield* src_default3(source2, ({ key, value }) => ({
        key: transform.invert(key),
        value
      }));
    });
  }
  async *deleteMany(source, options = {}) {
    const transform = this.transform;
    const child = this.child;
    yield* pipe(source, async function* (source2) {
      yield* src_default3(source2, (key) => transform.convert(key));
    }, async function* (source2) {
      yield* child.deleteMany(source2, options);
    }, async function* (source2) {
      yield* src_default3(source2, (key) => transform.invert(key));
    });
  }
  batch() {
    const b = this.child.batch();
    return {
      put: (key, value) => {
        b.put(this.transform.convert(key), value);
      },
      delete: (key) => {
        b.delete(this.transform.convert(key));
      },
      commit: async (options) => {
        await b.commit(options);
      }
    };
  }
  query(q, options) {
    const query = {
      ...q
    };
    query.filters = (query.filters ?? []).map((filter) => {
      return ({ key, value }) => filter({ key: this.transform.convert(key), value });
    });
    const { prefix } = q;
    if (prefix != null && prefix !== "/") {
      delete query.prefix;
      query.filters.push(({ key }) => {
        return this.transform.invert(key).toString().startsWith(prefix);
      });
    }
    if (query.orders != null) {
      query.orders = query.orders.map((order) => {
        return (a, b) => order({ key: this.transform.invert(a.key), value: a.value }, { key: this.transform.invert(b.key), value: b.value });
      });
    }
    return src_default3(this.child.query(query, options), ({ key, value }) => {
      return {
        key: this.transform.invert(key),
        value
      };
    });
  }
  queryKeys(q, options) {
    const query = {
      ...q
    };
    query.filters = (query.filters ?? []).map((filter) => {
      return (key) => filter(this.transform.convert(key));
    });
    const { prefix } = q;
    if (prefix != null && prefix !== "/") {
      delete query.prefix;
      query.filters.push((key) => {
        return this.transform.invert(key).toString().startsWith(prefix);
      });
    }
    if (query.orders != null) {
      query.orders = query.orders.map((order) => {
        return (a, b) => order(this.transform.invert(a), this.transform.invert(b));
      });
    }
    return src_default3(this.child.queryKeys(query, options), (key) => {
      return this.transform.invert(key);
    });
  }
};

// node_modules/datastore-core/dist/src/sharding.js
var shardKey = new Key(SHARDING_FN);
var ShardingDatastore = class _ShardingDatastore extends BaseDatastore {
  child;
  shard;
  constructor(store, shard) {
    super();
    this.child = new KeyTransformDatastore(store, {
      convert: this._convertKey.bind(this),
      invert: this._invertKey.bind(this)
    });
    this.shard = shard;
  }
  async open() {
    this.shard = await _ShardingDatastore.create(this.child, this.shard);
  }
  _convertKey(key) {
    const s = key.toString();
    if (s === shardKey.toString()) {
      return key;
    }
    const parent = new Key(this.shard.fun(s));
    return parent.child(key);
  }
  _invertKey(key) {
    const s = key.toString();
    if (s === shardKey.toString()) {
      return key;
    }
    return Key.withNamespaces(key.list().slice(1));
  }
  static async create(store, shard) {
    const hasShard = await store.has(shardKey);
    if (!hasShard) {
      if (shard == null) {
        throw new OpenFailedError("Shard is required when datastore doesn't have a shard key already");
      }
      await store.put(shardKey, new TextEncoder().encode(shard.toString() + "\n"));
    }
    if (shard == null) {
      shard = await readShardFun("/", store);
    }
    const diskShard = await readShardFun("/", store);
    const a = diskShard.toString();
    const b = shard.toString();
    if (a !== b) {
      throw new Error(`specified fun ${b} does not match repo shard fun ${a}`);
    }
    return diskShard;
  }
  async put(key, val, options) {
    await this.child.put(key, val, options);
    return key;
  }
  async get(key, options) {
    return this.child.get(key, options);
  }
  async has(key, options) {
    return this.child.has(key, options);
  }
  async delete(key, options) {
    await this.child.delete(key, options);
  }
  async *putMany(source, options = {}) {
    yield* this.child.putMany(source, options);
  }
  async *getMany(source, options = {}) {
    yield* this.child.getMany(source, options);
  }
  async *deleteMany(source, options = {}) {
    yield* this.child.deleteMany(source, options);
  }
  batch() {
    return this.child.batch();
  }
  query(q, options) {
    const omitShard = ({ key }) => key.toString() !== shardKey.toString();
    const tq = {
      ...q,
      filters: [
        omitShard
      ].concat(q.filters ?? [])
    };
    return this.child.query(tq, options);
  }
  queryKeys(q, options) {
    const omitShard = (key) => key.toString() !== shardKey.toString();
    const tq = {
      ...q,
      filters: [
        omitShard
      ].concat(q.filters ?? [])
    };
    return this.child.queryKeys(tq, options);
  }
};

// node_modules/datastore-core/dist/src/mount.js
var MountDatastore = class extends BaseDatastore {
  mounts;
  constructor(mounts) {
    super();
    this.mounts = mounts.slice();
  }
  /**
   * Lookup the matching datastore for the given key
   */
  _lookup(key) {
    for (const mount of this.mounts) {
      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {
        return {
          datastore: mount.datastore,
          mountpoint: mount.prefix
        };
      }
    }
  }
  async put(key, value, options) {
    const match = this._lookup(key);
    if (match == null) {
      throw new PutFailedError("No datastore mounted for this key");
    }
    await match.datastore.put(key, value, options);
    return key;
  }
  /**
   * @param {Key} key
   * @param {Options} [options]
   */
  async get(key, options = {}) {
    const match = this._lookup(key);
    if (match == null) {
      throw new NotFoundError("No datastore mounted for this key");
    }
    return match.datastore.get(key, options);
  }
  async has(key, options) {
    const match = this._lookup(key);
    if (match == null) {
      return Promise.resolve(false);
    }
    return match.datastore.has(key, options);
  }
  async delete(key, options) {
    const match = this._lookup(key);
    if (match == null) {
      throw new DeleteFailedError("No datastore mounted for this key");
    }
    await match.datastore.delete(key, options);
  }
  batch() {
    const batchMounts = {};
    const lookup = (key) => {
      const match = this._lookup(key);
      if (match == null) {
        throw new Error("No datastore mounted for this key");
      }
      const m = match.mountpoint.toString();
      if (batchMounts[m] == null) {
        batchMounts[m] = match.datastore.batch();
      }
      return {
        batch: batchMounts[m]
      };
    };
    return {
      put: (key, value) => {
        const match = lookup(key);
        match.batch.put(key, value);
      },
      delete: (key) => {
        const match = lookup(key);
        match.batch.delete(key);
      },
      commit: async (options) => {
        await Promise.all(Object.keys(batchMounts).map(async (p) => {
          await batchMounts[p].commit(options);
        }));
      }
    };
  }
  query(q, options) {
    const qs = this.mounts.map((m) => {
      return m.datastore.query({
        prefix: q.prefix,
        filters: q.filters
      }, options);
    });
    let it = src_default(...qs);
    if (q.filters != null) {
      q.filters.forEach((f) => {
        it = src_default2(it, f);
      });
    }
    if (q.orders != null) {
      q.orders.forEach((o) => {
        it = src_default6(it, o);
      });
    }
    if (q.offset != null) {
      let i = 0;
      const offset = q.offset;
      it = src_default2(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default7(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    const qs = this.mounts.map((m) => {
      return m.datastore.queryKeys({
        prefix: q.prefix,
        filters: q.filters
      }, options);
    });
    let it = src_default(...qs);
    if (q.filters != null) {
      q.filters.forEach((f) => {
        it = src_default2(it, f);
      });
    }
    if (q.orders != null) {
      q.orders.forEach((o) => {
        it = src_default6(it, o);
      });
    }
    if (q.offset != null) {
      let i = 0;
      const offset = q.offset;
      it = src_default2(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default7(it, q.limit);
    }
    return it;
  }
};

// node_modules/datastore-core/dist/src/tiered.js
var log = logger("datastore:core:tiered");
var TieredDatastore = class extends BaseDatastore {
  stores;
  constructor(stores) {
    super();
    this.stores = stores.slice();
  }
  async put(key, value, options) {
    await Promise.all(this.stores.map(async (store) => {
      await store.put(key, value, options);
    }));
    return key;
  }
  async get(key, options) {
    let error;
    for (const store of this.stores) {
      try {
        const res = await store.get(key, options);
        if (res != null) {
          return res;
        }
      } catch (err) {
        error = err;
        log.error(err);
      }
    }
    throw error ?? new NotFoundError();
  }
  async has(key, options) {
    for (const s of this.stores) {
      if (await s.has(key, options)) {
        return true;
      }
    }
    return false;
  }
  async delete(key, options) {
    await Promise.all(this.stores.map(async (store) => {
      await store.delete(key, options);
    }));
  }
  async *putMany(source, options = {}) {
    for await (const pair of source) {
      await this.put(pair.key, pair.value, options);
      yield pair.key;
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    const batches = this.stores.map((store) => store.batch());
    return {
      put: (key, value) => {
        batches.forEach((b) => {
          b.put(key, value);
        });
      },
      delete: (key) => {
        batches.forEach((b) => {
          b.delete(key);
        });
      },
      commit: async (options) => {
        for (const batch of batches) {
          await batch.commit(options);
        }
      }
    };
  }
  query(q, options) {
    return this.stores[this.stores.length - 1].query(q, options);
  }
  queryKeys(q, options) {
    return this.stores[this.stores.length - 1].queryKeys(q, options);
  }
};

// node_modules/datastore-core/dist/src/namespace.js
var NamespaceDatastore = class extends KeyTransformDatastore {
  iChild;
  iKey;
  constructor(child, prefix) {
    super(child, {
      convert(key) {
        return prefix.child(key);
      },
      invert(key) {
        if (prefix.toString() === "/") {
          return key;
        }
        if (!prefix.isAncestorOf(key)) {
          throw new Error(`Expected prefix: (${prefix.toString()}) in key: ${key.toString()}`);
        }
        return new Key(key.toString().slice(prefix.toString().length), false);
      }
    });
    this.iChild = child;
    this.iKey = prefix;
  }
  query(q, options) {
    const query = {
      ...q
    };
    query.filters = (query.filters ?? []).map((filter) => {
      return ({ key, value }) => filter({ key: this.transform.invert(key), value });
    });
    const { prefix } = q;
    if (prefix != null && prefix !== "/") {
      delete query.prefix;
      query.filters.push(({ key }) => {
        return this.transform.invert(key).toString().startsWith(prefix);
      });
    }
    if (query.orders != null) {
      query.orders = query.orders.map((order) => {
        return (a, b) => order({ key: this.transform.invert(a.key), value: a.value }, { key: this.transform.invert(b.key), value: b.value });
      });
    }
    query.filters.unshift(({ key }) => this.iKey.isAncestorOf(key));
    return src_default3(this.iChild.query(query, options), ({ key, value }) => {
      return {
        key: this.transform.invert(key),
        value
      };
    });
  }
  queryKeys(q, options) {
    const query = {
      ...q
    };
    query.filters = (query.filters ?? []).map((filter) => {
      return (key) => filter(this.transform.invert(key));
    });
    const { prefix } = q;
    if (prefix != null && prefix !== "/") {
      delete query.prefix;
      query.filters.push((key) => {
        return this.transform.invert(key).toString().startsWith(prefix);
      });
    }
    if (query.orders != null) {
      query.orders = query.orders.map((order) => {
        return (a, b) => order(this.transform.invert(a), this.transform.invert(b));
      });
    }
    query.filters.unshift((key) => this.iKey.isAncestorOf(key));
    return src_default3(this.iChild.queryKeys(query, options), (key) => {
      return this.transform.invert(key);
    });
  }
};

export {
  src_default5 as src_default,
  Key,
  src_default7 as src_default2,
  shard_exports,
  BaseDatastore,
  MemoryDatastore,
  KeyTransformDatastore,
  ShardingDatastore,
  MountDatastore,
  TieredDatastore,
  NamespaceDatastore
};
//# sourceMappingURL=chunk-6PD3Z677.js.map

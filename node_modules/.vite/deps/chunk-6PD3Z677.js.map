{
  "version": 3,
  "sources": ["../../datastore-core/src/shard.ts", "../../interface-datastore/src/key.ts", "../../it-drain/src/index.ts", "../../it-sort/src/index.ts", "../../it-take/src/index.ts", "../../datastore-core/src/base.ts", "../../datastore-core/src/memory.ts", "../../datastore-core/src/keytransform.ts", "../../datastore-core/src/sharding.ts", "../../datastore-core/src/mount.ts", "../../datastore-core/src/tiered.ts", "../../datastore-core/src/namespace.ts"],
  "sourcesContent": ["import { Key } from 'interface-datastore/key'\nimport type { Shard } from './index.js'\nimport type { Datastore } from 'interface-datastore'\n\nexport const PREFIX = '/repo/flatfs/shard/'\nexport const SHARDING_FN = 'SHARDING'\n\nexport class ShardBase implements Shard {\n  public param: number\n  public name: string\n  public _padding: string\n\n  constructor (param: number) {\n    this.param = param\n    this.name = 'base'\n    this._padding = ''\n  }\n\n  fun (s: string): string {\n    return 'implement me'\n  }\n\n  toString (): string {\n    return `${PREFIX}v1/${this.name}/${this.param}`\n  }\n}\n\nexport class Prefix extends ShardBase {\n  constructor (prefixLen: number) {\n    super(prefixLen)\n    this._padding = ''.padStart(prefixLen, '_')\n    this.name = 'prefix'\n  }\n\n  fun (noslash: string): string {\n    return (noslash + this._padding).slice(0, this.param)\n  }\n}\n\nexport class Suffix extends ShardBase {\n  constructor (suffixLen: number) {\n    super(suffixLen)\n\n    this._padding = ''.padStart(suffixLen, '_')\n    this.name = 'suffix'\n  }\n\n  fun (noslash: string): string {\n    const s = this._padding + noslash\n    return s.slice(s.length - this.param)\n  }\n}\n\nexport class NextToLast extends ShardBase {\n  constructor (suffixLen: number) {\n    super(suffixLen)\n    this._padding = ''.padStart(suffixLen + 1, '_')\n    this.name = 'next-to-last'\n  }\n\n  fun (noslash: string): string {\n    const s = this._padding + noslash\n    const offset = s.length - this.param - 1\n    return s.slice(offset, offset + this.param)\n  }\n}\n\n/**\n * Convert a given string to the matching sharding function\n */\nexport function parseShardFun (str: string): Shard {\n  str = str.trim()\n\n  if (str.length === 0) {\n    throw new Error('empty shard string')\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(`invalid or no path prefix: ${str}`)\n  }\n\n  const parts = str.slice(PREFIX.length).split('/')\n  const version = parts[0]\n\n  if (version !== 'v1') {\n    throw new Error(`expect 'v1' version, got '${version}'`)\n  }\n\n  const name = parts[1]\n\n  if (parts[2] == null || parts[2] === '') {\n    throw new Error('missing param')\n  }\n\n  const param = parseInt(parts[2], 10)\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param)\n    case 'suffix':\n      return new Suffix(param)\n    case 'next-to-last':\n      return new NextToLast(param)\n    default:\n      throw new Error(`unkown sharding function: ${name}`)\n  }\n}\n\nexport const readShardFun = async (path: string | Uint8Array, store: Datastore): Promise<Shard> => {\n  const key = new Key(path).child(new Key(SHARDING_FN))\n  // @ts-expect-error not all stores have this\n  const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store)\n  const res = await get(key)\n  return parseShardFun(new TextDecoder().decode(res ?? '').trim())\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { SupportedEncodings } from 'uint8arrays/to-string'\n\nconst pathSepS = '/'\nconst pathSepB = new TextEncoder().encode(pathSepS)\nconst pathSep = pathSepB[0]\n\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nexport class Key {\n  private _buf: Uint8Array\n\n  /**\n   * @param {string | Uint8Array} s\n   * @param {boolean} [clean]\n   */\n  constructor (s: string | Uint8Array, clean?: boolean) {\n    if (typeof s === 'string') {\n      this._buf = uint8ArrayFromString(s)\n    } else if (s instanceof Uint8Array) {\n      this._buf = s\n    } else {\n      throw new Error('Invalid key, should be String of Uint8Array')\n    }\n\n    if (clean == null) {\n      clean = true\n    }\n\n    if (clean) {\n      this.clean()\n    }\n\n    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key')\n    }\n  }\n\n  /**\n   * Convert to the string representation\n   *\n   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding] - The encoding to use.\n   * @returns {string}\n   */\n  toString (encoding: SupportedEncodings = 'utf8'): string {\n    return uint8ArrayToString(this._buf, encoding)\n  }\n\n  /**\n   * Return the Uint8Array representation of the key\n   *\n   * @returns {Uint8Array}\n   */\n  uint8Array (): Uint8Array {\n    return this._buf\n  }\n\n  /**\n   * Return string representation of the key\n   *\n   * @returns {string}\n   */\n  get [Symbol.toStringTag] (): string {\n    return `Key(${this.toString()})`\n  }\n\n  /**\n   * Constructs a key out of a namespace array.\n   *\n   * @param {Array<string>} list - The array of namespaces\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.withNamespaces(['one', 'two'])\n   * // => Key('/one/two')\n   * ```\n   */\n  static withNamespaces (list: string[]): Key {\n    return new Key(list.join(pathSepS))\n  }\n\n  /**\n   * Returns a randomly (uuid) generated key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.random()\n   * // => Key('/344502982398')\n   * ```\n   */\n  static random (): Key {\n    return new Key(Math.random().toString().substring(2))\n  }\n\n  /**\n   * @param {*} other\n   */\n  static asKey (other: any): Key | null {\n    if (other instanceof Uint8Array || typeof other === 'string') {\n      // we can create a key from this\n      return new Key(other)\n    }\n\n    if (typeof other.uint8Array === 'function') {\n      // this is an older version or may have crossed the esm/cjs boundary\n      return new Key(other.uint8Array())\n    }\n\n    return null\n  }\n\n  /**\n   * Cleanup the current key\n   *\n   * @returns {void}\n   */\n  clean (): void {\n    if (this._buf == null || this._buf.byteLength === 0) {\n      this._buf = pathSepB\n    }\n\n    if (this._buf[0] !== pathSep) {\n      const bytes = new Uint8Array(this._buf.byteLength + 1)\n      bytes.fill(pathSep, 0, 1)\n      bytes.set(this._buf, 1)\n      this._buf = bytes\n    }\n\n    // normalize does not remove trailing slashes\n    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n      this._buf = this._buf.subarray(0, -1)\n    }\n  }\n\n  /**\n   * Check if the given key is sorted lower than ourself.\n   *\n   * @param {Key} key - The other Key to check against\n   * @returns {boolean}\n   */\n  less (key: Key): boolean {\n    const list1 = this.list()\n    const list2 = key.list()\n\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false\n      }\n\n      const c1 = list1[i]\n      const c2 = list2[i]\n\n      if (c1 < c2) {\n        return true\n      } else if (c1 > c2) {\n        return false\n      }\n    }\n\n    return list1.length < list2.length\n  }\n\n  /**\n   * Returns the key with all parts in reversed order.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n   * ```\n   */\n  reverse (): Key {\n    return Key.withNamespaces(this.list().slice().reverse())\n  }\n\n  /**\n   * Returns the `namespaces` making up this Key.\n   *\n   * @returns {Array<string>}\n   */\n  namespaces (): string[] {\n    return this.list()\n  }\n\n  /**\n   * Returns the \"base\" namespace of this key.\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n   * // => 'Actor:JohnCleese'\n   * ```\n   */\n  baseNamespace (): string {\n    const ns = this.namespaces()\n    return ns[ns.length - 1]\n  }\n\n  /**\n   * Returns the `list` representation of this key.\n   *\n   * @returns {Array<string>}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n   * ```\n   */\n  list (): string[] {\n    return this.toString().split(pathSepS).slice(1)\n  }\n\n  /**\n   * Returns the \"type\" of this key (value of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n   * // => 'Actor'\n   * ```\n   */\n  type (): string {\n    return namespaceType(this.baseNamespace())\n  }\n\n  /**\n   * Returns the \"name\" of this key (field of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n   * // => 'JohnCleese'\n   * ```\n   */\n  name (): string {\n    return namespaceValue(this.baseNamespace())\n  }\n\n  /**\n   * Returns an \"instance\" of this type key (appends value to namespace).\n   *\n   * @param {string} s - The string to append.\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n  instance (s: string): Key {\n    return new Key(this.toString() + ':' + s)\n  }\n\n  /**\n   * Returns the \"path\" of this key (parent + type).\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n   * // => Key('/Comedy/MontyPython/Actor')\n   * ```\n   */\n  path (): Key {\n    let p = this.parent().toString()\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS\n    }\n    p += this.type()\n    return new Key(p)\n  }\n\n  /**\n   * Returns the `parent` Key of this Key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n   * // => Key(\"/Comedy/MontyPython\")\n   * ```\n   */\n  parent (): Key {\n    const list = this.list()\n    if (list.length === 1) {\n      return new Key(pathSepS)\n    }\n\n    return new Key(list.slice(0, -1).join(pathSepS))\n  }\n\n  /**\n   * Returns the `child` Key of this Key.\n   *\n   * @param {Key} key - The child Key to add\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n  child (key: Key): Key {\n    if (this.toString() === pathSepS) {\n      return key\n    } else if (key.toString() === pathSepS) {\n      return this\n    }\n\n    return new Key(this.toString() + key.toString(), false)\n  }\n\n  /**\n   * Returns whether this key is a prefix of `other`\n   *\n   * @param {Key} other - The other key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n   * // => true\n   * ```\n   */\n  isAncestorOf (other: Key): boolean {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return other.toString().startsWith(this.toString())\n  }\n\n  /**\n   * Returns whether this key is a contains another as prefix.\n   *\n   * @param {Key} other - The other Key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n   * // => true\n   * ```\n   */\n  isDecendantOf (other: Key): boolean {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return this.toString().startsWith(other.toString())\n  }\n\n  /**\n   * Checks if this key has only one namespace.\n   *\n   * @returns {boolean}\n   */\n  isTopLevel (): boolean {\n    return this.list().length === 1\n  }\n\n  /**\n   * Concats one or more Keys into one new Key.\n   *\n   * @param {Array<Key>} keys - The array of keys to concatenate\n   * @returns {Key}\n   */\n  concat (...keys: Key[]): Key {\n    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))])\n  }\n}\n\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType (ns: string): string {\n  const parts = ns.split(':')\n  if (parts.length < 2) {\n    return ''\n  }\n  return parts.slice(0, -1).join(':')\n}\n\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue (ns: string): string {\n  const parts = ns.split(':')\n  return parts[parts.length - 1]\n}\n\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\nfunction flatten (arr: any[]): string[] {\n  return ([]).concat(...arr)\n}\n", "/**\n * @packageDocumentation\n *\n * Mostly useful for tests or when you want to be explicit about consuming an iterable without doing anything with any yielded values.\n *\n * @example\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * drain(values)\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * const values = async function * {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * await drain(values())\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Drains an (async) iterable discarding its' content and does not return\n * anything\n */\nfunction drain (source: Iterable<unknown>): void\nfunction drain (source: Iterable<unknown> | AsyncIterable<unknown>): Promise<void>\nfunction drain (source: Iterable<unknown> | AsyncIterable<unknown>): Promise<void> | void {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      for await (const _ of source) { } // eslint-disable-line no-empty,@typescript-eslint/no-unused-vars\n    })()\n  } else {\n    for (const _ of source) { } // eslint-disable-line no-empty,@typescript-eslint/no-unused-vars\n  }\n}\n\nexport default drain\n", "/**\n * @packageDocumentation\n *\n * Consumes all values from an (async)iterable and returns them sorted by the passed sort function.\n *\n * @example\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * // This can also be an iterator, generator, etc\n * const values = ['foo', 'bar']\n *\n * const arr = all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * const values = async function * () {\n *   yield * ['foo', 'bar']\n * }\n *\n * const arr = await all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n */\n\nimport all from 'it-all'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nexport interface CompareFunction<T> {\n  (a: T, b: T): number\n}\n\n/**\n * Collects all values from an async iterator, sorts them\n * using the passed function and yields them\n */\nfunction sort <T> (source: Iterable<T>, sorter: CompareFunction<T>): Generator<T, void, undefined>\nfunction sort <T> (source: Iterable<T> | AsyncIterable<T>, sorter: CompareFunction<T>): AsyncGenerator<T, void, undefined>\nfunction sort <T> (source: Iterable<T> | AsyncIterable<T>, sorter: CompareFunction<T>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      const arr = await all(source)\n\n      yield * arr.sort(sorter)\n    })()\n  }\n\n  return (function * () {\n    const arr = all(source)\n\n    yield * arr.sort(sorter)\n  })()\n}\n\nexport default sort\n", "/**\n * @packageDocumentation\n *\n * For when you only want a few values out of an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const arr = all(take(values, 2))\n *\n * console.info(arr) // 0, 1\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(take(values(), 2))\n *\n * console.info(arr) // 0, 1\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Stop iteration after n items have been received\n */\nfunction take <T> (source: Iterable<T>, limit: number): Generator<T, void, undefined>\nfunction take <T> (source: Iterable<T> | AsyncIterable<T>, limit: number): AsyncGenerator<T, void, undefined>\nfunction take <T> (source: Iterable<T> | AsyncIterable<T>, limit: number): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      let items = 0\n\n      if (limit < 1) {\n        return\n      }\n\n      for await (const entry of source) {\n        yield entry\n\n        items++\n\n        if (items === limit) {\n          return\n        }\n      }\n    })()\n  }\n\n  return (function * () {\n    let items = 0\n\n    if (limit < 1) {\n      return\n    }\n\n    for (const entry of source) {\n      yield entry\n\n      items++\n\n      if (items === limit) {\n        return\n      }\n    }\n  })()\n}\n\nexport default take\n", "import drain from 'it-drain'\nimport filter from 'it-filter'\nimport sort from 'it-sort'\nimport take from 'it-take'\nimport type { Batch, Datastore, Key, KeyQuery, Pair, Query } from 'interface-datastore'\nimport type { AbortOptions, Await, AwaitIterable } from 'interface-store'\n\nexport class BaseDatastore implements Datastore {\n  put (key: Key, val: Uint8Array, options?: AbortOptions): Await<Key> {\n    return Promise.reject(new Error('.put is not implemented'))\n  }\n\n  get (key: Key, options?: AbortOptions): Await<Uint8Array> {\n    return Promise.reject(new Error('.get is not implemented'))\n  }\n\n  has (key: Key, options?: AbortOptions): Await<boolean> {\n    return Promise.reject(new Error('.has is not implemented'))\n  }\n\n  delete (key: Key, options?: AbortOptions): Await<void> {\n    return Promise.reject(new Error('.delete is not implemented'))\n  }\n\n  async * putMany (source: AwaitIterable<Pair>, options: AbortOptions = {}): AwaitIterable<Key> {\n    for await (const { key, value } of source) {\n      await this.put(key, value, options)\n      yield key\n    }\n  }\n\n  async * getMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AwaitIterable<Pair> {\n    for await (const key of source) {\n      yield {\n        key,\n        value: await this.get(key, options)\n      }\n    }\n  }\n\n  async * deleteMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AwaitIterable<Key> {\n    for await (const key of source) {\n      await this.delete(key, options)\n      yield key\n    }\n  }\n\n  batch (): Batch {\n    let puts: Pair[] = []\n    let dels: Key[] = []\n\n    return {\n      put (key, value) {\n        puts.push({ key, value })\n      },\n\n      delete (key) {\n        dels.push(key)\n      },\n      commit: async (options) => {\n        await drain(this.putMany(puts, options))\n        puts = []\n        await drain(this.deleteMany(dels, options))\n        dels = []\n      }\n    }\n  }\n\n  /**\n   * Extending classes should override `query` or implement this method\n   */\n  // eslint-disable-next-line require-yield\n  async * _all (q: Query, options?: AbortOptions): AwaitIterable<Pair> {\n    throw new Error('._all is not implemented')\n  }\n\n  /**\n   * Extending classes should override `queryKeys` or implement this method\n   */\n  // eslint-disable-next-line require-yield\n  async * _allKeys (q: KeyQuery, options?: AbortOptions): AwaitIterable<Key> {\n    throw new Error('._allKeys is not implemented')\n  }\n\n  query (q: Query, options?: AbortOptions): AwaitIterable<Pair> {\n    let it = this._all(q, options)\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      it = filter(it, (e) => e.key.toString().startsWith(prefix))\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      const offset = q.offset\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n\n  queryKeys (q: KeyQuery, options?: AbortOptions): AwaitIterable<Key> {\n    let it = this._allKeys(q, options)\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      it = filter(it, (key) =>\n        key.toString().startsWith(prefix)\n      )\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    if (q.offset != null) {\n      const offset = q.offset\n      let i = 0\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n}\n", "import { Key } from 'interface-datastore/key'\nimport { NotFoundError } from 'interface-store'\nimport { BaseDatastore } from './base.js'\nimport type { KeyQuery, Pair, Query } from 'interface-datastore'\nimport type { AbortOptions, Await, AwaitIterable } from 'interface-store'\n\nexport class MemoryDatastore extends BaseDatastore {\n  private readonly data: Map<string, Uint8Array>\n\n  constructor () {\n    super()\n\n    this.data = new Map()\n  }\n\n  put (key: Key, val: Uint8Array, options?: AbortOptions): Await<Key> {\n    options?.signal?.throwIfAborted()\n\n    this.data.set(key.toString(), val)\n\n    return key\n  }\n\n  get (key: Key, options?: AbortOptions): Await<Uint8Array> {\n    options?.signal?.throwIfAborted()\n\n    const result = this.data.get(key.toString())\n\n    if (result == null) {\n      throw new NotFoundError()\n    }\n\n    return result\n  }\n\n  has (key: Key, options?: AbortOptions): Await<boolean> {\n    options?.signal?.throwIfAborted()\n    return this.data.has(key.toString())\n  }\n\n  delete (key: Key, options?: AbortOptions): Await<void> {\n    options?.signal?.throwIfAborted()\n    this.data.delete(key.toString())\n  }\n\n  * _all (q: Query, options?: AbortOptions): AwaitIterable<Pair> {\n    options?.signal?.throwIfAborted()\n    for (const [key, value] of this.data.entries()) {\n      yield { key: new Key(key), value }\n      options?.signal?.throwIfAborted()\n    }\n  }\n\n  * _allKeys (q: KeyQuery, options?: AbortOptions): AwaitIterable<Key> {\n    options?.signal?.throwIfAborted()\n    for (const key of this.data.keys()) {\n      yield new Key(key)\n      options?.signal?.throwIfAborted()\n    }\n  }\n}\n", "import map from 'it-map'\nimport { pipe } from 'it-pipe'\nimport { BaseDatastore } from './base.js'\nimport type { KeyTransform } from './index.js'\nimport type { Batch, Datastore, Key, KeyQuery, Pair, Query } from 'interface-datastore'\nimport type { AbortOptions, AwaitIterable } from 'interface-store'\n\n/**\n * A datastore shim, that wraps around a given datastore, changing\n * the way keys look to the user, for example namespacing\n * keys, reversing them, etc.\n */\nexport class KeyTransformDatastore extends BaseDatastore {\n  private readonly child: Datastore\n  public transform: KeyTransform\n\n  constructor (child: Datastore, transform: KeyTransform) {\n    super()\n\n    this.child = child\n    this.transform = transform\n  }\n\n  async put (key: Key, val: Uint8Array, options?: AbortOptions): Promise<Key> {\n    await this.child.put(this.transform.convert(key), val, options)\n\n    return key\n  }\n\n  async get (key: Key, options?: AbortOptions): Promise<Uint8Array> {\n    return this.child.get(this.transform.convert(key), options)\n  }\n\n  async has (key: Key, options?: AbortOptions): Promise<boolean> {\n    return this.child.has(this.transform.convert(key), options)\n  }\n\n  async delete (key: Key, options?: AbortOptions): Promise<void> {\n    await this.child.delete(this.transform.convert(key), options)\n  }\n\n  async * putMany (source: AwaitIterable<Pair>, options: AbortOptions = {}): AsyncIterable<Key> {\n    const transform = this.transform\n    const child = this.child\n\n    yield * pipe(\n      source,\n      async function * (source) {\n        yield * map(source, ({ key, value }) => ({\n          key: transform.convert(key),\n          value\n        }))\n      },\n      async function * (source) {\n        yield * child.putMany(source, options)\n      },\n      async function * (source) {\n        yield * map(source, key => transform.invert(key))\n      }\n    )\n  }\n\n  async * getMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AsyncIterable<Pair> {\n    const transform = this.transform\n    const child = this.child\n\n    yield * pipe(\n      source,\n      async function * (source) {\n        yield * map(source, key => transform.convert(key))\n      },\n      async function * (source) {\n        yield * child.getMany(source, options)\n      },\n      async function * (source) {\n        yield * map(source, ({ key, value }) => ({\n          key: transform.invert(key),\n          value\n        }))\n      }\n    )\n  }\n\n  async * deleteMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AsyncIterable<Key> {\n    const transform = this.transform\n    const child = this.child\n\n    yield * pipe(\n      source,\n      async function * (source) {\n        yield * map(source, key => transform.convert(key))\n      },\n      async function * (source) {\n        yield * child.deleteMany(source, options)\n      },\n      async function * (source) {\n        yield * map(source, key => transform.invert(key))\n      }\n    )\n  }\n\n  batch (): Batch {\n    const b = this.child.batch()\n    return {\n      put: (key, value) => {\n        b.put(this.transform.convert(key), value)\n      },\n      delete: (key) => {\n        b.delete(this.transform.convert(key))\n      },\n      commit: async (options) => {\n        await b.commit(options)\n      }\n    }\n  }\n\n  query (q: Query, options?: AbortOptions): AsyncIterable<Pair> {\n    const query: Query = {\n      ...q\n    }\n\n    query.filters = (query.filters ?? []).map(filter => {\n      return ({ key, value }) => filter({ key: this.transform.convert(key), value })\n    })\n\n    const { prefix } = q\n    if (prefix != null && prefix !== '/') {\n      delete query.prefix\n      query.filters.push(({ key }) => {\n        return this.transform.invert(key).toString().startsWith(prefix)\n      })\n    }\n\n    if (query.orders != null) {\n      query.orders = query.orders.map(order => {\n        return (a, b) => order(\n          { key: this.transform.invert(a.key), value: a.value },\n          { key: this.transform.invert(b.key), value: b.value }\n        )\n      })\n    }\n\n    return map(this.child.query(query, options), ({ key, value }) => {\n      return {\n        key: this.transform.invert(key),\n        value\n      }\n    })\n  }\n\n  queryKeys (q: KeyQuery, options?: AbortOptions): AsyncIterable<Key> {\n    const query = {\n      ...q\n    }\n\n    query.filters = (query.filters ?? []).map(filter => {\n      return (key) => filter(this.transform.convert(key))\n    })\n\n    const { prefix } = q\n    if (prefix != null && prefix !== '/') {\n      delete query.prefix\n      query.filters.push((key) => {\n        return this.transform.invert(key).toString().startsWith(prefix)\n      })\n    }\n\n    if (query.orders != null) {\n      query.orders = query.orders.map(order => {\n        return (a, b) => order(\n          this.transform.invert(a),\n          this.transform.invert(b)\n        )\n      })\n    }\n\n    return map(this.child.queryKeys(query, options), key => {\n      return this.transform.invert(key)\n    })\n  }\n}\n", "import { Key } from 'interface-datastore'\nimport { OpenFailedError } from 'interface-store'\nimport { BaseDatastore } from './base.js'\nimport { KeyTransformDatastore } from './keytransform.js'\nimport {\n  readShardFun,\n  SHARDING_FN\n} from './shard.js'\nimport type { Shard } from './index.js'\nimport type { Batch, KeyQuery, KeyQueryFilter, Pair, Query, QueryFilter, Datastore } from 'interface-datastore'\nimport type { AbortOptions, AwaitIterable } from 'interface-store'\n\nconst shardKey = new Key(SHARDING_FN)\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\nexport class ShardingDatastore extends BaseDatastore {\n  private readonly child: KeyTransformDatastore\n  private shard: Shard\n\n  constructor (store: Datastore, shard: Shard) {\n    super()\n\n    this.child = new KeyTransformDatastore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    })\n    this.shard = shard\n  }\n\n  async open (): Promise<void> {\n    this.shard = await ShardingDatastore.create(this.child, this.shard)\n  }\n\n  _convertKey (key: Key): Key {\n    const s = key.toString()\n    if (s === shardKey.toString()) {\n      return key\n    }\n\n    const parent = new Key(this.shard.fun(s))\n    return parent.child(key)\n  }\n\n  _invertKey (key: Key): Key {\n    const s = key.toString()\n    if (s === shardKey.toString()) {\n      return key\n    }\n    return Key.withNamespaces(key.list().slice(1))\n  }\n\n  static async create (store: Datastore, shard?: Shard): Promise<Shard> {\n    const hasShard = await store.has(shardKey)\n\n    if (!hasShard) {\n      if (shard == null) {\n        throw new OpenFailedError('Shard is required when datastore doesn\\'t have a shard key already')\n      }\n\n      await store.put(shardKey, new TextEncoder().encode(shard.toString() + '\\n'))\n    }\n\n    if (shard == null) {\n      shard = await readShardFun('/', store)\n    }\n\n    // test shards\n    const diskShard = await readShardFun('/', store)\n    const a = diskShard.toString()\n    const b = shard.toString()\n\n    if (a !== b) {\n      throw new Error(`specified fun ${b} does not match repo shard fun ${a}`)\n    }\n\n    return diskShard\n  }\n\n  async put (key: Key, val: Uint8Array, options?: AbortOptions): Promise<Key> {\n    await this.child.put(key, val, options)\n\n    return key\n  }\n\n  async get (key: Key, options?: AbortOptions): Promise<Uint8Array> {\n    return this.child.get(key, options)\n  }\n\n  async has (key: Key, options?: AbortOptions): Promise<boolean> {\n    return this.child.has(key, options)\n  }\n\n  async delete (key: Key, options?: AbortOptions): Promise<void> {\n    await this.child.delete(key, options)\n  }\n\n  async * putMany (source: AwaitIterable<Pair>, options: AbortOptions = {}): AsyncIterable<Key> {\n    yield * this.child.putMany(source, options)\n  }\n\n  async * getMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AsyncIterable<Pair> {\n    yield * this.child.getMany(source, options)\n  }\n\n  async * deleteMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AsyncIterable<Key> {\n    yield * this.child.deleteMany(source, options)\n  }\n\n  batch (): Batch {\n    return this.child.batch()\n  }\n\n  query (q: Query, options?: AbortOptions): AsyncIterable<Pair> {\n    const omitShard: QueryFilter = ({ key }) => key.toString() !== shardKey.toString()\n\n    const tq: Query = {\n      ...q,\n      filters: [\n        omitShard\n      ].concat(q.filters ?? [])\n    }\n\n    return this.child.query(tq, options)\n  }\n\n  queryKeys (q: KeyQuery, options?: AbortOptions): AsyncIterable<Key> {\n    const omitShard: KeyQueryFilter = (key) => key.toString() !== shardKey.toString()\n\n    const tq: KeyQuery = {\n      ...q,\n      filters: [\n        omitShard\n      ].concat(q.filters ?? [])\n    }\n\n    return this.child.queryKeys(tq, options)\n  }\n}\n", "import { DeleteFailedError, NotFoundError, PutFailedError } from 'interface-store'\nimport filter from 'it-filter'\nimport merge from 'it-merge'\nimport sort from 'it-sort'\nimport take from 'it-take'\nimport { BaseDatastore } from './base.js'\nimport type { Batch, Datastore, Key, KeyQuery, Pair, Query } from 'interface-datastore'\nimport type { AbortOptions } from 'interface-store'\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixes\n */\nexport class MountDatastore extends BaseDatastore {\n  private readonly mounts: Array<{ prefix: Key, datastore: Datastore }>\n\n  constructor (mounts: Array<{ prefix: Key, datastore: Datastore }>) {\n    super()\n\n    this.mounts = mounts.slice()\n  }\n\n  /**\n   * Lookup the matching datastore for the given key\n   */\n  private _lookup (key: Key): { datastore: Datastore, mountpoint: Key } | undefined {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix\n        }\n      }\n    }\n  }\n\n  async put (key: Key, value: Uint8Array, options?: AbortOptions): Promise<Key> {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw new PutFailedError('No datastore mounted for this key')\n    }\n\n    await match.datastore.put(key, value, options)\n\n    return key\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async get (key: Key, options: AbortOptions = {}): Promise<Uint8Array> {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw new NotFoundError('No datastore mounted for this key')\n    }\n    return match.datastore.get(key, options)\n  }\n\n  async has (key: Key, options?: AbortOptions): Promise<boolean> {\n    const match = this._lookup(key)\n    if (match == null) {\n      return Promise.resolve(false)\n    }\n    return match.datastore.has(key, options)\n  }\n\n  async delete (key: Key, options?: AbortOptions): Promise<void> {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw new DeleteFailedError('No datastore mounted for this key')\n    }\n\n    await match.datastore.delete(key, options)\n  }\n\n  batch (): Batch {\n    const batchMounts: Record<string, Batch> = {}\n\n    const lookup = (key: Key): { batch: Batch } => {\n      const match = this._lookup(key)\n      if (match == null) {\n        throw new Error('No datastore mounted for this key')\n      }\n\n      const m = match.mountpoint.toString()\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch()\n      }\n\n      return {\n        batch: batchMounts[m]\n      }\n    }\n\n    return {\n      put: (key, value) => {\n        const match = lookup(key)\n        match.batch.put(key, value)\n      },\n      delete: (key) => {\n        const match = lookup(key)\n        match.batch.delete(key)\n      },\n      commit: async (options) => {\n        await Promise.all(Object.keys(batchMounts).map(async p => { await batchMounts[p].commit(options) }))\n      }\n    }\n  }\n\n  query (q: Query, options?: AbortOptions): AsyncIterable<Pair> {\n    const qs = this.mounts.map(m => {\n      return m.datastore.query({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options)\n    })\n\n    let it = merge(...qs)\n    if (q.filters != null) { q.filters.forEach(f => { it = filter(it, f) }) }\n    if (q.orders != null) { q.orders.forEach(o => { it = sort(it, o) }) }\n    if (q.offset != null) {\n      let i = 0\n      const offset = q.offset\n      it = filter(it, () => i++ >= offset)\n    }\n    if (q.limit != null) { it = take(it, q.limit) }\n\n    return it\n  }\n\n  queryKeys (q: KeyQuery, options?: AbortOptions): AsyncIterable<Key> {\n    const qs = this.mounts.map(m => {\n      return m.datastore.queryKeys({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options)\n    })\n\n    /** @type AsyncIterable<Key> */\n    let it = merge(...qs)\n    if (q.filters != null) { q.filters.forEach(f => { it = filter(it, f) }) }\n    if (q.orders != null) { q.orders.forEach(o => { it = sort(it, o) }) }\n    if (q.offset != null) {\n      let i = 0\n      const offset = q.offset\n      it = filter(it, () => i++ >= offset)\n    }\n    if (q.limit != null) { it = take(it, q.limit) }\n\n    return it\n  }\n}\n", "import { logger } from '@libp2p/logger'\nimport { NotFoundError } from 'interface-store'\nimport { BaseDatastore } from './base.js'\nimport type { Batch, Datastore, Key, KeyQuery, Pair, Query } from 'interface-datastore'\nimport type { AbortOptions, AwaitIterable } from 'interface-store'\n\nconst log = logger('datastore:core:tiered')\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\nexport class TieredDatastore extends BaseDatastore {\n  private readonly stores: Datastore[]\n\n  constructor (stores: Datastore[]) {\n    super()\n\n    this.stores = stores.slice()\n  }\n\n  async put (key: Key, value: Uint8Array, options?: AbortOptions): Promise<Key> {\n    await Promise.all(\n      this.stores.map(async store => {\n        await store.put(key, value, options)\n      })\n    )\n\n    return key\n  }\n\n  async get (key: Key, options?: AbortOptions): Promise<Uint8Array> {\n    let error: Error | undefined\n\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options)\n\n        if (res != null) {\n          return res\n        }\n      } catch (err: any) {\n        error = err\n        log.error(err)\n      }\n    }\n\n    throw error ?? new NotFoundError()\n  }\n\n  async has (key: Key, options?: AbortOptions): Promise<boolean> {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  async delete (key: Key, options?: AbortOptions): Promise<void> {\n    await Promise.all(\n      this.stores.map(async store => {\n        await store.delete(key, options)\n      })\n    )\n  }\n\n  async * putMany (source: AwaitIterable<Pair>, options: AbortOptions = {}): AsyncIterable<Key> {\n    for await (const pair of source) {\n      await this.put(pair.key, pair.value, options)\n      yield pair.key\n    }\n  }\n\n  async * deleteMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AsyncIterable<Key> {\n    for await (const key of source) {\n      await this.delete(key, options)\n      yield key\n    }\n  }\n\n  batch (): Batch {\n    const batches = this.stores.map(store => store.batch())\n\n    return {\n      put: (key, value) => {\n        batches.forEach(b => { b.put(key, value) })\n      },\n      delete: (key) => {\n        batches.forEach(b => { b.delete(key) })\n      },\n      commit: async (options) => {\n        for (const batch of batches) {\n          await batch.commit(options)\n        }\n      }\n    }\n  }\n\n  query (q: Query, options?: AbortOptions): AwaitIterable<Pair> {\n    return this.stores[this.stores.length - 1].query(q, options)\n  }\n\n  queryKeys (q: KeyQuery, options?: AbortOptions): AwaitIterable<Key> {\n    return this.stores[this.stores.length - 1].queryKeys(q, options)\n  }\n}\n", "import { Key } from 'interface-datastore'\nimport map from 'it-map'\nimport { KeyTransformDatastore } from './keytransform.js'\nimport type { Datastore, Query, Pair, KeyQuery } from 'interface-datastore'\nimport type { AbortOptions } from 'interface-store'\n\n/**\n * Wraps a given datastore into a keytransform which\n * makes a given prefix transparent.\n *\n * For example, if the prefix is `new Key(/hello)` a call\n * to `store.put(new Key('/world'), mydata)` would store the data under\n * `/hello/world`.\n */\nexport class NamespaceDatastore extends KeyTransformDatastore {\n  private readonly iChild: Datastore\n  private readonly iKey: Key\n\n  constructor (child: Datastore, prefix: Key) {\n    super(child, {\n      convert (key) {\n        return prefix.child(key)\n      },\n      invert (key) {\n        if (prefix.toString() === '/') {\n          return key\n        }\n\n        if (!prefix.isAncestorOf(key)) {\n          throw new Error(`Expected prefix: (${prefix.toString()}) in key: ${key.toString()}`)\n        }\n\n        return new Key(key.toString().slice(prefix.toString().length), false)\n      }\n    })\n\n    this.iChild = child\n    this.iKey = prefix\n  }\n\n  query (q: Query, options?: AbortOptions): AsyncIterable<Pair> {\n    const query: Query = {\n      ...q\n    }\n\n    query.filters = (query.filters ?? []).map(filter => {\n      return ({ key, value }) => filter({ key: this.transform.invert(key), value })\n    })\n\n    const { prefix } = q\n    if (prefix != null && prefix !== '/') {\n      delete query.prefix\n      query.filters.push(({ key }) => {\n        return this.transform.invert(key).toString().startsWith(prefix)\n      })\n    }\n\n    if (query.orders != null) {\n      query.orders = query.orders.map(order => {\n        return (a, b) => order(\n          { key: this.transform.invert(a.key), value: a.value },\n          { key: this.transform.invert(b.key), value: b.value }\n        )\n      })\n    }\n\n    query.filters.unshift(({ key }) => this.iKey.isAncestorOf(key))\n\n    return map(this.iChild.query(query, options), ({ key, value }) => {\n      return {\n        key: this.transform.invert(key),\n        value\n      }\n    })\n  }\n\n  queryKeys (q: KeyQuery, options?: AbortOptions): AsyncIterable<Key> {\n    const query = {\n      ...q\n    }\n\n    query.filters = (query.filters ?? []).map(filter => {\n      return (key) => filter(this.transform.invert(key))\n    })\n\n    const { prefix } = q\n    if (prefix != null && prefix !== '/') {\n      delete query.prefix\n      query.filters.push((key) => {\n        return this.transform.invert(key).toString().startsWith(prefix)\n      })\n    }\n\n    if (query.orders != null) {\n      query.orders = query.orders.map(order => {\n        return (a, b) => order(\n          this.transform.invert(a),\n          this.transform.invert(b)\n        )\n      })\n    }\n\n    query.filters.unshift(key => this.iKey.isAncestorOf(key))\n\n    return map(this.iChild.queryKeys(query, options), key => {\n      return this.transform.invert(key)\n    })\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;ACIA,IAAM,WAAW;AACjB,IAAM,WAAW,IAAI,YAAW,EAAG,OAAO,QAAQ;AAClD,IAAM,UAAU,SAAS,CAAC;AAkBpB,IAAO,MAAP,MAAO,KAAG;EACN;;;;;EAMR,YAAa,GAAwB,OAAe;AAClD,QAAI,OAAO,MAAM,UAAU;AACzB,WAAK,OAAO,WAAqB,CAAC;IACpC,WAAW,aAAa,YAAY;AAClC,WAAK,OAAO;IACd,OAAO;AACL,YAAM,IAAI,MAAM,6CAA6C;IAC/D;AAEA,QAAI,SAAS,MAAM;AACjB,cAAQ;IACV;AAEA,QAAI,OAAO;AACT,WAAK,MAAK;IACZ;AAEA,QAAI,KAAK,KAAK,eAAe,KAAK,KAAK,KAAK,CAAC,MAAM,SAAS;AAC1D,YAAM,IAAI,MAAM,aAAa;IAC/B;EACF;;;;;;;EAQA,SAAU,WAA+B,QAAM;AAC7C,WAAO,SAAmB,KAAK,MAAM,QAAQ;EAC/C;;;;;;EAOA,aAAU;AACR,WAAO,KAAK;EACd;;;;;;EAOA,KAAK,OAAO,WAAW,IAAC;AACtB,WAAO,OAAO,KAAK,SAAQ,CAAE;EAC/B;;;;;;;;;;;;;EAcA,OAAO,eAAgB,MAAc;AACnC,WAAO,IAAI,KAAI,KAAK,KAAK,QAAQ,CAAC;EACpC;;;;;;;;;;;;EAaA,OAAO,SAAM;AACX,WAAO,IAAI,KAAI,KAAK,OAAM,EAAG,SAAQ,EAAG,UAAU,CAAC,CAAC;EACtD;;;;EAKA,OAAO,MAAO,OAAU;AACtB,QAAI,iBAAiB,cAAc,OAAO,UAAU,UAAU;AAE5D,aAAO,IAAI,KAAI,KAAK;IACtB;AAEA,QAAI,OAAO,MAAM,eAAe,YAAY;AAE1C,aAAO,IAAI,KAAI,MAAM,WAAU,CAAE;IACnC;AAEA,WAAO;EACT;;;;;;EAOA,QAAK;AACH,QAAI,KAAK,QAAQ,QAAQ,KAAK,KAAK,eAAe,GAAG;AACnD,WAAK,OAAO;IACd;AAEA,QAAI,KAAK,KAAK,CAAC,MAAM,SAAS;AAC5B,YAAM,QAAQ,IAAI,WAAW,KAAK,KAAK,aAAa,CAAC;AACrD,YAAM,KAAK,SAAS,GAAG,CAAC;AACxB,YAAM,IAAI,KAAK,MAAM,CAAC;AACtB,WAAK,OAAO;IACd;AAGA,WAAO,KAAK,KAAK,aAAa,KAAK,KAAK,KAAK,KAAK,KAAK,aAAa,CAAC,MAAM,SAAS;AAClF,WAAK,OAAO,KAAK,KAAK,SAAS,GAAG,EAAE;IACtC;EACF;;;;;;;EAQA,KAAM,KAAQ;AACZ,UAAM,QAAQ,KAAK,KAAI;AACvB,UAAM,QAAQ,IAAI,KAAI;AAEtB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAI,MAAM,SAAS,IAAI,GAAG;AACxB,eAAO;MACT;AAEA,YAAM,KAAK,MAAM,CAAC;AAClB,YAAM,KAAK,MAAM,CAAC;AAElB,UAAI,KAAK,IAAI;AACX,eAAO;MACT,WAAW,KAAK,IAAI;AAClB,eAAO;MACT;IACF;AAEA,WAAO,MAAM,SAAS,MAAM;EAC9B;;;;;;;;;;;;EAaA,UAAO;AACL,WAAO,KAAI,eAAe,KAAK,KAAI,EAAG,MAAK,EAAG,QAAO,CAAE;EACzD;;;;;;EAOA,aAAU;AACR,WAAO,KAAK,KAAI;EAClB;;;;;;;;;;;;EAaA,gBAAa;AACX,UAAM,KAAK,KAAK,WAAU;AAC1B,WAAO,GAAG,GAAG,SAAS,CAAC;EACzB;;;;;;;;;;;;EAaA,OAAI;AACF,WAAO,KAAK,SAAQ,EAAG,MAAM,QAAQ,EAAE,MAAM,CAAC;EAChD;;;;;;;;;;;;EAaA,OAAI;AACF,WAAO,cAAc,KAAK,cAAa,CAAE;EAC3C;;;;;;;;;;;;EAaA,OAAI;AACF,WAAO,eAAe,KAAK,cAAa,CAAE;EAC5C;;;;;;;;;;;;;EAcA,SAAU,GAAS;AACjB,WAAO,IAAI,KAAI,KAAK,SAAQ,IAAK,MAAM,CAAC;EAC1C;;;;;;;;;;;;EAaA,OAAI;AACF,QAAI,IAAI,KAAK,OAAM,EAAG,SAAQ;AAC9B,QAAI,CAAC,EAAE,SAAS,QAAQ,GAAG;AACzB,WAAK;IACP;AACA,SAAK,KAAK,KAAI;AACd,WAAO,IAAI,KAAI,CAAC;EAClB;;;;;;;;;;;;EAaA,SAAM;AACJ,UAAM,OAAO,KAAK,KAAI;AACtB,QAAI,KAAK,WAAW,GAAG;AACrB,aAAO,IAAI,KAAI,QAAQ;IACzB;AAEA,WAAO,IAAI,KAAI,KAAK,MAAM,GAAG,EAAE,EAAE,KAAK,QAAQ,CAAC;EACjD;;;;;;;;;;;;;EAcA,MAAO,KAAQ;AACb,QAAI,KAAK,SAAQ,MAAO,UAAU;AAChC,aAAO;IACT,WAAW,IAAI,SAAQ,MAAO,UAAU;AACtC,aAAO;IACT;AAEA,WAAO,IAAI,KAAI,KAAK,SAAQ,IAAK,IAAI,SAAQ,GAAI,KAAK;EACxD;;;;;;;;;;;;;EAcA,aAAc,OAAU;AACtB,QAAI,MAAM,SAAQ,MAAO,KAAK,SAAQ,GAAI;AACxC,aAAO;IACT;AAEA,WAAO,MAAM,SAAQ,EAAG,WAAW,KAAK,SAAQ,CAAE;EACpD;;;;;;;;;;;;;EAcA,cAAe,OAAU;AACvB,QAAI,MAAM,SAAQ,MAAO,KAAK,SAAQ,GAAI;AACxC,aAAO;IACT;AAEA,WAAO,KAAK,SAAQ,EAAG,WAAW,MAAM,SAAQ,CAAE;EACpD;;;;;;EAOA,aAAU;AACR,WAAO,KAAK,KAAI,EAAG,WAAW;EAChC;;;;;;;EAQA,UAAW,MAAW;AACpB,WAAO,KAAI,eAAe,CAAC,GAAG,KAAK,WAAU,GAAI,GAAG,QAAQ,KAAK,IAAI,SAAO,IAAI,WAAU,CAAE,CAAC,CAAC,CAAC;EACjG;;AASF,SAAS,cAAe,IAAU;AAChC,QAAM,QAAQ,GAAG,MAAM,GAAG;AAC1B,MAAI,MAAM,SAAS,GAAG;AACpB,WAAO;EACT;AACA,SAAO,MAAM,MAAM,GAAG,EAAE,EAAE,KAAK,GAAG;AACpC;AAQA,SAAS,eAAgB,IAAU;AACjC,QAAM,QAAQ,GAAG,MAAM,GAAG;AAC1B,SAAO,MAAM,MAAM,SAAS,CAAC;AAC/B;AASA,SAAS,QAAS,KAAU;AAC1B,SAAQ,CAAA,EAAI,OAAO,GAAG,GAAG;AAC3B;;;ADjbO,IAAM,SAAS;AACf,IAAM,cAAc;AAErB,IAAO,YAAP,MAAgB;EACb;EACA;EACA;EAEP,YAAa,OAAa;AACxB,SAAK,QAAQ;AACb,SAAK,OAAO;AACZ,SAAK,WAAW;EAClB;EAEA,IAAK,GAAS;AACZ,WAAO;EACT;EAEA,WAAQ;AACN,WAAO,GAAG,MAAM,MAAM,KAAK,IAAI,IAAI,KAAK,KAAK;EAC/C;;AAGI,IAAO,SAAP,cAAsB,UAAS;EACnC,YAAa,WAAiB;AAC5B,UAAM,SAAS;AACf,SAAK,WAAW,GAAG,SAAS,WAAW,GAAG;AAC1C,SAAK,OAAO;EACd;EAEA,IAAK,SAAe;AAClB,YAAQ,UAAU,KAAK,UAAU,MAAM,GAAG,KAAK,KAAK;EACtD;;AAGI,IAAO,SAAP,cAAsB,UAAS;EACnC,YAAa,WAAiB;AAC5B,UAAM,SAAS;AAEf,SAAK,WAAW,GAAG,SAAS,WAAW,GAAG;AAC1C,SAAK,OAAO;EACd;EAEA,IAAK,SAAe;AAClB,UAAM,IAAI,KAAK,WAAW;AAC1B,WAAO,EAAE,MAAM,EAAE,SAAS,KAAK,KAAK;EACtC;;AAGI,IAAO,aAAP,cAA0B,UAAS;EACvC,YAAa,WAAiB;AAC5B,UAAM,SAAS;AACf,SAAK,WAAW,GAAG,SAAS,YAAY,GAAG,GAAG;AAC9C,SAAK,OAAO;EACd;EAEA,IAAK,SAAe;AAClB,UAAM,IAAI,KAAK,WAAW;AAC1B,UAAM,SAAS,EAAE,SAAS,KAAK,QAAQ;AACvC,WAAO,EAAE,MAAM,QAAQ,SAAS,KAAK,KAAK;EAC5C;;AAMI,SAAU,cAAe,KAAW;AACxC,QAAM,IAAI,KAAI;AAEd,MAAI,IAAI,WAAW,GAAG;AACpB,UAAM,IAAI,MAAM,oBAAoB;EACtC;AAEA,MAAI,CAAC,IAAI,WAAW,MAAM,GAAG;AAC3B,UAAM,IAAI,MAAM,8BAA8B,GAAG,EAAE;EACrD;AAEA,QAAM,QAAQ,IAAI,MAAM,OAAO,MAAM,EAAE,MAAM,GAAG;AAChD,QAAM,UAAU,MAAM,CAAC;AAEvB,MAAI,YAAY,MAAM;AACpB,UAAM,IAAI,MAAM,6BAA6B,OAAO,GAAG;EACzD;AAEA,QAAM,OAAO,MAAM,CAAC;AAEpB,MAAI,MAAM,CAAC,KAAK,QAAQ,MAAM,CAAC,MAAM,IAAI;AACvC,UAAM,IAAI,MAAM,eAAe;EACjC;AAEA,QAAM,QAAQ,SAAS,MAAM,CAAC,GAAG,EAAE;AAEnC,UAAQ,MAAM;IACZ,KAAK;AACH,aAAO,IAAI,OAAO,KAAK;IACzB,KAAK;AACH,aAAO,IAAI,OAAO,KAAK;IACzB,KAAK;AACH,aAAO,IAAI,WAAW,KAAK;IAC7B;AACE,YAAM,IAAI,MAAM,6BAA6B,IAAI,EAAE;EACvD;AACF;AAEO,IAAM,eAAe,OAAO,MAA2B,UAAoC;AAChG,QAAM,MAAM,IAAI,IAAI,IAAI,EAAE,MAAM,IAAI,IAAI,WAAW,CAAC;AAEpD,QAAM,MAAM,OAAO,MAAM,WAAW,aAAa,MAAM,OAAO,KAAK,KAAK,IAAI,MAAM,IAAI,KAAK,KAAK;AAChG,QAAM,MAAM,MAAM,IAAI,GAAG;AACzB,SAAO,cAAc,IAAI,YAAW,EAAG,OAAO,OAAO,EAAE,EAAE,KAAI,CAAE;AACjE;;;AErFA,SAAS,gBAAqB,OAAU;AACtC,SAAO,MAAM,OAAO,aAAa,KAAK;AACxC;AAQA,SAAS,MAAO,QAAkD;AAChE,MAAI,gBAAgB,MAAM,GAAG;AAC3B,YAAQ,YAAW;AACjB,uBAAiB,KAAK,QAAQ;MAAE;IAClC,GAAE;EACJ,OAAO;AACL,eAAW,KAAK,QAAQ;IAAE;EAC5B;AACF;AAEA,IAAAA,eAAe;;;ACJf,SAASC,iBAAqB,OAAU;AACtC,SAAO,MAAM,OAAO,aAAa,KAAK;AACxC;AAYA,SAAS,KAAU,QAAwC,QAA0B;AACnF,MAAIA,iBAAgB,MAAM,GAAG;AAC3B,WAAQ,mBAAgB;AACtB,YAAM,MAAM,MAAMC,aAAI,MAAM;AAE5B,aAAQ,IAAI,KAAK,MAAM;IACzB,EAAE;EACJ;AAEA,SAAQ,aAAU;AAChB,UAAM,MAAMA,aAAI,MAAM;AAEtB,WAAQ,IAAI,KAAK,MAAM;EACzB,EAAE;AACJ;AAEA,IAAAA,eAAe;;;ACxCf,SAASC,iBAAqB,OAAU;AACtC,SAAO,MAAM,OAAO,aAAa,KAAK;AACxC;AAOA,SAAS,KAAU,QAAwC,OAAa;AACtE,MAAIA,iBAAgB,MAAM,GAAG;AAC3B,WAAQ,mBAAgB;AACtB,UAAI,QAAQ;AAEZ,UAAI,QAAQ,GAAG;AACb;MACF;AAEA,uBAAiB,SAAS,QAAQ;AAChC,cAAM;AAEN;AAEA,YAAI,UAAU,OAAO;AACnB;QACF;MACF;IACF,EAAE;EACJ;AAEA,SAAQ,aAAU;AAChB,QAAI,QAAQ;AAEZ,QAAI,QAAQ,GAAG;AACb;IACF;AAEA,eAAW,SAAS,QAAQ;AAC1B,YAAM;AAEN;AAEA,UAAI,UAAU,OAAO;AACnB;MACF;IACF;EACF,EAAE;AACJ;AAEA,IAAAC,eAAe;;;AC7ET,IAAO,gBAAP,MAAoB;EACxB,IAAK,KAAU,KAAiB,SAAsB;AACpD,WAAO,QAAQ,OAAO,IAAI,MAAM,yBAAyB,CAAC;EAC5D;EAEA,IAAK,KAAU,SAAsB;AACnC,WAAO,QAAQ,OAAO,IAAI,MAAM,yBAAyB,CAAC;EAC5D;EAEA,IAAK,KAAU,SAAsB;AACnC,WAAO,QAAQ,OAAO,IAAI,MAAM,yBAAyB,CAAC;EAC5D;EAEA,OAAQ,KAAU,SAAsB;AACtC,WAAO,QAAQ,OAAO,IAAI,MAAM,4BAA4B,CAAC;EAC/D;EAEA,OAAQ,QAAS,QAA6B,UAAwB,CAAA,GAAE;AACtE,qBAAiB,EAAE,KAAK,MAAK,KAAM,QAAQ;AACzC,YAAM,KAAK,IAAI,KAAK,OAAO,OAAO;AAClC,YAAM;IACR;EACF;EAEA,OAAQ,QAAS,QAA4B,UAAwB,CAAA,GAAE;AACrE,qBAAiB,OAAO,QAAQ;AAC9B,YAAM;QACJ;QACA,OAAO,MAAM,KAAK,IAAI,KAAK,OAAO;;IAEtC;EACF;EAEA,OAAQ,WAAY,QAA4B,UAAwB,CAAA,GAAE;AACxE,qBAAiB,OAAO,QAAQ;AAC9B,YAAM,KAAK,OAAO,KAAK,OAAO;AAC9B,YAAM;IACR;EACF;EAEA,QAAK;AACH,QAAI,OAAe,CAAA;AACnB,QAAI,OAAc,CAAA;AAElB,WAAO;MACL,IAAK,KAAK,OAAK;AACb,aAAK,KAAK,EAAE,KAAK,MAAK,CAAE;MAC1B;MAEA,OAAQ,KAAG;AACT,aAAK,KAAK,GAAG;MACf;MACA,QAAQ,OAAO,YAAW;AACxB,cAAMC,aAAM,KAAK,QAAQ,MAAM,OAAO,CAAC;AACvC,eAAO,CAAA;AACP,cAAMA,aAAM,KAAK,WAAW,MAAM,OAAO,CAAC;AAC1C,eAAO,CAAA;MACT;;EAEJ;;;;;EAMA,OAAQ,KAAM,GAAU,SAAsB;AAC5C,UAAM,IAAI,MAAM,0BAA0B;EAC5C;;;;;EAMA,OAAQ,SAAU,GAAa,SAAsB;AACnD,UAAM,IAAI,MAAM,8BAA8B;EAChD;EAEA,MAAO,GAAU,SAAsB;AACrC,QAAI,KAAK,KAAK,KAAK,GAAG,OAAO;AAE7B,QAAI,EAAE,UAAU,MAAM;AACpB,YAAM,SAAS,EAAE;AACjB,WAAKA,aAAO,IAAI,CAAC,MAAM,EAAE,IAAI,SAAQ,EAAG,WAAW,MAAM,CAAC;IAC5D;AAEA,QAAI,MAAM,QAAQ,EAAE,OAAO,GAAG;AAC5B,WAAK,EAAE,QAAQ,OAAO,CAACC,KAAI,MAAMD,aAAOC,KAAI,CAAC,GAAG,EAAE;IACpD;AAEA,QAAI,MAAM,QAAQ,EAAE,MAAM,GAAG;AAC3B,WAAK,EAAE,OAAO,OAAO,CAACA,KAAI,MAAMD,aAAKC,KAAI,CAAC,GAAG,EAAE;IACjD;AAEA,QAAI,EAAE,UAAU,MAAM;AACpB,UAAI,IAAI;AACR,YAAM,SAAS,EAAE;AACjB,WAAKD,aAAO,IAAI,MAAM,OAAO,MAAM;IACrC;AAEA,QAAI,EAAE,SAAS,MAAM;AACnB,WAAKA,aAAK,IAAI,EAAE,KAAK;IACvB;AAEA,WAAO;EACT;EAEA,UAAW,GAAa,SAAsB;AAC5C,QAAI,KAAK,KAAK,SAAS,GAAG,OAAO;AAEjC,QAAI,EAAE,UAAU,MAAM;AACpB,YAAM,SAAS,EAAE;AACjB,WAAKA,aAAO,IAAI,CAAC,QACf,IAAI,SAAQ,EAAG,WAAW,MAAM,CAAC;IAErC;AAEA,QAAI,MAAM,QAAQ,EAAE,OAAO,GAAG;AAC5B,WAAK,EAAE,QAAQ,OAAO,CAACC,KAAI,MAAMD,aAAOC,KAAI,CAAC,GAAG,EAAE;IACpD;AAEA,QAAI,MAAM,QAAQ,EAAE,MAAM,GAAG;AAC3B,WAAK,EAAE,OAAO,OAAO,CAACA,KAAI,MAAMD,aAAKC,KAAI,CAAC,GAAG,EAAE;IACjD;AAEA,QAAI,EAAE,UAAU,MAAM;AACpB,YAAM,SAAS,EAAE;AACjB,UAAI,IAAI;AACR,WAAKD,aAAO,IAAI,MAAM,OAAO,MAAM;IACrC;AAEA,QAAI,EAAE,SAAS,MAAM;AACnB,WAAKA,aAAK,IAAI,EAAE,KAAK;IACvB;AAEA,WAAO;EACT;;;;ACxII,IAAO,kBAAP,cAA+B,cAAa;EAC/B;EAEjB,cAAA;AACE,UAAK;AAEL,SAAK,OAAO,oBAAI,IAAG;EACrB;EAEA,IAAK,KAAU,KAAiB,SAAsB;AACpD,aAAS,QAAQ,eAAc;AAE/B,SAAK,KAAK,IAAI,IAAI,SAAQ,GAAI,GAAG;AAEjC,WAAO;EACT;EAEA,IAAK,KAAU,SAAsB;AACnC,aAAS,QAAQ,eAAc;AAE/B,UAAM,SAAS,KAAK,KAAK,IAAI,IAAI,SAAQ,CAAE;AAE3C,QAAI,UAAU,MAAM;AAClB,YAAM,IAAI,cAAa;IACzB;AAEA,WAAO;EACT;EAEA,IAAK,KAAU,SAAsB;AACnC,aAAS,QAAQ,eAAc;AAC/B,WAAO,KAAK,KAAK,IAAI,IAAI,SAAQ,CAAE;EACrC;EAEA,OAAQ,KAAU,SAAsB;AACtC,aAAS,QAAQ,eAAc;AAC/B,SAAK,KAAK,OAAO,IAAI,SAAQ,CAAE;EACjC;EAEA,CAAE,KAAM,GAAU,SAAsB;AACtC,aAAS,QAAQ,eAAc;AAC/B,eAAW,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,QAAO,GAAI;AAC9C,YAAM,EAAE,KAAK,IAAI,IAAI,GAAG,GAAG,MAAK;AAChC,eAAS,QAAQ,eAAc;IACjC;EACF;EAEA,CAAE,SAAU,GAAa,SAAsB;AAC7C,aAAS,QAAQ,eAAc;AAC/B,eAAW,OAAO,KAAK,KAAK,KAAI,GAAI;AAClC,YAAM,IAAI,IAAI,GAAG;AACjB,eAAS,QAAQ,eAAc;IACjC;EACF;;;;AC/CI,IAAO,wBAAP,cAAqC,cAAa;EACrC;EACV;EAEP,YAAa,OAAkB,WAAuB;AACpD,UAAK;AAEL,SAAK,QAAQ;AACb,SAAK,YAAY;EACnB;EAEA,MAAM,IAAK,KAAU,KAAiB,SAAsB;AAC1D,UAAM,KAAK,MAAM,IAAI,KAAK,UAAU,QAAQ,GAAG,GAAG,KAAK,OAAO;AAE9D,WAAO;EACT;EAEA,MAAM,IAAK,KAAU,SAAsB;AACzC,WAAO,KAAK,MAAM,IAAI,KAAK,UAAU,QAAQ,GAAG,GAAG,OAAO;EAC5D;EAEA,MAAM,IAAK,KAAU,SAAsB;AACzC,WAAO,KAAK,MAAM,IAAI,KAAK,UAAU,QAAQ,GAAG,GAAG,OAAO;EAC5D;EAEA,MAAM,OAAQ,KAAU,SAAsB;AAC5C,UAAM,KAAK,MAAM,OAAO,KAAK,UAAU,QAAQ,GAAG,GAAG,OAAO;EAC9D;EAEA,OAAQ,QAAS,QAA6B,UAAwB,CAAA,GAAE;AACtE,UAAM,YAAY,KAAK;AACvB,UAAM,QAAQ,KAAK;AAEnB,WAAQ,KACN,QACA,iBAAkBE,SAAM;AACtB,aAAQC,aAAID,SAAQ,CAAC,EAAE,KAAK,MAAK,OAAQ;QACvC,KAAK,UAAU,QAAQ,GAAG;QAC1B;QACA;IACJ,GACA,iBAAkBA,SAAM;AACtB,aAAQ,MAAM,QAAQA,SAAQ,OAAO;IACvC,GACA,iBAAkBA,SAAM;AACtB,aAAQC,aAAID,SAAQ,SAAO,UAAU,OAAO,GAAG,CAAC;IAClD,CAAC;EAEL;EAEA,OAAQ,QAAS,QAA4B,UAAwB,CAAA,GAAE;AACrE,UAAM,YAAY,KAAK;AACvB,UAAM,QAAQ,KAAK;AAEnB,WAAQ,KACN,QACA,iBAAkBA,SAAM;AACtB,aAAQC,aAAID,SAAQ,SAAO,UAAU,QAAQ,GAAG,CAAC;IACnD,GACA,iBAAkBA,SAAM;AACtB,aAAQ,MAAM,QAAQA,SAAQ,OAAO;IACvC,GACA,iBAAkBA,SAAM;AACtB,aAAQC,aAAID,SAAQ,CAAC,EAAE,KAAK,MAAK,OAAQ;QACvC,KAAK,UAAU,OAAO,GAAG;QACzB;QACA;IACJ,CAAC;EAEL;EAEA,OAAQ,WAAY,QAA4B,UAAwB,CAAA,GAAE;AACxE,UAAM,YAAY,KAAK;AACvB,UAAM,QAAQ,KAAK;AAEnB,WAAQ,KACN,QACA,iBAAkBA,SAAM;AACtB,aAAQC,aAAID,SAAQ,SAAO,UAAU,QAAQ,GAAG,CAAC;IACnD,GACA,iBAAkBA,SAAM;AACtB,aAAQ,MAAM,WAAWA,SAAQ,OAAO;IAC1C,GACA,iBAAkBA,SAAM;AACtB,aAAQC,aAAID,SAAQ,SAAO,UAAU,OAAO,GAAG,CAAC;IAClD,CAAC;EAEL;EAEA,QAAK;AACH,UAAM,IAAI,KAAK,MAAM,MAAK;AAC1B,WAAO;MACL,KAAK,CAAC,KAAK,UAAS;AAClB,UAAE,IAAI,KAAK,UAAU,QAAQ,GAAG,GAAG,KAAK;MAC1C;MACA,QAAQ,CAAC,QAAO;AACd,UAAE,OAAO,KAAK,UAAU,QAAQ,GAAG,CAAC;MACtC;MACA,QAAQ,OAAO,YAAW;AACxB,cAAM,EAAE,OAAO,OAAO;MACxB;;EAEJ;EAEA,MAAO,GAAU,SAAsB;AACrC,UAAM,QAAe;MACnB,GAAG;;AAGL,UAAM,WAAW,MAAM,WAAW,CAAA,GAAI,IAAI,YAAS;AACjD,aAAO,CAAC,EAAE,KAAK,MAAK,MAAO,OAAO,EAAE,KAAK,KAAK,UAAU,QAAQ,GAAG,GAAG,MAAK,CAAE;IAC/E,CAAC;AAED,UAAM,EAAE,OAAM,IAAK;AACnB,QAAI,UAAU,QAAQ,WAAW,KAAK;AACpC,aAAO,MAAM;AACb,YAAM,QAAQ,KAAK,CAAC,EAAE,IAAG,MAAM;AAC7B,eAAO,KAAK,UAAU,OAAO,GAAG,EAAE,SAAQ,EAAG,WAAW,MAAM;MAChE,CAAC;IACH;AAEA,QAAI,MAAM,UAAU,MAAM;AACxB,YAAM,SAAS,MAAM,OAAO,IAAI,WAAQ;AACtC,eAAO,CAAC,GAAG,MAAM,MACf,EAAE,KAAK,KAAK,UAAU,OAAO,EAAE,GAAG,GAAG,OAAO,EAAE,MAAK,GACnD,EAAE,KAAK,KAAK,UAAU,OAAO,EAAE,GAAG,GAAG,OAAO,EAAE,MAAK,CAAE;MAEzD,CAAC;IACH;AAEA,WAAOC,aAAI,KAAK,MAAM,MAAM,OAAO,OAAO,GAAG,CAAC,EAAE,KAAK,MAAK,MAAM;AAC9D,aAAO;QACL,KAAK,KAAK,UAAU,OAAO,GAAG;QAC9B;;IAEJ,CAAC;EACH;EAEA,UAAW,GAAa,SAAsB;AAC5C,UAAM,QAAQ;MACZ,GAAG;;AAGL,UAAM,WAAW,MAAM,WAAW,CAAA,GAAI,IAAI,YAAS;AACjD,aAAO,CAAC,QAAQ,OAAO,KAAK,UAAU,QAAQ,GAAG,CAAC;IACpD,CAAC;AAED,UAAM,EAAE,OAAM,IAAK;AACnB,QAAI,UAAU,QAAQ,WAAW,KAAK;AACpC,aAAO,MAAM;AACb,YAAM,QAAQ,KAAK,CAAC,QAAO;AACzB,eAAO,KAAK,UAAU,OAAO,GAAG,EAAE,SAAQ,EAAG,WAAW,MAAM;MAChE,CAAC;IACH;AAEA,QAAI,MAAM,UAAU,MAAM;AACxB,YAAM,SAAS,MAAM,OAAO,IAAI,WAAQ;AACtC,eAAO,CAAC,GAAG,MAAM,MACf,KAAK,UAAU,OAAO,CAAC,GACvB,KAAK,UAAU,OAAO,CAAC,CAAC;MAE5B,CAAC;IACH;AAEA,WAAOA,aAAI,KAAK,MAAM,UAAU,OAAO,OAAO,GAAG,SAAM;AACrD,aAAO,KAAK,UAAU,OAAO,GAAG;IAClC,CAAC;EACH;;;;ACvKF,IAAM,WAAW,IAAI,IAAI,WAAW;AAQ9B,IAAO,oBAAP,MAAO,2BAA0B,cAAa;EACjC;EACT;EAER,YAAa,OAAkB,OAAY;AACzC,UAAK;AAEL,SAAK,QAAQ,IAAI,sBAAsB,OAAO;MAC5C,SAAS,KAAK,YAAY,KAAK,IAAI;MACnC,QAAQ,KAAK,WAAW,KAAK,IAAI;KAClC;AACD,SAAK,QAAQ;EACf;EAEA,MAAM,OAAI;AACR,SAAK,QAAQ,MAAM,mBAAkB,OAAO,KAAK,OAAO,KAAK,KAAK;EACpE;EAEA,YAAa,KAAQ;AACnB,UAAM,IAAI,IAAI,SAAQ;AACtB,QAAI,MAAM,SAAS,SAAQ,GAAI;AAC7B,aAAO;IACT;AAEA,UAAM,SAAS,IAAI,IAAI,KAAK,MAAM,IAAI,CAAC,CAAC;AACxC,WAAO,OAAO,MAAM,GAAG;EACzB;EAEA,WAAY,KAAQ;AAClB,UAAM,IAAI,IAAI,SAAQ;AACtB,QAAI,MAAM,SAAS,SAAQ,GAAI;AAC7B,aAAO;IACT;AACA,WAAO,IAAI,eAAe,IAAI,KAAI,EAAG,MAAM,CAAC,CAAC;EAC/C;EAEA,aAAa,OAAQ,OAAkB,OAAa;AAClD,UAAM,WAAW,MAAM,MAAM,IAAI,QAAQ;AAEzC,QAAI,CAAC,UAAU;AACb,UAAI,SAAS,MAAM;AACjB,cAAM,IAAI,gBAAgB,mEAAoE;MAChG;AAEA,YAAM,MAAM,IAAI,UAAU,IAAI,YAAW,EAAG,OAAO,MAAM,SAAQ,IAAK,IAAI,CAAC;IAC7E;AAEA,QAAI,SAAS,MAAM;AACjB,cAAQ,MAAM,aAAa,KAAK,KAAK;IACvC;AAGA,UAAM,YAAY,MAAM,aAAa,KAAK,KAAK;AAC/C,UAAM,IAAI,UAAU,SAAQ;AAC5B,UAAM,IAAI,MAAM,SAAQ;AAExB,QAAI,MAAM,GAAG;AACX,YAAM,IAAI,MAAM,iBAAiB,CAAC,kCAAkC,CAAC,EAAE;IACzE;AAEA,WAAO;EACT;EAEA,MAAM,IAAK,KAAU,KAAiB,SAAsB;AAC1D,UAAM,KAAK,MAAM,IAAI,KAAK,KAAK,OAAO;AAEtC,WAAO;EACT;EAEA,MAAM,IAAK,KAAU,SAAsB;AACzC,WAAO,KAAK,MAAM,IAAI,KAAK,OAAO;EACpC;EAEA,MAAM,IAAK,KAAU,SAAsB;AACzC,WAAO,KAAK,MAAM,IAAI,KAAK,OAAO;EACpC;EAEA,MAAM,OAAQ,KAAU,SAAsB;AAC5C,UAAM,KAAK,MAAM,OAAO,KAAK,OAAO;EACtC;EAEA,OAAQ,QAAS,QAA6B,UAAwB,CAAA,GAAE;AACtE,WAAQ,KAAK,MAAM,QAAQ,QAAQ,OAAO;EAC5C;EAEA,OAAQ,QAAS,QAA4B,UAAwB,CAAA,GAAE;AACrE,WAAQ,KAAK,MAAM,QAAQ,QAAQ,OAAO;EAC5C;EAEA,OAAQ,WAAY,QAA4B,UAAwB,CAAA,GAAE;AACxE,WAAQ,KAAK,MAAM,WAAW,QAAQ,OAAO;EAC/C;EAEA,QAAK;AACH,WAAO,KAAK,MAAM,MAAK;EACzB;EAEA,MAAO,GAAU,SAAsB;AACrC,UAAM,YAAyB,CAAC,EAAE,IAAG,MAAO,IAAI,SAAQ,MAAO,SAAS,SAAQ;AAEhF,UAAM,KAAY;MAChB,GAAG;MACH,SAAS;QACP;QACA,OAAO,EAAE,WAAW,CAAA,CAAE;;AAG1B,WAAO,KAAK,MAAM,MAAM,IAAI,OAAO;EACrC;EAEA,UAAW,GAAa,SAAsB;AAC5C,UAAM,YAA4B,CAAC,QAAQ,IAAI,SAAQ,MAAO,SAAS,SAAQ;AAE/E,UAAM,KAAe;MACnB,GAAG;MACH,SAAS;QACP;QACA,OAAO,EAAE,WAAW,CAAA,CAAE;;AAG1B,WAAO,KAAK,MAAM,UAAU,IAAI,OAAO;EACzC;;;;AChII,IAAO,iBAAP,cAA8B,cAAa;EAC9B;EAEjB,YAAa,QAAoD;AAC/D,UAAK;AAEL,SAAK,SAAS,OAAO,MAAK;EAC5B;;;;EAKQ,QAAS,KAAQ;AACvB,eAAW,SAAS,KAAK,QAAQ;AAC/B,UAAI,MAAM,OAAO,SAAQ,MAAO,IAAI,SAAQ,KAAM,MAAM,OAAO,aAAa,GAAG,GAAG;AAChF,eAAO;UACL,WAAW,MAAM;UACjB,YAAY,MAAM;;MAEtB;IACF;EACF;EAEA,MAAM,IAAK,KAAU,OAAmB,SAAsB;AAC5D,UAAM,QAAQ,KAAK,QAAQ,GAAG;AAC9B,QAAI,SAAS,MAAM;AACjB,YAAM,IAAI,eAAe,mCAAmC;IAC9D;AAEA,UAAM,MAAM,UAAU,IAAI,KAAK,OAAO,OAAO;AAE7C,WAAO;EACT;;;;;EAMA,MAAM,IAAK,KAAU,UAAwB,CAAA,GAAE;AAC7C,UAAM,QAAQ,KAAK,QAAQ,GAAG;AAC9B,QAAI,SAAS,MAAM;AACjB,YAAM,IAAI,cAAc,mCAAmC;IAC7D;AACA,WAAO,MAAM,UAAU,IAAI,KAAK,OAAO;EACzC;EAEA,MAAM,IAAK,KAAU,SAAsB;AACzC,UAAM,QAAQ,KAAK,QAAQ,GAAG;AAC9B,QAAI,SAAS,MAAM;AACjB,aAAO,QAAQ,QAAQ,KAAK;IAC9B;AACA,WAAO,MAAM,UAAU,IAAI,KAAK,OAAO;EACzC;EAEA,MAAM,OAAQ,KAAU,SAAsB;AAC5C,UAAM,QAAQ,KAAK,QAAQ,GAAG;AAC9B,QAAI,SAAS,MAAM;AACjB,YAAM,IAAI,kBAAkB,mCAAmC;IACjE;AAEA,UAAM,MAAM,UAAU,OAAO,KAAK,OAAO;EAC3C;EAEA,QAAK;AACH,UAAM,cAAqC,CAAA;AAE3C,UAAM,SAAS,CAAC,QAA8B;AAC5C,YAAM,QAAQ,KAAK,QAAQ,GAAG;AAC9B,UAAI,SAAS,MAAM;AACjB,cAAM,IAAI,MAAM,mCAAmC;MACrD;AAEA,YAAM,IAAI,MAAM,WAAW,SAAQ;AACnC,UAAI,YAAY,CAAC,KAAK,MAAM;AAC1B,oBAAY,CAAC,IAAI,MAAM,UAAU,MAAK;MACxC;AAEA,aAAO;QACL,OAAO,YAAY,CAAC;;IAExB;AAEA,WAAO;MACL,KAAK,CAAC,KAAK,UAAS;AAClB,cAAM,QAAQ,OAAO,GAAG;AACxB,cAAM,MAAM,IAAI,KAAK,KAAK;MAC5B;MACA,QAAQ,CAAC,QAAO;AACd,cAAM,QAAQ,OAAO,GAAG;AACxB,cAAM,MAAM,OAAO,GAAG;MACxB;MACA,QAAQ,OAAO,YAAW;AACxB,cAAM,QAAQ,IAAI,OAAO,KAAK,WAAW,EAAE,IAAI,OAAM,MAAI;AAAG,gBAAM,YAAY,CAAC,EAAE,OAAO,OAAO;QAAE,CAAC,CAAC;MACrG;;EAEJ;EAEA,MAAO,GAAU,SAAsB;AACrC,UAAM,KAAK,KAAK,OAAO,IAAI,OAAI;AAC7B,aAAO,EAAE,UAAU,MAAM;QACvB,QAAQ,EAAE;QACV,SAAS,EAAE;SACV,OAAO;IACZ,CAAC;AAED,QAAI,KAAK,YAAM,GAAG,EAAE;AACpB,QAAI,EAAE,WAAW,MAAM;AAAE,QAAE,QAAQ,QAAQ,OAAI;AAAG,aAAKC,aAAO,IAAI,CAAC;MAAE,CAAC;IAAE;AACxE,QAAI,EAAE,UAAU,MAAM;AAAE,QAAE,OAAO,QAAQ,OAAI;AAAG,aAAKA,aAAK,IAAI,CAAC;MAAE,CAAC;IAAE;AACpE,QAAI,EAAE,UAAU,MAAM;AACpB,UAAI,IAAI;AACR,YAAM,SAAS,EAAE;AACjB,WAAKA,aAAO,IAAI,MAAM,OAAO,MAAM;IACrC;AACA,QAAI,EAAE,SAAS,MAAM;AAAE,WAAKA,aAAK,IAAI,EAAE,KAAK;IAAE;AAE9C,WAAO;EACT;EAEA,UAAW,GAAa,SAAsB;AAC5C,UAAM,KAAK,KAAK,OAAO,IAAI,OAAI;AAC7B,aAAO,EAAE,UAAU,UAAU;QAC3B,QAAQ,EAAE;QACV,SAAS,EAAE;SACV,OAAO;IACZ,CAAC;AAGD,QAAI,KAAK,YAAM,GAAG,EAAE;AACpB,QAAI,EAAE,WAAW,MAAM;AAAE,QAAE,QAAQ,QAAQ,OAAI;AAAG,aAAKA,aAAO,IAAI,CAAC;MAAE,CAAC;IAAE;AACxE,QAAI,EAAE,UAAU,MAAM;AAAE,QAAE,OAAO,QAAQ,OAAI;AAAG,aAAKA,aAAK,IAAI,CAAC;MAAE,CAAC;IAAE;AACpE,QAAI,EAAE,UAAU,MAAM;AACpB,UAAI,IAAI;AACR,YAAM,SAAS,EAAE;AACjB,WAAKA,aAAO,IAAI,MAAM,OAAO,MAAM;IACrC;AACA,QAAI,EAAE,SAAS,MAAM;AAAE,WAAKA,aAAK,IAAI,EAAE,KAAK;IAAE;AAE9C,WAAO;EACT;;;;ACjJF,IAAM,MAAM,OAAO,uBAAuB;AASpC,IAAO,kBAAP,cAA+B,cAAa;EAC/B;EAEjB,YAAa,QAAmB;AAC9B,UAAK;AAEL,SAAK,SAAS,OAAO,MAAK;EAC5B;EAEA,MAAM,IAAK,KAAU,OAAmB,SAAsB;AAC5D,UAAM,QAAQ,IACZ,KAAK,OAAO,IAAI,OAAM,UAAQ;AAC5B,YAAM,MAAM,IAAI,KAAK,OAAO,OAAO;IACrC,CAAC,CAAC;AAGJ,WAAO;EACT;EAEA,MAAM,IAAK,KAAU,SAAsB;AACzC,QAAI;AAEJ,eAAW,SAAS,KAAK,QAAQ;AAC/B,UAAI;AACF,cAAM,MAAM,MAAM,MAAM,IAAI,KAAK,OAAO;AAExC,YAAI,OAAO,MAAM;AACf,iBAAO;QACT;MACF,SAAS,KAAU;AACjB,gBAAQ;AACR,YAAI,MAAM,GAAG;MACf;IACF;AAEA,UAAM,SAAS,IAAI,cAAa;EAClC;EAEA,MAAM,IAAK,KAAU,SAAsB;AACzC,eAAW,KAAK,KAAK,QAAQ;AAC3B,UAAI,MAAM,EAAE,IAAI,KAAK,OAAO,GAAG;AAC7B,eAAO;MACT;IACF;AAEA,WAAO;EACT;EAEA,MAAM,OAAQ,KAAU,SAAsB;AAC5C,UAAM,QAAQ,IACZ,KAAK,OAAO,IAAI,OAAM,UAAQ;AAC5B,YAAM,MAAM,OAAO,KAAK,OAAO;IACjC,CAAC,CAAC;EAEN;EAEA,OAAQ,QAAS,QAA6B,UAAwB,CAAA,GAAE;AACtE,qBAAiB,QAAQ,QAAQ;AAC/B,YAAM,KAAK,IAAI,KAAK,KAAK,KAAK,OAAO,OAAO;AAC5C,YAAM,KAAK;IACb;EACF;EAEA,OAAQ,WAAY,QAA4B,UAAwB,CAAA,GAAE;AACxE,qBAAiB,OAAO,QAAQ;AAC9B,YAAM,KAAK,OAAO,KAAK,OAAO;AAC9B,YAAM;IACR;EACF;EAEA,QAAK;AACH,UAAM,UAAU,KAAK,OAAO,IAAI,WAAS,MAAM,MAAK,CAAE;AAEtD,WAAO;MACL,KAAK,CAAC,KAAK,UAAS;AAClB,gBAAQ,QAAQ,OAAI;AAAG,YAAE,IAAI,KAAK,KAAK;QAAE,CAAC;MAC5C;MACA,QAAQ,CAAC,QAAO;AACd,gBAAQ,QAAQ,OAAI;AAAG,YAAE,OAAO,GAAG;QAAE,CAAC;MACxC;MACA,QAAQ,OAAO,YAAW;AACxB,mBAAW,SAAS,SAAS;AAC3B,gBAAM,MAAM,OAAO,OAAO;QAC5B;MACF;;EAEJ;EAEA,MAAO,GAAU,SAAsB;AACrC,WAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC,EAAE,MAAM,GAAG,OAAO;EAC7D;EAEA,UAAW,GAAa,SAAsB;AAC5C,WAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC,EAAE,UAAU,GAAG,OAAO;EACjE;;;;AC/FI,IAAO,qBAAP,cAAkC,sBAAqB;EAC1C;EACA;EAEjB,YAAa,OAAkB,QAAW;AACxC,UAAM,OAAO;MACX,QAAS,KAAG;AACV,eAAO,OAAO,MAAM,GAAG;MACzB;MACA,OAAQ,KAAG;AACT,YAAI,OAAO,SAAQ,MAAO,KAAK;AAC7B,iBAAO;QACT;AAEA,YAAI,CAAC,OAAO,aAAa,GAAG,GAAG;AAC7B,gBAAM,IAAI,MAAM,qBAAqB,OAAO,SAAQ,CAAE,aAAa,IAAI,SAAQ,CAAE,EAAE;QACrF;AAEA,eAAO,IAAI,IAAI,IAAI,SAAQ,EAAG,MAAM,OAAO,SAAQ,EAAG,MAAM,GAAG,KAAK;MACtE;KACD;AAED,SAAK,SAAS;AACd,SAAK,OAAO;EACd;EAEA,MAAO,GAAU,SAAsB;AACrC,UAAM,QAAe;MACnB,GAAG;;AAGL,UAAM,WAAW,MAAM,WAAW,CAAA,GAAI,IAAI,YAAS;AACjD,aAAO,CAAC,EAAE,KAAK,MAAK,MAAO,OAAO,EAAE,KAAK,KAAK,UAAU,OAAO,GAAG,GAAG,MAAK,CAAE;IAC9E,CAAC;AAED,UAAM,EAAE,OAAM,IAAK;AACnB,QAAI,UAAU,QAAQ,WAAW,KAAK;AACpC,aAAO,MAAM;AACb,YAAM,QAAQ,KAAK,CAAC,EAAE,IAAG,MAAM;AAC7B,eAAO,KAAK,UAAU,OAAO,GAAG,EAAE,SAAQ,EAAG,WAAW,MAAM;MAChE,CAAC;IACH;AAEA,QAAI,MAAM,UAAU,MAAM;AACxB,YAAM,SAAS,MAAM,OAAO,IAAI,WAAQ;AACtC,eAAO,CAAC,GAAG,MAAM,MACf,EAAE,KAAK,KAAK,UAAU,OAAO,EAAE,GAAG,GAAG,OAAO,EAAE,MAAK,GACnD,EAAE,KAAK,KAAK,UAAU,OAAO,EAAE,GAAG,GAAG,OAAO,EAAE,MAAK,CAAE;MAEzD,CAAC;IACH;AAEA,UAAM,QAAQ,QAAQ,CAAC,EAAE,IAAG,MAAO,KAAK,KAAK,aAAa,GAAG,CAAC;AAE9D,WAAOC,aAAI,KAAK,OAAO,MAAM,OAAO,OAAO,GAAG,CAAC,EAAE,KAAK,MAAK,MAAM;AAC/D,aAAO;QACL,KAAK,KAAK,UAAU,OAAO,GAAG;QAC9B;;IAEJ,CAAC;EACH;EAEA,UAAW,GAAa,SAAsB;AAC5C,UAAM,QAAQ;MACZ,GAAG;;AAGL,UAAM,WAAW,MAAM,WAAW,CAAA,GAAI,IAAI,YAAS;AACjD,aAAO,CAAC,QAAQ,OAAO,KAAK,UAAU,OAAO,GAAG,CAAC;IACnD,CAAC;AAED,UAAM,EAAE,OAAM,IAAK;AACnB,QAAI,UAAU,QAAQ,WAAW,KAAK;AACpC,aAAO,MAAM;AACb,YAAM,QAAQ,KAAK,CAAC,QAAO;AACzB,eAAO,KAAK,UAAU,OAAO,GAAG,EAAE,SAAQ,EAAG,WAAW,MAAM;MAChE,CAAC;IACH;AAEA,QAAI,MAAM,UAAU,MAAM;AACxB,YAAM,SAAS,MAAM,OAAO,IAAI,WAAQ;AACtC,eAAO,CAAC,GAAG,MAAM,MACf,KAAK,UAAU,OAAO,CAAC,GACvB,KAAK,UAAU,OAAO,CAAC,CAAC;MAE5B,CAAC;IACH;AAEA,UAAM,QAAQ,QAAQ,SAAO,KAAK,KAAK,aAAa,GAAG,CAAC;AAExD,WAAOA,aAAI,KAAK,OAAO,UAAU,OAAO,OAAO,GAAG,SAAM;AACtD,aAAO,KAAK,UAAU,OAAO,GAAG;IAClC,CAAC;EACH;;",
  "names": ["src_default", "isAsyncIterable", "src_default", "isAsyncIterable", "src_default", "src_default", "it", "source", "src_default", "src_default", "src_default"]
}

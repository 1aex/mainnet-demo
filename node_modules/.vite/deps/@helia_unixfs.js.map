{
  "version": 3,
  "sources": ["../../murmurhash3js-revisited/lib/murmurHash3js.js", "../../murmurhash3js-revisited/index.js", "../../sparse-array/index.js", "../../rabin-wasm/src/rabin.js", "../../@assemblyscript/loader/index.js", "../../rabin-wasm/dist/rabin-wasm.js", "../../rabin-wasm/src/index.js", "../../it-batch/src/index.ts", "../../it-parallel-batch/src/index.ts", "../../ipfs-unixfs-importer/src/chunker/fixed-size.ts", "../../ipfs-unixfs/src/errors.ts", "../../ipfs-unixfs/src/unixfs.ts", "../../ipfs-unixfs/src/index.ts", "../../ipfs-unixfs-importer/node_modules/multiformats/src/codecs/raw.ts", "../../ipfs-unixfs-importer/node_modules/multiformats/src/bytes.ts", "../../ipfs-unixfs-importer/node_modules/multiformats/src/vendor/base-x.js", "../../ipfs-unixfs-importer/node_modules/multiformats/src/bases/base.ts", "../../ipfs-unixfs-importer/node_modules/multiformats/src/bases/base32.ts", "../../ipfs-unixfs-importer/node_modules/multiformats/src/bases/base36.ts", "../../ipfs-unixfs-importer/node_modules/multiformats/src/bases/base58.ts", "../../ipfs-unixfs-importer/node_modules/multiformats/src/vendor/varint.js", "../../ipfs-unixfs-importer/node_modules/multiformats/src/varint.ts", "../../ipfs-unixfs-importer/node_modules/multiformats/src/hashes/digest.ts", "../../ipfs-unixfs-importer/node_modules/multiformats/src/cid.ts", "../../ipfs-unixfs-importer/node_modules/multiformats/src/hashes/hasher.ts", "../../ipfs-unixfs-importer/node_modules/multiformats/src/hashes/sha2-browser.ts", "../../ipfs-unixfs-importer/src/utils/persist.ts", "../../ipfs-unixfs-importer/src/dag-builder/buffer-importer.ts", "../../ipfs-unixfs-importer/src/errors.ts", "../../ipfs-unixfs-importer/src/dag-builder/dir.ts", "../../ipfs-unixfs-importer/src/dag-builder/file.ts", "../../ipfs-unixfs-importer/src/dag-builder/index.ts", "../../ipfs-unixfs-importer/src/dag-builder/validate-chunks.ts", "../../ipfs-unixfs-importer/src/layout/balanced.ts", "../../ipfs-unixfs-importer/src/dir.ts", "../../ipfs-unixfs-importer/src/dir-flat.ts", "../../@multiformats/murmur3/node_modules/multiformats/src/bytes.ts", "../../@multiformats/murmur3/node_modules/multiformats/src/vendor/base-x.js", "../../@multiformats/murmur3/node_modules/multiformats/src/bases/base.ts", "../../@multiformats/murmur3/node_modules/multiformats/src/bases/base32.ts", "../../@multiformats/murmur3/node_modules/multiformats/src/bases/base36.ts", "../../@multiformats/murmur3/node_modules/multiformats/src/bases/base58.ts", "../../@multiformats/murmur3/node_modules/multiformats/src/vendor/varint.js", "../../@multiformats/murmur3/node_modules/multiformats/src/varint.ts", "../../@multiformats/murmur3/node_modules/multiformats/src/hashes/digest.ts", "../../@multiformats/murmur3/node_modules/multiformats/src/cid.ts", "../../@multiformats/murmur3/node_modules/multiformats/src/hashes/hasher.ts", "../../@multiformats/murmur3/src/index.js", "../../hamt-sharding/src/bucket.ts", "../../hamt-sharding/src/consumable-buffer.ts", "../../hamt-sharding/src/consumable-hash.ts", "../../hamt-sharding/src/index.ts", "../../ipfs-unixfs-importer/src/dir-sharded.ts", "../../ipfs-unixfs-importer/src/flat-to-shard.ts", "../../ipfs-unixfs-importer/src/utils/to-path-components.ts", "../../ipfs-unixfs-importer/src/tree-builder.ts", "../../ipfs-unixfs-importer/src/index.ts", "../../ipfs-unixfs-importer/src/chunker/rabin.ts", "../../it-last/src/index.ts", "../../@helia/unixfs/src/errors.ts", "../../@helia/unixfs/src/commands/add.ts", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/bytes.ts", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/vendor/base-x.js", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/bases/base.ts", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/bases/base32.ts", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/bases/base36.ts", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/bases/base58.ts", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/vendor/varint.js", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/varint.ts", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/hashes/digest.ts", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/cid.ts", "../../ipfs-unixfs-exporter/src/errors.ts", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/codecs/json.ts", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/codecs/raw.ts", "../../ipfs-unixfs-exporter/node_modules/multiformats/src/hashes/identity.ts", "../../ipfs-unixfs-exporter/src/utils/resolve-object-path.ts", "../../ipfs-unixfs-exporter/src/resolvers/dag-cbor.ts", "../../ipfs-unixfs-exporter/src/resolvers/dag-json.ts", "../../ipfs-unixfs-exporter/src/utils/extract-data-from-block.ts", "../../ipfs-unixfs-exporter/src/utils/validate-offset-and-length.ts", "../../ipfs-unixfs-exporter/src/resolvers/identity.ts", "../../ipfs-unixfs-exporter/src/resolvers/json.ts", "../../ipfs-unixfs-exporter/src/resolvers/raw.ts", "../../ipfs-unixfs-exporter/src/utils/find-cid-in-shard.ts", "../../ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/directory.ts", "../../ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.ts", "../../ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/hamt-sharded-directory.ts", "../../ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.ts", "../../ipfs-unixfs-exporter/src/resolvers/index.ts", "../../ipfs-unixfs-exporter/src/index.ts", "../../@helia/unixfs/node_modules/multiformats/src/bytes.ts", "../../@helia/unixfs/node_modules/multiformats/src/vendor/base-x.js", "../../@helia/unixfs/node_modules/multiformats/src/bases/base.ts", "../../@helia/unixfs/node_modules/multiformats/src/bases/base32.ts", "../../@helia/unixfs/node_modules/multiformats/src/bases/base36.ts", "../../@helia/unixfs/node_modules/multiformats/src/bases/base58.ts", "../../@helia/unixfs/node_modules/multiformats/src/vendor/varint.js", "../../@helia/unixfs/node_modules/multiformats/src/varint.ts", "../../@helia/unixfs/node_modules/multiformats/src/hashes/digest.ts", "../../@helia/unixfs/node_modules/multiformats/src/cid.ts", "../../@helia/unixfs/node_modules/multiformats/src/hashes/hasher.ts", "../../@helia/unixfs/node_modules/multiformats/src/hashes/sha2-browser.ts", "../../@helia/unixfs/src/commands/utils/add-link.ts", "../../@helia/unixfs/src/commands/utils/consumable-hash.ts", "../../@helia/unixfs/src/commands/utils/hamt-constants.ts", "../../@helia/unixfs/src/commands/utils/hamt-utils.ts", "../../@helia/unixfs/src/commands/utils/persist.ts", "../../@helia/unixfs/src/commands/utils/dir-sharded.ts", "../../@helia/unixfs/src/commands/utils/is-over-shard-threshold.ts", "../../@helia/unixfs/src/commands/utils/cid-to-directory.ts", "../../@helia/unixfs/src/commands/utils/cid-to-pblink.ts", "../../@helia/unixfs/src/commands/utils/resolve.ts", "../../@helia/unixfs/src/commands/cat.ts", "../../@helia/unixfs/node_modules/multiformats/src/codecs/raw.ts", "../../@helia/unixfs/src/commands/utils/constants.ts", "../../@helia/unixfs/src/commands/chmod.ts", "../../@helia/unixfs/src/commands/cp.ts", "../../@helia/unixfs/src/commands/ls.ts", "../../@helia/unixfs/src/commands/mkdir.ts", "../../@helia/unixfs/src/commands/utils/remove-link.ts", "../../@helia/unixfs/src/commands/rm.ts", "../../@helia/unixfs/src/commands/stat.ts", "../../@helia/unixfs/src/commands/touch.ts", "../../@helia/unixfs/src/unixfs.ts", "../../@helia/unixfs/src/utils/glob-source.browser.ts", "../../@helia/unixfs/src/utils/url-source.ts", "../../@helia/unixfs/src/index.ts"],
  "sourcesContent": ["/* jshint -W086: true */\n// +----------------------------------------------------------------------+\n// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js\n// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |\n// |----------------------------------------------------------------------|\n// | Copyright (c) 2012-2015 Karan Lyons                                       |\n// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |\n// | Freely distributable under the MIT license.                          |\n// +----------------------------------------------------------------------+\n\n;(function (root, undefined) {\n    'use strict';\n\n    // Create a local object that'll be exported or referenced globally.\n    var library = {\n        'version': '3.0.0',\n        'x86': {},\n        'x64': {},\n        'inputValidation': true\n    };\n\n    // PRIVATE FUNCTIONS\n    // -----------------\n\n    function _validBytes(bytes) {\n        // check the input is an array or a typed array\n        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {\n            return false;\n        }\n\n        // check all bytes are actually bytes\n        for (var i = 0; i < bytes.length; i++) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _x86Multiply(m, n) {\n        //\n        // Given two 32bit ints, returns the two multiplied together as a\n        // 32bit int.\n        //\n\n        return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);\n    }\n\n    function _x86Rotl(m, n) {\n        //\n        // Given a 32bit int and an int representing a number of bit positions,\n        // returns the 32bit int rotated left by that number of positions.\n        //\n\n        return (m << n) | (m >>> (32 - n));\n    }\n\n    function _x86Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x86 mix of that block.\n        //\n\n        h ^= h >>> 16;\n        h = _x86Multiply(h, 0x85ebca6b);\n        h ^= h >>> 13;\n        h = _x86Multiply(h, 0xc2b2ae35);\n        h ^= h >>> 16;\n\n        return h;\n    }\n\n    function _x64Add(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // added together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] + n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] + n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] + n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += m[0] + n[0];\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Multiply(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // multiplied together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] * n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] * n[3];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[2] += m[3] * n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] * n[3];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[2] * n[2];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[3] * n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += (m[0] * n[3]) + (m[1] * n[2]) + (m[2] * n[1]) + (m[3] * n[0]);\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Rotl(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) rotated left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 32) {\n            return [m[1], m[0]];\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), (m[1] << n) | (m[0] >>> (32 - n))];\n        } else {\n            n -= 32;\n            return [(m[1] << n) | (m[0] >>> (32 - n)), (m[0] << n) | (m[1] >>> (32 - n))];\n        }\n    }\n\n    function _x64LeftShift(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) shifted left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 0) {\n            return m;\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), m[1] << n];\n        } else {\n            return [m[1] << (n - 32), 0];\n        }\n    }\n\n    function _x64Xor(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // xored together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        return [m[0] ^ n[0], m[1] ^ n[1]];\n    }\n\n    function _x64Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x64 mix of that block.\n        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the\n        // only place where we need to right shift 64bit ints.)\n        //\n\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xff51afd7, 0xed558ccd]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n\n        return h;\n    }\n\n    // PUBLIC FUNCTIONS\n    // ----------------\n\n    library.x86.hash32 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 32 bit hash\n        // using the x86 flavor of MurmurHash3, as an unsigned int.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 4;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n\n        var k1 = 0;\n\n        var c1 = 0xcc9e2d51;\n        var c2 = 0x1b873593;\n\n        for (var i = 0; i < blocks; i = i + 4) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n\n            h1 ^= k1;\n            h1 = _x86Rotl(h1, 13);\n            h1 = _x86Multiply(h1, 5) + 0xe6546b64;\n        }\n\n        k1 = 0;\n\n        switch (remainder) {\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h1 = _x86Fmix(h1);\n\n        return h1 >>> 0;\n    };\n\n    library.x86.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n\n        seed = seed || 0;\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n        var h2 = seed;\n        var h3 = seed;\n        var h4 = seed;\n\n        var k1 = 0;\n        var k2 = 0;\n        var k3 = 0;\n        var k4 = 0;\n\n        var c1 = 0x239b961b;\n        var c2 = 0xab0e9789;\n        var c3 = 0x38b34ae5;\n        var c4 = 0xa1e38b93;\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n            k2 = (bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24);\n            k3 = (bytes[i + 8]) | (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24);\n            k4 = (bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n            h1 ^= k1;\n\n            h1 = _x86Rotl(h1, 19);\n            h1 += h2;\n            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;\n\n            k2 = _x86Multiply(k2, c2);\n            k2 = _x86Rotl(k2, 16);\n            k2 = _x86Multiply(k2, c3);\n            h2 ^= k2;\n\n            h2 = _x86Rotl(h2, 17);\n            h2 += h3;\n            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;\n\n            k3 = _x86Multiply(k3, c3);\n            k3 = _x86Rotl(k3, 17);\n            k3 = _x86Multiply(k3, c4);\n            h3 ^= k3;\n\n            h3 = _x86Rotl(h3, 15);\n            h3 += h4;\n            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;\n\n            k4 = _x86Multiply(k4, c4);\n            k4 = _x86Rotl(k4, 18);\n            k4 = _x86Multiply(k4, c1);\n            h4 ^= k4;\n\n            h4 = _x86Rotl(h4, 13);\n            h4 += h1;\n            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;\n        }\n\n        k1 = 0;\n        k2 = 0;\n        k3 = 0;\n        k4 = 0;\n\n        switch (remainder) {\n            case 15:\n                k4 ^= bytes[i + 14] << 16;\n\n            case 14:\n                k4 ^= bytes[i + 13] << 8;\n\n            case 13:\n                k4 ^= bytes[i + 12];\n                k4 = _x86Multiply(k4, c4);\n                k4 = _x86Rotl(k4, 18);\n                k4 = _x86Multiply(k4, c1);\n                h4 ^= k4;\n\n            case 12:\n                k3 ^= bytes[i + 11] << 24;\n\n            case 11:\n                k3 ^= bytes[i + 10] << 16;\n\n            case 10:\n                k3 ^= bytes[i + 9] << 8;\n\n            case 9:\n                k3 ^= bytes[i + 8];\n                k3 = _x86Multiply(k3, c3);\n                k3 = _x86Rotl(k3, 17);\n                k3 = _x86Multiply(k3, c4);\n                h3 ^= k3;\n\n            case 8:\n                k2 ^= bytes[i + 7] << 24;\n\n            case 7:\n                k2 ^= bytes[i + 6] << 16;\n\n            case 6:\n                k2 ^= bytes[i + 5] << 8;\n\n            case 5:\n                k2 ^= bytes[i + 4];\n                k2 = _x86Multiply(k2, c2);\n                k2 = _x86Rotl(k2, 16);\n                k2 = _x86Multiply(k2, c3);\n                h2 ^= k2;\n\n            case 4:\n                k1 ^= bytes[i + 3] << 24;\n\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h2 ^= bytes.length;\n        h3 ^= bytes.length;\n        h4 ^= bytes.length;\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        h1 = _x86Fmix(h1);\n        h2 = _x86Fmix(h2);\n        h3 = _x86Fmix(h3);\n        h4 = _x86Fmix(h4);\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        return (\"00000000\" + (h1 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h3 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h4 >>> 0).toString(16)).slice(-8);\n    };\n\n    library.x64.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = [0, seed];\n        var h2 = [0, seed];\n\n        var k1 = [0, 0];\n        var k2 = [0, 0];\n\n        var c1 = [0x87c37b91, 0x114253d5];\n        var c2 = [0x4cf5ad43, 0x2745937f];\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = [(bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24), (bytes[i]) |\n                (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24)];\n            k2 = [(bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24), (bytes[i + 8]) |\n                (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24)];\n\n            k1 = _x64Multiply(k1, c1);\n            k1 = _x64Rotl(k1, 31);\n            k1 = _x64Multiply(k1, c2);\n            h1 = _x64Xor(h1, k1);\n\n            h1 = _x64Rotl(h1, 27);\n            h1 = _x64Add(h1, h2);\n            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 0x52dce729]);\n\n            k2 = _x64Multiply(k2, c2);\n            k2 = _x64Rotl(k2, 33);\n            k2 = _x64Multiply(k2, c1);\n            h2 = _x64Xor(h2, k2);\n\n            h2 = _x64Rotl(h2, 31);\n            h2 = _x64Add(h2, h1);\n            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);\n        }\n\n        k1 = [0, 0];\n        k2 = [0, 0];\n\n        switch (remainder) {\n            case 15:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));\n\n            case 14:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));\n\n            case 13:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));\n\n            case 12:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));\n\n            case 11:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));\n\n            case 10:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));\n\n            case 9:\n                k2 = _x64Xor(k2, [0, bytes[i + 8]]);\n                k2 = _x64Multiply(k2, c2);\n                k2 = _x64Rotl(k2, 33);\n                k2 = _x64Multiply(k2, c1);\n                h2 = _x64Xor(h2, k2);\n\n            case 8:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));\n\n            case 7:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));\n\n            case 6:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));\n\n            case 5:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));\n\n            case 4:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));\n\n            case 3:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));\n\n            case 2:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));\n\n            case 1:\n                k1 = _x64Xor(k1, [0, bytes[i]]);\n                k1 = _x64Multiply(k1, c1);\n                k1 = _x64Rotl(k1, 31);\n                k1 = _x64Multiply(k1, c2);\n                h1 = _x64Xor(h1, k1);\n        }\n\n        h1 = _x64Xor(h1, [0, bytes.length]);\n        h2 = _x64Xor(h2, [0, bytes.length]);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        h1 = _x64Fmix(h1);\n        h2 = _x64Fmix(h2);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        return (\"00000000\" + (h1[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h1[1] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[1] >>> 0).toString(16)).slice(-8);\n    };\n\n    // INITIALIZATION\n    // --------------\n\n    // Export murmurHash3 for CommonJS, either as an AMD module or just as part\n    // of the global object.\n    if (typeof exports !== 'undefined') {\n\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = library;\n        }\n\n        exports.murmurHash3 = library;\n\n    } else if (typeof define === 'function' && define.amd) {\n\n        define([], function () {\n            return library;\n        });\n    } else {\n\n        // Use murmurHash3.noConflict to restore `murmurHash3` back to its\n        // original value. Returns a reference to the library object, to allow\n        // it to be used under a different name.\n        library._murmurHash3 = root.murmurHash3;\n\n        library.noConflict = function () {\n            root.murmurHash3 = library._murmurHash3;\n            library._murmurHash3 = undefined;\n            library.noConflict = undefined;\n\n            return library;\n        };\n\n        root.murmurHash3 = library;\n    }\n})(this);\n", "module.exports = require('./lib/murmurHash3js');\n", "'use strict'\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7\n\nmodule.exports = class SparseArray {\n  constructor () {\n    this._bitArrays = []\n    this._data = []\n    this._length = 0\n    this._changedLength = false\n    this._changedData = false\n  }\n\n  set (index, value) {\n    let pos = this._internalPositionFor(index, false)\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos)\n        this._unsetBit(index)\n        this._changedLength = true\n        this._changedData = true\n      }\n    } else {\n      let needsSort = false\n      if (pos === -1) {\n        pos = this._data.length\n        this._setBit(index)\n        this._changedData = true\n      } else {\n        needsSort = true\n      }\n      this._setInternalPos(pos, index, value, needsSort)\n      this._changedLength = true\n    }\n  }\n\n  unset (index) {\n    this.set(index, undefined)\n  }\n\n  get (index) {\n    this._sortData()\n    const pos = this._internalPositionFor(index, true)\n    if (pos === -1) {\n      return undefined\n    }\n    return this._data[pos][1]\n  }\n\n  push (value) {\n    this.set(this.length, value)\n    return this.length\n  }\n\n  get length () {\n    this._sortData()\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1]\n      this._length = last ? last[0] + 1 : 0\n      this._changedLength = false\n    }\n    return this._length\n  }\n\n  forEach (iterator) {\n    let i = 0\n    while(i < this.length) {\n      iterator(this.get(i), i, this)\n      i++\n    }\n  }\n\n  map (iterator) {\n    let i = 0\n    let mapped = new Array(this.length)\n    while(i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this)\n      i++\n    }\n    return mapped\n  }\n\n  reduce (reducer, initialValue) {\n    let i = 0\n    let acc = initialValue\n    while(i < this.length) {\n      const value = this.get(i)\n      acc = reducer(acc, value, i)\n      i++\n    }\n    return acc\n  }\n\n  find (finder) {\n    let i = 0, found, last\n    while ((i < this.length) && !found) {\n      last = this.get(i)\n      found = finder(last)\n      i++\n    }\n    return found ? last : undefined\n  }\n\n  _internalPositionFor (index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate)\n    if (bytePos >= this._bitArrays.length) {\n      return -1\n    }\n    const byte = this._bitArrays[bytePos]\n    const bitPos = index - bytePos * BITS_PER_BYTE\n    const exists = (byte & (1 << bitPos)) > 0\n    if (!exists) {\n      return -1\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)\n\n    const mask = ~(0xffffffff << (bitPos + 1))\n    const bytePopCount = popCount(byte & mask)\n    const arrayPos = previousPopCount + bytePopCount - 1\n    return arrayPos\n  }\n\n  _bytePosFor (index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE)\n    const targetLength = bytePos + 1\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0)\n    }\n    return bytePos\n  }\n\n  _setBit (index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data =this._data\n    const elem = [index, value]\n    if (needsSort) {\n      this._sortData()\n      data[pos] = elem\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem)\n        } else if (data[0][0] <= index) {\n          data.unshift(elem)\n        } else {\n          const randomIndex = Math.round(data.length / 2)\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))\n        }\n      } else {\n        this._data.push(elem)\n      }\n      this._changedData = true\n      this._changedLength = true\n    }\n  }\n\n  _unsetInternalPos (pos) {\n    this._data.splice(pos, 1)\n  }\n\n  _sortData () {\n    if (this._changedData) {\n      this._data.sort(sortInternal)\n    }\n\n    this._changedData = false\n  }\n\n  bitField () {\n    const bytes = []\n    let pendingBitsForResultingByte = 8\n    let pendingBitsForNewByte = 0\n    let resultingByte = 0\n    let newByte\n    const pending = this._bitArrays.slice()\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift()\n        pendingBitsForNewByte = 7\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)\n      const mask = ~(0b11111111 << usingBits)\n      const masked = newByte & mask\n      resultingByte |= masked << (8 - pendingBitsForResultingByte)\n      newByte = newByte >>> usingBits\n      pendingBitsForNewByte -= usingBits\n      pendingBitsForResultingByte -= usingBits\n\n      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {\n        bytes.push(resultingByte)\n        resultingByte = 0\n        pendingBitsForResultingByte = 8\n      }\n    }\n\n    // remove trailing zeroes\n    for(var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i]\n      if (value === 0) {\n        bytes.pop()\n      } else {\n        break\n      }\n    }\n\n    return bytes\n  }\n\n  compactArray () {\n    this._sortData()\n    return this._data.map(valueOnly)\n  }\n}\n\nfunction popCountReduce (count, byte) {\n  return count + popCount(byte)\n}\n\nfunction popCount(_v) {\n  let v = _v\n  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary\n  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp\n  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\nfunction sortInternal (a, b) {\n  return a[0] - b[0]\n}\n\nfunction valueOnly (elem) {\n  return elem[1]\n}", "/**\n * Rabin fingerprinting\n *\n * @class Rabin\n */\nclass Rabin {\n    /**\n     * Creates an instance of Rabin.\n     * @param { import(\"./../dist/rabin-wasm\") } asModule\n     * @param {number} [bits=12]\n     * @param {number} [min=8 * 1024]\n     * @param {number} [max=32 * 1024]\n     * @param {number} polynomial\n     * @memberof Rabin\n     */\n    constructor(asModule, bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {\n        this.bits = bits\n        this.min = min\n        this.max = max\n        this.asModule = asModule\n        this.rabin = new asModule.Rabin(bits, min, max, windowSize, polynomial)\n        this.polynomial = polynomial\n    }\n\n    /**\n     * Fingerprints the buffer\n     *\n     * @param {Uint8Array} buf\n     * @returns {Array<number>}\n     * @memberof Rabin\n     */\n    fingerprint(buf) {\n        const {\n            __retain,\n            __release,\n            __allocArray,\n            __getInt32Array,\n            Int32Array_ID,\n            Uint8Array_ID\n        } = this.asModule\n\n        const lengths = new Int32Array(Math.ceil(buf.length/this.min))\n        const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths))\n        const pointer = __retain(__allocArray(Uint8Array_ID, buf))\n\n        const out = this.rabin.fingerprint(pointer, lengthsPtr)\n        const processed = __getInt32Array(out)\n\n        __release(pointer)\n        __release(lengthsPtr)\n\n        const end = processed.indexOf(0);\n        return end >= 0 ? processed.subarray(0, end) : processed;\n    }\n}\n\nmodule.exports = Rabin", "\"use strict\";\n\n// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN_OFFSET = 5;\nconst VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN_OFFSET = 14;\nconst KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const U32 = new Uint32Array(buffer);\n  const U16 = new Uint16Array(buffer);\n  var length = U32[(ptr + SIZE_OFFSET) >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  function getKeyAlign(info) {\n    return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __allocString(str) {\n    const length = str.length;\n    const ptr = alloc(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.__allocString = __allocString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n\n  baseModule.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    const U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT)\n          .subarray(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  baseModule.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);\n  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);\n  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);\n  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);\n  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);\n  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);\n  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);\n  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);\n  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);\n  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);\n  if (BIGINT) {\n    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);\n    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);\n    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);\n    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);\n  }\n  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);\n  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);\n  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);\n  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    var id = U32[(ptr + ID_OFFSET) >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true;\n      while (id = getBase(id));\n    }\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table  = baseModule.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, baseModule);\n}\n\nfunction isResponse(o) {\n  return typeof Response !== \"undefined\" && o instanceof Response;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nasync function instantiate(source, imports) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    await WebAssembly.instantiate(\n      source instanceof WebAssembly.Module\n        ? source\n        : await WebAssembly.compile(source),\n      imports\n    )\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nfunction instantiateSync(source, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(\n      source instanceof WebAssembly.Module\n        ? source\n        : new WebAssembly.Module(source),\n      imports\n    )\n  )\n}\n\nexports.instantiateSync = instantiateSync;\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nasync function instantiateStreaming(source, imports) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(source, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setArgumentsLength = exports[\"__argumentsLength\"]\n    ? function(length) { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || function() {};\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[THIS]); },\n            set: function(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return module;\n}\n\nexports.demangle = demangle;\n", "\nconst { instantiate } = require(\"@assemblyscript/loader\");\n\nloadWebAssembly.supported = typeof WebAssembly !== 'undefined'\n\nfunction loadWebAssembly (imp = {}) {\n  if (!loadWebAssembly.supported) return null\n  \n  var wasm = new Uint8Array([0,97,115,109,1,0,0,0,1,78,14,96,2,127,126,0,96,1,127,1,126,96,2,127,127,0,96,1,127,1,127,96,1,127,0,96,2,127,127,1,127,96,3,127,127,127,1,127,96,0,0,96,3,127,127,127,0,96,0,1,127,96,4,127,127,127,127,0,96,5,127,127,127,127,127,1,127,96,1,126,1,127,96,2,126,126,1,126,2,13,1,3,101,110,118,5,97,98,111,114,116,0,10,3,54,53,2,2,8,9,3,5,2,8,6,5,3,4,2,6,9,12,13,2,5,11,3,2,3,2,3,2,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,6,7,7,4,4,5,3,1,0,1,6,47,9,127,1,65,0,11,127,1,65,0,11,127,0,65,3,11,127,0,65,4,11,127,1,65,0,11,127,1,65,0,11,127,1,65,0,11,127,0,65,240,2,11,127,0,65,6,11,7,240,5,41,6,109,101,109,111,114,121,2,0,7,95,95,97,108,108,111,99,0,10,8,95,95,114,101,116,97,105,110,0,11,9,95,95,114,101,108,101,97,115,101,0,12,9,95,95,99,111,108,108,101,99,116,0,51,11,95,95,114,116,116,105,95,98,97,115,101,3,7,13,73,110,116,51,50,65,114,114,97,121,95,73,68,3,2,13,85,105,110,116,56,65,114,114,97,121,95,73,68,3,3,6,100,101,103,114,101,101,0,16,3,109,111,100,0,17,5,82,97,98,105,110,3,8,16,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,0,21,16,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,0,22,21,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,23,21,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,24,14,82,97,98,105,110,35,103,101,116,58,119,112,111,115,0,25,14,82,97,98,105,110,35,115,101,116,58,119,112,111,115,0,26,15,82,97,98,105,110,35,103,101,116,58,99,111,117,110,116,0,27,15,82,97,98,105,110,35,115,101,116,58,99,111,117,110,116,0,28,13,82,97,98,105,110,35,103,101,116,58,112,111,115,0,29,13,82,97,98,105,110,35,115,101,116,58,112,111,115,0,30,15,82,97,98,105,110,35,103,101,116,58,115,116,97,114,116,0,31,15,82,97,98,105,110,35,115,101,116,58,115,116,97,114,116,0,32,16,82,97,98,105,110,35,103,101,116,58,100,105,103,101,115,116,0,33,16,82,97,98,105,110,35,115,101,116,58,100,105,103,101,115,116,0,34,21,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,35,21,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,36,22,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,37,22,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,38,31,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,39,31,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,40,20,82,97,98,105,110,35,103,101,116,58,112,111,108,121,110,111,109,105,97,108,0,41,20,82,97,98,105,110,35,115,101,116,58,112,111,108,121,110,111,109,105,97,108,0,42,17,82,97,98,105,110,35,103,101,116,58,109,105,110,115,105,122,101,0,43,17,82,97,98,105,110,35,115,101,116,58,109,105,110,115,105,122,101,0,44,17,82,97,98,105,110,35,103,101,116,58,109,97,120,115,105,122,101,0,45,17,82,97,98,105,110,35,115,101,116,58,109,97,120,115,105,122,101,0,46,14,82,97,98,105,110,35,103,101,116,58,109,97,115,107,0,47,14,82,97,98,105,110,35,115,101,116,58,109,97,115,107,0,48,17,82,97,98,105,110,35,99,111,110,115,116,114,117,99,116,111,114,0,20,17,82,97,98,105,110,35,102,105,110,103,101,114,112,114,105,110,116,0,49,8,1,50,10,165,31,53,199,1,1,4,127,32,1,40,2,0,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,3,65,4,107,118,65,16,115,33,4,32,3,65,7,107,11,33,3,32,1,40,2,20,33,2,32,1,40,2,16,34,5,4,64,32,5,32,2,54,2,20,11,32,2,4,64,32,2,32,5,54,2,16,11,32,1,32,0,32,4,32,3,65,4,116,106,65,2,116,106,40,2,96,70,4,64,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,2,54,2,96,32,2,69,4,64,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,65,127,115,113,34,1,54,2,4,32,1,69,4,64,32,0,32,0,40,2,0,65,1,32,3,116,65,127,115,113,54,2,0,11,11,11,11,226,2,1,6,127,32,1,40,2,0,33,3,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,34,5,65,1,113,4,64,32,3,65,124,113,65,16,106,32,5,65,124,113,106,34,2,65,240,255,255,255,3,73,4,64,32,0,32,4,16,1,32,1,32,2,32,3,65,3,113,114,34,3,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,33,5,11,11,32,3,65,2,113,4,64,32,1,65,4,107,40,2,0,34,2,40,2,0,34,6,65,124,113,65,16,106,32,3,65,124,113,106,34,7,65,240,255,255,255,3,73,4,64,32,0,32,2,16,1,32,2,32,7,32,6,65,3,113,114,34,3,54,2,0,32,2,33,1,11,11,32,4,32,5,65,2,114,54,2,0,32,4,65,4,107,32,1,54,2,0,32,0,32,3,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,2,65,4,107,118,65,16,115,33,4,32,2,65,7,107,11,34,3,65,4,116,32,4,106,65,2,116,106,40,2,96,33,2,32,1,65,0,54,2,16,32,1,32,2,54,2,20,32,2,4,64,32,2,32,1,54,2,16,11,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,1,54,2,96,32,0,32,0,40,2,0,65,1,32,3,116,114,54,2,0,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,114,54,2,4,11,119,1,1,127,32,2,2,127,32,0,40,2,160,12,34,2,4,64,32,2,32,1,65,16,107,70,4,64,32,2,40,2,0,33,3,32,1,65,16,107,33,1,11,11,32,1,11,107,34,2,65,48,73,4,64,15,11,32,1,32,3,65,2,113,32,2,65,32,107,65,1,114,114,54,2,0,32,1,65,0,54,2,16,32,1,65,0,54,2,20,32,1,32,2,106,65,16,107,34,2,65,2,54,2,0,32,0,32,2,54,2,160,12,32,0,32,1,16,2,11,155,1,1,3,127,35,0,34,0,69,4,64,65,1,63,0,34,0,74,4,127,65,1,32,0,107,64,0,65,0,72,5,65,0,11,4,64,0,11,65,176,3,34,0,65,0,54,2,0,65,208,15,65,0,54,2,0,3,64,32,1,65,23,73,4,64,32,1,65,2,116,65,176,3,106,65,0,54,2,4,65,0,33,2,3,64,32,2,65,16,73,4,64,32,1,65,4,116,32,2,106,65,2,116,65,176,3,106,65,0,54,2,96,32,2,65,1,106,33,2,12,1,11,11,32,1,65,1,106,33,1,12,1,11,11,65,176,3,65,224,15,63,0,65,16,116,16,3,65,176,3,36,0,11,32,0,11,45,0,32,0,65,240,255,255,255,3,79,4,64,65,32,65,224,0,65,201,3,65,29,16,0,0,11,32,0,65,15,106,65,112,113,34,0,65,16,32,0,65,16,75,27,11,169,1,1,1,127,32,0,32,1,65,128,2,73,4,127,32,1,65,4,118,33,1,65,0,5,32,1,65,248,255,255,255,1,73,4,64,32,1,65,1,65,27,32,1,103,107,116,106,65,1,107,33,1,11,32,1,65,31,32,1,103,107,34,2,65,4,107,118,65,16,115,33,1,32,2,65,7,107,11,34,2,65,2,116,106,40,2,4,65,127,32,1,116,113,34,1,4,127,32,0,32,1,104,32,2,65,4,116,106,65,2,116,106,40,2,96,5,32,0,40,2,0,65,127,32,2,65,1,106,116,113,34,1,4,127,32,0,32,0,32,1,104,34,0,65,2,116,106,40,2,4,104,32,0,65,4,116,106,65,2,116,106,40,2,96,5,65,0,11,11,11,111,1,1,127,63,0,34,2,32,1,65,248,255,255,255,1,73,4,127,32,1,65,1,65,27,32,1,103,107,116,65,1,107,106,5,32,1,11,65,16,32,0,40,2,160,12,32,2,65,16,116,65,16,107,71,116,106,65,255,255,3,106,65,128,128,124,113,65,16,118,34,1,32,2,32,1,74,27,64,0,65,0,72,4,64,32,1,64,0,65,0,72,4,64,0,11,11,32,0,32,2,65,16,116,63,0,65,16,116,16,3,11,113,1,2,127,32,1,40,2,0,34,3,65,124,113,32,2,107,34,4,65,32,79,4,64,32,1,32,2,32,3,65,2,113,114,54,2,0,32,2,32,1,65,16,106,106,34,1,32,4,65,16,107,65,1,114,54,2,0,32,0,32,1,16,2,5,32,1,32,3,65,126,113,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,32,1,65,16,106,32,1,40,2,0,65,124,113,106,40,2,0,65,125,113,54,2,0,11,11,91,1,2,127,32,0,32,1,16,5,34,4,16,6,34,3,69,4,64,65,1,36,1,65,0,36,1,32,0,32,4,16,6,34,3,69,4,64,32,0,32,4,16,7,32,0,32,4,16,6,33,3,11,11,32,3,65,0,54,2,4,32,3,32,2,54,2,8,32,3,32,1,54,2,12,32,0,32,3,16,1,32,0,32,3,32,4,16,8,32,3,11,13,0,16,4,32,0,32,1,16,9,65,16,106,11,33,1,1,127,32,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,18,0,32,0,65,172,3,75,4,64,32,0,65,16,107,16,52,11,11,140,3,1,1,127,2,64,32,1,69,13,0,32,0,65,0,58,0,0,32,0,32,1,106,65,1,107,65,0,58,0,0,32,1,65,2,77,13,0,32,0,65,1,106,65,0,58,0,0,32,0,65,2,106,65,0,58,0,0,32,0,32,1,106,34,2,65,2,107,65,0,58,0,0,32,2,65,3,107,65,0,58,0,0,32,1,65,6,77,13,0,32,0,65,3,106,65,0,58,0,0,32,0,32,1,106,65,4,107,65,0,58,0,0,32,1,65,8,77,13,0,32,1,65,0,32,0,107,65,3,113,34,1,107,33,2,32,0,32,1,106,34,0,65,0,54,2,0,32,0,32,2,65,124,113,34,1,106,65,4,107,65,0,54,2,0,32,1,65,8,77,13,0,32,0,65,4,106,65,0,54,2,0,32,0,65,8,106,65,0,54,2,0,32,0,32,1,106,34,2,65,12,107,65,0,54,2,0,32,2,65,8,107,65,0,54,2,0,32,1,65,24,77,13,0,32,0,65,12,106,65,0,54,2,0,32,0,65,16,106,65,0,54,2,0,32,0,65,20,106,65,0,54,2,0,32,0,65,24,106,65,0,54,2,0,32,0,32,1,106,34,2,65,28,107,65,0,54,2,0,32,2,65,24,107,65,0,54,2,0,32,2,65,20,107,65,0,54,2,0,32,2,65,16,107,65,0,54,2,0,32,0,32,0,65,4,113,65,24,106,34,2,106,33,0,32,1,32,2,107,33,1,3,64,32,1,65,32,79,4,64,32,0,66,0,55,3,0,32,0,65,8,106,66,0,55,3,0,32,0,65,16,106,66,0,55,3,0,32,0,65,24,106,66,0,55,3,0,32,1,65,32,107,33,1,32,0,65,32,106,33,0,12,1,11,11,11,11,178,1,1,3,127,32,1,65,240,255,255,255,3,32,2,118,75,4,64,65,144,1,65,192,1,65,23,65,56,16,0,0,11,32,1,32,2,116,34,3,65,0,16,10,34,2,32,3,16,13,32,0,69,4,64,65,12,65,2,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,2,34,1,32,0,40,2,0,34,4,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,32,4,16,12,11,32,0,32,1,54,2,0,32,0,32,2,54,2,4,32,0,32,3,54,2,8,32,0,11,46,1,2,127,65,12,65,5,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,65,128,2,65,3,16,14,11,9,0,65,63,32,0,121,167,107,11,49,1,2,127,65,63,32,1,121,167,107,33,2,3,64,65,63,32,0,121,167,107,32,2,107,34,3,65,0,78,4,64,32,0,32,1,32,3,172,134,133,33,0,12,1,11,11,32,0,11,40,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,163,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,65,0,58,0,0,11,38,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,152,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,45,0,0,11,254,5,2,1,127,4,126,32,0,69,4,64,65,232,0,65,6,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,24,32,0,66,0,55,3,32,32,0,66,0,55,3,40,32,0,66,0,55,3,48,32,0,66,0,55,3,56,32,0,66,0,55,3,64,32,0,66,0,55,3,72,32,0,66,0,55,3,80,32,0,66,0,55,3,88,32,0,66,0,55,3,96,32,0,32,2,173,55,3,80,32,0,32,3,173,55,3,88,65,12,65,4,16,10,34,2,65,172,3,75,4,64,32,2,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,32,4,65,0,16,14,33,2,32,0,40,2,0,16,12,32,0,32,2,54,2,0,32,0,32,4,54,2,4,32,0,66,1,32,1,173,134,66,1,125,55,3,96,32,0,66,243,130,183,218,216,230,232,30,55,3,72,35,4,69,4,64,65,0,33,2,3,64,32,2,65,128,2,72,4,64,32,2,65,255,1,113,173,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,65,0,33,4,3,64,32,4,32,0,40,2,4,65,1,107,72,4,64,32,6,66,8,134,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,32,4,65,1,106,33,4,12,1,11,11,35,6,40,2,4,32,2,65,3,116,106,32,6,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,63,32,0,41,3,72,121,167,107,172,33,7,65,0,33,2,3,64,32,2,65,128,2,72,4,64,35,5,33,1,32,2,172,32,7,134,34,8,33,6,65,63,32,0,41,3,72,34,9,121,167,107,33,3,3,64,65,63,32,6,121,167,107,32,3,107,34,4,65,0,78,4,64,32,6,32,9,32,4,172,134,133,33,6,12,1,11,11,32,1,40,2,4,32,2,65,3,116,106,32,6,32,8,132,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,1,36,4,11,32,0,66,0,55,3,24,32,0,66,0,55,3,32,65,0,33,2,3,64,32,2,32,0,40,2,4,72,4,64,32,0,40,2,0,32,2,16,18,32,2,65,1,106,33,2,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,6,66,45,136,167,65,3,116,106,41,3,0,32,6,66,8,134,66,1,132,133,55,3,40,32,0,11,38,1,1,127,32,0,40,2,0,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,55,1,2,127,32,1,32,0,40,2,0,34,2,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,16,12,11,32,0,32,1,54,2,0,11,7,0,32,0,40,2,4,11,9,0,32,0,32,1,54,2,4,11,7,0,32,0,40,2,8,11,9,0,32,0,32,1,54,2,8,11,7,0,32,0,41,3,16,11,9,0,32,0,32,1,55,3,16,11,7,0,32,0,41,3,24,11,9,0,32,0,32,1,55,3,24,11,7,0,32,0,41,3,32,11,9,0,32,0,32,1,55,3,32,11,7,0,32,0,41,3,40,11,9,0,32,0,32,1,55,3,40,11,7,0,32,0,41,3,48,11,9,0,32,0,32,1,55,3,48,11,7,0,32,0,41,3,56,11,9,0,32,0,32,1,55,3,56,11,7,0,32,0,41,3,64,11,9,0,32,0,32,1,55,3,64,11,7,0,32,0,41,3,72,11,9,0,32,0,32,1,55,3,72,11,7,0,32,0,41,3,80,11,9,0,32,0,32,1,55,3,80,11,7,0,32,0,41,3,88,11,9,0,32,0,32,1,55,3,88,11,7,0,32,0,41,3,96,11,9,0,32,0,32,1,55,3,96,11,172,4,2,5,127,1,126,32,2,65,172,3,75,4,64,32,2,65,16,107,34,4,32,4,40,2,4,65,1,106,54,2,4,11,32,2,33,4,65,0,33,2,32,1,40,2,8,33,5,32,1,40,2,4,33,6,3,64,2,127,65,0,33,3,3,64,32,3,32,5,72,4,64,32,3,32,6,106,45,0,0,33,1,32,0,40,2,0,32,0,40,2,8,16,19,33,7,32,0,40,2,8,32,0,40,2,0,40,2,4,106,32,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,7,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,1,173,32,8,66,8,134,132,133,55,3,40,32,0,32,0,41,3,16,66,1,124,55,3,16,32,0,32,0,41,3,24,66,1,124,55,3,24,32,0,41,3,16,32,0,41,3,80,90,4,127,32,0,41,3,40,32,0,41,3,96,131,80,5,65,0,11,4,127,65,1,5,32,0,41,3,16,32,0,41,3,88,90,11,4,64,32,0,32,0,41,3,32,55,3,48,32,0,32,0,41,3,16,55,3,56,32,0,32,0,41,3,40,55,3,64,65,0,33,1,3,64,32,1,32,0,40,2,4,72,4,64,32,0,40,2,0,32,1,16,18,32,1,65,1,106,33,1,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,8,66,8,134,66,1,132,133,55,3,40,32,3,65,1,106,12,3,11,32,3,65,1,106,33,3,12,1,11,11,65,127,11,34,1,65,0,78,4,64,32,5,32,1,107,33,5,32,1,32,6,106,33,6,32,2,34,1,65,1,106,33,2,32,4,40,2,4,32,1,65,2,116,106,32,0,41,3,56,62,2,0,12,1,11,11,32,4,11,10,0,16,15,36,5,16,15,36,6,11,3,0,1,11,73,1,2,127,32,0,40,2,4,34,1,65,255,255,255,255,0,113,34,2,65,1,70,4,64,32,0,65,16,106,16,53,32,0,32,0,40,2,0,65,1,114,54,2,0,35,0,32,0,16,2,5,32,0,32,2,65,1,107,32,1,65,128,128,128,128,127,113,114,54,2,4,11,11,58,0,2,64,2,64,2,64,32,0,65,8,107,40,2,0,14,7,0,0,1,1,1,1,1,2,11,15,11,32,0,40,2,0,34,0,4,64,32,0,65,172,3,79,4,64,32,0,65,16,107,16,52,11,11,15,11,0,11,11,137,3,7,0,65,16,11,55,40,0,0,0,1,0,0,0,1,0,0,0,40,0,0,0,97,0,108,0,108,0,111,0,99,0,97,0,116,0,105,0,111,0,110,0,32,0,116,0,111,0,111,0,32,0,108,0,97,0,114,0,103,0,101,0,65,208,0,11,45,30,0,0,0,1,0,0,0,1,0,0,0,30,0,0,0,126,0,108,0,105,0,98,0,47,0,114,0,116,0,47,0,116,0,108,0,115,0,102,0,46,0,116,0,115,0,65,128,1,11,43,28,0,0,0,1,0,0,0,1,0,0,0,28,0,0,0,73,0,110,0,118,0,97,0,108,0,105,0,100,0,32,0,108,0,101,0,110,0,103,0,116,0,104,0,65,176,1,11,53,38,0,0,0,1,0,0,0,1,0,0,0,38,0,0,0,126,0,108,0,105,0,98,0,47,0,97,0,114,0,114,0,97,0,121,0,98,0,117,0,102,0,102,0,101,0,114,0,46,0,116,0,115,0,65,240,1,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,73,0,110,0,100,0,101,0,120,0,32,0,111,0,117,0,116,0,32,0,111,0,102,0,32,0,114,0,97,0,110,0,103,0,101,0,65,176,2,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,126,0,108,0,105,0,98,0,47,0,116,0,121,0,112,0,101,0,100,0,97,0,114,0,114,0,97,0,121,0,46,0,116,0,115,0,65,240,2,11,53,7,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,145,4,0,0,2,0,0,0,49,0,0,0,2,0,0,0,17,1,0,0,2,0,0,0,16,0,34,16,115,111,117,114,99,101,77,97,112,112,105,110,103,85,82,76,16,46,47,114,97,98,105,110,46,119,97,115,109,46,109,97,112])\n  // make it work async because browsers throw when a wasm module is bigger than 4kb and load sync\n  return instantiate(new Response(new Blob([wasm], {type: 'application/wasm'})), imp)\n}\nmodule.exports = loadWebAssembly\n", "const Rabin = require('./rabin')\nconst getRabin = require('../dist/rabin-wasm.node.js')\n\nconst create = async (avg, min, max, windowSize, polynomial) => {\n    const compiled = await getRabin()\n    return new Rabin(compiled, avg, min, max, windowSize, polynomial)\n}\n\nmodule.exports = {\n    Rabin,\n    create\n}\n", "/**\n * @packageDocumentation\n *\n * The final batch may be smaller than the max.\n *\n * @example\n *\n * ```javascript\n * import batch from 'it-batch'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n * const batchSize = 2\n *\n * const result = all(batch(values, batchSize))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import batch from 'it-batch'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const batchSize = 2\n * const result = await all(batch(values(), batchSize))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Takes an (async) iterable that emits things and returns an async iterable that\n * emits those things in fixed-sized batches\n */\nfunction batch <T> (source: Iterable<T>, size?: number): Generator<T[], void, undefined>\nfunction batch <T> (source: Iterable<T> | AsyncIterable<T>, size?: number): AsyncGenerator<T[], void, undefined>\nfunction batch <T> (source: Iterable<T> | AsyncIterable<T>, size: number = 1): Generator<T[], void, undefined> | AsyncGenerator<T[], void, undefined> {\n  size = Number(size)\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      let things: T[] = []\n\n      if (size < 1) {\n        size = 1\n      }\n\n      if (size !== Math.round(size)) {\n        throw new Error('Batch size must be an integer')\n      }\n\n      for await (const thing of source) {\n        things.push(thing)\n\n        while (things.length >= size) {\n          yield things.slice(0, size)\n\n          things = things.slice(size)\n        }\n      }\n\n      while (things.length > 0) {\n        yield things.slice(0, size)\n\n        things = things.slice(size)\n      }\n    }())\n  }\n\n  return (function * () {\n    let things: T[] = []\n\n    if (size < 1) {\n      size = 1\n    }\n\n    if (size !== Math.round(size)) {\n      throw new Error('Batch size must be an integer')\n    }\n\n    for (const thing of source) {\n      things.push(thing)\n\n      while (things.length >= size) {\n        yield things.slice(0, size)\n\n        things = things.slice(size)\n      }\n    }\n\n    while (things.length > 0) {\n      yield things.slice(0, size)\n\n      things = things.slice(size)\n    }\n  }())\n}\n\nexport default batch\n", "/**\n * @packageDocumentation\n *\n * Takes an async iterator that emits promise-returning functions, invokes them in parallel and emits the results in the same order as the input.\n *\n * The final batch may be smaller than the batch size.\n *\n * @example\n *\n * ```javascript\n * import parallelBatch from 'it-parallel-batch'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     await delay(500)\n *\n *     return 1\n *   },\n *   async () => {\n *     await delay(200)\n *\n *     return 2\n *   },\n *   async () => {\n *     await delay(100)\n *\n *     return 3\n *   }\n * ]\n *\n * const batchSize = 2\n *\n * const result = await all(parallelBatch(input, batchSize))\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\n\nimport batch from 'it-batch'\n\ninterface Success<T> {\n  ok: true\n  value: T\n}\n\ninterface Failure {\n  ok: false\n  err: Error\n}\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function * parallelBatch <T> (source: AsyncIterable<() => Promise<T>> | Iterable<() => Promise<T>>, size: number = 1): AsyncGenerator<T, void, undefined> {\n  for await (const tasks of batch(source, size)) {\n    const things: Array<Promise<Success<T> | Failure>> = tasks.map(\n      async (p: () => Promise<T>) => {\n        return p().then(value => ({ ok: true, value }), err => ({ ok: false, err }))\n      })\n\n    for (let i = 0; i < things.length; i++) {\n      const result = await things[i]\n\n      if (result.ok) {\n        yield result.value\n      } else {\n        throw result.err\n      }\n    }\n  }\n}\n", "import { Uint8ArrayList } from 'uint8arraylist'\nimport type { Chunker } from './index.js'\n\nexport interface FixedSizeOptions {\n  chunkSize?: number\n}\n\nconst DEFAULT_CHUNK_SIZE = 262144\n\nexport const fixedSize = (options: FixedSizeOptions = {}): Chunker => {\n  const chunkSize = options.chunkSize ?? DEFAULT_CHUNK_SIZE\n\n  return async function * fixedSizeChunker (source) {\n    let list = new Uint8ArrayList()\n    let currentLength = 0\n    let emitted = false\n\n    for await (const buffer of source) {\n      list.append(buffer)\n\n      currentLength += buffer.length\n\n      while (currentLength >= chunkSize) {\n        yield list.slice(0, chunkSize)\n        emitted = true\n\n        // throw away consumed bytes\n        if (chunkSize === list.length) {\n          list = new Uint8ArrayList()\n          currentLength = 0\n        } else {\n          const newBl = new Uint8ArrayList()\n          newBl.append(list.sublist(chunkSize))\n          list = newBl\n\n          // update our offset\n          currentLength -= chunkSize\n        }\n      }\n    }\n\n    if (!emitted || currentLength > 0) {\n      // return any remaining bytes\n      yield list.subarray(0, currentLength)\n    }\n  }\n}\n", "export class InvalidTypeError extends Error {\n  static name = 'InvalidTypeError'\n  static code = 'ERR_INVALID_TYPE'\n  name = InvalidTypeError.name\n  code = InvalidTypeError.code\n\n  constructor (message = 'Invalid type') {\n    super(message)\n  }\n}\n\nexport class InvalidUnixFSMessageError extends Error {\n  static name = 'InvalidUnixFSMessageError'\n  static code = 'ERR_INVALID_MESSAGE'\n  name = InvalidUnixFSMessageError.name\n  code = InvalidUnixFSMessageError.code\n\n  constructor (message = 'Invalid message') {\n    super(message)\n  }\n}\n", "import { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Data {\n  Type?: Data.DataType\n  Data?: Uint8Array\n  filesize?: bigint\n  blocksizes: bigint[]\n  hashType?: bigint\n  fanout?: bigint\n  mode?: number\n  mtime?: UnixTime\n}\n\nexport namespace Data {\n  export enum DataType {\n    Raw = 'Raw',\n    Directory = 'Directory',\n    File = 'File',\n    Metadata = 'Metadata',\n    Symlink = 'Symlink',\n    HAMTShard = 'HAMTShard'\n  }\n\n  enum __DataTypeValues {\n    Raw = 0,\n    Directory = 1,\n    File = 2,\n    Metadata = 3,\n    Symlink = 4,\n    HAMTShard = 5\n  }\n\n  export namespace DataType {\n    export const codec = (): Codec<DataType> => {\n      return enumeration<DataType>(__DataTypeValues)\n    }\n  }\n\n  let _codec: Codec<Data>\n\n  export const codec = (): Codec<Data> => {\n    if (_codec == null) {\n      _codec = message<Data>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          Data.DataType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (obj.filesize != null) {\n          w.uint32(24)\n          w.uint64(obj.filesize)\n        }\n\n        if (obj.blocksizes != null) {\n          for (const value of obj.blocksizes) {\n            w.uint32(32)\n            w.uint64(value)\n          }\n        }\n\n        if (obj.hashType != null) {\n          w.uint32(40)\n          w.uint64(obj.hashType)\n        }\n\n        if (obj.fanout != null) {\n          w.uint32(48)\n          w.uint64(obj.fanout)\n        }\n\n        if (obj.mode != null) {\n          w.uint32(56)\n          w.uint32(obj.mode)\n        }\n\n        if (obj.mtime != null) {\n          w.uint32(66)\n          UnixTime.codec().encode(obj.mtime, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          blocksizes: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Type = Data.DataType.codec().decode(reader)\n              break\n            case 2:\n              obj.Data = reader.bytes()\n              break\n            case 3:\n              obj.filesize = reader.uint64()\n              break\n            case 4:\n              obj.blocksizes.push(reader.uint64())\n              break\n            case 5:\n              obj.hashType = reader.uint64()\n              break\n            case 6:\n              obj.fanout = reader.uint64()\n              break\n            case 7:\n              obj.mode = reader.uint32()\n              break\n            case 8:\n              obj.mtime = UnixTime.codec().decode(reader, reader.uint32())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Data>): Uint8Array => {\n    return encodeMessage(obj, Data.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Data => {\n    return decodeMessage(buf, Data.codec())\n  }\n}\n\nexport interface UnixTime {\n  Seconds?: bigint\n  FractionalNanoseconds?: number\n}\n\nexport namespace UnixTime {\n  let _codec: Codec<UnixTime>\n\n  export const codec = (): Codec<UnixTime> => {\n    if (_codec == null) {\n      _codec = message<UnixTime>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Seconds != null) {\n          w.uint32(8)\n          w.int64(obj.Seconds)\n        }\n\n        if (obj.FractionalNanoseconds != null) {\n          w.uint32(21)\n          w.fixed32(obj.FractionalNanoseconds)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Seconds = reader.int64()\n              break\n            case 2:\n              obj.FractionalNanoseconds = reader.fixed32()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<UnixTime>): Uint8Array => {\n    return encodeMessage(obj, UnixTime.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): UnixTime => {\n    return decodeMessage(buf, UnixTime.codec())\n  }\n}\n\nexport interface Metadata {\n  MimeType?: string\n}\n\nexport namespace Metadata {\n  let _codec: Codec<Metadata>\n\n  export const codec = (): Codec<Metadata> => {\n    if (_codec == null) {\n      _codec = message<Metadata>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.MimeType != null) {\n          w.uint32(10)\n          w.string(obj.MimeType)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.MimeType = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Metadata>): Uint8Array => {\n    return encodeMessage(obj, Metadata.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Metadata => {\n    return decodeMessage(buf, Metadata.codec())\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * This module contains the protobuf definition of the UnixFS data structure found at the root of all UnixFS DAGs.\n *\n * The UnixFS spec can be found in the [ipfs/specs repository](http://github.com/ipfs/specs)\n *\n * @example Create a file composed of several blocks\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * data.addBlockSize(256n) // add the size of each block\n * data.addBlockSize(256n)\n * // ...\n * ```\n *\n * @example Create a directory that contains several files\n *\n * Creating a directory that contains several files is achieve by creating a unixfs element that identifies a MerkleDAG node as a directory. The links of that MerkleDAG node are the files that are contained in this directory.\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'directory' })\n * ```\n *\n * @example Create an unixfs Data element\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({\n *   // ...options\n * })\n * ```\n *\n * `options` is an optional object argument that might include the following keys:\n *\n * - type (string, default `file`): The type of UnixFS entry.  Can be:\n *   - `raw`\n *   - `directory`\n *   - `file`\n *   - `metadata`\n *   - `symlink`\n *   - `hamt-sharded-directory`\n * - data (Uint8Array): The optional data field for this node\n * - blockSizes (Array, default: `[]`): If this is a `file` node that is made up of multiple blocks, `blockSizes` is a list numbers that represent the size of the file chunks stored in each child node. It is used to calculate the total file size.\n * - mode (Number, default `0644` for files, `0755` for directories/hamt-sharded-directories) file mode\n * - mtime (`Date`, `{ secs, nsecs }`, `{ Seconds, FractionalNanoseconds }`, `[ secs, nsecs ]`): The modification time of this node\n *\n * @example Add and remove a block size to the block size list\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * const sizeInBytes = 100n\n * data.addBlockSize(sizeInBytes)\n * ```\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n *\n * const index = 0\n * data.removeBlockSize(index)\n * ```\n *\n * @example Get total fileSize\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * data.fileSize() // => size in bytes\n * ```\n *\n * @example Marshal and unmarshal\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * const marshaled = data.marshal()\n * const unmarshaled = UnixFS.unmarshal(marshaled)\n * ```\n *\n * @example Is this UnixFS entry a directory?\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const dir = new UnixFS({ type: 'directory' })\n * dir.isDirectory() // true\n *\n * const file = new UnixFS({ type: 'file' })\n * file.isDirectory() // false\n * ```\n *\n * @example Has an mtime been set?\n *\n * If no modification time has been set, no `mtime` property will be present on the `Data` instance:\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const file = new UnixFS({ type: 'file' })\n * file.mtime // undefined\n *\n * Object.prototype.hasOwnProperty.call(file, 'mtime') // false\n *\n * const dir = new UnixFS({ type: 'directory', mtime: { secs: 5n } })\n * dir.mtime // { secs: Number, nsecs: Number }\n * ```\n */\n\nimport { InvalidTypeError, InvalidUnixFSMessageError } from './errors.js'\nimport { Data as PBData } from './unixfs.js'\n\nexport interface Mtime {\n  secs: bigint\n  nsecs?: number\n}\n\nexport type MtimeLike = Mtime | { Seconds: number, FractionalNanoseconds?: number } | [number, number] | Date\n\nexport type UnixFSType = 'raw' | 'directory' | 'file' | 'metadata' | 'symlink' | 'hamt-sharded-directory'\n\nconst types: Record<string, UnixFSType> = {\n  Raw: 'raw',\n  Directory: 'directory',\n  File: 'file',\n  Metadata: 'metadata',\n  Symlink: 'symlink',\n  HAMTShard: 'hamt-sharded-directory'\n}\n\nconst dirTypes = [\n  'directory',\n  'hamt-sharded-directory'\n]\n\nconst DEFAULT_FILE_MODE = parseInt('0644', 8)\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8)\n\n// https://github.com/ipfs/boxo/blob/364c5040ec91ec8e2a61446e9921e9225704c34d/ipld/unixfs/hamt/hamt.go#L778\nconst MAX_FANOUT = BigInt(1 << 10)\n\nexport interface UnixFSOptions {\n  type?: UnixFSType\n  data?: Uint8Array\n  blockSizes?: bigint[]\n  hashType?: bigint\n  fanout?: bigint\n  mtime?: Mtime\n  mode?: number\n}\n\nclass UnixFS {\n  /**\n   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n   */\n  static unmarshal (marshaled: Uint8Array): UnixFS {\n    const message = PBData.decode(marshaled)\n\n    if (message.fanout != null && message.fanout > MAX_FANOUT) {\n      throw new InvalidUnixFSMessageError(`Fanout size was too large - ${message.fanout} > ${MAX_FANOUT}`)\n    }\n\n    const data = new UnixFS({\n      type: types[message.Type != null ? message.Type.toString() : 'File'],\n      data: message.Data,\n      blockSizes: message.blocksizes,\n      mode: message.mode,\n      mtime: message.mtime != null\n        ? {\n            secs: message.mtime.Seconds ?? 0n,\n            nsecs: message.mtime.FractionalNanoseconds\n          }\n        : undefined,\n      fanout: message.fanout\n    })\n\n    // make sure we honour the original mode\n    data._originalMode = message.mode ?? 0\n\n    return data\n  }\n\n  public type: string\n  public data?: Uint8Array\n  public blockSizes: bigint[]\n  public hashType?: bigint\n  public fanout?: bigint\n  public mtime?: Mtime\n\n  private _mode?: number\n  private _originalMode: number\n\n  constructor (options: UnixFSOptions = {\n    type: 'file'\n  }) {\n    const {\n      type,\n      data,\n      blockSizes,\n      hashType,\n      fanout,\n      mtime,\n      mode\n    } = options\n\n    if (type != null && !Object.values(types).includes(type)) {\n      throw new InvalidTypeError('Type: ' + type + ' is not valid')\n    }\n\n    this.type = type ?? 'file'\n    this.data = data\n    this.hashType = hashType\n    this.fanout = fanout\n    this.blockSizes = blockSizes ?? []\n    this._originalMode = 0\n    this.mode = mode\n    this.mtime = mtime\n  }\n\n  set mode (mode: number | undefined) {\n    if (mode == null) {\n      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE\n    } else {\n      this._mode = (mode & 0xFFF)\n    }\n  }\n\n  get mode (): number | undefined {\n    return this._mode\n  }\n\n  isDirectory (): boolean {\n    return dirTypes.includes(this.type)\n  }\n\n  addBlockSize (size: bigint): void {\n    this.blockSizes.push(size)\n  }\n\n  removeBlockSize (index: number): void {\n    this.blockSizes.splice(index, 1)\n  }\n\n  /**\n   * Returns `0n` for directories or `data.length + sum(blockSizes)` for everything else\n   */\n  fileSize (): bigint {\n    if (this.isDirectory()) {\n      // dirs don't have file size\n      return 0n\n    }\n\n    let sum = 0n\n    this.blockSizes.forEach((size) => {\n      sum += size\n    })\n\n    if (this.data != null) {\n      sum += BigInt(this.data.length)\n    }\n\n    return sum\n  }\n\n  /**\n   * encode to protobuf Uint8Array\n   */\n  marshal (): Uint8Array {\n    let type\n\n    switch (this.type) {\n      case 'raw': type = PBData.DataType.Raw; break\n      case 'directory': type = PBData.DataType.Directory; break\n      case 'file': type = PBData.DataType.File; break\n      case 'metadata': type = PBData.DataType.Metadata; break\n      case 'symlink': type = PBData.DataType.Symlink; break\n      case 'hamt-sharded-directory': type = PBData.DataType.HAMTShard; break\n      default:\n        throw new InvalidTypeError(`Type: ${type} is not valid`)\n    }\n\n    let data = this.data\n\n    if (this.data == null || this.data.length === 0) {\n      data = undefined\n    }\n\n    let mode\n\n    if (this.mode != null) {\n      mode = (this._originalMode & 0xFFFFF000) | (this.mode ?? 0)\n\n      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n        mode = undefined\n      }\n\n      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n        mode = undefined\n      }\n    }\n\n    let mtime\n\n    if (this.mtime != null) {\n      mtime = {\n        Seconds: this.mtime.secs,\n        FractionalNanoseconds: this.mtime.nsecs\n      }\n    }\n\n    return PBData.encode({\n      Type: type,\n      Data: data,\n      filesize: this.isDirectory() ? undefined : this.fileSize(),\n      blocksizes: this.blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode,\n      mtime\n    })\n  }\n}\n\nexport { UnixFS }\nexport * from './errors.js'\n", "import { coerce } from '../bytes.js'\nimport type { ArrayBufferView, ByteView } from './interface.js'\n\nexport const name = 'raw'\nexport const code = 0x55\n\nexport function encode (node: Uint8Array): ByteView<Uint8Array> {\n  return coerce(node)\n}\n\nexport function decode (data: ByteView<Uint8Array> | ArrayBufferView<Uint8Array>): Uint8Array {\n  return coerce(data)\n}\n", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n", "import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode }: { name: Name, code: Code, encode(input: Uint8Array): Await<Uint8Array> }): Hasher<Name, Code> {\n  return new Hasher(name, code, encode)\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  digest (input: Uint8Array): Await<Digest.Digest<Code, number>> {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as dagPb from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport type { WritableStorage } from '../index.js'\nimport type { Version as CIDVersion } from 'multiformats/cid'\nimport type { BlockCodec } from 'multiformats/codecs/interface'\nimport type { ProgressOptions } from 'progress-events'\n\nexport interface PersistOptions extends ProgressOptions {\n  codec?: BlockCodec<any, any>\n  cidVersion: CIDVersion\n  signal?: AbortSignal\n}\n\nexport const persist = async (buffer: Uint8Array, blockstore: WritableStorage, options: PersistOptions): Promise<CID> => {\n  if (options.codec == null) {\n    options.codec = dagPb\n  }\n\n  const multihash = await sha256.digest(buffer)\n  const cid = CID.create(options.cidVersion, options.codec.code, multihash)\n\n  await blockstore.put(cid, buffer, options)\n\n  return cid\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport * as raw from 'multiformats/codecs/raw'\nimport { CustomProgressEvent } from 'progress-events'\nimport { persist } from '../utils/persist.js'\nimport type { BufferImporter } from '../index.js'\nimport type { PersistOptions } from '../utils/persist.js'\nimport type { CID, Version } from 'multiformats/cid'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\n/**\n * Passed to the onProgress callback while importing files\n */\nexport interface ImportWriteProgress {\n  /**\n   * How many bytes we have written for this source so far - this may be\n   * bigger than the file size due to the DAG-PB wrappers of each block\n   */\n  bytesWritten: bigint\n\n  /**\n   * The CID of the block that has been written\n   */\n  cid: CID\n\n  /**\n   * The path of the file being imported, if one was specified\n   */\n  path?: string\n}\n\nexport type BufferImportProgressEvents =\n  ProgressEvent<'unixfs:importer:progress:file:write', ImportWriteProgress>\n\nexport interface BufferImporterOptions extends ProgressOptions<BufferImportProgressEvents> {\n  cidVersion: Version\n  rawLeaves: boolean\n  leafType: 'file' | 'raw'\n}\n\nexport function defaultBufferImporter (options: BufferImporterOptions): BufferImporter {\n  return async function * bufferImporter (file, blockstore) {\n    let bytesWritten = 0n\n\n    for await (let block of file.content) {\n      yield async () => { // eslint-disable-line no-loop-func\n        let unixfs\n\n        const opts: PersistOptions = {\n          codec: dagPb,\n          cidVersion: options.cidVersion,\n          onProgress: options.onProgress\n        }\n\n        if (options.rawLeaves) {\n          opts.codec = raw\n          opts.cidVersion = 1\n        } else {\n          unixfs = new UnixFS({\n            type: options.leafType,\n            data: block\n          })\n\n          block = dagPb.encode({\n            Data: unixfs.marshal(),\n            Links: []\n          })\n        }\n\n        const cid = await persist(block, blockstore, opts)\n\n        bytesWritten += BigInt(block.byteLength)\n\n        options.onProgress?.(new CustomProgressEvent<ImportWriteProgress>('unixfs:importer:progress:file:write', {\n          bytesWritten,\n          cid,\n          path: file.path\n        }))\n\n        return {\n          cid,\n          unixfs,\n          size: BigInt(block.length),\n          block\n        }\n      }\n    }\n  }\n}\n", "export class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n  static code = 'ERR_INVALID_PARAMS'\n  name = InvalidParametersError.name\n  code = InvalidParametersError.code\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n  }\n}\n\nexport class InvalidAvgChunkSizeError extends Error {\n  static name = 'InvalidAvgChunkSizeError'\n  static code = 'ERR_INVALID_AVG_CHUNK_SIZE'\n  name = InvalidAvgChunkSizeError.name\n  code = InvalidAvgChunkSizeError.code\n\n  constructor (message = 'Invalid avg chunk size') {\n    super(message)\n  }\n}\n\nexport class InvalidChunkSizeError extends Error {\n  static name = 'InvalidChunkSizeError'\n  static code = 'ERR_INVALID_CHUNK_SIZE'\n  name = InvalidChunkSizeError.name\n  code = InvalidChunkSizeError.code\n\n  constructor (message = 'Invalid chunk size') {\n    super(message)\n  }\n}\n\nexport class InvalidMinChunkSizeError extends Error {\n  static name = 'InvalidMinChunkSizeError'\n  static code = 'ERR_INVALID_MIN_CHUNK_SIZE'\n  name = InvalidMinChunkSizeError.name\n  code = InvalidMinChunkSizeError.code\n\n  constructor (message = 'Invalid min chunk size') {\n    super(message)\n  }\n}\n\nexport class InvalidContentError extends Error {\n  static name = 'InvalidContentError'\n  static code = 'ERR_INVALID_CONTENT'\n  name = InvalidContentError.name\n  code = InvalidContentError.code\n\n  constructor (message = 'Invalid content') {\n    super(message)\n  }\n}\n", "import { encode, prepare } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { persist } from '../utils/persist.js'\nimport type { Directory, InProgressImportResult, WritableStorage } from '../index.js'\nimport type { Version } from 'multiformats/cid'\n\nexport interface DirBuilderOptions {\n  cidVersion: Version\n  signal?: AbortSignal\n}\n\nexport interface DirBuilder {\n  (dir: Directory, blockstore: WritableStorage, options: DirBuilderOptions): Promise<InProgressImportResult>\n}\n\nexport const defaultDirBuilder: DirBuilder = async (dir: Directory, blockstore: WritableStorage, options: DirBuilderOptions): Promise<InProgressImportResult> => {\n  const unixfs = new UnixFS({\n    type: 'directory',\n    mtime: dir.mtime,\n    mode: dir.mode\n  })\n\n  const block = encode(prepare({ Data: unixfs.marshal() }))\n  const cid = await persist(block, blockstore, options)\n  const path = dir.path\n\n  return {\n    cid,\n    path,\n    unixfs,\n    size: BigInt(block.length),\n    originalPath: dir.originalPath,\n    block\n  }\n}\n", "import { encode, prepare } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport parallelBatch from 'it-parallel-batch'\nimport * as rawCodec from 'multiformats/codecs/raw'\nimport { CustomProgressEvent } from 'progress-events'\nimport { persist } from '../utils/persist.js'\nimport type { BufferImporter, File, InProgressImportResult, WritableStorage, SingleBlockImportResult, ImporterProgressEvents } from '../index.js'\nimport type { FileLayout, Reducer } from '../layout/index.js'\nimport type { PBLink, PBNode } from '@ipld/dag-pb'\nimport type { CID, Version } from 'multiformats/cid'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\ninterface BuildFileBatchOptions {\n  bufferImporter: BufferImporter\n  blockWriteConcurrency: number\n}\n\nasync function * buildFileBatch (file: File, blockstore: WritableStorage, options: BuildFileBatchOptions): AsyncGenerator<InProgressImportResult> {\n  let count = -1\n  let previous: SingleBlockImportResult | undefined\n\n  for await (const entry of parallelBatch(options.bufferImporter(file, blockstore), options.blockWriteConcurrency)) {\n    count++\n\n    if (count === 0) {\n      // cache the first entry if case there aren't any more\n      previous = {\n        ...entry,\n        single: true\n      }\n\n      continue\n    } else if (count === 1 && previous != null) {\n      // we have the second block of a multiple block import so yield the first\n      yield {\n        ...previous,\n        block: undefined,\n        single: undefined\n      }\n      previous = undefined\n    }\n\n    // yield the second or later block of a multiple block import\n    yield {\n      ...entry,\n      block: undefined\n    }\n  }\n\n  if (previous != null) {\n    yield previous\n  }\n}\n\nexport interface LayoutLeafProgress {\n  /**\n   * The CID of the leaf being written\n   */\n  cid: CID\n\n  /**\n   * The path of the file being imported, if one was specified\n   */\n  path?: string\n}\n\nexport type ReducerProgressEvents =\n  ProgressEvent<'unixfs:importer:progress:file:layout', LayoutLeafProgress>\n\ninterface ReduceOptions extends ProgressOptions<ImporterProgressEvents> {\n  reduceSingleLeafToSelf: boolean\n  cidVersion: Version\n  signal?: AbortSignal\n}\n\nfunction isSingleBlockImport (result: any): result is SingleBlockImportResult {\n  return result.single === true\n}\n\nconst reduce = (file: File, blockstore: WritableStorage, options: ReduceOptions): Reducer => {\n  const reducer: Reducer = async function (leaves) {\n    if (leaves.length === 1 && isSingleBlockImport(leaves[0]) && options.reduceSingleLeafToSelf) {\n      const leaf = leaves[0]\n      let node: Uint8Array | PBNode = leaf.block\n\n      if (isSingleBlockImport(leaf) && (file.mtime !== undefined || file.mode !== undefined)) {\n        // only one leaf node which is a raw leaf - we have metadata so convert it into a\n        // UnixFS entry otherwise we'll have nowhere to store the metadata\n        leaf.unixfs = new UnixFS({\n          type: 'file',\n          mtime: file.mtime,\n          mode: file.mode,\n          data: leaf.block\n        })\n\n        node = { Data: leaf.unixfs.marshal(), Links: [] }\n\n        leaf.block = encode(prepare(node))\n\n        leaf.cid = await persist(leaf.block, blockstore, {\n          ...options,\n          cidVersion: options.cidVersion\n        })\n        leaf.size = BigInt(leaf.block.length)\n      }\n\n      options.onProgress?.(new CustomProgressEvent<LayoutLeafProgress>('unixfs:importer:progress:file:layout', {\n        cid: leaf.cid,\n        path: leaf.originalPath\n      }))\n\n      return {\n        cid: leaf.cid,\n        path: file.path,\n        unixfs: leaf.unixfs,\n        size: leaf.size,\n        originalPath: leaf.originalPath\n      }\n    }\n\n    // create a parent node and add all the leaves\n    const f = new UnixFS({\n      type: 'file',\n      mtime: file.mtime,\n      mode: file.mode\n    })\n\n    const links: PBLink[] = leaves\n      .filter(leaf => {\n        if (leaf.cid.code === rawCodec.code && leaf.size > 0) {\n          return true\n        }\n\n        if (leaf.unixfs != null && leaf.unixfs.data == null && leaf.unixfs.fileSize() > 0n) {\n          return true\n        }\n\n        return Boolean(leaf.unixfs?.data?.length)\n      })\n      .map((leaf) => {\n        if (leaf.cid.code === rawCodec.code) {\n          // node is a leaf buffer\n          f.addBlockSize(leaf.size)\n\n          return {\n            Name: '',\n            Tsize: Number(leaf.size),\n            Hash: leaf.cid\n          }\n        }\n\n        if ((leaf.unixfs?.data == null)) {\n          // node is an intermediate node\n          f.addBlockSize(leaf.unixfs?.fileSize() ?? 0n)\n        } else {\n          // node is a unixfs 'file' leaf node\n          f.addBlockSize(BigInt(leaf.unixfs.data.length))\n        }\n\n        return {\n          Name: '',\n          Tsize: Number(leaf.size),\n          Hash: leaf.cid\n        }\n      })\n\n    const node = {\n      Data: f.marshal(),\n      Links: links\n    }\n    const block = encode(prepare(node))\n    const cid = await persist(block, blockstore, options)\n\n    options.onProgress?.(new CustomProgressEvent<LayoutLeafProgress>('unixfs:importer:progress:file:layout', {\n      cid,\n      path: file.originalPath\n    }))\n\n    return {\n      cid,\n      path: file.path,\n      unixfs: f,\n      size: BigInt(block.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0)),\n      originalPath: file.originalPath,\n      block\n    }\n  }\n\n  return reducer\n}\n\nexport interface FileBuilder {\n  (file: File, blockstore: WritableStorage, options: FileBuilderOptions): Promise<InProgressImportResult>\n}\n\nexport interface FileBuilderOptions extends BuildFileBatchOptions, ReduceOptions {\n  layout: FileLayout\n}\n\nexport const defaultFileBuilder: FileBuilder = async (file: File, block: WritableStorage, options: FileBuilderOptions): Promise<InProgressImportResult> => {\n  return options.layout(\n    buildFileBatch(file, block, options),\n    reduce(file, block, options)\n  )\n}\n", "import { CustomProgressEvent } from 'progress-events'\nimport { InvalidContentError } from '../errors.js'\nimport { defaultDirBuilder } from './dir.js'\nimport { defaultFileBuilder } from './file.js'\nimport type { DirBuilder, DirBuilderOptions } from './dir.js'\nimport type { FileBuilder, FileBuilderOptions } from './file.js'\nimport type { ChunkValidator } from './validate-chunks.js'\nimport type { Chunker } from '../chunker/index.js'\nimport type { Directory, File, FileCandidate, ImportCandidate, ImporterProgressEvents, InProgressImportResult, WritableStorage } from '../index.js'\nimport type { ProgressEvent, ProgressOptions } from 'progress-events'\n\n/**\n * Passed to the onProgress callback while importing files\n */\nexport interface ImportReadProgress {\n  /**\n   * How many bytes we have read from this source so far\n   */\n  bytesRead: bigint\n\n  /**\n   * The size of the current chunk\n   */\n  chunkSize: bigint\n\n  /**\n   * The path of the file being imported, if one was specified\n   */\n  path?: string\n}\n\nexport type DagBuilderProgressEvents =\n  ProgressEvent<'unixfs:importer:progress:file:read', ImportReadProgress>\n\nfunction isIterable (thing: any): thing is Iterable<any> {\n  return Symbol.iterator in thing\n}\n\nfunction isAsyncIterable (thing: any): thing is AsyncIterable<any> {\n  return Symbol.asyncIterator in thing\n}\n\nfunction contentAsAsyncIterable (content: Uint8Array | AsyncIterable<Uint8Array> | Iterable<Uint8Array>): AsyncIterable<Uint8Array> {\n  try {\n    if (content instanceof Uint8Array) {\n      return (async function * () {\n        yield content\n      })()\n    } else if (isIterable(content)) {\n      return (async function * () {\n        yield * content\n      })()\n    } else if (isAsyncIterable(content)) {\n      return content\n    }\n  } catch {\n    throw new InvalidContentError('Content was invalid')\n  }\n\n  throw new InvalidContentError('Content was invalid')\n}\n\nexport interface DagBuilderOptions extends FileBuilderOptions, DirBuilderOptions, ProgressOptions<ImporterProgressEvents> {\n  chunker: Chunker\n  chunkValidator: ChunkValidator\n  wrapWithDirectory: boolean\n  dirBuilder?: DirBuilder\n  fileBuilder?: FileBuilder\n}\n\nexport type ImporterSourceStream = AsyncIterable<ImportCandidate> | Iterable<ImportCandidate>\n\nexport interface DAGBuilder {\n  (source: ImporterSourceStream, blockstore: WritableStorage): AsyncIterable<() => Promise<InProgressImportResult>>\n}\n\nexport function defaultDagBuilder (options: DagBuilderOptions): DAGBuilder {\n  return async function * dagBuilder (source, blockstore) {\n    for await (const entry of source) {\n      let originalPath: string | undefined\n\n      if (entry.path != null) {\n        originalPath = entry.path\n        entry.path = entry.path\n          .split('/')\n          .filter(path => path != null && path !== '.')\n          .join('/')\n      }\n\n      if (isFileCandidate(entry)) {\n        const file: File = {\n          path: entry.path,\n          mtime: entry.mtime,\n          mode: entry.mode,\n          content: (async function * () {\n            let bytesRead = 0n\n\n            for await (const chunk of options.chunker(options.chunkValidator(contentAsAsyncIterable(entry.content)))) {\n              const currentChunkSize = BigInt(chunk.byteLength)\n              bytesRead += currentChunkSize\n\n              options.onProgress?.(new CustomProgressEvent<ImportReadProgress>('unixfs:importer:progress:file:read', {\n                bytesRead,\n                chunkSize: currentChunkSize,\n                path: entry.path\n              }))\n\n              yield chunk\n            }\n          })(),\n          originalPath\n        }\n\n        const fileBuilder = options.fileBuilder ?? defaultFileBuilder\n\n        yield async () => fileBuilder(file, blockstore, options)\n      } else if (entry.path != null) {\n        const dir: Directory = {\n          path: entry.path,\n          mtime: entry.mtime,\n          mode: entry.mode,\n          originalPath\n        }\n\n        const dirBuilder = options.dirBuilder ?? defaultDirBuilder\n\n        yield async () => dirBuilder(dir, blockstore, options)\n      } else {\n        throw new Error('Import candidate must have content or path or both')\n      }\n    }\n  }\n}\n\nfunction isFileCandidate (entry: any): entry is FileCandidate {\n  return entry.content != null\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { InvalidContentError } from '../errors.js'\n\nexport interface ChunkValidator { (source: AsyncIterable<Uint8Array>): AsyncIterable<Uint8Array> }\n\nexport const defaultChunkValidator = (): ChunkValidator => {\n  return async function * validateChunks (source) {\n    for await (const content of source) {\n      if (content.length === undefined) {\n        throw new InvalidContentError('Content was invalid')\n      }\n\n      if (typeof content === 'string' || content instanceof String) {\n        yield uint8ArrayFromString(content.toString())\n      } else if (Array.isArray(content)) {\n        yield Uint8Array.from(content)\n      } else if (content instanceof Uint8Array) {\n        yield content\n      } else {\n        throw new InvalidContentError('Content was invalid')\n      }\n    }\n  }\n}\n", "import batch from 'it-batch'\nimport type { FileLayout } from './index.js'\nimport type { InProgressImportResult } from '../index.js'\n\nconst DEFAULT_MAX_CHILDREN_PER_NODE = 174\n\nexport interface BalancedOptions {\n  maxChildrenPerNode?: number\n}\n\nexport function balanced (options?: BalancedOptions): FileLayout {\n  const maxChildrenPerNode = options?.maxChildrenPerNode ?? DEFAULT_MAX_CHILDREN_PER_NODE\n\n  return async function balancedLayout (source, reduce): Promise<InProgressImportResult> {\n    const roots = []\n\n    for await (const chunked of batch(source, maxChildrenPerNode)) {\n      roots.push(await reduce(chunked))\n    }\n\n    if (roots.length > 1) {\n      return balancedLayout(roots, reduce)\n    }\n\n    return roots[0]\n  }\n}\n", "import { CID } from 'multiformats/cid'\nimport type { WritableStorage, ImportResult, InProgressImportResult } from './index.js'\nimport type { PersistOptions } from './utils/persist.js'\nimport type { Mtime, UnixFS } from 'ipfs-unixfs'\n\nexport interface DirProps {\n  root: boolean\n  dir: boolean\n  path: string\n  dirty: boolean\n  flat: boolean\n  parent?: Dir\n  parentKey?: string\n  unixfs?: UnixFS\n  mode?: number\n  mtime?: Mtime\n}\n\nexport abstract class Dir {\n  public options: PersistOptions\n  public root: boolean\n  public dir: boolean\n  public path: string\n  public dirty: boolean\n  public flat: boolean\n  public parent?: Dir\n  public parentKey?: string\n  public unixfs?: UnixFS\n  public mode?: number\n  public mtime?: Mtime\n  public cid?: CID\n  public size?: number\n  public nodeSize?: number\n\n  constructor (props: DirProps, options: PersistOptions) {\n    this.options = options ?? {}\n\n    this.root = props.root\n    this.dir = props.dir\n    this.path = props.path\n    this.dirty = props.dirty\n    this.flat = props.flat\n    this.parent = props.parent\n    this.parentKey = props.parentKey\n    this.unixfs = props.unixfs\n    this.mode = props.mode\n    this.mtime = props.mtime\n  }\n\n  abstract put (name: string, value: InProgressImportResult | Dir): Promise<void>\n  abstract get (name: string): Promise<InProgressImportResult | Dir | undefined>\n  abstract eachChildSeries (): Iterable<{ key: string, child: InProgressImportResult | Dir }>\n  abstract flush (blockstore: WritableStorage): AsyncGenerator<ImportResult>\n  abstract estimateNodeSize (): number\n  abstract childCount (): number\n}\n\n// we use these to calculate the node size to use as a check for whether a directory\n// should be sharded or not. Since CIDs have a constant length and We're only\n// interested in the data length and not the actual content identifier we can use\n// any old CID instead of having to hash the data which is expensive.\nexport const CID_V0 = CID.parse('QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn')\nexport const CID_V1 = CID.parse('zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi')\n", "import { encode, prepare } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { Dir, CID_V0, CID_V1 } from './dir.js'\nimport { persist } from './utils/persist.js'\nimport type { DirProps } from './dir.js'\nimport type { ImportResult, InProgressImportResult } from './index.js'\nimport type { PersistOptions } from './utils/persist.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { CID } from 'multiformats/cid'\n\nexport class DirFlat extends Dir {\n  private readonly _children: Map<string, InProgressImportResult | Dir>\n\n  constructor (props: DirProps, options: PersistOptions) {\n    super(props, options)\n\n    this._children = new Map()\n  }\n\n  async put (name: string, value: InProgressImportResult | Dir): Promise<void> {\n    this.cid = undefined\n    this.size = undefined\n    this.nodeSize = undefined\n\n    this._children.set(name, value)\n  }\n\n  async get (name: string): Promise<InProgressImportResult | Dir | undefined> {\n    return Promise.resolve(this._children.get(name))\n  }\n\n  childCount (): number {\n    return this._children.size\n  }\n\n  directChildrenCount (): number {\n    return this.childCount()\n  }\n\n  onlyChild (): InProgressImportResult | Dir | undefined {\n    return this._children.values().next().value\n  }\n\n  * eachChildSeries (): Generator<{ key: string, child: InProgressImportResult | Dir }, void, undefined> {\n    for (const [key, child] of this._children.entries()) {\n      yield {\n        key,\n        child\n      }\n    }\n  }\n\n  estimateNodeSize (): number {\n    if (this.nodeSize !== undefined) {\n      return this.nodeSize\n    }\n\n    this.nodeSize = 0\n\n    // estimate size only based on DAGLink name and CID byte lengths\n    // https://github.com/ipfs/go-unixfsnode/blob/37b47f1f917f1b2f54c207682f38886e49896ef9/data/builder/directory.go#L81-L96\n    for (const [name, child] of this._children.entries()) {\n      if (child.size != null && (child.cid != null)) {\n        this.nodeSize += name.length + (this.options.cidVersion === 1 ? CID_V1.bytes.byteLength : CID_V0.bytes.byteLength)\n      }\n    }\n\n    return this.nodeSize\n  }\n\n  async * flush (block: Blockstore): AsyncGenerator<ImportResult> {\n    const links = []\n\n    for (const [name, child] of this._children.entries()) {\n      let result: { size?: bigint | number, cid?: CID } = child\n\n      if (child instanceof Dir) {\n        for await (const entry of child.flush(block)) {\n          result = entry\n\n          yield entry\n        }\n      }\n\n      if (result.size != null && (result.cid != null)) {\n        links.push({\n          Name: name,\n          Tsize: Number(result.size),\n          Hash: result.cid\n        })\n      }\n    }\n\n    const unixfs = new UnixFS({\n      type: 'directory',\n      mtime: this.mtime,\n      mode: this.mode\n    })\n\n    const node: PBNode = { Data: unixfs.marshal(), Links: links }\n    const buffer = encode(prepare(node))\n    const cid = await persist(buffer, block, this.options)\n    const size = buffer.length + node.Links.reduce(\n      /**\n       * @param {number} acc\n       * @param {PBLink} curr\n       */\n      (acc, curr) => acc + (curr.Tsize ?? 0),\n      0)\n\n    this.cid = cid\n    this.size = size\n\n    yield {\n      cid,\n      unixfs,\n      path: this.path,\n      size: BigInt(size)\n    }\n  }\n}\n", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n", "import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode }: { name: Name, code: Code, encode(input: Uint8Array): Await<Uint8Array> }): Hasher<Name, Code> {\n  return new Hasher(name, code, encode)\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  digest (input: Uint8Array): Await<Digest.Digest<Code, number>> {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n", "import { bytes } from 'multiformats'\nimport { from } from 'multiformats/hashes/hasher'\n// @ts-expect-error no types\nimport mur from 'murmurhash3js-revisited'\n\n/**\n * @param {number} number\n * @returns {Uint8Array}\n */\nfunction fromNumberTo32BitBuf (number) {\n  const bytes = new Array(4)\n  for (let i = 0; i < 4; i++) {\n    bytes[i] = number & 0xff\n    number = number >> 8\n  }\n  return new Uint8Array(bytes)\n}\n\nexport const murmur332 = from({\n  name: 'murmur3-32',\n  code: 0x23,\n  encode: (input) => fromNumberTo32BitBuf(mur.x86.hash32(input))\n})\n\nexport const murmur3128 = from({\n  name: 'murmur3-128',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input))\n})\n\n// A special-use 0x22 that truncates 64 bits, specifically for use in the UnixFS HAMT\nexport const murmur364 = from({\n  name: 'murmur3-x64-64',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input)).subarray(0, 8)\n})\n", "// @ts-expect-error no types\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { InfiniteHash } from './consumable-hash.js'\n\nexport interface BucketChild<V> {\n  key: string\n  value: V\n  hash: InfiniteHash\n}\n\ninterface SA<B> {\n  length: number\n  compactArray(): B[]\n  get(i: number): B\n  set(i: number, value: B): void\n  reduce <A> (fn: (acc: A, curr: B, index: number) => A, initial: A): B\n  find(fn: (item: B) => boolean): B | undefined\n  bitField(): number[]\n  unset(i: number): void\n}\n\nexport interface BucketPosition<T> {\n  bucket: Bucket<T>\n  pos: number\n  hash: InfiniteHash\n  existingChild?: BucketChild<T>\n}\n\nexport interface BucketOptions {\n  bits: number\n  hash(value: Uint8Array | InfiniteHash): InfiniteHash\n}\n\nexport class Bucket<T> {\n  _options: BucketOptions\n  _popCount: number\n  _parent?: Bucket<T>\n  _posAtParent: number\n  _children: SA<Bucket<T> | BucketChild<T>>\n\n  key: string | null\n\n  constructor (options: BucketOptions, parent?: Bucket<T>, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n    this._children = new SparseArray()\n    this.key = null\n  }\n\n  async put (key: string, value: T): Promise<void> {\n    const place = await this._findNewBucketAndPos(key)\n\n    place.bucket._putAt(place, key, value)\n  }\n\n  async get (key: string): Promise<T | undefined> {\n    const child = await this._findChild(key)\n\n    if (child != null) {\n      return child.value\n    }\n  }\n\n  async del (key: string): Promise<void> {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child != null && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  leafCount (): number {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount (): number {\n    return this._children.length\n  }\n\n  onlyChild (): Bucket<T> | BucketChild<T> {\n    return this._children.get(0)\n  }\n\n  * eachLeafSeries (): Iterable<BucketChild<T>> {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n  }\n\n  serialize <M> (map: (value: BucketChild<T>, index: number) => M, reduce: (reduced: Bucket<T> | BucketChild<T>) => M): M {\n    const acc: M[] = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child != null) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  async asyncTransform <R = T> (asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<R>): Promise<R> {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON (): Record<string, any> {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint (): string {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize (): number {\n    return Math.pow(2, this._options.bits)\n  }\n\n  async _findChild (key: string): Promise<BucketChild<T> | undefined> {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child != null && child.key === key) {\n      return child\n    }\n  }\n\n  async _findPlace (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  async _findNewBucketAndPos (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const place = await this._findPlace(key)\n\n    if ((place.existingChild != null) && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  _putAt (place: BucketPosition<T>, key: string, value: T): void {\n    this._putObjectAt(place.pos, {\n      key,\n      value,\n      hash: place.hash\n    })\n  }\n\n  _putObjectAt (pos: number, object: Bucket<T> | BucketChild<T>): void {\n    if (this._children.get(pos) == null) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  _delAt (pos: number): void {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos) != null) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level (): void {\n    if (this._parent != null && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if ((onlyChild != null) && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  _at (index: number): Bucket<T> | BucketChild<T> {\n    return this._children.get(index)\n  }\n}\n\nfunction exists (o: any): boolean {\n  return Boolean(o)\n}\n\nfunction mapNode (node: { key: string }, _: number): string {\n  return node.key\n}\n\nfunction reduceNodes <T> (nodes: T): any {\n  return nodes\n}\n\nasync function asyncTransformBucket <T, R = T> (bucket: Bucket<T>, asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<R>): Promise<R> {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n", "const START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nexport class ConsumableBuffer {\n  _value: Uint8Array\n  _currentBytePos: number\n  _currentBitPos: number\n\n  constructor (value: Uint8Array) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits (): number {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits (): number {\n    return this._value.length * 8\n  }\n\n  take (bits: number): number {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits > 0 && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits (): boolean {\n    return this._currentBytePos >= 0\n  }\n}\n\nfunction byteBitsToInt (byte: number, start: number, length: number): number {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\nfunction maskFor (start: number, length: number): number {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { ConsumableBuffer } from './consumable-buffer.js'\n\nexport function wrapHash (hashFn: (value: Uint8Array) => Promise<Uint8Array>): (value: InfiniteHash | Uint8Array) => InfiniteHash {\n  function hashing (value: InfiniteHash | Uint8Array): InfiniteHash {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nexport class InfiniteHash {\n  _value: Uint8Array\n  _hashFn: (value: Uint8Array) => Promise<Uint8Array>\n  _depth: number\n  _availableBits: number\n  _currentBufferIndex: number\n  _buffers: ConsumableBuffer[]\n\n  constructor (value: Uint8Array, hashFn: (value: Uint8Array) => Promise<Uint8Array>) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n    this._buffers = []\n  }\n\n  async take (bits: number): Promise<number> {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits (): Promise<void> {\n    this._depth++\n\n    const value = this._depth > 0 ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A [Hash Mapped Trie](https://en.wikipedia.org/wiki/Hash_array_mapped_trie) implementation for JavaScript.\n *\n * This is used by [@helia/unixfs](https://www.npmjs.com/package/@helia/unixfs) for it's HAMT-sharded directory implementation.\n *\n * @example\n *\n * ```TypeScript\n * import { createHAMT } from 'hamt-sharding'\n * import crypto from 'crypto-promise'\n *\n * // decide how to hash buffers made from keys, can return a Promise\n * const hashFn = async (buf) => {\n *   return crypto\n *     .createHash('sha256')\n *     .update(buf)\n *     .digest()\n * }\n *\n * const bucket = createHAMT({\n *   hashFn: hashFn\n * })\n *\n * await bucket.put('key', 'value')\n *\n * const output = await bucket.get('key')\n * // output === 'value'\n * ```\n */\n\nimport { Bucket } from './bucket.js'\nimport { wrapHash } from './consumable-hash.js'\nimport type { BucketOptions, BucketPosition, BucketChild } from './bucket.js'\n\ninterface UserBucketOptions {\n  hashFn(value: Uint8Array): Promise<Uint8Array>\n  bits?: number\n}\n\nexport function createHAMT<T> (options: UserBucketOptions): Bucket<T> {\n  if (options == null || options.hashFn == null) {\n    throw new Error('please define an options.hashFn')\n  }\n\n  const bucketOptions = {\n    bits: options.bits ?? 8,\n    hash: wrapHash(options.hashFn)\n  }\n\n  return new Bucket<T>(bucketOptions)\n}\n\nexport { Bucket }\nexport type { BucketOptions, BucketPosition, BucketChild }\n", "import { encode, prepare } from '@ipld/dag-pb'\nimport { murmur3128 } from '@multiformats/murmur3'\nimport { createHAMT, Bucket } from 'hamt-sharding'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { Dir, CID_V0, CID_V1 } from './dir.js'\nimport { persist } from './utils/persist.js'\nimport type { DirProps } from './dir.js'\nimport type { ImportResult, InProgressImportResult } from './index.js'\nimport type { PersistOptions } from './utils/persist.js'\nimport type { PBLink } from '@ipld/dag-pb'\nimport type { BucketChild } from 'hamt-sharding'\nimport type { Blockstore } from 'interface-blockstore'\n\nasync function hamtHashFn (buf: Uint8Array): Promise<Uint8Array> {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .slice(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n\nconst HAMT_HASH_CODE = BigInt(0x22)\nconst DEFAULT_FANOUT_BITS = 8\n\nexport interface DirShardedOptions extends PersistOptions {\n  shardFanoutBits: number\n}\n\nclass DirSharded extends Dir {\n  private readonly _bucket: Bucket<InProgressImportResult | Dir>\n\n  constructor (props: DirProps, options: DirShardedOptions) {\n    super(props, options)\n\n    this._bucket = createHAMT({\n      hashFn: hamtHashFn,\n      bits: options.shardFanoutBits ?? DEFAULT_FANOUT_BITS\n    })\n  }\n\n  async put (name: string, value: InProgressImportResult | Dir): Promise<void> {\n    this.cid = undefined\n    this.size = undefined\n    this.nodeSize = undefined\n\n    await this._bucket.put(name, value)\n  }\n\n  async get (name: string): Promise<InProgressImportResult | Dir | undefined> {\n    return this._bucket.get(name)\n  }\n\n  childCount (): number {\n    return this._bucket.leafCount()\n  }\n\n  directChildrenCount (): number {\n    return this._bucket.childrenCount()\n  }\n\n  onlyChild (): Bucket<InProgressImportResult | Dir> | BucketChild<InProgressImportResult | Dir> {\n    return this._bucket.onlyChild()\n  }\n\n  * eachChildSeries (): Generator<{ key: string, child: InProgressImportResult | Dir }> {\n    for (const { key, value } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      }\n    }\n  }\n\n  estimateNodeSize (): number {\n    if (this.nodeSize !== undefined) {\n      return this.nodeSize\n    }\n\n    this.nodeSize = calculateSize(this._bucket, this, this.options)\n\n    return this.nodeSize\n  }\n\n  async * flush (blockstore: Blockstore): AsyncGenerator<ImportResult> {\n    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n      yield {\n        ...entry,\n        path: this.path\n      }\n    }\n  }\n}\n\nexport default DirSharded\n\nasync function * flush (bucket: Bucket<Dir | InProgressImportResult>, blockstore: Blockstore, shardRoot: DirSharded | null, options: PersistOptions): AsyncIterable<ImportResult> {\n  const children = bucket._children\n  const padLength = (bucket.tableSize() - 1).toString(16).length\n  const links: PBLink[] = []\n  let childrenSize = 0n\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (child == null) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(padLength, '0')\n\n    if (child instanceof Bucket) {\n      let shard\n\n      for await (const subShard of flush(child, blockstore, null, options)) {\n        shard = subShard\n      }\n\n      if (shard == null) {\n        throw new Error('Could not flush sharded directory, no subshard found')\n      }\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: Number(shard.size),\n        Hash: shard.cid\n      })\n      childrenSize += shard.size\n    } else if (isDir(child.value)) {\n      const dir = child.value\n      let flushedDir: ImportResult | undefined\n\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry\n\n        yield flushedDir\n      }\n\n      if (flushedDir == null) {\n        throw new Error('Did not flush dir')\n      }\n\n      const label = labelPrefix + child.key\n      links.push({\n        Name: label,\n        Tsize: Number(flushedDir.size),\n        Hash: flushedDir.cid\n      })\n\n      childrenSize += flushedDir.size\n    } else {\n      const value = child.value\n\n      if (value.cid == null) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: Number(size),\n        Hash: value.cid\n      })\n      childrenSize += BigInt(size ?? 0)\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: BigInt(bucket.tableSize()),\n    hashType: HAMT_HASH_CODE,\n    mtime: shardRoot?.mtime,\n    mode: shardRoot?.mode\n  })\n\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  }\n  const buffer = encode(prepare(node))\n  const cid = await persist(buffer, blockstore, options)\n  const size = BigInt(buffer.byteLength) + childrenSize\n\n  yield {\n    cid,\n    unixfs: dir,\n    size\n  }\n}\n\nfunction isDir (obj: any): obj is Dir {\n  return typeof obj.flush === 'function'\n}\n\nfunction calculateSize (bucket: Bucket<any>, shardRoot: DirSharded | null, options: PersistOptions): number {\n  const children = bucket._children\n  const padLength = (bucket.tableSize() - 1).toString(16).length\n  const links: PBLink[] = []\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (child == null) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(padLength, '0')\n\n    if (child instanceof Bucket) {\n      const size = calculateSize(child, null, options)\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: Number(size),\n        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n      })\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value\n      const size = dir.nodeSize()\n\n      links.push({\n        Name: labelPrefix + child.key,\n        Tsize: Number(size),\n        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n      })\n    } else {\n      const value = child.value\n\n      if (value.cid == null) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: Number(size),\n        Hash: value.cid\n      })\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: BigInt(bucket.tableSize()),\n    hashType: HAMT_HASH_CODE,\n    mtime: shardRoot?.mtime,\n    mode: shardRoot?.mode\n  })\n\n  const buffer = encode(prepare({\n    Data: dir.marshal(),\n    Links: links\n  }))\n\n  return buffer.length\n}\n", "import { DirFlat } from './dir-flat.js'\nimport DirSharded from './dir-sharded.js'\nimport type { DirShardedOptions } from './dir-sharded.js'\nimport type { Dir } from './dir.js'\n\nexport async function flatToShard (child: Dir | null, dir: Dir, threshold: number, options: DirShardedOptions): Promise<DirSharded> {\n  let newDir = dir as DirSharded\n\n  if (dir instanceof DirFlat && dir.estimateNodeSize() > threshold) {\n    newDir = await convertToShard(dir, options)\n  }\n\n  const parent = newDir.parent\n\n  if (parent != null) {\n    if (newDir !== dir) {\n      if (child != null) {\n        child.parent = newDir\n      }\n\n      if (newDir.parentKey == null) {\n        throw new Error('No parent key found')\n      }\n\n      await parent.put(newDir.parentKey, newDir)\n    }\n\n    return flatToShard(newDir, parent, threshold, options)\n  }\n\n  return newDir\n}\n\nasync function convertToShard (oldDir: DirFlat, options: DirShardedOptions): Promise<DirSharded> {\n  const newDir = new DirSharded({\n    root: oldDir.root,\n    dir: true,\n    parent: oldDir.parent,\n    parentKey: oldDir.parentKey,\n    path: oldDir.path,\n    dirty: oldDir.dirty,\n    flat: false,\n    mtime: oldDir.mtime,\n    mode: oldDir.mode\n  }, options)\n\n  for (const { key, child } of oldDir.eachChildSeries()) {\n    await newDir.put(key, child)\n  }\n\n  return newDir\n}\n", "export const toPathComponents = (path: string = ''): string[] => {\n  // split on / unless escaped with \\\n  return path.split(/(?<!\\\\)\\//).filter(Boolean)\n}\n", "import { DirFlat } from './dir-flat.js'\nimport { Dir } from './dir.js'\nimport { flatToShard } from './flat-to-shard.js'\nimport { toPathComponents } from './utils/to-path-components.js'\nimport type { ImportResult, InProgressImportResult, TreeBuilder, WritableStorage } from './index.js'\nimport type { PersistOptions } from './utils/persist.js'\n\nexport interface AddToTreeOptions extends PersistOptions {\n  shardSplitThresholdBytes: number\n  shardFanoutBits: number\n}\n\nasync function addToTree (elem: InProgressImportResult, tree: Dir, options: AddToTreeOptions): Promise<Dir> {\n  const pathElems = toPathComponents(elem.path ?? '')\n  const lastIndex = pathElems.length - 1\n  let parent = tree\n  let currentPath = ''\n\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i]\n\n    currentPath += `${currentPath !== '' ? '/' : ''}${pathElem}`\n\n    const last = (i === lastIndex)\n    parent.dirty = true\n    parent.cid = undefined\n    parent.size = undefined\n\n    if (last) {\n      await parent.put(pathElem, elem)\n      tree = await flatToShard(null, parent, options.shardSplitThresholdBytes, options)\n    } else {\n      let dir = await parent.get(pathElem)\n\n      if ((dir == null) || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          root: false,\n          dir: true,\n          parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir?.unixfs?.mtime,\n          mode: dir?.unixfs?.mode\n        }, options)\n      }\n\n      await parent.put(pathElem, dir)\n\n      parent = dir\n    }\n  }\n\n  return tree\n}\n\nasync function * flushAndYield (tree: Dir | InProgressImportResult, blockstore: WritableStorage): AsyncGenerator<ImportResult> {\n  if (!(tree instanceof Dir)) {\n    if (tree.unixfs?.isDirectory() === true) {\n      yield tree\n    }\n\n    return\n  }\n\n  yield * tree.flush(blockstore)\n}\n\nexport interface TreeBuilderOptions extends AddToTreeOptions {\n  wrapWithDirectory: boolean\n}\n\nexport function defaultTreeBuilder (options: TreeBuilderOptions): TreeBuilder {\n  return async function * treeBuilder (source, block) {\n    let tree: Dir = new DirFlat({\n      root: true,\n      dir: true,\n      path: '',\n      dirty: true,\n      flat: true\n    }, options)\n\n    let rootDir: string | undefined\n    let singleRoot = false\n\n    for await (const entry of source) {\n      if (entry == null) {\n        continue\n      }\n\n      // if all paths are from the same root directory, we should\n      // wrap them all in that root directory\n      const dir = `${entry.originalPath ?? ''}`.split('/')[0]\n\n      if (dir != null && dir !== '') {\n        if (rootDir == null) {\n          rootDir = dir\n          singleRoot = true\n        } else if (rootDir !== dir) {\n          singleRoot = false\n        }\n      }\n\n      tree = await addToTree(entry, tree, options)\n\n      if (entry.unixfs?.isDirectory() !== true) {\n        yield entry\n      }\n    }\n\n    if (options.wrapWithDirectory || (singleRoot && tree.childCount() > 1)) {\n      yield * flushAndYield(tree, block)\n    } else {\n      for (const unwrapped of tree.eachChildSeries()) {\n        if (unwrapped == null) {\n          continue\n        }\n\n        yield * flushAndYield(unwrapped.child, block)\n      }\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * @example\n *\n * Let's create a little directory to import:\n *\n * ```console\n * > cd /tmp\n * > mkdir foo\n * > echo 'hello' > foo/bar\n * > echo 'world' > foo/quux\n * ```\n *\n * And write the importing logic:\n *\n * ```TypeScript\n * import { importer } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n * import * as fs from 'node:fs'\n *\n * // Where the blocks will be stored\n * const blockstore = new MemoryBlockstore()\n *\n * // Import path /tmp/foo/\n * const source = [{\n *   path: '/tmp/foo/bar',\n *   content: fs.createReadStream('/tmp/foo/bar')\n * }, {\n *   path: '/tmp/foo/quxx',\n *   content: fs.createReadStream('/tmp/foo/quux')\n * }]\n *\n * for await (const entry of importer(source, blockstore)) {\n *   console.info(entry)\n * }\n * ```\n *\n * When run, metadata about DAGNodes in the created tree is printed until the root:\n *\n * ```\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp/foo/bar',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp/foo/quxx',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp/foo',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * ```\n */\n\nimport first from 'it-first'\nimport parallelBatch from 'it-parallel-batch'\nimport { fixedSize } from './chunker/fixed-size.js'\nimport { defaultBufferImporter } from './dag-builder/buffer-importer.js'\nimport { defaultDagBuilder } from './dag-builder/index.js'\nimport { defaultChunkValidator } from './dag-builder/validate-chunks.js'\nimport { InvalidParametersError } from './errors.js'\nimport { balanced } from './layout/index.js'\nimport { defaultTreeBuilder } from './tree-builder.js'\nimport type { Chunker } from './chunker/index.js'\nimport type { BufferImportProgressEvents } from './dag-builder/buffer-importer.js'\nimport type { DirBuilder } from './dag-builder/dir.js'\nimport type { FileBuilder, ReducerProgressEvents } from './dag-builder/file.js'\nimport type { DAGBuilder, DagBuilderProgressEvents } from './dag-builder/index.js'\nimport type { ChunkValidator } from './dag-builder/validate-chunks.js'\nimport type { FileLayout } from './layout/index.js'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { AwaitIterable } from 'interface-store'\nimport type { UnixFS, Mtime } from 'ipfs-unixfs'\nimport type { CID, Version as CIDVersion } from 'multiformats/cid'\nimport type { ProgressOptions } from 'progress-events'\n\nexport * from './errors.js'\n\nexport type ByteStream = AwaitIterable<Uint8Array>\nexport type ImportContent = ByteStream | Uint8Array\n\nexport type WritableStorage = Pick<Blockstore, 'put'>\n\nexport interface FileCandidate<T extends ImportContent = ImportContent> {\n  path?: string\n  content: T\n  mtime?: Mtime\n  mode?: number\n}\n\nexport interface DirectoryCandidate {\n  path: string\n  mtime?: Mtime\n  mode?: number\n}\n\nexport type ImportCandidate = FileCandidate | DirectoryCandidate\n\nexport interface File {\n  content: AsyncIterable<Uint8Array>\n  path?: string\n  mtime?: Mtime\n  mode?: number\n  originalPath?: string\n}\n\nexport interface Directory {\n  path?: string\n  mtime?: Mtime\n  mode?: number\n  originalPath?: string\n}\n\nexport interface ImportResult {\n  cid: CID\n  size: bigint\n  path?: string\n  unixfs?: UnixFS\n}\n\nexport interface MultipleBlockImportResult extends ImportResult {\n  originalPath?: string\n}\n\nexport interface SingleBlockImportResult extends ImportResult {\n  single: true\n  originalPath?: string\n  block: Uint8Array\n}\n\nexport type InProgressImportResult = SingleBlockImportResult | MultipleBlockImportResult\n\nexport interface BufferImporterResult extends ImportResult {\n  block: Uint8Array\n}\n\nexport interface HamtHashFn { (value: Uint8Array): Promise<Uint8Array> }\nexport interface TreeBuilder { (source: AsyncIterable<InProgressImportResult>, blockstore: WritableStorage): AsyncIterable<ImportResult> }\nexport interface BufferImporter { (file: File, blockstore: WritableStorage): AsyncIterable<() => Promise<BufferImporterResult>> }\n\nexport type ImporterProgressEvents =\n  BufferImportProgressEvents |\n  DagBuilderProgressEvents |\n  ReducerProgressEvents\n\n/**\n * Options to control the importer's behaviour\n */\nexport interface ImporterOptions extends ProgressOptions<ImporterProgressEvents> {\n  /**\n   * When a file would span multiple DAGNodes, if this is true the leaf nodes\n   * will not be wrapped in `UnixFS` protobufs and will instead contain the\n   * raw file bytes. Default: true\n   */\n  rawLeaves?: boolean\n\n  /**\n   * If the file being imported is small enough to fit into one DAGNodes, store\n   * the file data in the root node along with the UnixFS metadata instead of\n   * in a leaf node which would then require additional I/O to load. Default: true\n   */\n  reduceSingleLeafToSelf?: boolean\n\n  /**\n   * What type of UnixFS node leaves should be - can be `'file'` or `'raw'`\n   * (ignored when `rawLeaves` is `true`).\n   *\n   * This option exists to simulate kubo's trickle dag which uses a combination\n   * of `'raw'` UnixFS leaves and `reduceSingleLeafToSelf: false`.\n   *\n   * For modern code the `rawLeaves: true` option should be used instead so leaves\n   * are plain Uint8Arrays without a UnixFS/Protobuf wrapper.\n   */\n  leafType?: 'file' | 'raw'\n\n  /**\n   * the CID version to use when storing the data. Default: 1\n   */\n  cidVersion?: CIDVersion\n\n  /**\n   * If the serialized node is larger than this it might be converted to a HAMT\n   * sharded directory. Default: 256KiB\n   */\n  shardSplitThresholdBytes?: number\n\n  /**\n   * The number of bits of a hash digest used at each level of sharding to\n   * the child index. 2**shardFanoutBits will dictate the maximum number of\n   * children for any shard in the HAMT. Default: 8\n   */\n  shardFanoutBits?: number\n\n  /**\n   * How many files to import concurrently. For large numbers of small files this\n   * should be high (e.g. 50). Default: 10\n   */\n  fileImportConcurrency?: number\n\n  /**\n   * How many blocks to hash and write to the block store concurrently. For small\n   * numbers of large files this should be high (e.g. 50). Default: 50\n   */\n  blockWriteConcurrency?: number\n\n  /**\n   * If true, all imported files and folders will be contained in a directory that\n   * will correspond to the CID of the final entry yielded. Default: false\n   */\n  wrapWithDirectory?: boolean\n\n  /**\n   * The chunking strategy. See [./src/chunker/index.ts](./src/chunker/index.ts)\n   * for available chunkers. Default: fixedSize\n   */\n  chunker?: Chunker\n\n  /**\n   * How the DAG that represents files are created. See\n   * [./src/layout/index.ts](./src/layout/index.ts) for available layouts. Default: balanced\n   */\n  layout?: FileLayout\n\n  /**\n   * This option can be used to override the importer internals.\n   *\n   * This function should read `{ path, content }` entries from `source` and turn them\n   * into DAGs\n   * It should yield a `function` that returns a `Promise` that resolves to\n   * `{ cid, path, unixfs, node }` where `cid` is a `CID`, `path` is a string, `unixfs`\n   * is a UnixFS entry and `node` is a `DAGNode`.\n   * Values will be pulled from this generator in parallel - the amount of parallelisation\n   * is controlled by the `fileImportConcurrency` option (default: 50)\n   */\n  dagBuilder?: DAGBuilder\n\n  /**\n   * This option can be used to override the importer internals.\n   *\n   * This function should read `{ cid, path, unixfs, node }` entries from `source` and\n   * place them in a directory structure\n   * It should yield an object with the properties `{ cid, path, unixfs, size }` where\n   * `cid` is a `CID`, `path` is a string, `unixfs` is a UnixFS entry and `size` is a `Number`.\n   */\n  treeBuilder?: TreeBuilder\n\n  /**\n   * This option can be used to override the importer internals.\n   *\n   * This function should read `Buffer`s from `source` and persist them using `blockstore.put`\n   * or similar\n   * `entry` is the `{ path, content }` entry, where `entry.content` is an async\n   * generator that yields Buffers\n   * It should yield functions that return a Promise that resolves to an object with\n   * the properties `{ cid, unixfs, size }` where `cid` is a [CID], `unixfs` is a [UnixFS] entry and `size` is a `Number` that represents the serialized size of the [IPLD] node that holds the buffer data.\n   * Values will be pulled from this generator in parallel - the amount of\n   * parallelisation is controlled by the `blockWriteConcurrency` option (default: 10)\n   */\n  bufferImporter?: BufferImporter\n\n  /**\n   * This option can be used to override the importer internals.\n   *\n   * This function takes input from the `content` field of imported entries.\n   * It should transform them into `Buffer`s, throwing an error if it cannot.\n   * It should yield `Buffer` objects constructed from the `source` or throw an\n   * `Error`\n   */\n  chunkValidator?: ChunkValidator\n\n  /**\n   * This option can be used to override how a directory IPLD node is built.\n   *\n   * This function takes a `Directory` object and returns a `Promise` that resolves to an `InProgressImportResult`.\n   */\n  dirBuilder?: DirBuilder\n\n  /**\n   * This option can be used to override how a file IPLD node is built.\n   *\n   * This function takes a `File` object and returns a `Promise` that resolves to an `InProgressImportResult`.\n   */\n  fileBuilder?: FileBuilder\n}\n\nexport type ImportCandidateStream = AsyncIterable<FileCandidate | DirectoryCandidate> | Iterable<FileCandidate | DirectoryCandidate>\n\n/**\n * The importer creates UnixFS DAGs and stores the blocks that make\n * them up in the passed blockstore.\n *\n * @example\n *\n * ```typescript\n * import { importer } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input = [{\n *   path: './foo.txt',\n *   content: Uint8Array.from([0, 1, 2, 3, 4])\n * }, {\n *   path: './bar.txt',\n *   content: Uint8Array.from([0, 1, 2, 3, 4])\n * }]\n *\n * for await (const entry of importer(input, blockstore)) {\n *   console.info(entry)\n *   // { cid: CID(), ... }\n * }\n * ```\n */\nexport async function * importer (source: ImportCandidateStream, blockstore: WritableStorage, options: ImporterOptions = {}): AsyncGenerator<ImportResult, void, unknown> {\n  let candidates: AsyncIterable<FileCandidate | DirectoryCandidate> | Iterable<FileCandidate | DirectoryCandidate>\n\n  if (Symbol.asyncIterator in source || Symbol.iterator in source) {\n    candidates = source\n  } else {\n    candidates = [source]\n  }\n\n  const wrapWithDirectory = options.wrapWithDirectory ?? false\n  const shardSplitThresholdBytes = options.shardSplitThresholdBytes ?? 262144\n  const shardFanoutBits = options.shardFanoutBits ?? 8\n  const cidVersion = options.cidVersion ?? 1\n  const rawLeaves = options.rawLeaves ?? true\n  const leafType = options.leafType ?? 'file'\n  const fileImportConcurrency = options.fileImportConcurrency ?? 50\n  const blockWriteConcurrency = options.blockWriteConcurrency ?? 10\n  const reduceSingleLeafToSelf = options.reduceSingleLeafToSelf ?? true\n\n  const chunker = options.chunker ?? fixedSize()\n  const chunkValidator = options.chunkValidator ?? defaultChunkValidator()\n  const buildDag: DAGBuilder = options.dagBuilder ?? defaultDagBuilder({\n    chunker,\n    chunkValidator,\n    wrapWithDirectory,\n    layout: options.layout ?? balanced(),\n    bufferImporter: options.bufferImporter ?? defaultBufferImporter({\n      cidVersion,\n      rawLeaves,\n      leafType,\n      onProgress: options.onProgress\n    }),\n    blockWriteConcurrency,\n    reduceSingleLeafToSelf,\n    cidVersion,\n    onProgress: options.onProgress,\n    dirBuilder: options.dirBuilder,\n    fileBuilder: options.fileBuilder\n  })\n  const buildTree: TreeBuilder = options.treeBuilder ?? defaultTreeBuilder({\n    wrapWithDirectory,\n    shardSplitThresholdBytes,\n    shardFanoutBits,\n    cidVersion,\n    onProgress: options.onProgress\n  })\n\n  for await (const entry of buildTree(parallelBatch(buildDag(candidates, blockstore), fileImportConcurrency), blockstore)) {\n    yield {\n      cid: entry.cid,\n      path: entry.path,\n      unixfs: entry.unixfs,\n      size: entry.size\n    }\n  }\n}\n\n/**\n * `importFile` is similar to `importer` except it accepts a single\n * `FileCandidate` and returns a promise of a single `ImportResult`\n * instead of a stream of results.\n *\n * @example\n *\n * ```typescript\n * import { importFile } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input: FileCandidate = {\n *   path: './foo.txt',\n *   content: Uint8Array.from([0, 1, 2, 3, 4])\n * }\n *\n * const entry = await importFile(input, blockstore)\n * ```\n */\nexport async function importFile (content: FileCandidate, blockstore: WritableStorage, options: ImporterOptions = {}): Promise<ImportResult> {\n  const result = await first(importer([content], blockstore, options))\n\n  if (result == null) {\n    throw new InvalidParametersError('Nothing imported')\n  }\n\n  return result\n}\n\n/**\n * `importDir` is similar to `importer` except it accepts a single\n * `DirectoryCandidate` and returns a promise of a single `ImportResult`\n * instead of a stream of results.\n *\n * @example\n *\n * ```typescript\n * import { importDirectory } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input: DirectoryCandidate = {\n *   path: './foo.txt'\n * }\n *\n * const entry = await importDirectory(input, blockstore)\n * ```\n */\nexport async function importDirectory (content: DirectoryCandidate, blockstore: WritableStorage, options: ImporterOptions = {}): Promise<ImportResult> {\n  const result = await first(importer([content], blockstore, options))\n\n  if (result == null) {\n    throw new InvalidParametersError('Nothing imported')\n  }\n\n  return result\n}\n\n/**\n * `importBytes` accepts a single Uint8Array and returns a promise\n * of a single `ImportResult`.\n *\n * @example\n *\n * ```typescript\n * import { importBytes } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input = Uint8Array.from([0, 1, 2, 3, 4])\n *\n * const entry = await importBytes(input, blockstore)\n * ```\n */\nexport async function importBytes (buf: ImportContent, blockstore: WritableStorage, options: ImporterOptions = {}): Promise<ImportResult> {\n  return importFile({\n    content: buf\n  }, blockstore, options)\n}\n\n/**\n * `importByteStream` accepts a single stream of Uint8Arrays and\n * returns a promise of a single `ImportResult`.\n *\n * @example\n *\n * ```typescript\n * import { importByteStream } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input = [\n *   Uint8Array.from([0, 1, 2, 3, 4]),\n *   Uint8Array.from([5, 6, 7, 8, 9])\n * ]\n *\n * const entry = await importByteStream(input, blockstore)\n * ```\n */\nexport async function importByteStream (bufs: ByteStream, blockstore: WritableStorage, options: ImporterOptions = {}): Promise<ImportResult> {\n  return importFile({\n    content: bufs\n  }, blockstore, options)\n}\n", "// @ts-expect-error no types\nimport { create } from 'rabin-wasm'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { InvalidAvgChunkSizeError, InvalidChunkSizeError, InvalidMinChunkSizeError } from '../errors.js'\nimport type { Chunker } from './index.js'\n\nconst DEFAULT_MIN_CHUNK_SIZE = 262144\nconst DEFAULT_MAX_CHUNK_SIZE = 262144\nconst DEFAULT_AVG_CHUNK_SIZE = 262144\nconst DEFAULT_WINDOW = 16\n\nasync function * chunker (source: AsyncIterable<Uint8Array>, r: any): AsyncGenerator<Uint8Array> {\n  const buffers = new Uint8ArrayList()\n\n  for await (const chunk of source) {\n    buffers.append(chunk)\n\n    const sizes = r.fingerprint(chunk)\n\n    for (let i = 0; i < sizes.length; i++) {\n      const size = sizes[i]\n      const buf = buffers.slice(0, size)\n      buffers.consume(size)\n\n      yield buf\n    }\n  }\n\n  if (buffers.length > 0) {\n    yield buffers.subarray(0)\n  }\n}\n\nexport interface RabinOptions {\n  minChunkSize?: number\n  maxChunkSize?: number\n  avgChunkSize?: number\n  window?: number\n}\n\nexport const rabin = (options: RabinOptions = {}): Chunker => {\n  let min = options.minChunkSize ?? DEFAULT_MIN_CHUNK_SIZE\n  let max = options.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE\n  let avg = options.avgChunkSize ?? DEFAULT_AVG_CHUNK_SIZE\n  const window = options.window ?? DEFAULT_WINDOW\n\n  // if only avg was passed, calculate min/max from that\n  if (options.avgChunkSize != null && options.minChunkSize == null && options.maxChunkSize == null) {\n    min = avg / 3\n    max = avg + (avg / 2)\n  }\n\n  const isInvalidChunkSizes = [min, avg, max].some((size) => size == null || isNaN(size))\n\n  if (isInvalidChunkSizes) {\n    if (options.avgChunkSize != null) {\n      throw new InvalidAvgChunkSizeError('please specify a valid average chunk size number')\n    }\n\n    throw new InvalidChunkSizeError('please specify valid numbers for (min|max|avg)ChunkSize')\n  }\n\n  // validate min/max/avg in the same way as go\n  if (min < 16) {\n    throw new InvalidMinChunkSizeError('rabin min must be greater than 16')\n  }\n\n  if (max < min) {\n    max = min\n  }\n\n  if (avg < min) {\n    avg = min\n  }\n\n  const sizepow = Math.floor(Math.log2(avg))\n\n  return async function * rabinChunker (source) {\n    const r = await create(sizepow, min, max, window)\n\n    for await (const chunk of chunker(source, r)) {\n      yield chunk\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Return the last value from an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import last from 'it-last'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const res = last(values)\n *\n * console.info(res) // 4\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import last from 'it-last'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const res = await last(values())\n *\n * console.info(res) // 4\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Returns the last item of an (async) iterable, unless empty, in which case\n * return `undefined`\n */\nfunction last <T> (source: Iterable<T>): T | undefined\nfunction last <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined>\nfunction last <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined> | T | undefined {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      let res\n\n      for await (const entry of source) {\n        res = entry\n      }\n\n      return res\n    })()\n  }\n\n  let res\n\n  for (const entry of source) {\n    res = entry\n  }\n\n  return res\n}\n\nexport default last\n", "export abstract class UnixFSError extends Error {\n  public readonly name: string\n  public readonly code: string\n\n  constructor (message: string, name: string, code: string) {\n    super(message)\n\n    this.name = name\n    this.code = code\n  }\n}\n\nexport class NotUnixFSError extends UnixFSError {\n  constructor (message = 'not a Unixfs node') {\n    super(message, 'NotUnixFSError', 'ERR_NOT_UNIXFS')\n  }\n}\n\nexport class InvalidPBNodeError extends UnixFSError {\n  constructor (message = 'invalid PBNode') {\n    super(message, 'InvalidPBNodeError', 'ERR_INVALID_PB_NODE')\n  }\n}\n\nexport class UnknownError extends UnixFSError {\n  constructor (message = 'unknown error') {\n    super(message, 'InvalidPBNodeError', 'ERR_UNKNOWN_ERROR')\n  }\n}\n\nexport class AlreadyExistsError extends UnixFSError {\n  constructor (message = 'path already exists') {\n    super(message, 'AlreadyExistsError', 'ERR_ALREADY_EXISTS')\n  }\n}\n\nexport class DoesNotExistError extends UnixFSError {\n  constructor (message = 'path does not exist') {\n    super(message, 'DoesNotExistError', 'ERR_DOES_NOT_EXIST')\n  }\n}\n\nexport class NoContentError extends UnixFSError {\n  constructor (message = 'no content') {\n    super(message, 'NoContentError', 'ERR_NO_CONTENT')\n  }\n}\n\nexport class NotAFileError extends UnixFSError {\n  constructor (message = 'not a file') {\n    super(message, 'NotAFileError', 'ERR_NOT_A_FILE')\n  }\n}\n\nexport class NotADirectoryError extends UnixFSError {\n  constructor (message = 'not a directory') {\n    super(message, 'NotADirectoryError', 'ERR_NOT_A_DIRECTORY')\n  }\n}\n\nexport class InvalidParametersError extends UnixFSError {\n  constructor (message = 'invalid parameters') {\n    super(message, 'InvalidParametersError', 'ERR_INVALID_PARAMETERS')\n  }\n}\n", "import { importBytes, importByteStream, importer } from 'ipfs-unixfs-importer'\nimport { fixedSize } from 'ipfs-unixfs-importer/chunker'\nimport { balanced } from 'ipfs-unixfs-importer/layout'\nimport first from 'it-first'\nimport last from 'it-last'\nimport { InvalidParametersError } from '../errors.js'\nimport type { FileCandidate, AddOptions, AddFileOptions } from '../index.js'\nimport type { PutStore } from '../unixfs.js'\nimport type { ByteStream, DirectoryCandidate, ImportCandidateStream, ImportResult } from 'ipfs-unixfs-importer'\nimport type { CID } from 'multiformats/cid'\n\n/**\n * Default importer settings match Filecoin\n */\nconst defaultImporterSettings: AddOptions = {\n  cidVersion: 1,\n  rawLeaves: true,\n  layout: balanced({\n    maxChildrenPerNode: 1024\n  }),\n  chunker: fixedSize({\n    chunkSize: 1_048_576\n  })\n}\n\nexport async function * addAll (source: ImportCandidateStream, blockstore: PutStore, options: Partial<AddOptions> = {}): AsyncGenerator<ImportResult, void, unknown> {\n  yield * importer(source, blockstore, {\n    ...defaultImporterSettings,\n    ...options\n  })\n}\n\nexport async function addBytes (bytes: Uint8Array, blockstore: PutStore, options: Partial<AddFileOptions> = {}): Promise<CID> {\n  const { cid } = await importBytes(bytes, blockstore, {\n    ...defaultImporterSettings,\n    ...options\n  })\n\n  return cid\n}\n\nexport async function addByteStream (bytes: ByteStream, blockstore: PutStore, options: Partial<AddFileOptions> = {}): Promise<CID> {\n  const { cid } = await importByteStream(bytes, blockstore, {\n    ...defaultImporterSettings,\n    ...options\n  })\n\n  return cid\n}\n\nexport async function addFile (file: FileCandidate, blockstore: PutStore, options: Partial<AddFileOptions> = {}): Promise<CID> {\n  if (file.path == null) {\n    throw new InvalidParametersError('path is required')\n  }\n\n  if (file.content == null) {\n    throw new InvalidParametersError('content is required')\n  }\n\n  const result = await last(addAll([file], blockstore, {\n    ...defaultImporterSettings,\n    ...options,\n    wrapWithDirectory: true\n  }))\n\n  if (result == null) {\n    throw new InvalidParametersError('Nothing imported')\n  }\n\n  return result.cid\n}\n\nexport async function addDirectory (dir: Partial<DirectoryCandidate>, blockstore: PutStore, options: Partial<AddFileOptions> = {}): Promise<CID> {\n  // @ts-expect-error field is not in the types\n  if (dir.content != null) {\n    throw new InvalidParametersError('Directories cannot have content, use addFile instead')\n  }\n\n  const ord = dir.path == null ? first : last\n\n  const result = await ord(addAll([{\n    ...dir,\n    path: dir.path ?? '-'\n  }], blockstore, {\n    ...defaultImporterSettings,\n    ...options,\n    wrapWithDirectory: dir.path != null\n  }))\n\n  if (result == null) {\n    throw new InvalidParametersError('Nothing imported')\n  }\n\n  return result.cid\n}\n", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n", "import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "export class BadPathError extends Error {\n  static name = 'BadPathError'\n  static code = 'ERR_BAD_PATH'\n  name = BadPathError.name\n  code = BadPathError.code\n\n  constructor (message = 'Bad path') {\n    super(message)\n  }\n}\n\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n  static code = 'ERR_NOT_FOUND'\n  name = NotFoundError.name\n  code = NotFoundError.code\n\n  constructor (message = 'Not found') {\n    super(message)\n  }\n}\n\nexport class NoResolverError extends Error {\n  static name = 'NoResolverError'\n  static code = 'ERR_NO_RESOLVER'\n  name = NoResolverError.name\n  code = NoResolverError.code\n\n  constructor (message = 'No resolver') {\n    super(message)\n  }\n}\n\nexport class NotUnixFSError extends Error {\n  static name = 'NotUnixFSError'\n  static code = 'ERR_NOT_UNIXFS'\n  name = NotUnixFSError.name\n  code = NotUnixFSError.code\n\n  constructor (message = 'Not UnixFS') {\n    super(message)\n  }\n}\n\nexport class OverReadError extends Error {\n  static name = 'OverReadError'\n  static code = 'ERR_OVER_READ'\n  name = OverReadError.name\n  code = OverReadError.code\n\n  constructor (message = 'Over read') {\n    super(message)\n  }\n}\n\nexport class UnderReadError extends Error {\n  static name = 'UnderReadError'\n  static code = 'ERR_UNDER_READ'\n  name = UnderReadError.name\n  code = UnderReadError.code\n\n  constructor (message = 'Under read') {\n    super(message)\n  }\n}\n\nexport class NoPropError extends Error {\n  static name = 'NoPropError'\n  static code = 'ERR_NO_PROP'\n  name = NoPropError.name\n  code = NoPropError.code\n\n  constructor (message = 'No Property found') {\n    super(message)\n  }\n}\n\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n  static code = 'ERR_INVALID_PARAMS'\n  name = InvalidParametersError.name\n  code = InvalidParametersError.code\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n  }\n}\n", "import type { ArrayBufferView, ByteView } from './interface.js'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\nexport function encode <T> (node: T): ByteView<T> {\n  return textEncoder.encode(JSON.stringify(node))\n}\n\nexport function decode <T> (data: ByteView<T> | ArrayBufferView<T>): T {\n  return JSON.parse(textDecoder.decode(data))\n}\n", "import { coerce } from '../bytes.js'\nimport type { ArrayBufferView, ByteView } from './interface.js'\n\nexport const name = 'raw'\nexport const code = 0x55\n\nexport function encode (node: Uint8Array): ByteView<Uint8Array> {\n  return coerce(node)\n}\n\nexport function decode (data: ByteView<Uint8Array> | ArrayBufferView<Uint8Array>): Uint8Array {\n  return coerce(data)\n}\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code: 0x0 = 0x0\nconst name = 'identity'\n\nconst encode: (input: Uint8Array) => Uint8Array = coerce\n\nfunction digest (input: Uint8Array): Digest.Digest<typeof code, number> {\n  return Digest.create(code, encode(input))\n}\n\nexport const identity = { code, name, encode, digest }\n", "import { CID } from 'multiformats/cid'\nimport { NoPropError } from '../errors.js'\nimport type { ResolveResult } from '../index.js'\n\nexport function resolveObjectPath (object: any, block: Uint8Array, cid: CID, name: string, path: string, toResolve: string[], depth: number): ResolveResult {\n  let subObject = object\n  let subPath = path\n\n  while (toResolve.length > 0) {\n    const prop = toResolve[0]\n\n    if (prop in subObject) {\n      // remove the bit of the path we have resolved\n      toResolve.shift()\n      subPath = `${subPath}/${prop}`\n\n      const subObjectCid = CID.asCID(subObject[prop])\n      if (subObjectCid != null) {\n        return {\n          entry: {\n            type: 'object',\n            name,\n            path,\n            cid,\n            node: block,\n            depth,\n            size: BigInt(block.length),\n            content: async function * () {\n              yield object\n            }\n          },\n          next: {\n            cid: subObjectCid,\n            name: prop,\n            path: subPath,\n            toResolve\n          }\n        }\n      }\n\n      subObject = subObject[prop]\n    } else {\n      // cannot resolve further\n      throw new NoPropError(`No property named ${prop} found in node ${cid}`)\n    }\n  }\n\n  return {\n    entry: {\n      type: 'object',\n      name,\n      path,\n      cid,\n      node: block,\n      depth,\n      size: BigInt(block.length),\n      content: async function * () {\n        yield object\n      }\n    }\n  }\n}\n", "import * as dagCbor from '@ipld/dag-cbor'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = dagCbor.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n", "import * as dagJson from '@ipld/dag-json'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = dagJson.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n", "function extractDataFromBlock (block: Uint8Array, blockStart: bigint, requestedStart: bigint, requestedEnd: bigint): Uint8Array {\n  const blockLength = BigInt(block.length)\n  const blockEnd = BigInt(blockStart + blockLength)\n\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    // If we are looking for a byte range that is starts after the start of the block,\n    // return an empty block.  This can happen when internal nodes contain data\n    return new Uint8Array(0)\n  }\n\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    // If the end byte is in the current block, truncate the block to the end byte\n    block = block.subarray(0, Number(requestedEnd - blockStart))\n  }\n\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    // If the start byte is in the current block, skip to the start byte\n    block = block.subarray(Number(requestedStart - blockStart))\n  }\n\n  return block\n}\n\nexport default extractDataFromBlock\n", "import { InvalidParametersError } from '../errors.js'\n\nconst validateOffsetAndLength = (size: number | bigint, offset: number | bigint = 0, length: number | bigint = size): { start: bigint, end: bigint } => {\n  const fileSize = BigInt(size)\n  const start = BigInt(offset ?? 0)\n  let end = BigInt(length)\n\n  if (end !== fileSize) {\n    end = start + end\n  }\n\n  if (end > fileSize) {\n    end = fileSize\n  }\n\n  if (start < 0n) {\n    throw new InvalidParametersError('Offset must be greater than or equal to 0')\n  }\n\n  if (start > fileSize) {\n    throw new InvalidParametersError('Offset must be less than the file size')\n  }\n\n  if (end < 0n) {\n    throw new InvalidParametersError('Length must be greater than or equal to 0')\n  }\n\n  if (end > fileSize) {\n    throw new InvalidParametersError('Length must be less than the file size')\n  }\n\n  return {\n    start,\n    end\n  }\n}\n\nexport default validateOffsetAndLength\n", "import * as mh from 'multiformats/hashes/digest'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotFoundError } from '../errors.js'\nimport extractDataFromBlock from '../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, Resolver, ExportProgress } from '../index.js'\n\nconst rawContent = (node: Uint8Array): ((options?: ExporterOptions) => AsyncGenerator<Uint8Array, void, undefined>) => {\n  async function * contentGenerator (options: ExporterOptions = {}): AsyncGenerator<Uint8Array, void, undefined> {\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    const buf = extractDataFromBlock(node, 0n, start, end)\n\n    options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:identity', {\n      bytesRead: BigInt(buf.byteLength),\n      totalBytes: end - start,\n      fileSize: BigInt(node.byteLength)\n    }))\n\n    yield buf\n  }\n\n  return contentGenerator\n}\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length > 0) {\n    throw new NotFoundError(`No link named ${path} found in raw node ${cid}`)\n  }\n  const buf = mh.decode(cid.multihash.bytes)\n\n  return {\n    entry: {\n      type: 'identity',\n      name,\n      path,\n      cid,\n      content: rawContent(buf.digest),\n      depth,\n      size: BigInt(buf.digest.length),\n      node: buf.digest\n    }\n  }\n}\n\nexport default resolve\n", "import * as json from 'multiformats/codecs/json'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = json.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n", "import { CustomProgressEvent } from 'progress-events'\nimport { NotFoundError } from '../errors.js'\nimport extractDataFromBlock from '../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, Resolver, ExportProgress } from '../index.js'\n\nconst rawContent = (node: Uint8Array): ((options?: ExporterOptions) => AsyncGenerator<Uint8Array, void, undefined>) => {\n  async function * contentGenerator (options: ExporterOptions = {}): AsyncGenerator<Uint8Array, void, undefined> {\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    const buf = extractDataFromBlock(node, 0n, start, end)\n\n    options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:raw', {\n      bytesRead: BigInt(buf.byteLength),\n      totalBytes: end - start,\n      fileSize: BigInt(node.byteLength)\n    }))\n\n    yield buf\n  }\n\n  return contentGenerator\n}\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length > 0) {\n    throw new NotFoundError(`No link named ${path} found in raw node ${cid}`)\n  }\n\n  const block = await blockstore.get(cid, options)\n\n  return {\n    entry: {\n      type: 'raw',\n      name,\n      path,\n      cid,\n      content: rawContent(block),\n      depth,\n      size: BigInt(block.length),\n      node: block\n    }\n  }\n}\n\nexport default resolve\n", "import { decode } from '@ipld/dag-pb'\nimport { murmur3128 } from '@multiformats/murmur3'\nimport { Bucket, createHAMT } from 'hamt-sharding'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { NotUnixFSError } from '../errors.js'\nimport type { ExporterOptions, ShardTraversalContext, ReadableStorage } from '../index.js'\nimport type { PBLink, PBNode } from '@ipld/dag-pb'\nimport type { BucketPosition } from 'hamt-sharding'\nimport type { CID } from 'multiformats/cid'\n\n// FIXME: this is copy/pasted from ipfs-unixfs-importer/src/options.js\nconst hashFn = async function (buf: Uint8Array): Promise<Uint8Array> {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .slice(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n\nconst addLinksToHamtBucket = async (links: PBLink[], bucket: Bucket<boolean>, rootBucket: Bucket<boolean>): Promise<void> => {\n  const padLength = (bucket.tableSize() - 1).toString(16).length\n  await Promise.all(\n    links.map(async link => {\n      if (link.Name == null) {\n        // TODO(@rvagg): what do? this is technically possible\n        throw new Error('Unexpected Link without a Name')\n      }\n      if (link.Name.length === padLength) {\n        const pos = parseInt(link.Name, 16)\n\n        bucket._putObjectAt(pos, new Bucket({\n          hash: rootBucket._options.hash,\n          bits: rootBucket._options.bits\n        }, bucket, pos))\n        return\n      }\n\n      await rootBucket.put(link.Name.substring(2), true)\n    })\n  )\n}\n\nconst toPrefix = (position: number, padLength: number): string => {\n  return position\n    .toString(16)\n    .toUpperCase()\n    .padStart(padLength, '0')\n    .substring(0, padLength)\n}\n\nconst toBucketPath = (position: BucketPosition<boolean>): Array<Bucket<boolean>> => {\n  let bucket = position.bucket\n  const path = []\n\n  while (bucket._parent != null) {\n    path.push(bucket)\n\n    bucket = bucket._parent\n  }\n\n  path.push(bucket)\n\n  return path.reverse()\n}\n\nconst findShardCid = async (node: PBNode, name: string, blockstore: ReadableStorage, context?: ShardTraversalContext, options?: ExporterOptions): Promise<CID | undefined> => {\n  if (context == null) {\n    if (node.Data == null) {\n      throw new NotUnixFSError('no data in PBNode')\n    }\n\n    let dir: UnixFS\n    try {\n      dir = UnixFS.unmarshal(node.Data)\n    } catch (err: any) {\n      throw new NotUnixFSError(err.message)\n    }\n\n    if (dir.type !== 'hamt-sharded-directory') {\n      throw new NotUnixFSError('not a HAMT')\n    }\n    if (dir.fanout == null) {\n      throw new NotUnixFSError('missing fanout')\n    }\n\n    const rootBucket = createHAMT<boolean>({\n      hashFn,\n      bits: Math.log2(Number(dir.fanout))\n    })\n\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    }\n  }\n\n  const padLength = (context.lastBucket.tableSize() - 1).toString(16).length\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)\n\n  const position = await context.rootBucket._findNewBucketAndPos(name)\n  let prefix = toPrefix(position.pos, padLength)\n  const bucketPath = toBucketPath(position)\n\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth]\n\n    prefix = toPrefix(context.lastBucket._posAtParent, padLength)\n  }\n\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false\n    }\n\n    const entryPrefix = link.Name.substring(0, padLength)\n    const entryName = link.Name.substring(padLength)\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return false\n    }\n\n    if (entryName !== '' && entryName !== name) {\n      // not the entry we're looking for\n      return false\n    }\n\n    return true\n  })\n\n  if (link == null) {\n    return\n  }\n\n  if (link.Name != null && link.Name.substring(padLength) === name) {\n    return link.Hash\n  }\n\n  context.hamtDepth++\n\n  const block = await blockstore.get(link.Hash, options)\n  node = decode(block)\n\n  return findShardCid(node, name, blockstore, context, options)\n}\n\nexport default findShardCid\n", "import filter from 'it-filter'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { CustomProgressEvent } from 'progress-events'\nimport type { ExporterOptions, ExportWalk, UnixfsV1DirectoryContent, UnixfsV1Resolver } from '../../../index.js'\n\nconst directoryContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function * yieldDirectoryContent (options: ExporterOptions = {}): UnixfsV1DirectoryContent {\n    const offset = options.offset ?? 0\n    const length = options.length ?? node.Links.length\n    const links = node.Links.slice(offset, length)\n\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:directory', {\n      cid\n    }))\n\n    yield * pipe(\n      links,\n      source => map(source, link => {\n        return async () => {\n          const linkName = link.Name ?? ''\n          const linkPath = `${path}/${linkName}`\n          const result = await resolve(link.Hash, linkName, linkPath, [], depth + 1, blockstore, options)\n          return result.entry\n        }\n      }),\n      source => parallel(source, {\n        ordered: true,\n        concurrency: options.blockReadConcurrency\n      }),\n      source => filter(source, entry => entry != null)\n    )\n  }\n\n  return yieldDirectoryContent\n}\n\nexport default directoryContent\n", "import * as dagPb from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { pushable } from 'it-pushable'\nimport * as raw from 'multiformats/codecs/raw'\nimport PQueue from 'p-queue'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotUnixFSError, OverReadError, UnderReadError } from '../../../errors.js'\nimport extractDataFromBlock from '../../../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, UnixfsV1FileContent, UnixfsV1Resolver, ReadableStorage, ExportProgress, ExportWalk } from '../../../index.js'\nimport type { Pushable } from 'it-pushable'\n\nasync function walkDAG (blockstore: ReadableStorage, node: dagPb.PBNode | Uint8Array, queue: Pushable<Uint8Array>, streamPosition: bigint, start: bigint, end: bigint, options: ExporterOptions): Promise<void> {\n  // a `raw` node\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end)\n\n    queue.push(buf)\n\n    return\n  }\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  let file: UnixFS\n\n  try {\n    file = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    throw new NotUnixFSError(err.message)\n  }\n\n  // might be a unixfs `raw` node or have data on intermediate nodes\n  if (file.data != null) {\n    const data = file.data\n    const buf = extractDataFromBlock(data, streamPosition, start, end)\n\n    queue.push(buf)\n\n    streamPosition += BigInt(buf.byteLength)\n  }\n\n  const childOps: Array<{ link: dagPb.PBLink, blockStart: bigint }> = []\n\n  if (node.Links.length !== file.blockSizes.length) {\n    throw new NotUnixFSError('Inconsistent block sizes and dag links')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i]\n    const childStart = streamPosition // inclusive\n    const childEnd = childStart + file.blockSizes[i] // exclusive\n\n    if ((start >= childStart && start < childEnd) || // child has offset byte\n        (end >= childStart && end <= childEnd) || // child has end byte\n        (start < childStart && end > childEnd)) { // child is between offset and end bytes\n      childOps.push({\n        link: childLink,\n        blockStart: streamPosition\n      })\n    }\n\n    streamPosition = childEnd\n\n    if (streamPosition > end) {\n      break\n    }\n  }\n\n  await pipe(\n    childOps,\n    (source) => map(source, (op) => {\n      return async () => {\n        const block = await blockstore.get(op.link.Hash, options)\n\n        return {\n          ...op,\n          block\n        }\n      }\n    }),\n    (source) => parallel(source, {\n      ordered: true,\n      concurrency: options.blockReadConcurrency\n    }),\n    async (source) => {\n      for await (const { link, block, blockStart } of source) {\n        let child: dagPb.PBNode | Uint8Array\n        switch (link.Hash.code) {\n          case dagPb.code:\n            child = dagPb.decode(block)\n            break\n          case raw.code:\n            child = block\n            break\n          default:\n            queue.end(new NotUnixFSError(`Unsupported codec: ${link.Hash.code}`))\n            return\n        }\n\n        // create a queue for this child - we use a queue instead of recursion\n        // to avoid overflowing the stack\n        const childQueue = new PQueue({\n          concurrency: 1\n        })\n        // if any of the child jobs error, end the read queue with the error\n        childQueue.on('error', error => {\n          queue.end(error)\n        })\n\n        // if the job rejects the 'error' event will be emitted on the child queue\n        void childQueue.add(async () => {\n          options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:file', {\n            cid: link.Hash\n          }))\n\n          await walkDAG(blockstore, child, queue, blockStart, start, end, options)\n        })\n\n        // wait for this child to complete before moving on to the next\n        await childQueue.onIdle()\n      }\n    }\n  )\n\n  if (streamPosition >= end) {\n    queue.end()\n  }\n}\n\nconst fileContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function * yieldFileContent (options: ExporterOptions = {}): UnixfsV1FileContent {\n    const fileSize = unixfs.fileSize()\n\n    if (fileSize === undefined) {\n      throw new Error('File was a directory')\n    }\n\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(fileSize, options.offset, options.length)\n\n    if (end === 0n) {\n      return\n    }\n\n    let read = 0n\n    const wanted = end - start\n    const queue = pushable()\n\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:file', {\n      cid\n    }))\n\n    void walkDAG(blockstore, node, queue, 0n, start, end, options)\n      .catch(err => {\n        queue.end(err)\n      })\n\n    for await (const buf of queue) {\n      if (buf == null) {\n        continue\n      }\n\n      read += BigInt(buf.byteLength)\n\n      if (read > wanted) {\n        queue.end()\n        throw new OverReadError('Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect')\n      }\n\n      if (read === wanted) {\n        queue.end()\n      }\n\n      options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:unixfs:file', {\n        bytesRead: read,\n        totalBytes: wanted,\n        fileSize\n      }))\n\n      yield buf\n    }\n\n    if (read < wanted) {\n      throw new UnderReadError('Traversed entire DAG but did not read enough bytes')\n    }\n  }\n\n  return yieldFileContent\n}\n\nexport default fileContent\n", "import { decode } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotUnixFSError } from '../../../errors.js'\nimport type { ExporterOptions, Resolve, UnixfsV1DirectoryContent, UnixfsV1Resolver, ReadableStorage, ExportWalk } from '../../../index.js'\nimport type { PBNode } from '@ipld/dag-pb'\n\nconst hamtShardedDirectoryContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldHamtDirectoryContent (options: ExporterOptions = {}): UnixfsV1DirectoryContent {\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:hamt-sharded-directory', {\n      cid\n    }))\n\n    return listDirectory(node, path, resolve, depth, blockstore, options)\n  }\n\n  return yieldHamtDirectoryContent\n}\n\nasync function * listDirectory (node: PBNode, path: string, resolve: Resolve, depth: number, blockstore: ReadableStorage, options: ExporterOptions): UnixfsV1DirectoryContent {\n  const links = node.Links\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  let dir: UnixFS\n  try {\n    dir = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    throw new NotUnixFSError(err.message)\n  }\n\n  if (dir.fanout == null) {\n    throw new NotUnixFSError('missing fanout')\n  }\n\n  const padLength = (dir.fanout - 1n).toString(16).length\n\n  const results = pipe(\n    links,\n    source => map(source, link => {\n      return async () => {\n        const name = link.Name != null ? link.Name.substring(padLength) : null\n\n        if (name != null && name !== '') {\n          const result = await resolve(link.Hash, name, `${path}/${name}`, [], depth + 1, blockstore, options)\n\n          return { entries: result.entry == null ? [] : [result.entry] }\n        } else {\n          // descend into subshard\n          const block = await blockstore.get(link.Hash, options)\n          node = decode(block)\n\n          options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:hamt-sharded-directory', {\n            cid: link.Hash\n          }))\n\n          return { entries: listDirectory(node, path, resolve, depth, blockstore, options) }\n        }\n      }\n    }),\n    source => parallel(source, {\n      ordered: true,\n      concurrency: options.blockReadConcurrency\n    })\n  )\n\n  for await (const { entries } of results) {\n    yield * entries\n  }\n}\n\nexport default hamtShardedDirectoryContent\n", "import { decode } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { NotFoundError, NotUnixFSError } from '../../errors.js'\nimport findShardCid from '../../utils/find-cid-in-shard.js'\nimport contentDirectory from './content/directory.js'\nimport contentFile from './content/file.js'\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js'\nimport type { Resolver, UnixfsV1Resolver } from '../../index.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { CID } from 'multiformats/cid'\n\nconst findLinkCid = (node: PBNode, name: string): CID | undefined => {\n  const link = node.Links.find(link => link.Name === name)\n\n  return link?.Hash\n}\n\nconst contentExporters: Record<string, UnixfsV1Resolver> = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  }\n}\n\n// @ts-expect-error types are wrong\nconst unixFsResolver: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const node = decode(block)\n  let unixfs\n  let next\n\n  if (name == null) {\n    name = cid.toString()\n  }\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  try {\n    unixfs = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw new NotUnixFSError(err.message)\n  }\n\n  if (path == null) {\n    path = name\n  }\n\n  if (toResolve.length > 0) {\n    let linkCid\n\n    if (unixfs?.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], blockstore)\n    } else {\n      linkCid = findLinkCid(node, toResolve[0])\n    }\n\n    if (linkCid == null) {\n      throw new NotFoundError('file does not exist')\n    }\n\n    // remove the path component we have resolved\n    const nextName = toResolve.shift()\n    const nextPath = `${path}/${nextName}`\n\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName ?? '',\n      path: nextPath\n    }\n  }\n\n  const content = contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore)\n\n  if (content == null) {\n    throw new NotFoundError('could not find content exporter')\n  }\n\n  if (unixfs.isDirectory()) {\n    return {\n      entry: {\n        type: 'directory',\n        name,\n        path,\n        cid,\n        content,\n        unixfs,\n        depth,\n        node,\n        size: unixfs.fileSize()\n      },\n      next\n    }\n  }\n\n  return {\n    entry: {\n      type: 'file',\n      name,\n      path,\n      cid,\n      content,\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  }\n}\n\nexport default unixFsResolver\n", "import * as dagCbor from '@ipld/dag-cbor'\nimport * as dagJson from '@ipld/dag-json'\nimport * as dagPb from '@ipld/dag-pb'\nimport * as json from 'multiformats/codecs/json'\nimport * as raw from 'multiformats/codecs/raw'\nimport { identity } from 'multiformats/hashes/identity'\nimport { NoResolverError } from '../errors.js'\nimport dagCborResolver from './dag-cbor.js'\nimport dagJsonResolver from './dag-json.js'\nimport identifyResolver from './identity.js'\nimport jsonResolver from './json.js'\nimport rawResolver from './raw.js'\nimport dagPbResolver from './unixfs-v1/index.js'\nimport type { Resolve, Resolver } from '../index.js'\n\nconst resolvers: Record<number, Resolver> = {\n  [dagPb.code]: dagPbResolver,\n  [raw.code]: rawResolver,\n  [dagCbor.code]: dagCborResolver,\n  [dagJson.code]: dagJsonResolver,\n  [identity.code]: identifyResolver,\n  [json.code]: jsonResolver\n}\n\nconst resolve: Resolve = async (cid, name, path, toResolve, depth, blockstore, options) => {\n  const resolver = resolvers[cid.code]\n\n  if (resolver == null) {\n    throw new NoResolverError(`No resolver for code ${cid.code}`)\n  }\n\n  return resolver(cid, name, path, toResolve, resolve, depth, blockstore, options)\n}\n\nexport default resolve\n", "/**\n * @packageDocumentation\n *\n * The UnixFS Exporter provides a means to read DAGs from a blockstore given a CID.\n *\n * @example\n *\n * ```TypeScript\n * // import a file and export it again\n * import { importer } from 'ipfs-unixfs-importer'\n * import { exporter } from 'ipfs-unixfs-exporter'\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n *\n * // Should contain the blocks we are trying to export\n * const blockstore = new MemoryBlockstore()\n * const files = []\n *\n * for await (const file of importer([{\n *   path: '/foo/bar.txt',\n *   content: new Uint8Array([0, 1, 2, 3])\n * }], blockstore)) {\n *   files.push(file)\n * }\n *\n * console.info(files[0].cid) // Qmbaz\n *\n * const entry = await exporter(files[0].cid, blockstore)\n *\n * if (entry.type !== 'file') {\n *   throw new Error('Unexpected entry type')\n * }\n *\n * console.info(entry.cid) // Qmqux\n * console.info(entry.path) // Qmbaz/foo/bar.txt\n * console.info(entry.name) // bar.txt\n * console.info(entry.unixfs.fileSize()) // 4\n *\n * // stream content from unixfs node\n * const size = entry.unixfs.fileSize()\n * const bytes = new Uint8Array(Number(size))\n * let offset = 0\n *\n * for await (const buf of entry.content()) {\n *   bytes.set(buf, offset)\n *   offset += buf.byteLength\n * }\n *\n * console.info(bytes) // 0, 1, 2, 3\n * ```\n */\n\nimport last from 'it-last'\nimport { CID } from 'multiformats/cid'\nimport { BadPathError, NotFoundError } from './errors.js'\nimport resolve from './resolvers/index.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { Bucket } from 'hamt-sharding'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { UnixFS } from 'ipfs-unixfs'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\nexport * from './errors.js'\n\nexport interface ExportProgress {\n  /**\n   * How many bytes of the file have been read\n   */\n  bytesRead: bigint\n\n  /**\n   * How many bytes of the file will be read - n.b. this may be\n   * smaller than `fileSize` if `offset`/`length` have been\n   * specified\n   */\n  totalBytes: bigint\n\n  /**\n   * The size of the file being read - n.b. this may be\n   * larger than `total` if `offset`/`length` has been\n   * specified\n   */\n  fileSize: bigint\n}\n\nexport interface ExportWalk {\n  cid: CID\n}\n\n/**\n * Progress events emitted by the exporter\n */\nexport type ExporterProgressEvents =\n  ProgressEvent<'unixfs:exporter:progress:unixfs:file', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:unixfs:raw', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:raw', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:identity', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:walk:file', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:directory', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:hamt-sharded-directory', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:raw', ExportWalk>\n\nexport interface ExporterOptions extends ProgressOptions<ExporterProgressEvents> {\n  /**\n   * An optional offset to start reading at.\n   *\n   * If the CID resolves to a file this will be a byte offset within that file,\n   * otherwise if it's a directory it will be a directory entry offset within\n   * the directory listing. (default: undefined)\n   */\n  offset?: number\n\n  /**\n   * An optional length to read.\n   *\n   * If the CID resolves to a file this will be the number of bytes read from\n   * the file, otherwise if it's a directory it will be the number of directory\n   * entries read from the directory listing. (default: undefined)\n   */\n  length?: number\n\n  /**\n   * This signal can be used to abort any long-lived operations such as fetching\n   * blocks from the network. (default: undefined)\n   */\n  signal?: AbortSignal\n\n  /**\n   * When a DAG layer is encountered, all child nodes are loaded in parallel but\n   * processed as they arrive. This allows us to load sibling nodes in advance\n   * of yielding their bytes. Pass a value here to control the number of blocks\n   * loaded in parallel. If a strict depth-first traversal is required, this\n   * value should be set to `1`, otherwise the traversal order will tend to\n   * resemble a breadth-first fan-out and yield a have stable ordering.\n   * (default: undefined)\n   */\n  blockReadConcurrency?: number\n}\n\nexport interface Exportable<T> {\n  /**\n   * A disambiguator to allow TypeScript to work out the type of the entry.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * if (entry.type === 'file') {\n   *   // access UnixFSFile properties safely\n   * }\n   *\n   * if (entry.type === 'directory') {\n   *   // access UnixFSDirectory properties safely\n   * }\n   * ```\n   */\n  type: 'file' | 'directory' | 'object' | 'raw' | 'identity'\n\n  /**\n   * The name of the entry\n   */\n  name: string\n\n  /**\n   * The path of the entry within the DAG in which it was encountered\n   */\n  path: string\n\n  /**\n   * The CID of the entry\n   */\n  cid: CID\n\n  /**\n   * How far down the DAG the entry is\n   */\n  depth: number\n\n  /**\n   * The size of the entry\n   */\n  size: bigint\n\n  /**\n   * @example File content\n   *\n   * When `entry` is a file or a `raw` node, `offset` and/or `length` arguments can be passed to `entry.content()` to return slices of data:\n   *\n   * ```TypeScript\n   * const length = 5\n   * const data = new Uint8Array(length)\n   * let offset = 0\n   *\n   * for await (const chunk of entry.content({\n   *   offset: 0,\n   *   length\n   * })) {\n   *   data.set(chunk, offset)\n   *   offset += chunk.length\n   * }\n   *\n   * // `data` contains the first 5 bytes of the file\n   * return data\n   * ```\n   *\n   * @example Directory content\n   *\n   * If `entry` is a directory, passing `offset` and/or `length` to `entry.content()` will limit the number of files returned from the directory.\n   *\n   * ```TypeScript\n   * const entries = []\n   *\n   * for await (const entry of dir.content({\n   *   offset: 0,\n   *   length: 5\n   * })) {\n   *   entries.push(entry)\n   * }\n   *\n   * // `entries` contains the first 5 files/directories in the directory\n   * ```\n   */\n  content(options?: ExporterOptions): AsyncGenerator<T, void, unknown>\n}\n\n/**\n * If the entry is a file, `entry.content()` returns an async iterator that yields one or more Uint8Arrays containing the file content:\n *\n * ```TypeScript\n * if (entry.type === 'file') {\n *   for await (const chunk of entry.content()) {\n *     // chunk is a Buffer\n *   }\n * }\n * ```\n */\nexport interface UnixFSFile extends Exportable<Uint8Array> {\n  type: 'file'\n  unixfs: UnixFS\n  node: PBNode\n}\n\n/**\n * If the entry is a directory, `entry.content()` returns further `entry` objects:\n *\n * ```TypeScript\n * if (entry.type === 'directory') {\n *   for await (const entry of dir.content()) {\n *     console.info(entry.name)\n *   }\n * }\n * ```\n */\nexport interface UnixFSDirectory extends Exportable<UnixFSEntry> {\n  type: 'directory'\n  unixfs: UnixFS\n  node: PBNode\n}\n\n/**\n * Entries with a `dag-cbor` or `dag-json` codec {@link CID} return JavaScript object entries\n */\nexport interface ObjectNode extends Exportable<any> {\n  type: 'object'\n  node: Uint8Array\n}\n\n/**\n * Entries with a `raw` codec {@link CID} return raw entries.\n *\n * `entry.content()` returns an async iterator that yields a buffer containing the node content:\n *\n * ```TypeScript\n * for await (const chunk of entry.content()) {\n *   // chunk is a Buffer\n * }\n * ```\n *\n * Unless you an options object containing `offset` and `length` keys as an argument to `entry.content()`, `chunk` will be equal to `entry.node`.\n */\nexport interface RawNode extends Exportable<Uint8Array> {\n  type: 'raw'\n  node: Uint8Array\n}\n\n/**\n * Entries with a `identity` codec {@link CID} return identity entries.\n *\n * These are entries where the data payload is stored in the CID itself,\n * otherwise they are identical to {@link RawNode}s.\n */\nexport interface IdentityNode extends Exportable<Uint8Array> {\n  type: 'identity'\n  node: Uint8Array\n}\n\n/**\n * A UnixFSEntry is a representation of the types of node that can be\n * encountered in a DAG.\n */\nexport type UnixFSEntry = UnixFSFile | UnixFSDirectory | ObjectNode | RawNode | IdentityNode\n\nexport interface NextResult {\n  cid: CID\n  name: string\n  path: string\n  toResolve: string[]\n}\n\nexport interface ResolveResult {\n  entry: UnixFSEntry\n  next?: NextResult\n}\n\nexport interface Resolve { (cid: CID, name: string, path: string, toResolve: string[], depth: number, blockstore: ReadableStorage, options: ExporterOptions): Promise<ResolveResult> }\nexport interface Resolver { (cid: CID, name: string, path: string, toResolve: string[], resolve: Resolve, depth: number, blockstore: ReadableStorage, options: ExporterOptions): Promise<ResolveResult> }\n\nexport type UnixfsV1FileContent = AsyncIterable<Uint8Array> | Iterable<Uint8Array>\nexport type UnixfsV1DirectoryContent = AsyncIterable<UnixFSEntry> | Iterable<UnixFSEntry>\nexport type UnixfsV1Content = UnixfsV1FileContent | UnixfsV1DirectoryContent\nexport interface UnixfsV1Resolver { (cid: CID, node: PBNode, unixfs: UnixFS, path: string, resolve: Resolve, depth: number, blockstore: ReadableStorage): (options: ExporterOptions) => UnixfsV1Content }\n\nexport interface ShardTraversalContext {\n  hamtDepth: number\n  rootBucket: Bucket<boolean>\n  lastBucket: Bucket<boolean>\n}\n\n/**\n * A subset of the {@link Blockstore} interface that just contains the get\n * method.\n */\nexport type ReadableStorage = Pick<Blockstore, 'get'>\n\nconst toPathComponents = (path: string = ''): string[] => {\n  // split on / unless escaped with \\\n  return (path\n    .trim()\n    .match(/([^\\\\^/]|\\\\\\/)+/g) ?? [])\n    .filter(Boolean)\n}\n\nconst cidAndRest = (path: string | Uint8Array | CID): { cid: CID, toResolve: string[] } => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    }\n  }\n\n  const cid = CID.asCID(path)\n  if (cid != null) {\n    return {\n      cid,\n      toResolve: []\n    }\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6)\n    }\n\n    const output = toPathComponents(path)\n\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    }\n  }\n\n  throw new BadPathError(`Unknown path type ${path}`)\n}\n\n/**\n * Returns an async iterator that yields entries for all segments in a path\n *\n * @example\n *\n * ```TypeScript\n * import { walkPath } from 'ipfs-unixfs-exporter'\n *\n * const entries = []\n *\n * for await (const entry of walkPath('Qmfoo/foo/bar/baz.txt', blockstore)) {\n *   entries.push(entry)\n * }\n *\n * // entries contains 4x `entry` objects\n * ```\n */\nexport async function * walkPath (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): AsyncGenerator<UnixFSEntry, void, any> {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path)\n  let name = cid.toString()\n  let entryPath = name\n  const startingDepth = toResolve.length\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options)\n\n    if (result.entry == null && result.next == null) {\n      throw new NotFoundError(`Could not resolve ${path}`)\n    }\n\n    if (result.entry != null) {\n      yield result.entry\n    }\n\n    if (result.next == null) {\n      return\n    }\n\n    // resolve further parts\n    toResolve = result.next.toResolve\n    cid = result.next.cid\n    name = result.next.name\n    entryPath = result.next.path\n  }\n}\n\n/**\n * Uses the given blockstore instance to fetch an IPFS node by a CID or path.\n *\n * Returns a {@link Promise} which resolves to a {@link UnixFSEntry}.\n *\n * @example\n *\n * ```typescript\n * import { exporter } from 'ipfs-unixfs-exporter'\n * import { CID } from 'multiformats/cid'\n *\n * const cid = CID.parse('QmFoo')\n *\n * const entry = await exporter(cid, blockstore, {\n *   signal: AbortSignal.timeout(50000)\n * })\n *\n * if (entry.type === 'file') {\n *   for await (const chunk of entry.content()) {\n *     // chunk is a Uint8Array\n *   }\n * }\n * ```\n */\nexport async function exporter (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): Promise<UnixFSEntry> {\n  const result = await last(walkPath(path, blockstore, options))\n\n  if (result == null) {\n    throw new NotFoundError(`Could not resolve ${path}`)\n  }\n\n  return result\n}\n\n/**\n * Returns an async iterator that yields all entries beneath a given CID or IPFS\n * path, as well as the containing directory.\n *\n * @example\n *\n * ```typescript\n * import { recursive } from 'ipfs-unixfs-exporter'\n *\n * const entries = []\n *\n * for await (const child of recursive('Qmfoo/foo/bar', blockstore)) {\n *   entries.push(entry)\n * }\n *\n * // entries contains all children of the `Qmfoo/foo/bar` directory and it's children\n * ```\n */\nexport async function * recursive (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): AsyncGenerator<UnixFSEntry, void, any> {\n  const node = await exporter(path, blockstore, options)\n\n  if (node == null) {\n    return\n  }\n\n  yield node\n\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child\n    }\n  }\n\n  async function * recurse (node: UnixFSDirectory, options: ExporterOptions): AsyncGenerator<UnixFSEntry, void, any> {\n    for await (const file of node.content(options)) {\n      yield file\n\n      if (file instanceof Uint8Array) {\n        continue\n      }\n\n      if (file.type === 'directory') {\n        yield * recurse(file, options)\n      }\n    }\n  }\n}\n", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n", "import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode }: { name: Name, code: Code, encode(input: Uint8Array): Await<Uint8Array> }): Hasher<Name, Code> {\n  return new Hasher(name, code, encode)\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  digest (input: Uint8Array): Await<Digest.Digest<Code, number>> {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\n// @ts-expect-error no types\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { AlreadyExistsError, InvalidParametersError, InvalidPBNodeError } from '../../errors.js'\nimport { wrapHash } from './consumable-hash.js'\nimport { hamtBucketBits, hamtHashFn } from './hamt-constants.js'\nimport {\n  createShard,\n  recreateShardedDirectory,\n  toPrefix,\n  updateShardedDirectory\n} from './hamt-utils.js'\nimport { isOverShardThreshold } from './is-over-shard-threshold.js'\nimport type { Directory } from './cid-to-directory.js'\nimport type { GetStore, PutStore } from '../../unixfs.js'\nimport type { PBNode, PBLink } from '@ipld/dag-pb'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { ImportResult } from 'ipfs-unixfs-importer'\nimport type { Version } from 'multiformats/cid'\n\nconst log = logger('helia:unixfs:components:utils:add-link')\n\nexport interface AddLinkResult {\n  node: PBNode\n  cid: CID\n}\n\nexport interface AddLinkOptions extends AbortOptions {\n  allowOverwriting: boolean\n  shardSplitThresholdBytes: number\n  cidVersion: Version\n}\n\nexport async function addLink (parent: Directory, child: Required<PBLink>, blockstore: GetStore & PutStore, options: AddLinkOptions): Promise<AddLinkResult> {\n  if (parent.node.Data == null) {\n    throw new InvalidParametersError('Invalid parent passed to addLink')\n  }\n\n  const meta = UnixFS.unmarshal(parent.node.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log('adding link to sharded directory')\n\n    return addToShardedDirectory(parent, child, blockstore, options)\n  }\n\n  log(`adding ${child.Name} (${child.Hash}) to regular directory`)\n\n  const result = await addToDirectory(parent, child, blockstore, options)\n\n  if (await isOverShardThreshold(result.node, blockstore, options.shardSplitThresholdBytes, options)) {\n    log('converting directory to sharded directory')\n\n    const converted = await convertToShardedDirectory(result, blockstore)\n    result.cid = converted.cid\n    result.node = dagPB.decode(await blockstore.get(converted.cid, options))\n  }\n\n  return result\n}\n\nconst convertToShardedDirectory = async (parent: Directory, blockstore: PutStore): Promise<ImportResult> => {\n  if (parent.node.Data == null) {\n    throw new InvalidParametersError('Invalid parent passed to convertToShardedDirectory')\n  }\n\n  const unixfs = UnixFS.unmarshal(parent.node.Data)\n\n  const result = await createShard(blockstore, parent.node.Links.map(link => ({\n    name: (link.Name ?? ''),\n    size: BigInt(link.Tsize ?? 0),\n    cid: link.Hash\n  })), {\n    mode: unixfs.mode,\n    mtime: unixfs.mtime,\n    cidVersion: parent.cid.version\n  })\n\n  log(`converted directory to sharded directory ${result.cid}`)\n\n  return result\n}\n\nconst addToDirectory = async (parent: Directory, child: PBLink, blockstore: PutStore, options: AddLinkOptions): Promise<AddLinkResult> => {\n  // Remove existing link if it exists\n  const parentLinks = parent.node.Links.filter((link) => {\n    const matches = link.Name === child.Name\n\n    if (matches && !options.allowOverwriting) {\n      throw new AlreadyExistsError()\n    }\n\n    return !matches\n  })\n  parentLinks.push(child)\n\n  if (parent.node.Data == null) {\n    throw new InvalidPBNodeError('Parent node with no data passed to addToDirectory')\n  }\n\n  const node = UnixFS.unmarshal(parent.node.Data)\n\n  let data\n  if (node.mtime != null) {\n    // Update mtime if previously set\n    const ms = Date.now()\n    const secs = Math.floor(ms / 1000)\n\n    node.mtime = {\n      secs: BigInt(secs),\n      nsecs: (ms - (secs * 1000)) * 1000\n    }\n\n    data = node.marshal()\n  } else {\n    data = parent.node.Data\n  }\n  parent.node = dagPB.prepare({\n    Data: data,\n    Links: parentLinks\n  })\n\n  // Persist the new parent PbNode\n  const buf = dagPB.encode(parent.node)\n  const hash = await sha256.digest(buf)\n  const cid = CID.create(parent.cid.version, dagPB.code, hash)\n\n  await blockstore.put(cid, buf)\n\n  return {\n    node: parent.node,\n    cid\n  }\n}\n\nconst addToShardedDirectory = async (parent: Directory, child: Required<PBLink>, blockstore: GetStore & PutStore, options: AddLinkOptions): Promise<AddLinkResult> => {\n  const { path, hash } = await recreateShardedDirectory(parent.cid, child.Name, blockstore, options)\n  const finalSegment = path[path.length - 1]\n\n  if (finalSegment == null) {\n    throw new Error('Invalid HAMT, could not generate path')\n  }\n\n  // find the next prefix\n  // const index = await hash.take(hamtBucketBits)\n  const prefix = finalSegment.prefix\n  const index = parseInt(prefix, 16)\n\n  log('next prefix for %s is %s', child.Name, prefix)\n\n  const linkName = `${prefix}${child.Name}`\n  const existingLink = finalSegment.node.Links.find(l => (l.Name ?? '').startsWith(prefix))\n\n  if (existingLink != null) {\n    log('link %s was present in shard', linkName)\n    // link is already present in shard\n\n    if (existingLink.Name === linkName) {\n      // file with same name is already present in shard\n      if (!options.allowOverwriting) {\n        throw new AlreadyExistsError()\n      }\n\n      log('overwriting %s in sub-shard', child.Name)\n      finalSegment.node.Links = finalSegment.node.Links.filter(l => l.Name !== linkName)\n      finalSegment.node.Links.push({\n        Name: linkName,\n        Hash: child.Hash,\n        Tsize: child.Tsize\n      })\n    } else if (existingLink.Name?.length === 2) {\n      throw new Error('Existing link was sub-shard?!')\n    } else {\n      // conflict, add a new HAMT segment\n      log('prefix %s already exists, creating new sub-shard', prefix)\n      // find the sibling we are going to replace\n      const index = finalSegment.node.Links.findIndex(l => l.Name?.startsWith(prefix))\n      const sibling = finalSegment.node.Links.splice(index, 1)[0]\n\n      // give the sibling a new HAMT prefix\n      const siblingName = (sibling.Name ?? '').substring(2)\n      const wrapped = wrapHash(hamtHashFn)\n      const siblingHash = wrapped(uint8ArrayFromString(siblingName))\n\n      // discard hash bits until we reach the sub-shard depth\n      for (let i = 0; i < path.length; i++) {\n        await siblingHash.take(hamtBucketBits)\n      }\n\n      while (true) {\n        const siblingIndex = await siblingHash.take(hamtBucketBits)\n        const siblingPrefix = toPrefix(siblingIndex)\n        sibling.Name = `${siblingPrefix}${siblingName}`\n\n        // calculate the target file's HAMT prefix in the new sub-shard\n        const newIndex = await hash.take(hamtBucketBits)\n        const newPrefix = toPrefix(newIndex)\n\n        if (siblingPrefix === newPrefix) {\n          // the two sibling names have caused another conflict - add an intermediate node to\n          // the HAMT and try again\n\n          // create the child locations\n          const children = new SparseArray()\n          children.set(newIndex, true)\n\n          path.push({\n            prefix: newPrefix,\n            children,\n            node: {\n              Links: []\n            }\n          })\n\n          continue\n        }\n\n        // create the child locations\n        const children = new SparseArray()\n        children.set(newIndex, true)\n        children.set(siblingIndex, true)\n\n        // add our new segment\n        path.push({\n          prefix,\n          children,\n          node: {\n            Links: [\n              sibling, {\n                Name: `${newPrefix}${child.Name}`,\n                Hash: child.Hash,\n                Tsize: child.Tsize\n              }\n            ]\n          }\n        })\n\n        break\n      }\n    }\n  } else {\n    log('link %s was not present in sub-shard', linkName)\n\n    // add new link to shard\n    child.Name = linkName\n    finalSegment.node.Links.push(child)\n    finalSegment.children.set(index, true)\n\n    log('adding %s to existing sub-shard', linkName)\n  }\n\n  return updateShardedDirectory(path, blockstore, options)\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\n\nexport function wrapHash (hashFn: (value: Uint8Array) => Promise<Uint8Array>): (value: InfiniteHash | Uint8Array) => InfiniteHash {\n  function hashing (value: InfiniteHash | Uint8Array): InfiniteHash {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nexport class InfiniteHash {\n  _value: Uint8Array\n  _hashFn: (value: Uint8Array) => Promise<Uint8Array>\n  _depth: number\n  _availableBits: number\n  _currentBufferIndex: number\n  _buffers: ConsumableBuffer[]\n\n  constructor (value: Uint8Array, hashFn: (value: Uint8Array) => Promise<Uint8Array>) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n    this._buffers = []\n  }\n\n  async take (bits: number): Promise<number> {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits (): Promise<void> {\n    this._depth++\n\n    const value = this._depth > 0 ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n\nconst START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nexport class ConsumableBuffer {\n  _value: Uint8Array\n  _currentBytePos: number\n  _currentBitPos: number\n\n  constructor (value: Uint8Array) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits (): number {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits (): number {\n    return this._value.length * 8\n  }\n\n  take (bits: number): number {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits > 0 && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits (): boolean {\n    return this._currentBytePos >= 0\n  }\n}\n\nfunction byteBitsToInt (byte: number, start: number, length: number): number {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\nfunction maskFor (start: number, length: number): number {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n", "import { murmur3128 } from '@multiformats/murmur3'\n\nexport const hamtHashCode = BigInt(murmur3128.code)\nexport const hamtBucketBits = 8\n\nexport async function hamtHashFn (buf: Uint8Array): Promise<Uint8Array> {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .subarray(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport last from 'it-last'\n// @ts-expect-error no types\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { wrapHash } from './consumable-hash.js'\nimport { DirSharded } from './dir-sharded.js'\nimport {\n  hamtHashCode,\n  hamtHashFn,\n  hamtBucketBits\n} from './hamt-constants.js'\nimport { persist } from './persist.js'\nimport type { InfiniteHash } from './consumable-hash.js'\nimport type { PersistOptions } from './persist.js'\nimport type { GetStore, PutStore } from '../../unixfs.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { Mtime } from 'ipfs-unixfs'\nimport type { ImportResult } from 'ipfs-unixfs-importer'\nimport type { CID, Version } from 'multiformats/cid'\n\nconst log = logger('helia:unixfs:commands:utils:hamt-utils')\n\nexport interface UpdateHamtDirectoryOptions extends AbortOptions {\n  cidVersion: Version\n}\n\nexport const toPrefix = (position: number): string => {\n  return position\n    .toString(16)\n    .toUpperCase()\n    .padStart(2, '0')\n    .substring(0, 2)\n}\n\nexport interface CreateShardOptions {\n  mtime?: Mtime\n  mode?: number\n  cidVersion: Version\n}\n\nexport const createShard = async (blockstore: PutStore, contents: Array<{ name: string, size: bigint, cid: CID }>, options: CreateShardOptions): Promise<ImportResult> => {\n  const shard = new DirSharded({\n    root: true,\n    dir: true,\n    parent: undefined,\n    parentKey: undefined,\n    path: '',\n    dirty: true,\n    flat: false,\n    mtime: options.mtime,\n    mode: options.mode\n  }, options)\n\n  for (let i = 0; i < contents.length; i++) {\n    await shard._bucket.put(contents[i].name, {\n      size: contents[i].size,\n      cid: contents[i].cid\n    })\n  }\n\n  const res = await last(shard.flush(blockstore))\n\n  if (res == null) {\n    throw new Error('Flushing shard yielded no result')\n  }\n\n  return res\n}\n\nexport interface HAMTPath {\n  prefix: string\n  children: SparseArray\n  node: dagPB.PBNode\n}\n\nexport const updateShardedDirectory = async (path: HAMTPath[], blockstore: GetStore & PutStore, options: PersistOptions): Promise<{ cid: CID, node: dagPB.PBNode }> => {\n  // persist any metadata on the shard root\n  const shardRoot = UnixFS.unmarshal(path[0].node.Data ?? new Uint8Array(0))\n\n  // this is always the same\n  const fanout = BigInt(Math.pow(2, hamtBucketBits))\n\n  // start from the leaf and ascend to the root\n  path.reverse()\n\n  let cid: CID | undefined\n  let node: dagPB.PBNode | undefined\n\n  for (let i = 0; i < path.length; i++) {\n    const isRoot = i === path.length - 1\n    const segment = path[i]\n\n    // go-ipfs uses little endian, that's why we have to\n    // reverse the bit field before storing it\n    const data = Uint8Array.from(segment.children.bitField().reverse())\n    const dir = new UnixFS({\n      type: 'hamt-sharded-directory',\n      data,\n      fanout,\n      hashType: hamtHashCode\n    })\n\n    if (isRoot) {\n      dir.mtime = shardRoot.mtime\n      dir.mode = shardRoot.mode\n    }\n\n    node = {\n      Data: dir.marshal(),\n      Links: segment.node.Links\n    }\n\n    const block = dagPB.encode(dagPB.prepare(node))\n\n    cid = await persist(block, blockstore, options)\n\n    if (!isRoot) {\n      // update link in parent sub-shard\n      const nextSegment = path[i + 1]\n\n      if (nextSegment == null) {\n        throw new Error('Was not operating on shard root but also had no parent?')\n      }\n\n      log('updating link in parent sub-shard with prefix %s', nextSegment.prefix)\n\n      nextSegment.node.Links = nextSegment.node.Links.filter(l => l.Name !== nextSegment.prefix)\n      nextSegment.node.Links.push({\n        Name: nextSegment.prefix,\n        Hash: cid,\n        Tsize: segment.node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), block.byteLength)\n      })\n    }\n  }\n\n  if (cid == null || node == null) {\n    throw new Error('Noting persisted')\n  }\n\n  return { cid, node }\n}\n\nexport const recreateShardedDirectory = async (cid: CID, fileName: string, blockstore: Pick<Blockstore, 'get'>, options: AbortOptions): Promise<{ path: HAMTPath[], hash: InfiniteHash }> => {\n  const wrapped = wrapHash(hamtHashFn)\n  const hash = wrapped(uint8ArrayFromString(fileName))\n  const path: HAMTPath[] = []\n\n  // descend the HAMT, loading each layer as we head towards the target child\n  while (true) {\n    const block = await blockstore.get(cid, options)\n    const node = dagPB.decode(block)\n    const children = new SparseArray()\n    const index = await hash.take(hamtBucketBits)\n    const prefix = toPrefix(index)\n\n    path.push({\n      prefix,\n      children,\n      node\n    })\n\n    let childLink: dagPB.PBLink | undefined\n\n    // update sparsearray child layout - the bitfield is used as the data field for the\n    // intermediate DAG node so this is required to generate consistent hashes\n    for (const link of node.Links) {\n      const linkName = link.Name ?? ''\n\n      if (linkName.length < 2) {\n        throw new Error('Invalid HAMT - link name was too short')\n      }\n\n      const position = parseInt(linkName.substring(0, 2), 16)\n      children.set(position, true)\n\n      // we found the child we are looking for\n      if (linkName.startsWith(prefix)) {\n        childLink = link\n      }\n    }\n\n    if (childLink == null) {\n      log('no link found with prefix %s for %s', prefix, fileName)\n      // hash.untake(hamtBucketBits)\n      break\n    }\n\n    const linkName = childLink.Name ?? ''\n\n    if (linkName.length < 2) {\n      throw new Error('Invalid HAMT - link name was too short')\n    }\n\n    if (linkName.length === 2) {\n      // found sub-shard\n      cid = childLink.Hash\n      log('descend into sub-shard with prefix %s', linkName)\n\n      continue\n    }\n\n    break\n  }\n\n  return { path, hash }\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport type { PutStore } from '../../unixfs.js'\nimport type { Version as CIDVersion } from 'multiformats/cid'\nimport type { BlockCodec } from 'multiformats/codecs/interface'\n\nexport interface PersistOptions {\n  codec?: BlockCodec<any, any>\n  cidVersion: CIDVersion\n  signal?: AbortSignal\n}\n\nexport const persist = async (buffer: Uint8Array, blockstore: PutStore, options: PersistOptions): Promise<CID> => {\n  if (options.codec == null) {\n    options.codec = dagPb\n  }\n\n  const multihash = await sha256.digest(buffer)\n  const cid = CID.create(options.cidVersion, options.codec.code, multihash)\n\n  await blockstore.put(cid, buffer, {\n    ...options,\n    signal: options.signal\n  })\n\n  return cid\n}\n", "import { encode, prepare } from '@ipld/dag-pb'\nimport { createHAMT, Bucket } from 'hamt-sharding'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { CID } from 'multiformats/cid'\nimport {\n  hamtHashCode,\n  hamtHashFn\n} from './hamt-constants.js'\nimport { persist } from './persist.js'\nimport type { PersistOptions } from './persist.js'\nimport type { PutStore } from '../../unixfs.js'\nimport type { PBLink } from '@ipld/dag-pb'\nimport type { BucketChild } from 'hamt-sharding'\nimport type { Mtime } from 'ipfs-unixfs'\n\ninterface InProgressImportResult extends ImportResult {\n  single?: boolean\n  originalPath?: string\n}\n\ninterface ImportResult {\n  cid: CID\n  size: bigint\n  path?: string\n  unixfs?: UnixFS\n}\n\ninterface DirProps {\n  root: boolean\n  dir: boolean\n  path: string\n  dirty: boolean\n  flat: boolean\n  parent?: Dir\n  parentKey?: string\n  unixfs?: UnixFS\n  mode?: number\n  mtime?: Mtime\n}\n\nabstract class Dir {\n  public options: PersistOptions\n  public root: boolean\n  public dir: boolean\n  public path: string\n  public dirty: boolean\n  public flat: boolean\n  public parent?: Dir\n  public parentKey?: string\n  public unixfs?: UnixFS\n  public mode?: number\n  public mtime?: Mtime\n  public cid?: CID\n  public size?: number\n  public nodeSize?: number\n\n  constructor (props: DirProps, options: PersistOptions) {\n    this.options = options ?? {}\n\n    this.root = props.root\n    this.dir = props.dir\n    this.path = props.path\n    this.dirty = props.dirty\n    this.flat = props.flat\n    this.parent = props.parent\n    this.parentKey = props.parentKey\n    this.unixfs = props.unixfs\n    this.mode = props.mode\n    this.mtime = props.mtime\n  }\n\n  abstract put (name: string, value: InProgressImportResult | Dir): Promise<void>\n  abstract get (name: string): Promise<InProgressImportResult | Dir | undefined>\n  abstract eachChildSeries (): AsyncIterable<{ key: string, child: InProgressImportResult | Dir }>\n  abstract flush (blockstore: PutStore): AsyncGenerator<ImportResult>\n  abstract estimateNodeSize (): number\n  abstract childCount (): number\n}\n\nexport class DirSharded extends Dir {\n  public _bucket: Bucket<InProgressImportResult | Dir>\n\n  constructor (props: DirProps, options: PersistOptions) {\n    super(props, options)\n\n    this._bucket = createHAMT({\n      hashFn: hamtHashFn,\n      bits: 8\n    })\n  }\n\n  async put (name: string, value: InProgressImportResult | Dir): Promise<void> {\n    this.cid = undefined\n    this.size = undefined\n    this.nodeSize = undefined\n\n    await this._bucket.put(name, value)\n  }\n\n  async get (name: string): Promise<InProgressImportResult | Dir | undefined> {\n    return this._bucket.get(name)\n  }\n\n  childCount (): number {\n    return this._bucket.leafCount()\n  }\n\n  directChildrenCount (): number {\n    return this._bucket.childrenCount()\n  }\n\n  onlyChild (): Bucket<InProgressImportResult | Dir> | BucketChild<InProgressImportResult | Dir> {\n    return this._bucket.onlyChild()\n  }\n\n  async * eachChildSeries (): AsyncGenerator<{ key: string, child: InProgressImportResult | Dir }> {\n    for (const { key, value } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      }\n    }\n  }\n\n  estimateNodeSize (): number {\n    if (this.nodeSize !== undefined) {\n      return this.nodeSize\n    }\n\n    this.nodeSize = calculateSize(this._bucket, this, this.options)\n\n    return this.nodeSize\n  }\n\n  async * flush (blockstore: PutStore): AsyncGenerator<ImportResult> {\n    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n      yield {\n        ...entry,\n        path: this.path\n      }\n    }\n  }\n}\n\nasync function * flush (bucket: Bucket<Dir | InProgressImportResult>, blockstore: PutStore, shardRoot: DirSharded | null, options: PersistOptions): AsyncIterable<ImportResult> {\n  const children = bucket._children\n  const links: PBLink[] = []\n  let childrenSize = 0n\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (child == null) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0')\n\n    if (child instanceof Bucket) {\n      let shard\n\n      for await (const subShard of flush(child, blockstore, null, options)) {\n        shard = subShard\n      }\n\n      if (shard == null) {\n        throw new Error('Could not flush sharded directory, no sub-shard found')\n      }\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: Number(shard.size),\n        Hash: shard.cid\n      })\n      childrenSize += shard.size\n    } else if (isDir(child.value)) {\n      const dir = child.value\n      let flushedDir: ImportResult | undefined\n\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry\n\n        yield flushedDir\n      }\n\n      if (flushedDir == null) {\n        throw new Error('Did not flush dir')\n      }\n\n      const label = labelPrefix + child.key\n      links.push({\n        Name: label,\n        Tsize: Number(flushedDir.size),\n        Hash: flushedDir.cid\n      })\n\n      childrenSize += flushedDir.size\n    } else {\n      const value = child.value\n\n      if (value.cid == null) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: Number(size),\n        Hash: value.cid\n      })\n      childrenSize += BigInt(size ?? 0)\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: BigInt(bucket.tableSize()),\n    hashType: hamtHashCode,\n    mtime: shardRoot?.mtime,\n    mode: shardRoot?.mode\n  })\n\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  }\n  const buffer = encode(prepare(node))\n  const cid = await persist(buffer, blockstore, options)\n  const size = BigInt(buffer.byteLength) + childrenSize\n\n  yield {\n    cid,\n    unixfs: dir,\n    size\n  }\n}\n\nfunction isDir (obj: any): obj is Dir {\n  return typeof obj.flush === 'function'\n}\n\nfunction calculateSize (bucket: Bucket<any>, shardRoot: DirSharded | null, options: PersistOptions): number {\n  const children = bucket._children\n  const links: PBLink[] = []\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (child == null) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0')\n\n    if (child instanceof Bucket) {\n      const size = calculateSize(child, null, options)\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: Number(size),\n        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n      })\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value\n      const size = dir.nodeSize()\n\n      links.push({\n        Name: labelPrefix + child.key,\n        Tsize: Number(size),\n        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n      })\n    } else {\n      const value = child.value\n\n      if (value.cid == null) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: Number(size),\n        Hash: value.cid\n      })\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: BigInt(bucket.tableSize()),\n    hashType: hamtHashCode,\n    mtime: shardRoot?.mtime,\n    mode: shardRoot?.mode\n  })\n\n  const buffer = encode(prepare({\n    Data: dir.marshal(),\n    Links: links\n  }))\n\n  return buffer.length\n}\n\n// we use these to calculate the node size to use as a check for whether a directory\n// should be sharded or not. Since CIDs have a constant length and We're only\n// interested in the data length and not the actual content identifier we can use\n// any old CID instead of having to hash the data which is expensive.\nexport const CID_V0 = CID.parse('QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn')\nexport const CID_V1 = CID.parse('zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi')\n", "import * as dagPb from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { CID_V0, CID_V1 } from './dir-sharded.js'\nimport type { GetStore } from '../../unixfs.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { AbortOptions } from '@libp2p/interface'\n\n/**\n * Estimate node size only based on DAGLink name and CID byte lengths\n * https://github.com/ipfs/go-unixfsnode/blob/37b47f1f917f1b2f54c207682f38886e49896ef9/data/builder/directory.go#L81-L96\n *\n * If the node is a hamt sharded directory the calculation is based on if it was a regular directory.\n */\nexport async function isOverShardThreshold (node: PBNode, blockstore: GetStore, threshold: number, options: AbortOptions): Promise<boolean> {\n  if (node.Data == null) {\n    throw new Error('DagPB node had no data')\n  }\n\n  const unixfs = UnixFS.unmarshal(node.Data)\n  let size: number\n\n  if (unixfs.type === 'directory') {\n    size = estimateNodeSize(node)\n  } else if (unixfs.type === 'hamt-sharded-directory') {\n    size = await estimateShardSize(node, 0, threshold, blockstore, options)\n  } else {\n    throw new Error('Can only estimate the size of directories or shards')\n  }\n\n  return size > threshold\n}\n\nfunction estimateNodeSize (node: PBNode): number {\n  let size = 0\n\n  // estimate size only based on DAGLink name and CID byte lengths\n  // https://github.com/ipfs/go-unixfsnode/blob/37b47f1f917f1b2f54c207682f38886e49896ef9/data/builder/directory.go#L81-L96\n  for (const link of node.Links) {\n    size += (link.Name ?? '').length\n    size += link.Hash.version === 1 ? CID_V1.bytes.byteLength : CID_V0.bytes.byteLength\n  }\n\n  return size\n}\n\nasync function estimateShardSize (node: PBNode, current: number, max: number, blockstore: GetStore, options: AbortOptions): Promise<number> {\n  if (current > max) {\n    return max\n  }\n\n  if (node.Data == null) {\n    return current\n  }\n\n  const unixfs = UnixFS.unmarshal(node.Data)\n\n  if (!unixfs.isDirectory()) {\n    return current\n  }\n\n  for (const link of node.Links) {\n    let name = link.Name ?? ''\n\n    // remove hamt hash prefix from name\n    name = name.substring(2)\n\n    current += name.length\n    current += link.Hash.bytes.byteLength\n\n    if (link.Hash.code === dagPb.code) {\n      const block = await blockstore.get(link.Hash, options)\n      const node = dagPb.decode(block)\n\n      current += await estimateShardSize(node, current, max, blockstore, options)\n    }\n  }\n\n  return current\n}\n", "import { exporter } from 'ipfs-unixfs-exporter'\nimport { NotADirectoryError } from '../../errors.js'\nimport type { GetStore } from '../../unixfs.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { ExporterOptions } from 'ipfs-unixfs-exporter'\nimport type { CID } from 'multiformats/cid'\n\nexport interface Directory {\n  cid: CID\n  node: PBNode\n}\n\nexport async function cidToDirectory (cid: CID, blockstore: GetStore, options: ExporterOptions = {}): Promise<Directory> {\n  const entry = await exporter(cid, blockstore, options)\n\n  if (entry.type !== 'directory') {\n    throw new NotADirectoryError(`${cid.toString()} was not a UnixFS directory`)\n  }\n\n  return {\n    cid,\n    node: entry.node\n  }\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { NotUnixFSError } from '../../errors.js'\nimport type { GetStore } from '../../unixfs.js'\nimport type { PBNode, PBLink } from '@ipld/dag-pb'\nimport type { ExporterOptions } from 'ipfs-unixfs-exporter'\nimport type { CID } from 'multiformats/cid'\n\nexport async function cidToPBLink (cid: CID, name: string, blockstore: GetStore, options?: ExporterOptions): Promise<Required<PBLink>> {\n  const sourceEntry = await exporter(cid, blockstore, options)\n\n  if (sourceEntry.type !== 'directory' && sourceEntry.type !== 'file' && sourceEntry.type !== 'raw') {\n    throw new NotUnixFSError(`${cid.toString()} was not a UnixFS node`)\n  }\n\n  return {\n    Name: name,\n    Tsize: sourceEntry.node instanceof Uint8Array ? sourceEntry.node.byteLength : dagNodeTsize(sourceEntry.node),\n    Hash: cid\n  }\n}\n\nfunction dagNodeTsize (node: PBNode): number {\n  const linkSizes = node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0)\n\n  return dagPb.encode(node).byteLength + linkSizes\n}\n", "import { logger } from '@libp2p/logger'\nimport { walkPath } from 'ipfs-unixfs-exporter'\nimport all from 'it-all'\nimport { DoesNotExistError } from '../../errors.js'\nimport { addLink } from './add-link.js'\nimport { cidToDirectory } from './cid-to-directory.js'\nimport { cidToPBLink } from './cid-to-pblink.js'\nimport type { GetStore, PutStore } from '../../unixfs.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { CID } from 'multiformats/cid'\n\nconst log = logger('helia:unixfs:components:utils:resolve')\n\nexport interface Segment {\n  name: string\n  cid: CID\n  size: bigint\n}\n\nexport interface ResolveResult {\n  /**\n   * The CID at the end of the path\n   */\n  cid: CID\n\n  path?: string\n\n  /**\n   * If present, these are the CIDs and path segments that were traversed through to reach the final CID\n   *\n   * If not present, there was no path passed or the path was an empty string\n   */\n  segments?: Segment[]\n}\n\nexport async function resolve (cid: CID, path: string | undefined, blockstore: GetStore, options: AbortOptions): Promise<ResolveResult> {\n  if (path == null || path === '') {\n    return { cid }\n  }\n\n  const p = `/ipfs/${cid}${path == null ? '' : `/${path}`}`\n  const segments = await all(walkPath(p, blockstore, options))\n\n  if (segments.length === 0) {\n    throw new DoesNotExistError('Could not find path in directory')\n  }\n\n  log('resolved %s to %c', path, cid)\n\n  return {\n    cid: segments[segments.length - 1].cid,\n    path,\n    segments\n  }\n}\n\nexport interface UpdatePathCidsOptions extends AbortOptions {\n  shardSplitThresholdBytes: number\n}\n\n/**\n * Where we have descended into a DAG to update a child node, ascend up the DAG creating\n * new hashes and blocks for the changed content\n */\nexport async function updatePathCids (cid: CID, result: ResolveResult, blockstore: PutStore & GetStore, options: UpdatePathCidsOptions): Promise<CID> {\n  if (result.segments == null || result.segments.length === 0) {\n    return cid\n  }\n\n  let child = result.segments.pop()\n\n  if (child == null) {\n    throw new Error('Insufficient segments')\n  }\n\n  child.cid = cid\n\n  result.segments.reverse()\n\n  for (const parent of result.segments) {\n    const [\n      directory,\n      pblink\n    ] = await Promise.all([\n      cidToDirectory(parent.cid, blockstore, options),\n      cidToPBLink(child.cid, child.name, blockstore, options)\n    ])\n\n    const result = await addLink(directory, pblink, blockstore, {\n      ...options,\n      allowOverwriting: true,\n      cidVersion: cid.version\n    })\n\n    cid = result.cid\n    parent.cid = cid\n    child = parent\n  }\n\n  return cid\n}\n", "import { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { NoContentError, NotAFileError } from '../errors.js'\nimport { resolve } from './utils/resolve.js'\nimport type { CatOptions } from '../index.js'\nimport type { GetStore } from '../unixfs.js'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\n\nconst defaultOptions: CatOptions = {\n\n}\n\nexport async function * cat (cid: CID, blockstore: GetStore, options: Partial<CatOptions> = {}): AsyncIterable<Uint8Array> {\n  const opts: CatOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, opts.path, blockstore, opts)\n  const result = await exporter(resolved.cid, blockstore, opts)\n\n  if (result.type !== 'file' && result.type !== 'raw') {\n    throw new NotAFileError()\n  }\n\n  if (result.content == null) {\n    throw new NoContentError()\n  }\n\n  yield * result.content(opts)\n}\n", "import { coerce } from '../bytes.js'\nimport type { ArrayBufferView, ByteView } from './interface.js'\n\nexport const name = 'raw'\nexport const code = 0x55\n\nexport function encode (node: Uint8Array): ByteView<Uint8Array> {\n  return coerce(node)\n}\n\nexport function decode (data: ByteView<Uint8Array> | ArrayBufferView<Uint8Array>): Uint8Array {\n  return coerce(data)\n}\n", "export const SHARD_SPLIT_THRESHOLD_BYTES = 262144\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { recursive } from 'ipfs-unixfs-exporter'\nimport { importer } from 'ipfs-unixfs-importer'\nimport last from 'it-last'\nimport { pipe } from 'it-pipe'\nimport { CID } from 'multiformats/cid'\nimport * as raw from 'multiformats/codecs/raw'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { InvalidPBNodeError, NotUnixFSError, UnknownError } from '../errors.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport { persist } from './utils/persist.js'\nimport { resolve, updatePathCids } from './utils/resolve.js'\nimport type { ChmodOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\nimport type { PBNode, PBLink } from '@ipld/dag-pb'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:chmod')\n\nconst defaultOptions: ChmodOptions = {\n  recursive: false,\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function chmod (cid: CID, mode: number, blockstore: PutStore & GetStore, options: Partial<ChmodOptions> = {}): Promise<CID> {\n  const opts: ChmodOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, opts.path, blockstore, options)\n\n  log('chmod %c %d', resolved.cid, mode)\n\n  if (opts.recursive) {\n    // recursively export from root CID, change perms of each entry then reimport\n    // but do not reimport files, only manipulate dag-pb nodes\n    const root = await pipe(\n      async function * () {\n        for await (const entry of recursive(resolved.cid, blockstore, options)) {\n          let metadata: UnixFS\n          let links: PBLink[] = []\n\n          if (entry.type === 'raw') {\n            // convert to UnixFS\n            metadata = new UnixFS({ type: 'file', data: entry.node })\n          } else if (entry.type === 'file' || entry.type === 'directory') {\n            metadata = entry.unixfs\n            links = entry.node.Links\n          } else {\n            throw new NotUnixFSError()\n          }\n\n          metadata.mode = mode\n\n          const node = {\n            Data: metadata.marshal(),\n            Links: links\n          }\n\n          yield {\n            path: entry.path,\n            content: node\n          }\n        }\n      },\n      // @ts-expect-error cannot combine progress types\n      (source) => importer(source, blockstore, {\n        ...opts,\n        dagBuilder: async function * (source, block) {\n          for await (const entry of source) {\n            yield async function () {\n              // @ts-expect-error cannot derive type\n              const node: PBNode = entry.content\n\n              const buf = dagPB.encode(node)\n              const updatedCid = await persist(buf, block, {\n                ...opts,\n                cidVersion: cid.version\n              })\n\n              if (node.Data == null) {\n                throw new InvalidPBNodeError(`${updatedCid} had no data`)\n              }\n\n              const unixfs = UnixFS.unmarshal(node.Data)\n\n              return {\n                cid: updatedCid,\n                size: BigInt(buf.length),\n                path: entry.path,\n                unixfs\n              }\n            }\n          }\n        }\n      }),\n      async (nodes) => last(nodes)\n    )\n\n    if (root == null) {\n      throw new UnknownError(`Could not chmod ${resolved.cid.toString()}`)\n    }\n\n    return updatePathCids(root.cid, resolved, blockstore, opts)\n  }\n\n  const block = await blockstore.get(resolved.cid, options)\n  let metadata: UnixFS\n  let links: PBLink[] = []\n\n  if (resolved.cid.code === raw.code) {\n    // convert to UnixFS\n    metadata = new UnixFS({ type: 'file', data: block })\n  } else {\n    const node = dagPB.decode(block)\n\n    if (node.Data == null) {\n      throw new InvalidPBNodeError(`${resolved.cid.toString()} had no data`)\n    }\n\n    links = node.Links\n    metadata = UnixFS.unmarshal(node.Data)\n  }\n\n  metadata.mode = mode\n  const updatedBlock = dagPB.encode({\n    Data: metadata.marshal(),\n    Links: links\n  })\n\n  const hash = await sha256.digest(updatedBlock)\n  const updatedCid = CID.create(resolved.cid.version, dagPB.code, hash)\n\n  await blockstore.put(updatedCid, updatedBlock)\n\n  return updatePathCids(updatedCid, resolved, blockstore, opts)\n}\n", "import { logger } from '@libp2p/logger'\nimport { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { InvalidParametersError } from '../errors.js'\nimport { addLink } from './utils/add-link.js'\nimport { cidToDirectory } from './utils/cid-to-directory.js'\nimport { cidToPBLink } from './utils/cid-to-pblink.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport type { CpOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:cp')\n\nconst defaultOptions: CpOptions = {\n  force: false,\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function cp (source: CID, target: CID, name: string, blockstore: GetStore & PutStore, options: Partial<CpOptions> = {}): Promise<CID> {\n  const opts: CpOptions = mergeOptions(defaultOptions, options)\n\n  if (name.includes('/')) {\n    throw new InvalidParametersError('Name must not have slashes')\n  }\n\n  const [\n    directory,\n    pblink\n  ] = await Promise.all([\n    cidToDirectory(target, blockstore, opts),\n    cidToPBLink(source, name, blockstore, opts)\n  ])\n\n  log('Adding %c as \"%s\" to %c', source, name, target)\n\n  const result = await addLink(directory, pblink, blockstore, {\n    allowOverwriting: opts.force,\n    cidVersion: target.version,\n    ...opts\n  })\n\n  return result.cid\n}\n", "import { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { NoContentError, NotADirectoryError } from '../errors.js'\nimport { resolve } from './utils/resolve.js'\nimport type { LsOptions } from '../index.js'\nimport type { GetStore } from '../unixfs.js'\nimport type { UnixFSEntry } from 'ipfs-unixfs-exporter'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\n\nconst defaultOptions: LsOptions = {\n\n}\n\nexport async function * ls (cid: CID, blockstore: GetStore, options: Partial<LsOptions> = {}): AsyncIterable<UnixFSEntry> {\n  const opts: LsOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, opts.path, blockstore, opts)\n  const result = await exporter(resolved.cid, blockstore)\n\n  if (result.type === 'file' || result.type === 'raw') {\n    yield result\n    return\n  }\n\n  if (result.content == null) {\n    throw new NoContentError()\n  }\n\n  if (result.type !== 'directory') {\n    throw new NotADirectoryError()\n  }\n\n  yield * result.content({\n    offset: options.offset,\n    length: options.length\n  })\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { InvalidParametersError, NotADirectoryError } from '../errors.js'\nimport { addLink } from './utils/add-link.js'\nimport { cidToDirectory } from './utils/cid-to-directory.js'\nimport { cidToPBLink } from './utils/cid-to-pblink.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport type { MkdirOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:mkdir')\n\nconst defaultOptions: MkdirOptions = {\n  cidVersion: 1,\n  force: false,\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function mkdir (parentCid: CID, dirname: string, blockstore: GetStore & PutStore, options: Partial<MkdirOptions> = {}): Promise<CID> {\n  const opts: MkdirOptions = mergeOptions(defaultOptions, options)\n\n  if (dirname.includes('/')) {\n    throw new InvalidParametersError('Path must not have slashes')\n  }\n\n  const entry = await exporter(parentCid, blockstore, options)\n\n  if (entry.type !== 'directory') {\n    throw new NotADirectoryError(`${parentCid.toString()} was not a UnixFS directory`)\n  }\n\n  log('creating %s', dirname)\n\n  const metadata = new UnixFS({\n    type: 'directory',\n    mode: opts.mode,\n    mtime: opts.mtime\n  })\n\n  // Persist the new parent PBNode\n  const node = {\n    Data: metadata.marshal(),\n    Links: []\n  }\n  const buf = dagPB.encode(node)\n  const hash = await sha256.digest(buf)\n  const emptyDirCid = CID.create(opts.cidVersion, dagPB.code, hash)\n\n  await blockstore.put(emptyDirCid, buf)\n\n  const [\n    directory,\n    pblink\n  ] = await Promise.all([\n    cidToDirectory(parentCid, blockstore, opts),\n    cidToPBLink(emptyDirCid, dirname, blockstore, opts)\n  ])\n\n  log('adding empty dir called %s to %c', dirname, parentCid)\n\n  const result = await addLink(directory, pblink, blockstore, {\n    ...opts,\n    allowOverwriting: opts.force\n  })\n\n  return result.cid\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { InvalidParametersError, InvalidPBNodeError } from '../../errors.js'\nimport {\n  recreateShardedDirectory,\n\n  updateShardedDirectory\n} from './hamt-utils.js'\nimport { isOverShardThreshold } from './is-over-shard-threshold.js'\nimport { persist } from './persist.js'\nimport type { Directory } from './cid-to-directory.js'\nimport type { UpdateHamtDirectoryOptions } from './hamt-utils.js'\nimport type { GetStore, PutStore } from '../../unixfs.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { CID, Version } from 'multiformats/cid'\n\nconst log = logger('helia:unixfs:utils:remove-link')\n\nexport interface RmLinkOptions extends AbortOptions {\n  shardSplitThresholdBytes: number\n  cidVersion: Version\n}\n\nexport interface RemoveLinkResult {\n  node: PBNode\n  cid: CID\n}\n\nexport async function removeLink (parent: Directory, name: string, blockstore: PutStore & GetStore, options: RmLinkOptions): Promise<RemoveLinkResult> {\n  if (parent.node.Data == null) {\n    throw new InvalidPBNodeError('Parent node had no data')\n  }\n\n  const meta = UnixFS.unmarshal(parent.node.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`removing ${name} from sharded directory`)\n\n    const result = await removeFromShardedDirectory(parent, name, blockstore, options)\n\n    if (!(await isOverShardThreshold(result.node, blockstore, options.shardSplitThresholdBytes, options))) {\n      log('converting shard to flat directory %c', parent.cid)\n\n      return convertToFlatDirectory(result, blockstore, options)\n    }\n\n    return result\n  }\n\n  log(`removing link ${name} regular directory`)\n\n  return removeFromDirectory(parent, name, blockstore, options)\n}\n\nconst removeFromDirectory = async (parent: Directory, name: string, blockstore: PutStore & GetStore, options: AbortOptions): Promise<RemoveLinkResult> => {\n  // Remove existing link if it exists\n  parent.node.Links = parent.node.Links.filter((link) => {\n    return link.Name !== name\n  })\n\n  const parentBlock = dagPB.encode(parent.node)\n  const parentCid = await persist(parentBlock, blockstore, {\n    ...options,\n    cidVersion: parent.cid.version\n  })\n\n  log(`Updated regular directory ${parentCid}`)\n\n  return {\n    node: parent.node,\n    cid: parentCid\n  }\n}\n\nconst removeFromShardedDirectory = async (parent: Directory, name: string, blockstore: PutStore & GetStore, options: UpdateHamtDirectoryOptions): Promise<{ cid: CID, node: PBNode }> => {\n  const { path } = await recreateShardedDirectory(parent.cid, name, blockstore, options)\n  const finalSegment = path[path.length - 1]\n\n  if (finalSegment == null) {\n    throw new Error('Invalid HAMT, could not generate path')\n  }\n\n  const linkName = finalSegment.node.Links.filter(l => (l.Name ?? '').substring(2) === name).map(l => l.Name).pop()\n\n  if (linkName == null) {\n    throw new Error('File not found')\n  }\n\n  const prefix = linkName.substring(0, 2)\n  const index = parseInt(prefix, 16)\n\n  // remove the file from the shard\n  finalSegment.node.Links = finalSegment.node.Links.filter(link => link.Name !== linkName)\n  finalSegment.children.unset(index)\n\n  if (finalSegment.node.Links.length === 1) {\n    // replace the sub-shard with the last remaining file in the parent\n    while (true) {\n      if (path.length === 1) {\n        break\n      }\n\n      const segment = path[path.length - 1]\n\n      if (segment == null || segment.node.Links.length > 1) {\n        break\n      }\n\n      // remove final segment\n      path.pop()\n\n      const nextSegment = path[path.length - 1]\n\n      if (nextSegment == null) {\n        break\n      }\n\n      const link = segment.node.Links[0]\n\n      nextSegment.node.Links = nextSegment.node.Links.filter(l => !(l.Name ?? '').startsWith(nextSegment.prefix))\n      nextSegment.node.Links.push({\n        Hash: link.Hash,\n        Name: `${nextSegment.prefix}${(link.Name ?? '').substring(2)}`,\n        Tsize: link.Tsize\n      })\n    }\n  }\n\n  return updateShardedDirectory(path, blockstore, options)\n}\n\nconst convertToFlatDirectory = async (parent: Directory, blockstore: PutStore & GetStore, options: RmLinkOptions): Promise<RemoveLinkResult> => {\n  if (parent.node.Data == null) {\n    throw new InvalidParametersError('Invalid parent passed to convertToFlatDirectory')\n  }\n\n  const rootNode: PBNode = {\n    Links: []\n  }\n  const dir = await exporter(parent.cid, blockstore)\n\n  if (dir.type !== 'directory') {\n    throw new Error('Unexpected node type')\n  }\n\n  for await (const entry of dir.content()) {\n    let tsize = 0\n\n    if (entry.node instanceof Uint8Array) {\n      tsize = entry.node.byteLength\n    } else {\n      tsize = dagPB.encode(entry.node).length\n    }\n\n    rootNode.Links.push({\n      Hash: entry.cid,\n      Name: entry.name,\n      Tsize: tsize\n    })\n  }\n\n  // copy mode/mtime over if set\n  const oldUnixfs = UnixFS.unmarshal(parent.node.Data)\n  rootNode.Data = new UnixFS({ type: 'directory', mode: oldUnixfs.mode, mtime: oldUnixfs.mtime }).marshal()\n  const block = dagPB.encode(dagPB.prepare(rootNode))\n\n  const cid = await persist(block, blockstore, {\n    codec: dagPB,\n    cidVersion: parent.cid.version,\n    signal: options.signal\n  })\n\n  return {\n    cid,\n    node: rootNode\n  }\n}\n", "import { logger } from '@libp2p/logger'\nimport { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { InvalidParametersError } from '../errors.js'\nimport { cidToDirectory } from './utils/cid-to-directory.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport { removeLink } from './utils/remove-link.js'\nimport type { RmOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:rm')\n\nconst defaultOptions: RmOptions = {\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function rm (target: CID, name: string, blockstore: GetStore & PutStore, options: Partial<RmOptions> = {}): Promise<CID> {\n  const opts: RmOptions = mergeOptions(defaultOptions, options)\n\n  if (name.includes('/')) {\n    throw new InvalidParametersError('Name must not have slashes')\n  }\n\n  const directory = await cidToDirectory(target, blockstore, opts)\n\n  log('Removing %s from %c', name, target)\n\n  const result = await removeLink(directory, name, blockstore, {\n    ...opts,\n    cidVersion: target.version\n  })\n\n  return result.cid\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { ScalableCuckooFilter } from '@libp2p/utils/filters'\nimport { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport * as raw from 'multiformats/codecs/raw'\nimport { InvalidPBNodeError, NotUnixFSError, UnknownError } from '../errors.js'\nimport { resolve } from './utils/resolve.js'\nimport type { ExtendedStatOptions, ExtendedDirectoryStats, ExtendedFileStats, StatOptions, DirectoryStats, FileStats, RawStats, ExtendedRawStats } from '../index.js'\nimport type { GetStore, HasStore } from '../unixfs.js'\nimport type { Filter } from '@libp2p/utils/filters'\nimport type { RawNode, UnixFSDirectory, UnixFSFile } from 'ipfs-unixfs-exporter'\nimport type { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/specs/blob/main/UNIXFS.md#metadata\nconst DEFAULT_DIR_MODE = 0x755\nconst DEFAULT_FILE_MODE = 0x644\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:stat')\n\nconst defaultOptions: StatOptions = {\n\n}\n\nexport async function stat (cid: CID, blockstore: GetStore & HasStore, options?: StatOptions): Promise<FileStats | DirectoryStats | RawStats>\nexport async function stat (cid: CID, blockstore: GetStore & HasStore, options?: ExtendedStatOptions): Promise<ExtendedFileStats | ExtendedDirectoryStats | ExtendedRawStats>\nexport async function stat (cid: CID, blockstore: GetStore & HasStore, options: Partial<ExtendedStatOptions> = {}): Promise<any> {\n  const opts: StatOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, options.path, blockstore, opts)\n\n  log('stat %c', resolved.cid)\n\n  const result = await exporter(resolved.cid, blockstore, opts)\n\n  if (result.type === 'raw') {\n    if (options.extended === true) {\n      return createExtendedRawStats(result)\n    }\n\n    return createRawStats(result)\n  } else if (result.type === 'file' || result.type === 'directory') {\n    if (options.extended === true) {\n      return createExtendedStats(result, blockstore, options.filter ?? new ScalableCuckooFilter({ filterSize: 1024 }), options)\n    }\n\n    return createStats(result)\n  }\n\n  throw new NotUnixFSError()\n}\n\nfunction createStats (entry: UnixFSFile | UnixFSDirectory): FileStats | DirectoryStats {\n  return {\n    type: entry.type,\n    cid: entry.cid,\n    unixfs: entry.unixfs,\n    mode: entry.unixfs.mode ?? (entry.unixfs.isDirectory() ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE),\n    mtime: entry.unixfs.mtime,\n    size: entry.unixfs.fileSize()\n  }\n}\n\nasync function createExtendedStats (entry: UnixFSFile | UnixFSDirectory, blockstore: GetStore & HasStore, filter: Filter, options: StatOptions): Promise<ExtendedFileStats | ExtendedDirectoryStats> {\n  const stats = await inspectDag(entry.cid, blockstore, false, filter, options)\n\n  return {\n    type: entry.type,\n    cid: entry.cid,\n    unixfs: entry.unixfs,\n    size: entry.unixfs.isDirectory() ? stats.dirSize : entry.unixfs.fileSize(),\n    mode: entry.unixfs.mode ?? (entry.unixfs.isDirectory() ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE),\n    mtime: entry.unixfs.mtime,\n    localSize: stats.localSize,\n    dagSize: stats.dagSize,\n    deduplicatedDagSize: stats.deduplicatedDagSize,\n    blocks: stats.blocks,\n    uniqueBlocks: stats.uniqueBlocks\n  }\n}\n\nfunction createRawStats (entry: RawNode): RawStats {\n  return {\n    type: entry.type,\n    cid: entry.cid,\n    unixfs: undefined,\n    mode: DEFAULT_FILE_MODE,\n    mtime: undefined,\n    size: BigInt(entry.node.byteLength)\n  }\n}\n\nfunction createExtendedRawStats (entry: RawNode): ExtendedRawStats {\n  return {\n    type: entry.type,\n    cid: entry.cid,\n    unixfs: undefined,\n    mode: DEFAULT_FILE_MODE,\n    mtime: undefined,\n    size: BigInt(entry.node.byteLength),\n    localSize: BigInt(entry.node.byteLength),\n    dagSize: BigInt(entry.node.byteLength),\n    deduplicatedDagSize: BigInt(entry.node.byteLength),\n    blocks: 1n,\n    uniqueBlocks: 1n\n  }\n}\n\ninterface InspectDagResults {\n  dirSize: bigint\n  localSize: bigint\n  dagSize: bigint\n  deduplicatedDagSize: bigint\n  blocks: bigint\n  uniqueBlocks: bigint\n}\n\nasync function inspectDag (cid: CID, blockstore: GetStore & HasStore, isFile: boolean, filter: Filter, options: StatOptions): Promise<InspectDagResults> {\n  const results: InspectDagResults = {\n    dirSize: 0n,\n    localSize: 0n,\n    dagSize: 0n,\n    deduplicatedDagSize: 0n,\n    blocks: 0n,\n    uniqueBlocks: 0n\n  }\n\n  try {\n    const alreadyTraversed = filter.has(cid.bytes)\n    filter.add(cid.bytes)\n\n    const block = await blockstore.get(cid, options)\n    results.blocks++\n    results.dagSize += BigInt(block.byteLength)\n\n    if (!alreadyTraversed) {\n      results.uniqueBlocks++\n      results.deduplicatedDagSize += BigInt(block.byteLength)\n    }\n\n    if (cid.code === raw.code) {\n      results.localSize += BigInt(block.byteLength)\n\n      if (isFile) {\n        results.dirSize += BigInt(block.byteLength)\n      }\n    } else if (cid.code === dagPb.code) {\n      const pbNode = dagPb.decode(block)\n\n      let unixfs: UnixFS | undefined\n\n      if (pbNode.Data != null) {\n        unixfs = UnixFS.unmarshal(pbNode.Data)\n      }\n\n      if (pbNode.Links.length > 0) {\n        // intermediate node\n        for (const link of pbNode.Links) {\n          const linkResult = await inspectDag(link.Hash, blockstore, linkIsFile(link, unixfs), filter, options)\n\n          results.localSize += linkResult.localSize\n          results.dagSize += linkResult.dagSize\n          results.deduplicatedDagSize += linkResult.deduplicatedDagSize\n          results.blocks += linkResult.blocks\n          results.uniqueBlocks += linkResult.uniqueBlocks\n          results.dirSize += linkResult.dirSize\n        }\n\n        // multi-block file node\n        if (isFile && unixfs != null) {\n          results.dirSize += unixfs.fileSize()\n        }\n      } else {\n        if (unixfs == null) {\n          throw new InvalidPBNodeError(`PBNode ${cid.toString()} had no data`)\n        }\n\n        // multi-block file leaf node\n        if (unixfs.data != null) {\n          results.localSize += BigInt(unixfs.data.byteLength ?? 0)\n        }\n\n        // single-block file node\n        if (isFile) {\n          results.dirSize += unixfs.fileSize()\n        }\n      }\n    } else {\n      throw new UnknownError(`${cid.toString()} was neither DAG_PB nor RAW`)\n    }\n  } catch (err: any) {\n    if (err.name !== 'NotFoundError' || options.offline !== true) {\n      throw err\n    }\n  }\n\n  return results\n}\n\nfunction linkIsFile (link: dagPb.PBLink, parent?: UnixFS): boolean {\n  if (parent == null) {\n    return false\n  }\n\n  const name = link.Name\n\n  if (name == null) {\n    return false\n  }\n\n  if (parent.type === 'directory') {\n    return true\n  } else if (parent.type === 'hamt-sharded-directory' && name.length > 2) {\n    return true\n  }\n\n  return false\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { recursive } from 'ipfs-unixfs-exporter'\nimport { importer } from 'ipfs-unixfs-importer'\nimport last from 'it-last'\nimport { pipe } from 'it-pipe'\nimport { CID } from 'multiformats/cid'\nimport * as raw from 'multiformats/codecs/raw'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { InvalidPBNodeError, NotUnixFSError, UnknownError } from '../errors.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport { persist } from './utils/persist.js'\nimport { resolve, updatePathCids } from './utils/resolve.js'\nimport type { TouchOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\nimport type { PBNode, PBLink } from '@ipld/dag-pb'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:touch')\n\nconst defaultOptions: TouchOptions = {\n  recursive: false,\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function touch (cid: CID, blockstore: GetStore & PutStore, options: Partial<TouchOptions> = {}): Promise<CID> {\n  const opts: TouchOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, opts.path, blockstore, opts)\n  const mtime = opts.mtime ?? {\n    secs: BigInt(Math.round(Date.now() / 1000)),\n    nsecs: 0\n  }\n\n  log('touch %c %o', resolved.cid, mtime)\n\n  if (opts.recursive) {\n    // recursively export from root CID, change perms of each entry then reimport\n    // but do not reimport files, only manipulate dag-pb nodes\n    const root = await pipe(\n      async function * () {\n        for await (const entry of recursive(resolved.cid, blockstore)) {\n          let metadata: UnixFS\n          let links: PBLink[]\n\n          if (entry.type === 'raw') {\n            metadata = new UnixFS({ data: entry.node })\n            links = []\n          } else if (entry.type === 'file' || entry.type === 'directory') {\n            metadata = entry.unixfs\n            links = entry.node.Links\n          } else {\n            throw new NotUnixFSError()\n          }\n\n          metadata.mtime = mtime\n\n          const node = {\n            Data: metadata.marshal(),\n            Links: links\n          }\n\n          yield {\n            path: entry.path,\n            content: node\n          }\n        }\n      },\n      // @ts-expect-error blockstore types are incompatible\n      (source) => importer(source, blockstore, {\n        ...opts,\n        dagBuilder: async function * (source, block) {\n          for await (const entry of source) {\n            yield async function () {\n              // @ts-expect-error cannot derive type\n              const node: PBNode = entry.content\n\n              const buf = dagPB.encode(node)\n              const updatedCid = await persist(buf, block, {\n                ...opts,\n                cidVersion: cid.version\n              })\n\n              if (node.Data == null) {\n                throw new InvalidPBNodeError(`${updatedCid} had no data`)\n              }\n\n              const unixfs = UnixFS.unmarshal(node.Data)\n\n              return {\n                cid: updatedCid,\n                size: BigInt(buf.length),\n                path: entry.path,\n                unixfs\n              }\n            }\n          }\n        }\n      }),\n      async (nodes) => last(nodes)\n    )\n\n    if (root == null) {\n      throw new UnknownError(`Could not chmod ${resolved.cid.toString()}`)\n    }\n\n    return updatePathCids(root.cid, resolved, blockstore, opts)\n  }\n\n  const block = await blockstore.get(resolved.cid, options)\n  let metadata: UnixFS\n  let links: PBLink[] = []\n\n  if (resolved.cid.code === raw.code) {\n    metadata = new UnixFS({ data: block })\n  } else {\n    const node = dagPB.decode(block)\n    links = node.Links\n\n    if (node.Data == null) {\n      throw new InvalidPBNodeError(`${resolved.cid.toString()} had no data`)\n    }\n\n    metadata = UnixFS.unmarshal(node.Data)\n  }\n\n  metadata.mtime = mtime\n  const updatedBlock = dagPB.encode({\n    Data: metadata.marshal(),\n    Links: links\n  })\n\n  const hash = await sha256.digest(updatedBlock)\n  const updatedCid = CID.create(resolved.cid.version, dagPB.code, hash)\n\n  await blockstore.put(updatedCid, updatedBlock)\n\n  return updatePathCids(updatedCid, resolved, blockstore, opts)\n}\n", "import { addAll, addBytes, addByteStream, addDirectory, addFile } from './commands/add.js'\nimport { cat } from './commands/cat.js'\nimport { chmod } from './commands/chmod.js'\nimport { cp } from './commands/cp.js'\nimport { ls } from './commands/ls.js'\nimport { mkdir } from './commands/mkdir.js'\nimport { rm } from './commands/rm.js'\nimport { stat } from './commands/stat.js'\nimport { touch } from './commands/touch.js'\nimport type { AddOptions, CatOptions, ChmodOptions, CpOptions, ExtendedStatOptions, ExtendedDirectoryStats, ExtendedFileStats, FileCandidate, LsOptions, MkdirOptions, RmOptions, StatOptions, TouchOptions, UnixFSComponents, DirectoryStats, FileStats, UnixFS as UnixFSInterface, RawStats, ExtendedRawStats } from './index.js'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { UnixFSEntry } from 'ipfs-unixfs-exporter'\nimport type { ByteStream, DirectoryCandidate, ImportCandidateStream, ImportResult } from 'ipfs-unixfs-importer'\nimport type { CID } from 'multiformats/cid'\n\nexport type PutStore = Pick<Blockstore, 'put'>\nexport type GetStore = Pick<Blockstore, 'get'>\nexport type HasStore = Pick<Blockstore, 'has'>\n\nexport class UnixFS implements UnixFSInterface {\n  private readonly components: UnixFSComponents\n\n  constructor (components: UnixFSComponents) {\n    this.components = components\n  }\n\n  async * addAll (source: ImportCandidateStream, options: Partial<AddOptions> = {}): AsyncIterable<ImportResult> {\n    yield * addAll(source, this.components.blockstore, options)\n  }\n\n  async addBytes (bytes: Uint8Array, options: Partial<AddOptions> = {}): Promise<CID> {\n    return addBytes(bytes, this.components.blockstore, options)\n  }\n\n  async addByteStream (bytes: ByteStream, options: Partial<AddOptions> = {}): Promise<CID> {\n    return addByteStream(bytes, this.components.blockstore, options)\n  }\n\n  async addFile (file: FileCandidate, options: Partial<AddOptions> = {}): Promise<CID> {\n    return addFile(file, this.components.blockstore, options)\n  }\n\n  async addDirectory (dir: Partial<DirectoryCandidate> = {}, options: Partial<AddOptions> = {}): Promise<CID> {\n    return addDirectory(dir, this.components.blockstore, options)\n  }\n\n  async * cat (cid: CID, options: Partial<CatOptions> = {}): AsyncIterable<Uint8Array> {\n    yield * cat(cid, this.components.blockstore, options)\n  }\n\n  async chmod (cid: CID, mode: number, options: Partial<ChmodOptions> = {}): Promise<CID> {\n    return chmod(cid, mode, this.components.blockstore, options)\n  }\n\n  async cp (source: CID, target: CID, name: string, options: Partial<CpOptions> = {}): Promise<CID> {\n    return cp(source, target, name, this.components.blockstore, options)\n  }\n\n  async * ls (cid: CID, options: Partial<LsOptions> = {}): AsyncIterable<UnixFSEntry> {\n    yield * ls(cid, this.components.blockstore, options)\n  }\n\n  async mkdir (cid: CID, dirname: string, options: Partial<MkdirOptions> = {}): Promise<CID> {\n    return mkdir(cid, dirname, this.components.blockstore, options)\n  }\n\n  async rm (cid: CID, path: string, options: Partial<RmOptions> = {}): Promise<CID> {\n    return rm(cid, path, this.components.blockstore, options)\n  }\n\n  async stat (cid: CID, options?: StatOptions): Promise<FileStats | DirectoryStats | RawStats>\n  async stat (cid: CID, options?: ExtendedStatOptions): Promise<ExtendedFileStats | ExtendedDirectoryStats | ExtendedRawStats>\n  async stat (cid: CID, options: Partial<StatOptions> = {}): Promise<FileStats | DirectoryStats | RawStats> {\n    return stat(cid, this.components.blockstore, options)\n  }\n\n  async touch (cid: CID, options: Partial<TouchOptions> = {}): Promise<CID> {\n    return touch(cid, this.components.blockstore, options)\n  }\n}\n", "// eslint-disable-next-line require-yield\nexport async function * globSource (): AsyncGenerator<any> {\n  throw new Error('Not supported in browsers')\n}\n", "import { UnknownError } from '../errors.js'\nimport type { FileCandidate } from '../index.js'\n\n/**\n * Import a file directly from a URL. The path of the file will be the path\n * section of the URL.\n *\n * @example\n *\n * ```ts\n * import { unixfs, urlSource } from '@helia/unixfs'\n * import { createHelia } from 'helia'\n *\n * const helia = await createHelia()\n * const fs = unixfs(helia)\n *\n * const cid = await fs.addFile(urlSource('http://example.com/path/to/file.html))\n * const stat = await fs.stat(cid)\n *\n * console.info(stat)\n * // { cid: CID(...), type: 'directory', ... }\n *\n * for await (const entry of fs.ls(cid)) {\n *   console.info(entry)\n *   // { type: 'file', name: 'file.html', cid: CID(...), ... }\n * }\n * ```\n */\nexport function urlSource (url: URL | string, options?: RequestInit): FileCandidate<AsyncGenerator<Uint8Array, void, unknown>> {\n  url = new URL(url)\n\n  return {\n    path: decodeURIComponent(new URL(url).pathname.split('/').pop() ?? ''),\n    content: readURLContent(url, options)\n  }\n}\n\n/**\n * Import a file directly from a URL ignoring the file name or any containing\n * directory.\n *\n * @example\n *\n * ```ts\n * import { unixfs, urlByteSource } from '@helia/unixfs'\n * import { createHelia } from 'helia'\n *\n * const helia = await createHelia()\n * const fs = unixfs(helia)\n *\n * const cid = await fs.addByteSource(urlByteSource('http://example.com/path/to/file.html))\n * const stat = await fs.stat(cid)\n *\n * console.info(stat)\n * // { type: 'file', cid: CID(...), ... }\n * ```\n */\nexport function urlByteSource (url: URL | string, options?: RequestInit): AsyncGenerator<Uint8Array, void, unknown> {\n  url = new URL(url)\n\n  return readURLContent(url, options)\n}\n\nasync function * readURLContent (url: URL, options?: RequestInit): AsyncGenerator<Uint8Array, void, unknown> {\n  const response = await globalThis.fetch(url, options)\n\n  if (response.body == null) {\n    throw new UnknownError('HTTP response did not have a body')\n  }\n\n  const reader = response.body.getReader()\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read()\n\n      if (done) {\n        return\n      }\n\n      if (value != null) {\n        yield value\n      }\n    }\n  } finally {\n    reader.releaseLock()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * `@helia/unixfs` is an implementation of a {@link https://github.com/ipfs/specs/blob/main/UNIXFS.md UnixFS filesystem} compatible with {@link https://github.com/ipfs/helia Helia}.\n *\n * See the [API docs](https://ipfs.github.io/helia/modules/_helia_unixfs.html) for all available operations.\n *\n * @example Creating files and directories\n *\n * ```typescript\n * import { createHelia } from 'helia'\n * import { unixfs } from '@helia/unixfs'\n *\n * const helia = await createHelia()\n * const fs = unixfs(helia)\n *\n * // create an empty dir and a file, then add the file to the dir\n * const emptyDirCid = await fs.addDirectory()\n * const fileCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n * const updateDirCid = await fs.cp(fileCid, emptyDirCid, 'foo.txt')\n *\n * // or doing the same thing as a stream\n * for await (const entry of fs.addAll([{\n *   path: 'foo.txt',\n *   content: Uint8Array.from([0, 1, 2, 3])\n * }])) {\n *   console.info(entry)\n * }\n * ```\n *\n * @example Recursively adding a directory\n *\n * Node.js-compatibly environments only:\n *\n * ```typescript\n * import { createHelia } from 'helia'\n * import { unixfs } from '@helia/unixfs'\n * import { globSource } from '@helia/unixfs'\n *\n * const helia = await createHelia()\n * const fs = unixfs(helia)\n *\n * for await (const entry of fs.addAll(globSource('path/to/containing/dir', 'glob-pattern'))) {\n *   console.info(entry)\n * }\n * ```\n */\n\nimport { UnixFS as UnixFSClass } from './unixfs.js'\nimport type { GetBlockProgressEvents, PutBlockProgressEvents } from '@helia/interface/blocks'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Filter } from '@libp2p/utils/filters'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { Mtime, UnixFS as IPFSUnixFS } from 'ipfs-unixfs'\nimport type { ExporterProgressEvents, UnixFSEntry } from 'ipfs-unixfs-exporter'\nimport type { ByteStream, DirectoryCandidate, ImportCandidateStream, ImporterOptions, ImporterProgressEvents, ImportResult, ImportContent } from 'ipfs-unixfs-importer'\nimport type { CID, Version } from 'multiformats/cid'\nimport type { ProgressOptions } from 'progress-events'\n\nexport interface UnixFSComponents {\n  blockstore: Pick<Blockstore, 'get' | 'put' | 'has'>\n}\n\nexport interface FileCandidate<T extends ImportContent = ImportContent> {\n  path: string\n  content: T\n  mtime?: Mtime\n  mode?: number\n}\n\nexport type AddEvents = PutBlockProgressEvents\n| ImporterProgressEvents\n\nexport interface AddOptions extends AbortOptions, Omit<ImporterOptions, 'onProgress'>, ProgressOptions<AddEvents> {\n\n}\n\nexport type AddFileOptions = Omit<AddOptions, 'wrapWithDirectory'>\n\nexport type GetEvents = GetBlockProgressEvents\n| ExporterProgressEvents\n\n/**\n * Options to pass to the cat command\n */\nexport interface CatOptions extends AbortOptions, ProgressOptions<GetEvents> {\n  /**\n   * Start reading the file at this offset\n   */\n  offset?: number\n\n  /**\n   * Stop reading the file after this many bytes\n   */\n  length?: number\n\n  /**\n   * An optional path to allow reading files inside directories\n   */\n  path?: string\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the chmod command\n */\nexport interface ChmodOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * If the target of the operation is a directory and this is true,\n   * apply the new mode to all directory contents\n   */\n  recursive: boolean\n\n  /**\n   * Optional path to set the mode on directory contents\n   */\n  path?: string\n\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the cp command\n */\nexport interface CpOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * If true, allow overwriting existing directory entries (default: false)\n   */\n  force: boolean\n\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the ls command\n */\nexport interface LsOptions extends AbortOptions, ProgressOptions<GetEvents> {\n  /**\n   * Optional path to list subdirectory contents if the target CID resolves to\n   * a directory\n   */\n  path?: string\n\n  /**\n   * Start reading the directory entries at this offset\n   */\n  offset?: number\n\n  /**\n   * Stop reading the directory contents after this many directory entries\n   */\n  length?: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the mkdir command\n */\nexport interface MkdirOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * The CID version to create the new directory with - defaults to the same\n   * version as the containing directory\n   */\n  cidVersion: Version\n\n  /**\n   * If true, allow overwriting existing directory entries (default: false)\n   */\n  force: boolean\n\n  /**\n   * An optional mode to set on the new directory\n   */\n  mode?: number\n\n  /**\n   * An optional mtime to set on the new directory\n   */\n  mtime?: Mtime\n\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the rm command\n */\nexport interface RmOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the stat command\n */\nexport interface StatOptions extends AbortOptions, ProgressOptions<GetEvents> {\n  /**\n   * An optional path to allow getting stats of paths inside directories\n   */\n  path?: string\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store.\n   *\n   * @default false\n   */\n  offline?: boolean\n}\n\nexport interface ExtendedStatOptions extends StatOptions {\n  /**\n   * If true, traverse the whole DAG to return additional stats. If all data is\n   * not in the local blockstore, this may involve fetching them from the\n   * network.\n   */\n  extended: true\n\n  /**\n   * By default CIDs are deduplicated using a `ScalableCuckooFilter` - if you\n   * wish to use a different filter, pass it here.\n   */\n  filter?: Filter\n}\n\n/**\n * Statistics relating to a UnixFS DAG\n */\nexport interface Stats {\n  /**\n   * The file or directory CID\n   */\n  cid: CID\n\n  /**\n   * The file or directory mode\n   */\n  mode: number\n\n  /**\n   * The file or directory mtime\n   */\n  mtime?: Mtime\n\n  /**\n   * The type of UnixFS node - 'file' or 'directory'\n   */\n  type: 'file' | 'directory' | 'raw'\n\n  /**\n   * UnixFS metadata about this file or directory\n   */\n  unixfs?: IPFSUnixFS\n\n  /**\n   * The size in bytes of the file as reported by the UnixFS metadata stored in\n   * the root DAG node, or if the CID resolves to a raw node, the size of the\n   * block that holds it.\n   *\n   * For directories this will return `0` as no size information is available in\n   * the root block - instead please stat with the `extended` option to traverse\n   * the DAG and calculate the size.\n   */\n  size: bigint\n}\n\nexport interface FileStats extends Stats {\n  type: 'file'\n  unixfs: IPFSUnixFS\n}\n\nexport interface DirectoryStats extends Stats {\n  type: 'directory'\n  unixfs: IPFSUnixFS\n}\n\nexport interface RawStats extends Stats {\n  type: 'raw'\n  unixfs: undefined\n}\n\n/**\n * More detailed statistics relating to a UnixFS DAG. These can involve\n * traversing the DAG behind the CID so can involve network operations and/or\n * more disk activity.\n */\nexport interface ExtendedStats extends Stats {\n  /**\n   * How many blocks make up the DAG.\n   *\n   * nb. this will only be accurate if either all blocks are present in the\n   * local blockstore or the `offline` option was not `true`\n   */\n  blocks: bigint\n\n  /**\n   * How many unique blocks make up the DAG - this count does not include any\n   * blocks that appear in the DAG more than once.\n   *\n   * nb. this will only be accurate if either all blocks are present in the\n   * local blockstore or the `offline` option was not `true`\n   */\n  uniqueBlocks: bigint\n\n  /**\n   * The size of the DAG that holds the file or directory in bytes - this is\n   * the sum of all block sizes so includes any protobuf overhead, etc.\n   *\n   * Duplicate blocks are included in this measurement.\n   *\n   * nb. this will only be accurate if either all blocks are present in the\n   * local blockstore or the `offline` option was not `true`\n   */\n  dagSize: bigint\n\n  /**\n   * Similar to `dagSize` except duplicate blocks are not included in the\n   * reported amount.\n   *\n   * nb. this will only be accurate if either all blocks are present in the\n   * local blockstore or the `offline` option was not `true`\n   */\n  deduplicatedDagSize: bigint\n\n  /**\n   * How much of the file or directory is in the local block store. If this is a\n   * directory it will include the `localSize` of all child files and\n   * directories.\n   *\n   * It does not include protobuf overhead, for that see `dagSize`.\n   *\n   * nb. if the `offline` option is `true`, and not all blocks for the\n   * file/directory are in the blockstore, this number may be smaller than\n   * `size`.\n   */\n  localSize: bigint\n}\n\nexport interface ExtendedFileStats extends ExtendedStats {\n  type: 'file'\n  unixfs: IPFSUnixFS\n}\n\nexport interface ExtendedDirectoryStats extends ExtendedStats {\n  type: 'directory'\n  unixfs: IPFSUnixFS\n}\n\nexport interface ExtendedRawStats extends ExtendedStats {\n  type: 'raw'\n  unixfs: undefined\n}\n\n/**\n * Options to pass to the touch command\n */\nexport interface TouchOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * Optional mtime to set on the DAG root, defaults to the current time\n   */\n  mtime?: Mtime\n\n  /**\n   * Optional path to set mtime on directory contents\n   */\n  path?: string\n\n  /**\n   * If the DAG is a directory and this is true, update the mtime on all contents\n   */\n  recursive: boolean\n\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * The UnixFS interface provides familiar filesystem operations to make working with\n * UnixFS DAGs simple and intuitive.\n */\nexport interface UnixFS {\n  /**\n   * Add all files and directories from the passed stream. This method wraps the\n   * `importer` export from the `ipfs-unixfs-importer` module - please see the docs\n   * for input/output types.\n   *\n   * @example\n   *\n   * ```typescript\n   * const source = [{\n   *   path: './foo.txt',\n   *   content: Uint8Array.from([0, 1, 2, 3])\n   * }, {\n   *   path: './bar.txt',\n   *   content: Uint8Array.from([4, 5, 6, 7])\n   * }]\n   *\n   * for await (const entry of fs.import(source)) {\n   *   console.info(entry)\n   * }\n   * ```\n   */\n  addAll(source: ImportCandidateStream, options?: Partial<AddOptions>): AsyncIterable<ImportResult>\n\n  /**\n   * Add a single `Uint8Array` to your Helia node and receive a CID that will\n   * resolve to it.\n   *\n   * If you want to preserve a file name or other metadata such as modification\n   * time or mode, use `addFile` instead.\n   *\n   * @example\n   *\n   * ```typescript\n   * const cid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   *\n   * console.info(cid)\n   * ```\n   */\n  addBytes(bytes: Uint8Array, options?: Partial<AddFileOptions>): Promise<CID>\n\n  /**\n   * Add a stream of `Uint8Array`s to your Helia node and receive a CID that\n   * will resolve to them.\n   *\n   * If you want to preserve a file name or other metadata such as modification\n   * time or mode, use `addFile` instead.\n   *\n   * @example\n   *\n   * ```typescript\n   * import fs from 'fs'\n   *\n   * const stream = fs.createReadStream('./foo.txt')\n   * const cid = await fs.addByteStream(stream)\n   *\n   * console.info(cid)\n   * ```\n   */\n  addByteStream(bytes: ByteStream, options?: Partial<AddFileOptions>): Promise<CID>\n\n  /**\n   * Add a file to your Helia node with metadata. The returned CID will resolve\n   * to a directory with one file entry.\n   *\n   * If you don't care about file names and just want a CID that will resolve to\n   * the contents of the file, use `addBytes` or `addByeStream` instead.\n   *\n   * @example\n   *\n   * ```typescript\n   * const cid = await fs.addFile({\n   *   path: './foo.txt',\n   *   content: Uint8Array.from([0, 1, 2, 3]),\n   *   mode: 0x755,\n   *   mtime: {\n   *     secs: 10n,\n   *     nsecs: 0\n   *   }\n   * })\n   *\n   * console.info(cid)\n   * ```\n   */\n  addFile(file: FileCandidate, options?: Partial<AddFileOptions>): Promise<CID>\n\n  /**\n   * Add a directory to your Helia node.\n   *\n   * @example\n   *\n   * If no path is specified, the returned CID will resolve to an empty\n   * directory.\n   *\n   * ```typescript\n   * const cid = await fs.addDirectory()\n   *\n   * console.info(cid) // empty directory CID\n   * ```\n   *\n   * @example\n   *\n   * If a path is specified, the CID will resolve to a directory that contains\n   * an empty directory with the specified name.\n   *\n   * ```typescript\n   * const cid = await fs.addDirectory({\n   *   path: 'my-dir'\n   * })\n   *\n   * console.info(cid) // containing directory CID\n   *\n   * const stat = await fs.stat(cid, {\n   *   path: 'my-dir'\n   * })\n   *\n   * console.info(stat.cid) // empty directory CID\n   * ```\n   */\n  addDirectory(dir?: Partial<DirectoryCandidate>, options?: Partial<AddFileOptions>): Promise<CID>\n\n  /**\n   * Retrieve the contents of a file from your Helia node.\n   *\n   * @example\n   *\n   * ```typescript\n   * for await (const buf of fs.cat(cid)) {\n   *   console.info(buf)\n   * }\n   * ```\n   */\n  cat(cid: CID, options?: Partial<CatOptions>): AsyncIterable<Uint8Array>\n\n  /**\n   * Change the permissions on a file or directory in a DAG\n   *\n   * @example\n   *\n   * ```typescript\n   * const beforeCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   * const beforeStats = await fs.stat(beforeCid)\n   *\n   * const afterCid = await fs.chmod(cid, 0x755)\n   * const afterStats = await fs.stat(afterCid)\n   *\n   * console.info(beforeCid, beforeStats)\n   * console.info(afterCid, afterStats)\n   * ```\n   */\n  chmod(cid: CID, mode: number, options?: Partial<ChmodOptions>): Promise<CID>\n\n  /**\n   * Add a file or directory to a target directory.\n   *\n   * @example\n   *\n   * ```typescript\n   * const fileCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   * const directoryCid = await fs.addDirectory()\n   *\n   * const updatedCid = await fs.cp(fileCid, directoryCid, 'foo.txt')\n   *\n   * console.info(updatedCid)\n   * ```\n   */\n  cp(source: CID, target: CID, name: string, options?: Partial<CpOptions>): Promise<CID>\n\n  /**\n   * List directory contents.\n   *\n   * @example\n   *\n   * ```typescript\n   * for await (const entry of fs.ls(directoryCid)) {\n   *   console.info(entry)\n   * }\n   * ```\n   */\n  ls(cid: CID, options?: Partial<LsOptions>): AsyncIterable<UnixFSEntry>\n\n  /**\n   * Make a new directory under an existing directory.\n   *\n   * @example\n   *\n   * ```typescript\n   * const directoryCid = await fs.addDirectory()\n   *\n   * const updatedCid = await fs.mkdir(directoryCid, 'new-dir')\n   *\n   * console.info(updatedCid)\n   * ```\n   */\n  mkdir(cid: CID, dirname: string, options?: Partial<MkdirOptions>): Promise<CID>\n\n  /**\n   * Remove a file or directory from an existing directory.\n   *\n   * @example\n   *\n   * ```typescript\n   * const directoryCid = await fs.addDirectory()\n   * const updatedCid = await fs.mkdir(directoryCid, 'new-dir')\n   *\n   * const finalCid = await fs.rm(updatedCid, 'new-dir')\n   *\n   * console.info(finalCid)\n   * ```\n   */\n  rm(cid: CID, path: string, options?: Partial<RmOptions>): Promise<CID>\n\n  /**\n   * Return statistics about a UnixFS DAG.\n   *\n   * @example\n   *\n   * ```typescript\n   * const fileCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   *\n   * const stats = await fs.stat(fileCid)\n   *\n   * console.info(stats)\n   * ```\n   */\n  stat(cid: CID, options?: StatOptions): Promise<FileStats | DirectoryStats | RawStats>\n  stat(cid: CID, options?: ExtendedStatOptions): Promise<ExtendedFileStats | ExtendedDirectoryStats | ExtendedRawStats>\n\n  /**\n   * Update the mtime of a UnixFS DAG\n   *\n   * @example\n   *\n   * ```typescript\n   * const beforeCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   * const beforeStats = await fs.stat(beforeCid)\n   *\n   * const afterCid = await fs.touch(beforeCid)\n   * const afterStats = await fs.stat(afterCid)\n   *\n   * console.info(beforeCid, beforeStats)\n   * console.info(afterCid, afterStats)\n   * ```\n   */\n  touch(cid: CID, options?: Partial<TouchOptions>): Promise<CID>\n}\n\n/**\n * Create a {@link UnixFS} instance for use with {@link https://github.com/ipfs/helia Helia}\n */\nexport function unixfs (helia: { blockstore: Pick<Blockstore, 'get' | 'put' | 'has'> }): UnixFS {\n  return new UnixFSClass(helia)\n}\n\nexport { globSource } from './utils/glob-source.js'\nexport type { GlobSourceResult, GlobSourceOptions } from './utils/glob-source.js'\nexport { urlSource } from './utils/url-source.js'\n"],
  "mappings": "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AAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,IAAG,KAAI,KAAI,GAAE,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,KAAI,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,KAAI,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,G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",
  "names": ["undefined", "last", "exists", "length", "last", "exports", "module", "name", "create", "src_default", "src_default", "message", "Data", "DataType", "__DataTypeValues", "length", "UnixTime", "Metadata", "message", "code", "decode", "encode", "code", "encode", "decode", "name", "encode", "length", "i", "j", "decode", "name", "encode", "decode", "encode", "decode", "decode", "code", "code", "digest", "decode", "equals", "base", "baseCache", "code", "digest", "equals", "base", "decode", "length", "cache", "cid", "from", "name", "code", "encode", "digest", "name", "from", "unixfs", "message", "message", "unixfs", "node", "code", "isAsyncIterable", "reduce", "src_default", "name", "unixfs", "coerce", "empty", "equals", "fromString", "base", "name", "encode", "length", "i", "j", "decode", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "Encoder", "name", "Decoder", "or", "ComposedDecoder", "Codec", "from", "encode", "decode", "baseX", "base_x_default", "coerce", "createAlphabetIdx", "rfc4648", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "base36", "baseX", "base36upper", "base58btc", "baseX", "base58flickr", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "decode", "read", "MSB$1", "REST$1", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "varint", "_brrp_varint", "varint_default", "decode", "code", "varint_default", "encodeTo", "encodingLength", "create", "code", "digest", "encodingLength", "encodeTo", "Digest", "decode", "coerce", "equals", "format", "base", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "CID", "code", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "equals", "base", "format", "encodeCID", "cidSymbol", "decode", "coerce", "Digest", "length", "parseCIDtoBytes", "base58btc", "base32", "base36", "toStringV0", "cid", "toStringV1", "encodingLength", "encodeTo", "from", "name", "code", "encode", "Hasher", "create", "digest", "from", "mur", "SparseArray", "reduce", "acc", "length", "hashFn", "name", "dir", "size", "last", "src_default", "isAsyncIterable", "res", "src_default", "message", "name", "code", "InvalidParametersError", "InvalidParametersError", "src_default", "empty", "equals", "coerce", "base", "name", "encode", "length", "i", "j", "decode", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "Encoder", "name", "Decoder", "or", "ComposedDecoder", "Codec", "from", "encode", "decode", "baseX", "base_x_default", "coerce", "createAlphabetIdx", "rfc4648", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "base36", "baseX", "base36upper", "base58btc", "baseX", "base58flickr", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "decode", "read", "MSB$1", "REST$1", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "varint", "_brrp_varint", "varint_default", "decode", "code", "varint_default", "encodeTo", "encodingLength", "create", "code", "digest", "encodingLength", "encodeTo", "Digest", "decode", "coerce", "equals", "format", "base", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "CID", "code", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "equals", "base", "format", "encodeCID", "cidSymbol", "decode", "coerce", "Digest", "length", "parseCIDtoBytes", "base58btc", "base32", "base36", "toStringV0", "cid", "toStringV1", "encodingLength", "encodeTo", "message", "NotUnixFSError", "InvalidParametersError", "code", "decode", "code", "code", "name", "encode", "coerce", "create", "name", "CID", "name", "resolve", "resolve", "name", "decode", "length", "InvalidParametersError", "resolve", "name", "decode", "resolve", "name", "decode", "rawContent", "resolve", "name", "name", "NotUnixFSError", "link", "decode", "unixfs", "resolve", "length", "src_default", "NotUnixFSError", "src_default", "code", "decode", "unixfs", "resolve", "read", "unixfs", "resolve", "NotUnixFSError", "src_default", "name", "decode", "name", "link", "unixfs", "resolve", "decode", "NotUnixFSError", "code", "resolve", "name", "toPathComponents", "CID", "name", "src_default", "node", "options", "empty", "equals", "coerce", "base", "name", "encode", "length", "i", "j", "decode", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "Encoder", "name", "Decoder", "or", "ComposedDecoder", "Codec", "from", "encode", "decode", "baseX", "base_x_default", "coerce", "createAlphabetIdx", "rfc4648", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "base36", "baseX", "base36upper", "base58btc", "baseX", "base58flickr", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "decode", "read", "MSB$1", "REST$1", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "varint", "_brrp_varint", "varint_default", "decode", "code", "varint_default", "encodeTo", "encodingLength", "create", "code", "digest", "encodingLength", "encodeTo", "Digest", "decode", "coerce", "equals", "format", "base", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "CID", "code", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "equals", "base", "format", "encodeCID", "cidSymbol", "decode", "coerce", "Digest", "length", "parseCIDtoBytes", "base58btc", "base32", "base36", "toStringV0", "cid", "toStringV1", "encodingLength", "encodeTo", "from", "name", "code", "encode", "Hasher", "create", "digest", "sha", "name", "sha256", "from", "sha512", "import_sparse_array", "wrapHash", "hashFn", "InfiniteHash", "ConsumableBuffer", "START_MASKS", "STOP_MASKS", "byteBitsToInt", "length", "maskFor", "hamtHashFn", "import_sparse_array", "persist", "sha256", "CID", "Dir", "DirSharded", "hamtHashFn", "name", "calculateSize", "flush", "isDir", "dir", "size", "persist", "CID_V0", "CID_V1", "CID", "toPrefix", "DirSharded", "src_default", "persist", "wrapHash", "hamtHashFn", "decode", "SparseArray", "linkName", "unixfs", "CID_V1", "CID_V0", "name", "code", "node", "decode", "log", "InvalidParametersError", "decode", "unixfs", "sha256", "CID", "code", "index", "wrapHash", "hamtHashFn", "toPrefix", "children", "SparseArray", "name", "log", "resolve", "src_default", "result", "mergeOptions", "resolve", "code", "mergeOptions", "log", "defaultOptions", "resolve", "metadata", "links", "source", "block", "updatedCid", "persist", "unixfs", "src_default", "code", "decode", "sha256", "CID", "mergeOptions", "log", "defaultOptions", "name", "InvalidParametersError", "mergeOptions", "defaultOptions", "resolve", "mergeOptions", "log", "defaultOptions", "InvalidParametersError", "sha256", "CID", "code", "log", "name", "persist", "InvalidParametersError", "mergeOptions", "log", "defaultOptions", "name", "InvalidParametersError", "DEFAULT_FILE_MODE", "mergeOptions", "log", "defaultOptions", "resolve", "code", "decode", "unixfs", "name", "mergeOptions", "log", "defaultOptions", "resolve", "metadata", "links", "source", "block", "updatedCid", "persist", "unixfs", "src_default", "code", "decode", "sha256", "CID", "UnixFS", "name", "UnixFS"]
}
